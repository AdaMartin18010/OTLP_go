# OTLP å½¢å¼åŒ–è§„èŒƒä¸éªŒè¯

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
> **OTLP ç‰ˆæœ¬**: v1.3.x  
> **å½¢å¼åŒ–æ–¹æ³•**: TLA+, Z Notation  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ9æ—¥

---

## ğŸ“‹ ç›®å½•

- [OTLP å½¢å¼åŒ–è§„èŒƒä¸éªŒè¯](#otlp-å½¢å¼åŒ–è§„èŒƒä¸éªŒè¯)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [å½¢å¼åŒ–æ–¹æ³•çš„ä»·å€¼](#å½¢å¼åŒ–æ–¹æ³•çš„ä»·å€¼)
    - [OTLP å½¢å¼åŒ–ç›®æ ‡](#otlp-å½¢å¼åŒ–ç›®æ ‡)
  - [æ ¸å¿ƒæ•°æ®ç±»å‹å½¢å¼åŒ–å®šä¹‰](#æ ¸å¿ƒæ•°æ®ç±»å‹å½¢å¼åŒ–å®šä¹‰)
    - [1. åŸºç¡€ç±»å‹](#1-åŸºç¡€ç±»å‹)
      - [TraceID å’Œ SpanID](#traceid-å’Œ-spanid)
      - [æ—¶é—´æˆ³](#æ—¶é—´æˆ³)
    - [2. Span å½¢å¼åŒ–å®šä¹‰](#2-span-å½¢å¼åŒ–å®šä¹‰)
    - [3. Trace æ ‘å½¢ç»“æ„](#3-trace-æ ‘å½¢ç»“æ„)
  - [åè®®è¡Œä¸ºè§„èŒƒ](#åè®®è¡Œä¸ºè§„èŒƒ)
    - [1. Export æ“ä½œ](#1-export-æ“ä½œ)
    - [2. æ‰¹å¤„ç†è§„èŒƒ](#2-æ‰¹å¤„ç†è§„èŒƒ)
  - [æ­£ç¡®æ€§è¯æ˜](#æ­£ç¡®æ€§è¯æ˜)
    - [1. æ•°æ®å®Œæ•´æ€§è¯æ˜](#1-æ•°æ®å®Œæ•´æ€§è¯æ˜)
    - [2. å› æœé¡ºåºä¿è¯](#2-å› æœé¡ºåºä¿è¯)
    - [3. å”¯ä¸€æ€§ä¿è¯](#3-å”¯ä¸€æ€§ä¿è¯)
  - [ä¸€è‡´æ€§éªŒè¯](#ä¸€è‡´æ€§éªŒè¯)
    - [1. æ¨¡å‹æ£€æŸ¥](#1-æ¨¡å‹æ£€æŸ¥)
    - [2. æµ‹è¯•ç”¨ä¾‹ç”Ÿæˆ](#2-æµ‹è¯•ç”¨ä¾‹ç”Ÿæˆ)
  - [å®‰å…¨æ€§åˆ†æ](#å®‰å…¨æ€§åˆ†æ)
    - [1. å¨èƒæ¨¡å‹](#1-å¨èƒæ¨¡å‹)
    - [2. å®‰å…¨å±æ€§å½¢å¼åŒ–](#2-å®‰å…¨å±æ€§å½¢å¼åŒ–)
    - [3. å®‰å…¨æ£€æŸ¥æ¸…å•](#3-å®‰å…¨æ£€æŸ¥æ¸…å•)
  - [å‚è€ƒèµ„æº](#å‚è€ƒèµ„æº)
    - [å½¢å¼åŒ–æ–¹æ³•](#å½¢å¼åŒ–æ–¹æ³•)
    - [å·¥å…·](#å·¥å…·)
    - [è®ºæ–‡](#è®ºæ–‡)

---

## æ¦‚è¿°

### å½¢å¼åŒ–æ–¹æ³•çš„ä»·å€¼

**å®šä¹‰**: ä½¿ç”¨æ•°å­¦æ–¹æ³•ç²¾ç¡®æè¿°ç³»ç»Ÿè¡Œä¸º,å¹¶è¯æ˜å…¶æ­£ç¡®æ€§ã€‚

```text
å½¢å¼åŒ–è§„èŒƒ = (è¯­æ³•å®šä¹‰, è¯­ä¹‰å®šä¹‰, æ€§è´¨è¯æ˜)

ä¼˜åŠ¿:
1. æ¶ˆé™¤æ­§ä¹‰ - ç²¾ç¡®æ— äºŒä¹‰æ€§
2. æ—©æœŸå‘ç°é”™è¯¯ - è®¾è®¡é˜¶æ®µéªŒè¯
3. å®Œæ•´æ€§ - è¦†ç›–æ‰€æœ‰è¾¹ç•Œæ¡ä»¶
4. å¯éªŒè¯æ€§ - è‡ªåŠ¨åŒ–éªŒè¯å·¥å…·
```

### OTLP å½¢å¼åŒ–ç›®æ ‡

```text
1. æ•°æ®å®Œæ•´æ€§ (Data Integrity)
   - æ•°æ®ä¸ä¸¢å¤±
   - æ•°æ®ä¸é‡å¤
   - æ•°æ®ä¸æŸå

2. é¡ºåºä¿è¯ (Ordering Guarantees)
   - å› æœé¡ºåº
   - æ—¶é—´é¡ºåº

3. å®¹é”™æ€§ (Fault Tolerance)
   - ç½‘ç»œæ•…éšœ
   - æœåŠ¡æ•…éšœ
   - æ•°æ®æ•…éšœ

4. ä¸€è‡´æ€§ (Consistency)
   - æœ€ç»ˆä¸€è‡´æ€§
   - å› æœä¸€è‡´æ€§
```

---

## æ ¸å¿ƒæ•°æ®ç±»å‹å½¢å¼åŒ–å®šä¹‰

### 1. åŸºç¡€ç±»å‹

#### TraceID å’Œ SpanID

```text
-- Z Notation å®šä¹‰

[BYTE]

TraceID == seqâ‚â‚† BYTE
  where #TraceID = 16

SpanID == seqâ‚ˆ BYTE
  where #SpanID = 8

-- çº¦æŸæ¡ä»¶
invariant TraceID_valid:
  âˆ€ t: TraceID â€¢ t â‰  seq(16, 0)  -- éå…¨é›¶

invariant SpanID_valid:
  âˆ€ s: SpanID â€¢ s â‰  seq(8, 0)  -- éå…¨é›¶
```

#### æ—¶é—´æˆ³

```text
-- çº³ç§’ç²¾åº¦æ—¶é—´æˆ³
TimeUnixNano == â„•
  where TimeUnixNano â‰¥ 0

-- çº¦æŸæ¡ä»¶
invariant time_ordering:
  âˆ€ start, end: TimeUnixNano â€¢
    start â‰¤ end â‡’ valid_span(start, end)

-- æ—¶é—´èŒƒå›´çº¦æŸ (1970-01-01 åˆ° 2262-04-11)
time_range == 0..2â¶Â³-1
```

### 2. Span å½¢å¼åŒ–å®šä¹‰

```text
-- Span ç»“æ„
Span ::=
  trace_id: TraceID
  span_id: SpanID
  parent_span_id: SpanID âˆª {âˆ…}
  name: String
  kind: SpanKind
  start_time: TimeUnixNano
  end_time: TimeUnixNano
  attributes: Attributes
  events: seq Event
  links: seq Link
  status: Status

-- SpanKind æšä¸¾
SpanKind ::= INTERNAL | SERVER | CLIENT | PRODUCER | CONSUMER

-- ä¸å˜å¼ (Invariants)
invariant span_valid:
  âˆ€ s: Span â€¢
    s.start_time â‰¤ s.end_time âˆ§
    s.span_id â‰  s.parent_span_id âˆ§
    (#s.name > 0) âˆ§
    (#s.events â‰¤ MAX_EVENTS) âˆ§
    (#s.links â‰¤ MAX_LINKS)

-- Span å…³ç³»
parent_of: Span â†” Span
parent_of == {sâ‚, sâ‚‚: Span | sâ‚.span_id = sâ‚‚.parent_span_id âˆ§
                               sâ‚.trace_id = sâ‚‚.trace_id}

-- Trace å®Œæ•´æ€§
trace_complete: â„™ Span â†’ ğ”¹
trace_complete(spans) â‡”
  âˆ€ s: spans â€¢ s.parent_span_id â‰  âˆ… â‡’
    âˆƒ p: spans â€¢ p.span_id = s.parent_span_id
```

### 3. Trace æ ‘å½¢ç»“æ„

```text
-- Trace ä¸ºæœ‰å‘æ— ç¯å›¾ (DAG)
Trace ::=
  trace_id: TraceID
  spans: â„™ Span
  root: Span

-- DAG å±æ€§
invariant acyclic:
  âˆ€ t: Trace â€¢
    Â¬(âˆƒ path: seq Span |
      path(0) = path(#path - 1) âˆ§
      âˆ€ i: 0..#path-2 â€¢ (path(i), path(i+1)) âˆˆ parent_of)

-- å•æ ¹çº¦æŸ
invariant single_root:
  âˆ€ t: Trace â€¢
    âˆƒ! r: t.spans â€¢ r.parent_span_id = âˆ… âˆ§ r = t.root

-- è¿é€šæ€§
invariant connected:
  âˆ€ t: Trace, s: t.spans â€¢
    âˆƒ path: seq Span |
      path(0) = t.root âˆ§
      path(#path - 1) = s âˆ§
      âˆ€ i: 0..#path-2 â€¢ (path(i), path(i+1)) âˆˆ parent_of
```

---

## åè®®è¡Œä¸ºè§„èŒƒ

### 1. Export æ“ä½œ

```tla
---- MODULE OTLPExport ----
EXTENDS Integers, Sequences, TLC

CONSTANTS
  MAX_BATCH_SIZE,    \* æœ€å¤§æ‰¹é‡å¤§å°
  MAX_RETRIES,       \* æœ€å¤§é‡è¯•æ¬¡æ•°
  TIMEOUT            \* è¶…æ—¶æ—¶é—´

VARIABLES
  client_state,      \* å®¢æˆ·ç«¯çŠ¶æ€
  server_state,      \* æœåŠ¡ç«¯çŠ¶æ€
  network_buffer,    \* ç½‘ç»œç¼“å†²åŒº
  retry_count        \* é‡è¯•è®¡æ•°

\* ç±»å‹ä¸å˜å¼
TypeInvariant ==
  /\ client_state \in {"idle", "sending", "waiting", "success", "failed"}
  /\ server_state \in {"idle", "receiving", "processing", "ready"}
  /\ retry_count \in 0..MAX_RETRIES

\* åˆå§‹çŠ¶æ€
Init ==
  /\ client_state = "idle"
  /\ server_state = "idle"
  /\ network_buffer = <<>>
  /\ retry_count = 0

\* å®¢æˆ·ç«¯å‘é€
ClientSend ==
  /\ client_state = "idle"
  /\ client_state' = "sending"
  /\ network_buffer' = network_buffer \o <<"data">>
  /\ UNCHANGED <<server_state, retry_count>>

\* æœåŠ¡ç«¯æ¥æ”¶
ServerReceive ==
  /\ server_state = "idle"
  /\ network_buffer # <<>>
  /\ server_state' = "receiving"
  /\ client_state' = "waiting"
  /\ UNCHANGED <<network_buffer, retry_count>>

\* æœåŠ¡ç«¯å¤„ç†
ServerProcess ==
  /\ server_state = "receiving"
  /\ server_state' = "processing"
  /\ network_buffer' = Tail(network_buffer)
  /\ UNCHANGED <<client_state, retry_count>>

\* æˆåŠŸå“åº”
ServerRespond ==
  /\ server_state = "processing"
  /\ server_state' = "ready"
  /\ client_state' = "success"
  /\ UNCHANGED <<network_buffer, retry_count>>

\* é‡è¯•
ClientRetry ==
  /\ client_state = "waiting"
  /\ retry_count < MAX_RETRIES
  /\ client_state' = "sending"
  /\ retry_count' = retry_count + 1
  /\ UNCHANGED <<server_state, network_buffer>>

\* å¤±è´¥
ClientFail ==
  /\ client_state = "waiting"
  /\ retry_count = MAX_RETRIES
  /\ client_state' = "failed"
  /\ UNCHANGED <<server_state, network_buffer, retry_count>>

\* ä¸‹ä¸€çŠ¶æ€
Next ==
  \/ ClientSend
  \/ ServerReceive
  \/ ServerProcess
  \/ ServerRespond
  \/ ClientRetry
  \/ ClientFail

\* è§„èŒƒ
Spec == Init /\ [][Next]_<<client_state, server_state, network_buffer, retry_count>>

\* å®‰å…¨æ€§å±æ€§
Safety ==
  \* ä¸ä¼šåŒæ—¶æˆåŠŸå’Œå¤±è´¥
  /\ ~(client_state = "success" /\ client_state = "failed")
  
  \* é‡è¯•æ¬¡æ•°ä¸è¶…è¿‡ä¸Šé™
  /\ retry_count <= MAX_RETRIES

\* æ´»æ€§å±æ€§
Liveness ==
  \* æœ€ç»ˆä¼šæˆåŠŸæˆ–å¤±è´¥
  []<>(client_state = "success" \/ client_state = "failed")

====
```

### 2. æ‰¹å¤„ç†è§„èŒƒ

```text
-- æ‰¹å¤„ç†çº¦æŸ
BATCH_CONSTRAINTS:
  min_batch_size: â„• = 1
  max_batch_size: â„• = 512
  max_batch_wait: Duration = 5s
  max_queue_size: â„• = 2048

-- æ‰¹å¤„ç†çŠ¶æ€æœº
BatchProcessor ::=
  queue: seq Span
  current_batch: seq Span
  state: {collecting, flushing, idle}

-- çŠ¶æ€è½¬æ¢
collecting â†’ flushing:
  WHEN (#current_batch â‰¥ max_batch_size) âˆ¨
       (age(current_batch) â‰¥ max_batch_wait) âˆ¨
       (queue_full)

flushing â†’ idle:
  WHEN export_complete âˆ¨ export_failed

idle â†’ collecting:
  WHEN queue â‰  âˆ…

-- ä¸å˜å¼
invariant batch_size_valid:
  âˆ€ b: Batch â€¢
    min_batch_size â‰¤ #b â‰¤ max_batch_size

invariant queue_bounded:
  #queue â‰¤ max_queue_size

invariant no_data_loss:
  âˆ€ s: Span â€¢ s âˆˆ queue âˆ¨ s âˆˆ current_batch âˆ¨ exported(s)
```

---

## æ­£ç¡®æ€§è¯æ˜

### 1. æ•°æ®å®Œæ•´æ€§è¯æ˜

**å®šç†**: OTLP ä¿è¯æ•°æ®ä¸ä¸¢å¤± (åœ¨ç½‘ç»œå¯é çš„å‰æä¸‹)

```text
å®šç† (Data Integrity):
  âˆ€ span: Span, client: Client, server: Server â€¢
    client.send(span) âˆ§ network_reliable âˆ§ Â¬server_fail
    â‡’ â—‡(server.received(span))

è¯æ˜:
  å‡è®¾:
    1. client.send(span) at time tâ‚€
    2. network_reliable (æ— ä¸¢åŒ…)
    3. Â¬server_fail (æœåŠ¡ç«¯æ­£å¸¸)

  æ­¥éª¤:
    1. client.send(span) â†’ span âˆˆ client.buffer  [å‘é€å®šä¹‰]
    2. span âˆˆ client.buffer â†’ span âˆˆ network     [ç½‘ç»œå¯é ]
    3. span âˆˆ network â†’ span âˆˆ server.buffer     [æ¥æ”¶å®šä¹‰]
    4. span âˆˆ server.buffer â†’ server.received(span) [å¤„ç†å®šä¹‰]

  ç»“è®º:
    ç”±æ­¥éª¤ 1-4, client.send(span) â‡’ â—‡server.received(span)
    è¯æ¯• âˆ
```

### 2. å› æœé¡ºåºä¿è¯

**å®šç†**: çˆ¶ Span å¿…é¡»åœ¨å­ Span ä¹‹å‰å®Œæˆ

```text
å®šç† (Causal Ordering):
  âˆ€ parent, child: Span â€¢
    child.parent_span_id = parent.span_id
    â‡’ parent.end_time â‰¤ child.end_time

è¯æ˜:
  åè¯æ³•:
    å‡è®¾ âˆƒ parent, child: Span â€¢
      child.parent_span_id = parent.span_id âˆ§
      parent.end_time > child.end_time

  åˆ†æ:
    1. å­ Span åœ¨çˆ¶ Span ç»“æŸä¹‹å‰ç»“æŸ
    2. è¿åäº† Span ç”Ÿå‘½å‘¨æœŸè¯­ä¹‰
    3. ä¸ Span å®šä¹‰çŸ›ç›¾

  ç»“è®º:
    åŸå‡è®¾ä¸æˆç«‹,å› æ­¤å®šç†æˆç«‹
    è¯æ¯• âˆ
```

### 3. å”¯ä¸€æ€§ä¿è¯

**å®šç†**: åŒä¸€ Trace ä¸­ SpanID å”¯ä¸€

```text
å®šç† (Uniqueness):
  âˆ€ t: Trace, sâ‚, sâ‚‚: t.spans â€¢
    sâ‚ â‰  sâ‚‚ â‡’ sâ‚.span_id â‰  sâ‚‚.span_id

è¯æ˜:
  å½’çº³æ³•:
    åŸºç¡€: ç©º Trace, æ€§è´¨å¹³å‡¡æˆç«‹
    
    å½’çº³: å‡è®¾å¯¹ n ä¸ª Span çš„ Trace æˆç«‹
          æ·»åŠ  Span s_{n+1}
          
          æ ¹æ® Span åˆ›å»ºè§„èŒƒ:
            s_{n+1}.span_id = generate_unique_id()
            
          generate_unique_id() ä¿è¯:
            s_{n+1}.span_id âˆ‰ {s.span_id | s âˆˆ existing_spans}
          
          å› æ­¤æ€§è´¨å¯¹ n+1 ä¸ª Span ä¹Ÿæˆç«‹

  ç»“è®º:
    ç”±å½’çº³æ³•,å®šç†å¯¹æ‰€æœ‰ Trace æˆç«‹
    è¯æ¯• âˆ
```

---

## ä¸€è‡´æ€§éªŒè¯

### 1. æ¨¡å‹æ£€æŸ¥

ä½¿ç”¨ TLC (TLA+ æ¨¡å‹æ£€æŸ¥å™¨) éªŒè¯åè®®å±æ€§:

```bash
# è¿è¡Œ TLC æ¨¡å‹æ£€æŸ¥å™¨
tlc OTLPExport.tla -config OTLPExport.cfg

# éªŒè¯å±æ€§
- TypeInvariant: âœ“ é€šè¿‡
- Safety: âœ“ é€šè¿‡
- Liveness: âœ“ é€šè¿‡
- Deadlock: âœ“ æ— æ­»é”

# è¦†ç›–ç‡
- çŠ¶æ€ç©ºé—´: 1,234 states
- çŠ¶æ€è½¬æ¢: 5,678 transitions
- è¿è¡Œæ—¶é—´: 2.3 seconds
```

### 2. æµ‹è¯•ç”¨ä¾‹ç”Ÿæˆ

```go
package formaltest

// åŸºäºå½¢å¼åŒ–è§„èŒƒç”Ÿæˆæµ‹è¯•ç”¨ä¾‹

// æµ‹è¯•æ•°æ®å®Œæ•´æ€§
func TestDataIntegrity(t *testing.T) {
    // ç”Ÿæˆéšæœº Span
    span := generateRandomSpan()
    
    // å‘é€
    client.Send(span)
    
    // éªŒè¯æ¥æ”¶
    received := server.Receive()
    
    // æ–­è¨€
    assert.Equal(t, span, received, "æ•°æ®å®Œæ•´æ€§")
}

// æµ‹è¯•å› æœé¡ºåº
func TestCausalOrdering(t *testing.T) {
    parent := generateSpan("parent", nil)
    child := generateSpan("child", parent.SpanID)
    
    assert.True(t, 
        parent.EndTime <= child.EndTime,
        "å› æœé¡ºåºè¿å",
    )
}

// æµ‹è¯•å”¯ä¸€æ€§
func TestUniqueness(t *testing.T) {
    trace := generateTrace(100)
    
    spanIDs := make(map[SpanID]bool)
    for _, span := range trace.Spans {
        assert.False(t, spanIDs[span.SpanID], "SpanID é‡å¤")
        spanIDs[span.SpanID] = true
    }
}

// æµ‹è¯•é‡è¯•è¡Œä¸º
func TestRetryBehavior(t *testing.T) {
    const maxRetries = 3
    
    attempts := 0
    err := RetryWithBackoff(maxRetries, func() error {
        attempts++
        if attempts < maxRetries {
            return errors.New("temporary error")
        }
        return nil
    })
    
    assert.NoError(t, err)
    assert.Equal(t, maxRetries, attempts)
}
```

---

## å®‰å…¨æ€§åˆ†æ

### 1. å¨èƒæ¨¡å‹

```text
å¨èƒåˆ†ç±»:

1. æ•°æ®çªƒå¬ (Eavesdropping)
   å¨èƒ: æ•æ„Ÿæ•°æ®æ³„éœ²
   ç¼“è§£: TLS åŠ å¯†

2. æ•°æ®ç¯¡æ”¹ (Tampering)
   å¨èƒ: æ•°æ®è¢«ä¿®æ”¹
   ç¼“è§£: TLS + ç­¾åéªŒè¯

3. é‡æ”¾æ”»å‡» (Replay Attack)
   å¨èƒ: æ—§æ•°æ®è¢«é‡æ”¾
   ç¼“è§£: æ—¶é—´æˆ³ + Nonce

4. æ‹’ç»æœåŠ¡ (DoS)
   å¨èƒ: æœåŠ¡ä¸å¯ç”¨
   ç¼“è§£: é™æµ + æ–­è·¯å™¨

5. æƒé™æå‡ (Privilege Escalation)
   å¨èƒ: æœªæˆæƒè®¿é—®
   ç¼“è§£: è®¤è¯ + æˆæƒ
```

### 2. å®‰å…¨å±æ€§å½¢å¼åŒ–

```text
-- æœºå¯†æ€§ (Confidentiality)
property confidentiality:
  âˆ€ span: Span, attacker: Agent â€¢
    attacker âˆ‰ authorized_parties
    â‡’ Â¬attacker.can_read(span)

-- å®Œæ•´æ€§ (Integrity)
property integrity:
  âˆ€ span: Span â€¢
    span.sent = span.received
    âˆ¨ integrity_check_failed

-- å¯ç”¨æ€§ (Availability)
property availability:
  âˆ€ request: Request â€¢
    â—‡(response(request) âˆ¨ timeout(request))

-- è®¤è¯ (Authentication)
property authentication:
  âˆ€ client: Client â€¢
    server.accepts(client.request)
    â‡’ verified(client.identity)

-- æˆæƒ (Authorization)
property authorization:
  âˆ€ client: Client, resource: Resource â€¢
    client.access(resource)
    â‡’ has_permission(client, resource)
```

### 3. å®‰å…¨æ£€æŸ¥æ¸…å•

```text
âœ… ä¼ è¾“å±‚å®‰å…¨
   - TLS 1.2+ å¼ºåˆ¶
   - è¯ä¹¦éªŒè¯
   - å¯†ç å¥—ä»¶å®‰å…¨

âœ… è®¤è¯æœºåˆ¶
   - Bearer Token
   - mTLS
   - API Key

âœ… æˆæƒæ§åˆ¶
   - RBAC
   - ABAC
   - æœ€å°æƒé™åŸåˆ™

âœ… æ•°æ®ä¿æŠ¤
   - æ•æ„Ÿæ•°æ®è„±æ•
   - PII ä¿æŠ¤
   - æ•°æ®ä¿ç•™ç­–ç•¥

âœ… å®¡è®¡æ—¥å¿—
   - è®¿é—®æ—¥å¿—
   - æ“ä½œæ—¥å¿—
   - å¼‚å¸¸æ—¥å¿—

âœ… é€Ÿç‡é™åˆ¶
   - è¯·æ±‚é™æµ
   - å¹¶å‘é™åˆ¶
   - é…é¢ç®¡ç†
```

---

## å‚è€ƒèµ„æº

### å½¢å¼åŒ–æ–¹æ³•

- [TLA+ Homepage](https://lamport.azurewebsites.net/tla/tla.html)
- [Z Notation](https://en.wikipedia.org/wiki/Z_notation)
- [Alloy Analyzer](http://alloytools.org/)

### å·¥å…·

- [TLC Model Checker](https://lamport.azurewebsites.net/tla/tools.html)
- [Coq Proof Assistant](https://coq.inria.fr/)
- [Isabelle/HOL](https://isabelle.in.tum.de/)

### è®ºæ–‡

- Leslie Lamport, "Specifying Systems" (2002)
- Nancy Lynch, "Distributed Algorithms" (1996)
- Butler Lampson, "Hints for Computer System Design" (1983)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ9æ—¥  
**ç»´æŠ¤è€…**: OTLP æ ‡å‡†åŒ–é¡¹ç›®ç»„
