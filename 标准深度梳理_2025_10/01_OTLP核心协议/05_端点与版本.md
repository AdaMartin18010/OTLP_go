# OTLP ç«¯ç‚¹ä¸ç‰ˆæœ¬ç®¡ç†

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
> **OTLP ç‰ˆæœ¬**: v1.3.x  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ9æ—¥

---

## ğŸ“‹ ç›®å½•

- [OTLP ç«¯ç‚¹ä¸ç‰ˆæœ¬ç®¡ç†](#otlp-ç«¯ç‚¹ä¸ç‰ˆæœ¬ç®¡ç†)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [ä»€ä¹ˆæ˜¯ OTLP ç«¯ç‚¹](#ä»€ä¹ˆæ˜¯-otlp-ç«¯ç‚¹)
    - [ç«¯ç‚¹ç±»å‹](#ç«¯ç‚¹ç±»å‹)
  - [ç«¯ç‚¹å®šä¹‰è§„èŒƒ](#ç«¯ç‚¹å®šä¹‰è§„èŒƒ)
    - [1. gRPC ç«¯ç‚¹](#1-grpc-ç«¯ç‚¹)
      - [æœåŠ¡å®šä¹‰](#æœåŠ¡å®šä¹‰)
      - [ç«¯ç‚¹æ ¼å¼](#ç«¯ç‚¹æ ¼å¼)
      - [å®Œæ•´ç¤ºä¾‹ (Go)](#å®Œæ•´ç¤ºä¾‹-go)
    - [2. HTTP ç«¯ç‚¹](#2-http-ç«¯ç‚¹)
      - [ç«¯ç‚¹è·¯å¾„](#ç«¯ç‚¹è·¯å¾„)
      - [å®Œæ•´ URL æ ¼å¼](#å®Œæ•´-url-æ ¼å¼)
      - [è¯·æ±‚å¤´](#è¯·æ±‚å¤´)
      - [1å®Œæ•´ç¤ºä¾‹ (Go)](#1å®Œæ•´ç¤ºä¾‹-go)
    - [3. Metrics ç«¯ç‚¹](#3-metrics-ç«¯ç‚¹)
  - [ç‰ˆæœ¬ç®¡ç†ç­–ç•¥](#ç‰ˆæœ¬ç®¡ç†ç­–ç•¥)
    - [1. ç‰ˆæœ¬å·æ ¼å¼](#1-ç‰ˆæœ¬å·æ ¼å¼)
    - [2. API ç‰ˆæœ¬æ¼”è¿›](#2-api-ç‰ˆæœ¬æ¼”è¿›)
      - [ç‰ˆæœ¬ç”Ÿå‘½å‘¨æœŸ](#ç‰ˆæœ¬ç”Ÿå‘½å‘¨æœŸ)
      - [ç‰ˆæœ¬å…¼å®¹æ€§çŸ©é˜µ](#ç‰ˆæœ¬å…¼å®¹æ€§çŸ©é˜µ)
    - [3. ç‰ˆæœ¬åå•†](#3-ç‰ˆæœ¬åå•†)
      - [gRPC ç‰ˆæœ¬åå•†](#grpc-ç‰ˆæœ¬åå•†)
      - [HTTP ç‰ˆæœ¬åå•†](#http-ç‰ˆæœ¬åå•†)
    - [4. å‘åå…¼å®¹ç­–ç•¥](#4-å‘åå…¼å®¹ç­–ç•¥)
      - [æ·»åŠ å­—æ®µ (å…¼å®¹)](#æ·»åŠ å­—æ®µ-å…¼å®¹)
      - [ç§»é™¤å­—æ®µ (ä¸å…¼å®¹ - éœ€è¦ä¸»ç‰ˆæœ¬å‡çº§)](#ç§»é™¤å­—æ®µ-ä¸å…¼å®¹---éœ€è¦ä¸»ç‰ˆæœ¬å‡çº§)
  - [URL ç»“æ„](#url-ç»“æ„)
    - [1. æ ‡å‡† URL æ ¼å¼](#1-æ ‡å‡†-url-æ ¼å¼)
    - [2. URL ç¤ºä¾‹](#2-url-ç¤ºä¾‹)
      - [æœ¬åœ°å¼€å‘](#æœ¬åœ°å¼€å‘)
      - [ç”Ÿäº§ç¯å¢ƒ](#ç”Ÿäº§ç¯å¢ƒ)
      - [äº‘æœåŠ¡](#äº‘æœåŠ¡)
    - [3. URL è§£æ](#3-url-è§£æ)
  - [ç«¯ç‚¹å‘ç°æœºåˆ¶](#ç«¯ç‚¹å‘ç°æœºåˆ¶)
    - [1. ç¯å¢ƒå˜é‡é…ç½®](#1-ç¯å¢ƒå˜é‡é…ç½®)
    - [2. é…ç½®æ–‡ä»¶](#2-é…ç½®æ–‡ä»¶)
    - [3. æœåŠ¡å‘ç°](#3-æœåŠ¡å‘ç°)
      - [DNS SRV è®°å½•](#dns-srv-è®°å½•)
      - [Go å®ç°](#go-å®ç°)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [1. ç«¯ç‚¹é…ç½®](#1-ç«¯ç‚¹é…ç½®)
    - [2. å¤šç«¯ç‚¹è´Ÿè½½å‡è¡¡](#2-å¤šç«¯ç‚¹è´Ÿè½½å‡è¡¡)
    - [3. ç«¯ç‚¹å¥åº·æ£€æŸ¥](#3-ç«¯ç‚¹å¥åº·æ£€æŸ¥)
  - [å‚è€ƒèµ„æº](#å‚è€ƒèµ„æº)
    - [å®˜æ–¹æ–‡æ¡£](#å®˜æ–¹æ–‡æ¡£)
    - [å®ç°å‚è€ƒ](#å®ç°å‚è€ƒ)

---

## æ¦‚è¿°

### ä»€ä¹ˆæ˜¯ OTLP ç«¯ç‚¹

**å½¢å¼åŒ–å®šä¹‰**:

```text
Endpoint = (Protocol, Host, Port, Path, Version)

å…¶ä¸­:
- Protocol: ä¼ è¾“åè®® (gRPC, HTTP/1.1, HTTP/2, HTTP/3)
- Host: æœåŠ¡å™¨åœ°å€
- Port: ç«¯å£å·
- Path: è¯·æ±‚è·¯å¾„
- Version: API ç‰ˆæœ¬
```

### ç«¯ç‚¹ç±»å‹

OTLP å®šä¹‰äº†ä¸‰ç§ä¸»è¦çš„ç«¯ç‚¹ç±»å‹:

| ç«¯ç‚¹ç±»å‹ | ç”¨é€” | é»˜è®¤ç«¯å£ |
|---------|------|---------|
| **Traces** | æ¥æ”¶è¿½è¸ªæ•°æ® | 4317 (gRPC), 4318 (HTTP) |
| **Metrics** | æ¥æ”¶æŒ‡æ ‡æ•°æ® | 4317 (gRPC), 4318 (HTTP) |
| **Logs** | æ¥æ”¶æ—¥å¿—æ•°æ® | 4317 (gRPC), 4318 (HTTP) |

---

## ç«¯ç‚¹å®šä¹‰è§„èŒƒ

### 1. gRPC ç«¯ç‚¹

#### æœåŠ¡å®šä¹‰

```protobuf
syntax = "proto3";

package opentelemetry.proto.collector.trace.v1;

import "opentelemetry/proto/trace/v1/trace.proto";

// Trace æœåŠ¡
service TraceService {
  // Export å¯¼å‡ºè¿½è¸ªæ•°æ®
  rpc Export(ExportTraceServiceRequest) returns (ExportTraceServiceResponse) {}
}

// è¯·æ±‚æ¶ˆæ¯
message ExportTraceServiceRequest {
  // èµ„æº Spans
  repeated opentelemetry.proto.trace.v1.ResourceSpans resource_spans = 1;
}

// å“åº”æ¶ˆæ¯
message ExportTraceServiceResponse {
  // éƒ¨åˆ†æˆåŠŸä¿¡æ¯
  ExportTracePartialSuccess partial_success = 1;
}
```

#### ç«¯ç‚¹æ ¼å¼

```text
æ ¼å¼: {scheme}://{host}:{port}

ç¤ºä¾‹:
- grpc://localhost:4317
- grpcs://otlp.example.com:4317  # TLS
- dns:///collector.example.com:4317  # DNS è§£æ
```

#### å®Œæ•´ç¤ºä¾‹ (Go)

```go
package client

import (
    "context"
    "time"

    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
)

// NewGRPCTraceExporter åˆ›å»º gRPC Trace Exporter
func NewGRPCTraceExporter(endpoint string) (*sdktrace.TracerProvider, error) {
    ctx := context.Background()

    // åˆ›å»º gRPC Exporter
    exporter, err := otlptracegrpc.New(ctx,
        otlptracegrpc.WithEndpoint(endpoint),
        otlptracegrpc.WithInsecure(),
        otlptracegrpc.WithTimeout(5*time.Second),
        otlptracegrpc.WithDialOption(
            grpc.WithBlock(),
            grpc.WithReturnConnectionError(),
        ),
    )
    if err != nil {
        return nil, err
    }

    // åˆ›å»º TracerProvider
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter),
    )

    return tp, nil
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    tp, err := NewGRPCTraceExporter("localhost:4317")
    if err != nil {
        panic(err)
    }
    defer tp.Shutdown(context.Background())
}
```

### 2. HTTP ç«¯ç‚¹

#### ç«¯ç‚¹è·¯å¾„

| ä¿¡å·ç±»å‹ | è·¯å¾„ | æ–¹æ³• |
|---------|------|------|
| **Traces** | `/v1/traces` | POST |
| **Metrics** | `/v1/metrics` | POST |
| **Logs** | `/v1/logs` | POST |

#### å®Œæ•´ URL æ ¼å¼

```text
æ ¼å¼: {scheme}://{host}:{port}{path}

ç¤ºä¾‹:
- http://localhost:4318/v1/traces
- https://otlp.example.com:4318/v1/metrics
- https://api.observability.io/otlp/v1/logs
```

#### è¯·æ±‚å¤´

```http
POST /v1/traces HTTP/1.1
Host: localhost:4318
Content-Type: application/x-protobuf
Content-Encoding: gzip
Accept: application/x-protobuf
User-Agent: otel-sdk/1.32.0
```

#### 1å®Œæ•´ç¤ºä¾‹ (Go)

```go
package client

import (
    "context"
    "time"

    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
)

// NewHTTPTraceExporter åˆ›å»º HTTP Trace Exporter
func NewHTTPTraceExporter(endpoint string) (*sdktrace.TracerProvider, error) {
    ctx := context.Background()

    // åˆ›å»º HTTP Exporter
    exporter, err := otlptracehttp.New(ctx,
        otlptracehttp.WithEndpoint(endpoint),
        otlptracehttp.WithInsecure(),
        otlptracehttp.WithTimeout(5*time.Second),
        otlptracehttp.WithURLPath("/v1/traces"),
        otlptracehttp.WithCompression(otlptracehttp.GzipCompression),
    )
    if err != nil {
        return nil, err
    }

    // åˆ›å»º TracerProvider
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter),
    )

    return tp, nil
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    tp, err := NewHTTPTraceExporter("localhost:4318")
    if err != nil {
        panic(err)
    }
    defer tp.Shutdown(context.Background())
}
```

### 3. Metrics ç«¯ç‚¹

```go
package client

import (
    "context"
    "time"

    "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
    sdkmetric "go.opentelemetry.io/otel/sdk/metric"
)

// NewMetricExporter åˆ›å»º Metric Exporter
func NewMetricExporter(endpoint string) (*sdkmetric.MeterProvider, error) {
    ctx := context.Background()

    // åˆ›å»º gRPC Metric Exporter
    exporter, err := otlpmetricgrpc.New(ctx,
        otlpmetricgrpc.WithEndpoint(endpoint),
        otlpmetricgrpc.WithInsecure(),
        otlpmetricgrpc.WithTimeout(5*time.Second),
    )
    if err != nil {
        return nil, err
    }

    // åˆ›å»º MeterProvider
    mp := sdkmetric.NewMeterProvider(
        sdkmetric.WithReader(
            sdkmetric.NewPeriodicReader(exporter,
                sdkmetric.WithInterval(10*time.Second),
            ),
        ),
    )

    return mp, nil
}
```

---

## ç‰ˆæœ¬ç®¡ç†ç­–ç•¥

### 1. ç‰ˆæœ¬å·æ ¼å¼

OTLP ä½¿ç”¨è¯­ä¹‰åŒ–ç‰ˆæœ¬ (Semantic Versioning):

```text
æ ¼å¼: v{MAJOR}.{MINOR}.{PATCH}

ç¤ºä¾‹:
- v1.0.0: åˆå§‹ç¨³å®šç‰ˆæœ¬
- v1.1.0: æ·»åŠ æ–°ç‰¹æ€§ (å‘åå…¼å®¹)
- v1.1.1: Bug ä¿®å¤ (å‘åå…¼å®¹)
- v2.0.0: é‡å¤§å˜æ›´ (ä¸å…¼å®¹)
```

### 2. API ç‰ˆæœ¬æ¼”è¿›

#### ç‰ˆæœ¬ç”Ÿå‘½å‘¨æœŸ

```text
å¼€å‘é˜¶æ®µ:
  v0.x.x â†’ Alpha â†’ Beta â†’ RC â†’ v1.0.0 (GA)

ç¨³å®šé˜¶æ®µ:
  v1.0.0 â†’ v1.1.0 â†’ v1.2.0 â†’ v1.x.x

é‡å¤§å‡çº§:
  v1.x.x â†’ v2.0.0 (åºŸå¼ƒ v1)
  
åºŸå¼ƒæœŸ:
  v1.x.x (åºŸå¼ƒ) â†’ 6-12ä¸ªæœˆ â†’ å®Œå…¨ç§»é™¤
```

#### ç‰ˆæœ¬å…¼å®¹æ€§çŸ©é˜µ

| å®¢æˆ·ç«¯ç‰ˆæœ¬ | æœåŠ¡ç«¯ v1.0 | æœåŠ¡ç«¯ v1.1 | æœåŠ¡ç«¯ v2.0 |
|----------|-----------|-----------|-----------|
| **v1.0** | âœ… å®Œå…¨å…¼å®¹ | âœ… å‘åå…¼å®¹ | âŒ ä¸å…¼å®¹ |
| **v1.1** | âœ… å‘å‰å…¼å®¹ | âœ… å®Œå…¨å…¼å®¹ | âŒ ä¸å…¼å®¹ |
| **v2.0** | âŒ ä¸å…¼å®¹ | âŒ ä¸å…¼å®¹ | âœ… å®Œå…¨å…¼å®¹ |

### 3. ç‰ˆæœ¬åå•†

#### gRPC ç‰ˆæœ¬åå•†

```go
package version

import (
    "context"
    
    "google.golang.org/grpc/metadata"
)

// å®¢æˆ·ç«¯å‘é€ç‰ˆæœ¬ä¿¡æ¯
func ClientWithVersion(ctx context.Context, version string) context.Context {
    md := metadata.Pairs(
        "otlp-version", version,
        "user-agent", "otel-sdk/1.32.0",
    )
    return metadata.NewOutgoingContext(ctx, md)
}

// æœåŠ¡ç«¯æ£€æŸ¥ç‰ˆæœ¬
func ServerCheckVersion(ctx context.Context) (string, error) {
    md, ok := metadata.FromIncomingContext(ctx)
    if !ok {
        return "", fmt.Errorf("no metadata")
    }
    
    versions := md.Get("otlp-version")
    if len(versions) == 0 {
        return "v1.0.0", nil  // é»˜è®¤ç‰ˆæœ¬
    }
    
    return versions[0], nil
}
```

#### HTTP ç‰ˆæœ¬åå•†

```http
# å®¢æˆ·ç«¯è¯·æ±‚
POST /v1/traces HTTP/1.1
Host: localhost:4318
OTLP-Version: 1.1.0
User-Agent: otel-sdk/1.32.0

# æœåŠ¡ç«¯å“åº”
HTTP/1.1 200 OK
OTLP-Version: 1.1.0
Server: otlp-collector/0.100.0
```

### 4. å‘åå…¼å®¹ç­–ç•¥

#### æ·»åŠ å­—æ®µ (å…¼å®¹)

```protobuf
// v1.0.0
message SpanV1 {
  bytes trace_id = 1;
  bytes span_id = 2;
  string name = 3;
}

// v1.1.0 (å‘åå…¼å®¹)
message SpanV1_1 {
  bytes trace_id = 1;
  bytes span_id = 2;
  string name = 3;
  
  // æ–°å­—æ®µ (æ—§å®¢æˆ·ç«¯ä¼šå¿½ç•¥)
  string display_name = 4;
}
```

#### ç§»é™¤å­—æ®µ (ä¸å…¼å®¹ - éœ€è¦ä¸»ç‰ˆæœ¬å‡çº§)

```protobuf
// v1.0.0
message SpanV1 {
  bytes trace_id = 1;
  bytes span_id = 2;
  string deprecated_field = 3;
}

// v2.0.0 (ä¸å…¼å®¹)
message SpanV2 {
  bytes trace_id = 1;
  bytes span_id = 2;
  // deprecated_field å·²ç§»é™¤
  reserved 3;
  reserved "deprecated_field";
}
```

---

## URL ç»“æ„

### 1. æ ‡å‡† URL æ ¼å¼

```text
å®Œæ•´æ ¼å¼:
{scheme}://{host}:{port}/{version}/{signal}[?{query}][#{fragment}]

ç»„ä»¶è¯´æ˜:
- scheme: http, https, grpc, grpcs
- host: ä¸»æœºåæˆ– IP
- port: ç«¯å£å·
- version: API ç‰ˆæœ¬ (v1, v2)
- signal: ä¿¡å·ç±»å‹ (traces, metrics, logs)
- query: æŸ¥è¯¢å‚æ•° (å¯é€‰)
- fragment: ç‰‡æ®µæ ‡è¯†ç¬¦ (å¯é€‰)
```

### 2. URL ç¤ºä¾‹

#### æœ¬åœ°å¼€å‘

```text
# gRPC
grpc://localhost:4317

# HTTP Traces
http://localhost:4318/v1/traces

# HTTP Metrics
http://localhost:4318/v1/metrics

# HTTP Logs
http://localhost:4318/v1/logs
```

#### ç”Ÿäº§ç¯å¢ƒ

```text
# ä½¿ç”¨ TLS
https://otlp.example.com:4318/v1/traces

# ä½¿ç”¨è‡ªå®šä¹‰è·¯å¾„
https://api.example.com/telemetry/otlp/v1/traces

# ä½¿ç”¨æŸ¥è¯¢å‚æ•°
https://otlp.example.com/v1/traces?tenant=acme

# ä½¿ç”¨åŸºæœ¬è®¤è¯
https://user:pass@otlp.example.com:4318/v1/traces
```

#### äº‘æœåŠ¡

```text
# AWS
https://otlp.us-east-1.amazonaws.com/v1/traces

# GCP
https://otlp.googleapis.com/v1/traces

# Azure
https://otlp.azure.com/v1/traces

# Datadog
https://trace.agent.datadoghq.com/v1/traces

# Honeycomb
https://api.honeycomb.io/v1/traces
```

### 3. URL è§£æ

```go
package url

import (
    "fmt"
    "net/url"
    "strings"
)

// OTLPEndpoint OTLP ç«¯ç‚¹
type OTLPEndpoint struct {
    Scheme  string  // http, https, grpc, grpcs
    Host    string  // ä¸»æœºå
    Port    int     // ç«¯å£å·
    Path    string  // è·¯å¾„
    Version string  // API ç‰ˆæœ¬
    Signal  string  // ä¿¡å·ç±»å‹
}

// ParseEndpoint è§£æç«¯ç‚¹ URL
func ParseEndpoint(rawURL string) (*OTLPEndpoint, error) {
    u, err := url.Parse(rawURL)
    if err != nil {
        return nil, err
    }

    endpoint := &OTLPEndpoint{
        Scheme: u.Scheme,
        Host:   u.Hostname(),
    }

    // è§£æç«¯å£
    if port := u.Port(); port != "" {
        fmt.Sscanf(port, "%d", &endpoint.Port)
    } else {
        // é»˜è®¤ç«¯å£
        if u.Scheme == "grpc" || u.Scheme == "grpcs" {
            endpoint.Port = 4317
        } else {
            endpoint.Port = 4318
        }
    }

    // è§£æè·¯å¾„
    pathParts := strings.Split(strings.Trim(u.Path, "/"), "/")
    if len(pathParts) >= 2 {
        endpoint.Version = pathParts[0]  // v1
        endpoint.Signal = pathParts[1]   // traces
    }

    return endpoint, nil
}

// String è¿”å›å®Œæ•´ URL
func (e *OTLPEndpoint) String() string {
    if e.Scheme == "grpc" || e.Scheme == "grpcs" {
        return fmt.Sprintf("%s://%s:%d", e.Scheme, e.Host, e.Port)
    }
    return fmt.Sprintf("%s://%s:%d/%s/%s",
        e.Scheme, e.Host, e.Port, e.Version, e.Signal)
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    endpoint, _ := ParseEndpoint("https://otlp.example.com:4318/v1/traces")
    fmt.Println(endpoint.Scheme)   // https
    fmt.Println(endpoint.Host)     // otlp.example.com
    fmt.Println(endpoint.Port)     // 4318
    fmt.Println(endpoint.Version)  // v1
    fmt.Println(endpoint.Signal)   // traces
}
```

---

## ç«¯ç‚¹å‘ç°æœºåˆ¶

### 1. ç¯å¢ƒå˜é‡é…ç½®

```bash
# gRPC ç«¯ç‚¹
export OTEL_EXPORTER_OTLP_ENDPOINT="grpc://localhost:4317"

# HTTP ç«¯ç‚¹
export OTEL_EXPORTER_OTLP_ENDPOINT="http://localhost:4318"

# å•ç‹¬é…ç½®
export OTEL_EXPORTER_OTLP_TRACES_ENDPOINT="http://localhost:4318/v1/traces"
export OTEL_EXPORTER_OTLP_METRICS_ENDPOINT="http://localhost:4318/v1/metrics"
export OTEL_EXPORTER_OTLP_LOGS_ENDPOINT="http://localhost:4318/v1/logs"

# åè®®
export OTEL_EXPORTER_OTLP_PROTOCOL="grpc"  # grpc, http/protobuf, http/json

# è®¤è¯
export OTEL_EXPORTER_OTLP_HEADERS="api-key=secret"
```

### 2. é…ç½®æ–‡ä»¶

```yaml
# otel-config.yaml
exporters:
  otlp:
    endpoint: "localhost:4317"
    protocol: grpc
    insecure: true
    timeout: 5s
    
  otlp/traces:
    endpoint: "https://traces.example.com"
    protocol: http/protobuf
    headers:
      api-key: "secret"
      
  otlp/metrics:
    endpoint: "https://metrics.example.com"
    protocol: http/protobuf
    
service:
  pipelines:
    traces:
      exporters: [otlp/traces]
    metrics:
      exporters: [otlp/metrics]
```

### 3. æœåŠ¡å‘ç°

#### DNS SRV è®°å½•

```text
# DNS é…ç½®
_otlp._tcp.example.com. 3600 IN SRV 10 60 4317 collector1.example.com.
_otlp._tcp.example.com. 3600 IN SRV 10 40 4317 collector2.example.com.

# æŸ¥è¯¢
dig _otlp._tcp.example.com SRV
```

#### Go å®ç°

```go
package discovery

import (
    "context"
    "fmt"
    "net"
)

// DiscoverEndpoints é€šè¿‡ DNS SRV å‘ç°ç«¯ç‚¹
func DiscoverEndpoints(service, proto, domain string) ([]string, error) {
    _, srvs, err := net.LookupSRV(service, proto, domain)
    if err != nil {
        return nil, err
    }

    endpoints := make([]string, 0, len(srvs))
    for _, srv := range srvs {
        endpoint := fmt.Sprintf("%s:%d", srv.Target, srv.Port)
        endpoints = append(endpoints, endpoint)
    }

    return endpoints, nil
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    endpoints, err := DiscoverEndpoints("otlp", "tcp", "example.com")
    if err != nil {
        panic(err)
    }
    
    for _, endpoint := range endpoints {
        fmt.Println(endpoint)
    }
    // è¾“å‡º:
    // collector1.example.com:4317
    // collector2.example.com:4317
}
```

---

## æœ€ä½³å®è·µ

### 1. ç«¯ç‚¹é…ç½®

```go
package config

import (
    "fmt"
    "net/url"
    "os"
    "strings"
)

// EndpointConfig ç«¯ç‚¹é…ç½®
type EndpointConfig struct {
    // åŸºç¡€é…ç½®
    Endpoint string
    Protocol string  // grpc, http/protobuf
    Insecure bool
    
    // è®¤è¯
    Headers map[string]string
    
    // è¶…æ—¶
    Timeout string
    
    // é‡è¯•
    RetryEnabled bool
    RetryMax     int
}

// LoadFromEnv ä»ç¯å¢ƒå˜é‡åŠ è½½é…ç½®
func LoadFromEnv() *EndpointConfig {
    cfg := &EndpointConfig{
        Endpoint: getEnv("OTEL_EXPORTER_OTLP_ENDPOINT", "localhost:4317"),
        Protocol: getEnv("OTEL_EXPORTER_OTLP_PROTOCOL", "grpc"),
        Insecure: getEnv("OTEL_EXPORTER_OTLP_INSECURE", "false") == "true",
        Timeout:  getEnv("OTEL_EXPORTER_OTLP_TIMEOUT", "10s"),
        Headers:  parseHeaders(os.Getenv("OTEL_EXPORTER_OTLP_HEADERS")),
    }
    
    return cfg
}

// Validate éªŒè¯é…ç½®
func (cfg *EndpointConfig) Validate() error {
    // éªŒè¯ URL
    if _, err := url.Parse(cfg.Endpoint); err != nil {
        return fmt.Errorf("invalid endpoint: %w", err)
    }
    
    // éªŒè¯åè®®
    validProtocols := map[string]bool{
        "grpc":          true,
        "http/protobuf": true,
        "http/json":     true,
    }
    if !validProtocols[cfg.Protocol] {
        return fmt.Errorf("invalid protocol: %s", cfg.Protocol)
    }
    
    return nil
}

func getEnv(key, fallback string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return fallback
}

func parseHeaders(headers string) map[string]string {
    result := make(map[string]string)
    for _, header := range strings.Split(headers, ",") {
        parts := strings.SplitN(header, "=", 2)
        if len(parts) == 2 {
            result[parts[0]] = parts[1]
        }
    }
    return result
}
```

### 2. å¤šç«¯ç‚¹è´Ÿè½½å‡è¡¡

```go
package loadbalancer

import (
    "context"
    "sync/atomic"
)

// RoundRobinBalancer è½®è¯¢è´Ÿè½½å‡è¡¡å™¨
type RoundRobinBalancer struct {
    endpoints []string
    counter   uint64
}

// NewRoundRobinBalancer åˆ›å»ºè½®è¯¢è´Ÿè½½å‡è¡¡å™¨
func NewRoundRobinBalancer(endpoints []string) *RoundRobinBalancer {
    return &RoundRobinBalancer{
        endpoints: endpoints,
        counter:   0,
    }
}

// Next è·å–ä¸‹ä¸€ä¸ªç«¯ç‚¹
func (rb *RoundRobinBalancer) Next() string {
    n := atomic.AddUint64(&rb.counter, 1)
    return rb.endpoints[(n-1)%uint64(len(rb.endpoints))]
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    endpoints := []string{
        "collector1.example.com:4317",
        "collector2.example.com:4317",
        "collector3.example.com:4317",
    }
    
    lb := NewRoundRobinBalancer(endpoints)
    
    for i := 0; i < 6; i++ {
        fmt.Println(lb.Next())
    }
    // è¾“å‡º (å¾ªç¯):
    // collector1.example.com:4317
    // collector2.example.com:4317
    // collector3.example.com:4317
    // collector1.example.com:4317
    // ...
}
```

### 3. ç«¯ç‚¹å¥åº·æ£€æŸ¥

```go
package healthcheck

import (
    "context"
    "fmt"
    "time"
    
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
    "google.golang.org/grpc/health/grpc_health_v1"
)

// HealthChecker å¥åº·æ£€æŸ¥å™¨
type HealthChecker struct {
    endpoint string
    timeout  time.Duration
}

// NewHealthChecker åˆ›å»ºå¥åº·æ£€æŸ¥å™¨
func NewHealthChecker(endpoint string, timeout time.Duration) *HealthChecker {
    return &HealthChecker{
        endpoint: endpoint,
        timeout:  timeout,
    }
}

// Check æ‰§è¡Œå¥åº·æ£€æŸ¥
func (hc *HealthChecker) Check(ctx context.Context) error {
    ctx, cancel := context.WithTimeout(ctx, hc.timeout)
    defer cancel()

    // å»ºç«‹è¿æ¥
    conn, err := grpc.DialContext(ctx, hc.endpoint,
        grpc.WithTransportCredentials(insecure.NewCredentials()),
        grpc.WithBlock(),
    )
    if err != nil {
        return fmt.Errorf("failed to connect: %w", err)
    }
    defer conn.Close()

    // å¥åº·æ£€æŸ¥
    client := grpc_health_v1.NewHealthClient(conn)
    resp, err := client.Check(ctx, &grpc_health_v1.HealthCheckRequest{
        Service: "opentelemetry.proto.collector.trace.v1.TraceService",
    })
    if err != nil {
        return fmt.Errorf("health check failed: %w", err)
    }

    if resp.Status != grpc_health_v1.HealthCheckResponse_SERVING {
        return fmt.Errorf("service not serving: %v", resp.Status)
    }

    return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    hc := NewHealthChecker("localhost:4317", 5*time.Second)
    
    if err := hc.Check(context.Background()); err != nil {
        fmt.Println("Health check failed:", err)
    } else {
        fmt.Println("Service is healthy")
    }
}
```

---

## å‚è€ƒèµ„æº

### å®˜æ–¹æ–‡æ¡£

- [OTLP Specification](https://github.com/open-telemetry/opentelemetry-proto)
- [Protocol Specification](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/otlp.md)
- [Exporter Specification](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/exporter.md)

### å®ç°å‚è€ƒ

- [OpenTelemetry Collector](https://github.com/open-telemetry/opentelemetry-collector)
- [Go SDK Exporters](https://github.com/open-telemetry/opentelemetry-go/tree/main/exporters/otlp)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ9æ—¥  
**ç»´æŠ¤è€…**: OTLP æ ‡å‡†åŒ–é¡¹ç›®ç»„
