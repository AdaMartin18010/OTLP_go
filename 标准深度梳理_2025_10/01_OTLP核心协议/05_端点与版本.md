# OTLP 端点与版本管理

> **文档版本**: v1.0.0  
> **OTLP 版本**: v1.3.x  
> **最后更新**: 2025年10月9日

---

## 📋 目录

- [OTLP 端点与版本管理](#otlp-端点与版本管理)
  - [📋 目录](#-目录)
  - [概述](#概述)
    - [什么是 OTLP 端点](#什么是-otlp-端点)
    - [端点类型](#端点类型)
  - [端点定义规范](#端点定义规范)
    - [1. gRPC 端点](#1-grpc-端点)
      - [服务定义](#服务定义)
      - [端点格式](#端点格式)
      - [完整示例 (Go)](#完整示例-go)
    - [2. HTTP 端点](#2-http-端点)
      - [端点路径](#端点路径)
      - [完整 URL 格式](#完整-url-格式)
      - [请求头](#请求头)
      - [1完整示例 (Go)](#1完整示例-go)
    - [3. Metrics 端点](#3-metrics-端点)
  - [版本管理策略](#版本管理策略)
    - [1. 版本号格式](#1-版本号格式)
    - [2. API 版本演进](#2-api-版本演进)
      - [版本生命周期](#版本生命周期)
      - [版本兼容性矩阵](#版本兼容性矩阵)
    - [3. 版本协商](#3-版本协商)
      - [gRPC 版本协商](#grpc-版本协商)
      - [HTTP 版本协商](#http-版本协商)
    - [4. 向后兼容策略](#4-向后兼容策略)
      - [添加字段 (兼容)](#添加字段-兼容)
      - [移除字段 (不兼容 - 需要主版本升级)](#移除字段-不兼容---需要主版本升级)
  - [URL 结构](#url-结构)
    - [1. 标准 URL 格式](#1-标准-url-格式)
    - [2. URL 示例](#2-url-示例)
      - [本地开发](#本地开发)
      - [生产环境](#生产环境)
      - [云服务](#云服务)
    - [3. URL 解析](#3-url-解析)
  - [端点发现机制](#端点发现机制)
    - [1. 环境变量配置](#1-环境变量配置)
    - [2. 配置文件](#2-配置文件)
    - [3. 服务发现](#3-服务发现)
      - [DNS SRV 记录](#dns-srv-记录)
      - [Go 实现](#go-实现)
  - [最佳实践](#最佳实践)
    - [1. 端点配置](#1-端点配置)
    - [2. 多端点负载均衡](#2-多端点负载均衡)
    - [3. 端点健康检查](#3-端点健康检查)
  - [参考资源](#参考资源)
    - [官方文档](#官方文档)
    - [实现参考](#实现参考)

---

## 概述

### 什么是 OTLP 端点

**形式化定义**:

```text
Endpoint = (Protocol, Host, Port, Path, Version)

其中:
- Protocol: 传输协议 (gRPC, HTTP/1.1, HTTP/2, HTTP/3)
- Host: 服务器地址
- Port: 端口号
- Path: 请求路径
- Version: API 版本
```

### 端点类型

OTLP 定义了三种主要的端点类型:

| 端点类型 | 用途 | 默认端口 |
|---------|------|---------|
| **Traces** | 接收追踪数据 | 4317 (gRPC), 4318 (HTTP) |
| **Metrics** | 接收指标数据 | 4317 (gRPC), 4318 (HTTP) |
| **Logs** | 接收日志数据 | 4317 (gRPC), 4318 (HTTP) |

---

## 端点定义规范

### 1. gRPC 端点

#### 服务定义

```protobuf
syntax = "proto3";

package opentelemetry.proto.collector.trace.v1;

import "opentelemetry/proto/trace/v1/trace.proto";

// Trace 服务
service TraceService {
  // Export 导出追踪数据
  rpc Export(ExportTraceServiceRequest) returns (ExportTraceServiceResponse) {}
}

// 请求消息
message ExportTraceServiceRequest {
  // 资源 Spans
  repeated opentelemetry.proto.trace.v1.ResourceSpans resource_spans = 1;
}

// 响应消息
message ExportTraceServiceResponse {
  // 部分成功信息
  ExportTracePartialSuccess partial_success = 1;
}
```

#### 端点格式

```text
格式: {scheme}://{host}:{port}

示例:
- grpc://localhost:4317
- grpcs://otlp.example.com:4317  # TLS
- dns:///collector.example.com:4317  # DNS 解析
```

#### 完整示例 (Go)

```go
package client

import (
    "context"
    "time"

    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
)

// NewGRPCTraceExporter 创建 gRPC Trace Exporter
func NewGRPCTraceExporter(endpoint string) (*sdktrace.TracerProvider, error) {
    ctx := context.Background()

    // 创建 gRPC Exporter
    exporter, err := otlptracegrpc.New(ctx,
        otlptracegrpc.WithEndpoint(endpoint),
        otlptracegrpc.WithInsecure(),
        otlptracegrpc.WithTimeout(5*time.Second),
        otlptracegrpc.WithDialOption(
            grpc.WithBlock(),
            grpc.WithReturnConnectionError(),
        ),
    )
    if err != nil {
        return nil, err
    }

    // 创建 TracerProvider
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter),
    )

    return tp, nil
}

// 使用示例
func Example() {
    tp, err := NewGRPCTraceExporter("localhost:4317")
    if err != nil {
        panic(err)
    }
    defer tp.Shutdown(context.Background())
}
```

### 2. HTTP 端点

#### 端点路径

| 信号类型 | 路径 | 方法 |
|---------|------|------|
| **Traces** | `/v1/traces` | POST |
| **Metrics** | `/v1/metrics` | POST |
| **Logs** | `/v1/logs` | POST |

#### 完整 URL 格式

```text
格式: {scheme}://{host}:{port}{path}

示例:
- http://localhost:4318/v1/traces
- https://otlp.example.com:4318/v1/metrics
- https://api.observability.io/otlp/v1/logs
```

#### 请求头

```http
POST /v1/traces HTTP/1.1
Host: localhost:4318
Content-Type: application/x-protobuf
Content-Encoding: gzip
Accept: application/x-protobuf
User-Agent: otel-sdk/1.32.0
```

#### 1完整示例 (Go)

```go
package client

import (
    "context"
    "time"

    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
)

// NewHTTPTraceExporter 创建 HTTP Trace Exporter
func NewHTTPTraceExporter(endpoint string) (*sdktrace.TracerProvider, error) {
    ctx := context.Background()

    // 创建 HTTP Exporter
    exporter, err := otlptracehttp.New(ctx,
        otlptracehttp.WithEndpoint(endpoint),
        otlptracehttp.WithInsecure(),
        otlptracehttp.WithTimeout(5*time.Second),
        otlptracehttp.WithURLPath("/v1/traces"),
        otlptracehttp.WithCompression(otlptracehttp.GzipCompression),
    )
    if err != nil {
        return nil, err
    }

    // 创建 TracerProvider
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter),
    )

    return tp, nil
}

// 使用示例
func Example() {
    tp, err := NewHTTPTraceExporter("localhost:4318")
    if err != nil {
        panic(err)
    }
    defer tp.Shutdown(context.Background())
}
```

### 3. Metrics 端点

```go
package client

import (
    "context"
    "time"

    "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
    sdkmetric "go.opentelemetry.io/otel/sdk/metric"
)

// NewMetricExporter 创建 Metric Exporter
func NewMetricExporter(endpoint string) (*sdkmetric.MeterProvider, error) {
    ctx := context.Background()

    // 创建 gRPC Metric Exporter
    exporter, err := otlpmetricgrpc.New(ctx,
        otlpmetricgrpc.WithEndpoint(endpoint),
        otlpmetricgrpc.WithInsecure(),
        otlpmetricgrpc.WithTimeout(5*time.Second),
    )
    if err != nil {
        return nil, err
    }

    // 创建 MeterProvider
    mp := sdkmetric.NewMeterProvider(
        sdkmetric.WithReader(
            sdkmetric.NewPeriodicReader(exporter,
                sdkmetric.WithInterval(10*time.Second),
            ),
        ),
    )

    return mp, nil
}
```

---

## 版本管理策略

### 1. 版本号格式

OTLP 使用语义化版本 (Semantic Versioning):

```text
格式: v{MAJOR}.{MINOR}.{PATCH}

示例:
- v1.0.0: 初始稳定版本
- v1.1.0: 添加新特性 (向后兼容)
- v1.1.1: Bug 修复 (向后兼容)
- v2.0.0: 重大变更 (不兼容)
```

### 2. API 版本演进

#### 版本生命周期

```text
开发阶段:
  v0.x.x → Alpha → Beta → RC → v1.0.0 (GA)

稳定阶段:
  v1.0.0 → v1.1.0 → v1.2.0 → v1.x.x

重大升级:
  v1.x.x → v2.0.0 (废弃 v1)
  
废弃期:
  v1.x.x (废弃) → 6-12个月 → 完全移除
```

#### 版本兼容性矩阵

| 客户端版本 | 服务端 v1.0 | 服务端 v1.1 | 服务端 v2.0 |
|----------|-----------|-----------|-----------|
| **v1.0** | ✅ 完全兼容 | ✅ 向后兼容 | ❌ 不兼容 |
| **v1.1** | ✅ 向前兼容 | ✅ 完全兼容 | ❌ 不兼容 |
| **v2.0** | ❌ 不兼容 | ❌ 不兼容 | ✅ 完全兼容 |

### 3. 版本协商

#### gRPC 版本协商

```go
package version

import (
    "context"
    
    "google.golang.org/grpc/metadata"
)

// 客户端发送版本信息
func ClientWithVersion(ctx context.Context, version string) context.Context {
    md := metadata.Pairs(
        "otlp-version", version,
        "user-agent", "otel-sdk/1.32.0",
    )
    return metadata.NewOutgoingContext(ctx, md)
}

// 服务端检查版本
func ServerCheckVersion(ctx context.Context) (string, error) {
    md, ok := metadata.FromIncomingContext(ctx)
    if !ok {
        return "", fmt.Errorf("no metadata")
    }
    
    versions := md.Get("otlp-version")
    if len(versions) == 0 {
        return "v1.0.0", nil  // 默认版本
    }
    
    return versions[0], nil
}
```

#### HTTP 版本协商

```http
# 客户端请求
POST /v1/traces HTTP/1.1
Host: localhost:4318
OTLP-Version: 1.1.0
User-Agent: otel-sdk/1.32.0

# 服务端响应
HTTP/1.1 200 OK
OTLP-Version: 1.1.0
Server: otlp-collector/0.100.0
```

### 4. 向后兼容策略

#### 添加字段 (兼容)

```protobuf
// v1.0.0
message SpanV1 {
  bytes trace_id = 1;
  bytes span_id = 2;
  string name = 3;
}

// v1.1.0 (向后兼容)
message SpanV1_1 {
  bytes trace_id = 1;
  bytes span_id = 2;
  string name = 3;
  
  // 新字段 (旧客户端会忽略)
  string display_name = 4;
}
```

#### 移除字段 (不兼容 - 需要主版本升级)

```protobuf
// v1.0.0
message SpanV1 {
  bytes trace_id = 1;
  bytes span_id = 2;
  string deprecated_field = 3;
}

// v2.0.0 (不兼容)
message SpanV2 {
  bytes trace_id = 1;
  bytes span_id = 2;
  // deprecated_field 已移除
  reserved 3;
  reserved "deprecated_field";
}
```

---

## URL 结构

### 1. 标准 URL 格式

```text
完整格式:
{scheme}://{host}:{port}/{version}/{signal}[?{query}][#{fragment}]

组件说明:
- scheme: http, https, grpc, grpcs
- host: 主机名或 IP
- port: 端口号
- version: API 版本 (v1, v2)
- signal: 信号类型 (traces, metrics, logs)
- query: 查询参数 (可选)
- fragment: 片段标识符 (可选)
```

### 2. URL 示例

#### 本地开发

```text
# gRPC
grpc://localhost:4317

# HTTP Traces
http://localhost:4318/v1/traces

# HTTP Metrics
http://localhost:4318/v1/metrics

# HTTP Logs
http://localhost:4318/v1/logs
```

#### 生产环境

```text
# 使用 TLS
https://otlp.example.com:4318/v1/traces

# 使用自定义路径
https://api.example.com/telemetry/otlp/v1/traces

# 使用查询参数
https://otlp.example.com/v1/traces?tenant=acme

# 使用基本认证
https://user:pass@otlp.example.com:4318/v1/traces
```

#### 云服务

```text
# AWS
https://otlp.us-east-1.amazonaws.com/v1/traces

# GCP
https://otlp.googleapis.com/v1/traces

# Azure
https://otlp.azure.com/v1/traces

# Datadog
https://trace.agent.datadoghq.com/v1/traces

# Honeycomb
https://api.honeycomb.io/v1/traces
```

### 3. URL 解析

```go
package url

import (
    "fmt"
    "net/url"
    "strings"
)

// OTLPEndpoint OTLP 端点
type OTLPEndpoint struct {
    Scheme  string  // http, https, grpc, grpcs
    Host    string  // 主机名
    Port    int     // 端口号
    Path    string  // 路径
    Version string  // API 版本
    Signal  string  // 信号类型
}

// ParseEndpoint 解析端点 URL
func ParseEndpoint(rawURL string) (*OTLPEndpoint, error) {
    u, err := url.Parse(rawURL)
    if err != nil {
        return nil, err
    }

    endpoint := &OTLPEndpoint{
        Scheme: u.Scheme,
        Host:   u.Hostname(),
    }

    // 解析端口
    if port := u.Port(); port != "" {
        fmt.Sscanf(port, "%d", &endpoint.Port)
    } else {
        // 默认端口
        if u.Scheme == "grpc" || u.Scheme == "grpcs" {
            endpoint.Port = 4317
        } else {
            endpoint.Port = 4318
        }
    }

    // 解析路径
    pathParts := strings.Split(strings.Trim(u.Path, "/"), "/")
    if len(pathParts) >= 2 {
        endpoint.Version = pathParts[0]  // v1
        endpoint.Signal = pathParts[1]   // traces
    }

    return endpoint, nil
}

// String 返回完整 URL
func (e *OTLPEndpoint) String() string {
    if e.Scheme == "grpc" || e.Scheme == "grpcs" {
        return fmt.Sprintf("%s://%s:%d", e.Scheme, e.Host, e.Port)
    }
    return fmt.Sprintf("%s://%s:%d/%s/%s",
        e.Scheme, e.Host, e.Port, e.Version, e.Signal)
}

// 使用示例
func Example() {
    endpoint, _ := ParseEndpoint("https://otlp.example.com:4318/v1/traces")
    fmt.Println(endpoint.Scheme)   // https
    fmt.Println(endpoint.Host)     // otlp.example.com
    fmt.Println(endpoint.Port)     // 4318
    fmt.Println(endpoint.Version)  // v1
    fmt.Println(endpoint.Signal)   // traces
}
```

---

## 端点发现机制

### 1. 环境变量配置

```bash
# gRPC 端点
export OTEL_EXPORTER_OTLP_ENDPOINT="grpc://localhost:4317"

# HTTP 端点
export OTEL_EXPORTER_OTLP_ENDPOINT="http://localhost:4318"

# 单独配置
export OTEL_EXPORTER_OTLP_TRACES_ENDPOINT="http://localhost:4318/v1/traces"
export OTEL_EXPORTER_OTLP_METRICS_ENDPOINT="http://localhost:4318/v1/metrics"
export OTEL_EXPORTER_OTLP_LOGS_ENDPOINT="http://localhost:4318/v1/logs"

# 协议
export OTEL_EXPORTER_OTLP_PROTOCOL="grpc"  # grpc, http/protobuf, http/json

# 认证
export OTEL_EXPORTER_OTLP_HEADERS="api-key=secret"
```

### 2. 配置文件

```yaml
# otel-config.yaml
exporters:
  otlp:
    endpoint: "localhost:4317"
    protocol: grpc
    insecure: true
    timeout: 5s
    
  otlp/traces:
    endpoint: "https://traces.example.com"
    protocol: http/protobuf
    headers:
      api-key: "secret"
      
  otlp/metrics:
    endpoint: "https://metrics.example.com"
    protocol: http/protobuf
    
service:
  pipelines:
    traces:
      exporters: [otlp/traces]
    metrics:
      exporters: [otlp/metrics]
```

### 3. 服务发现

#### DNS SRV 记录

```text
# DNS 配置
_otlp._tcp.example.com. 3600 IN SRV 10 60 4317 collector1.example.com.
_otlp._tcp.example.com. 3600 IN SRV 10 40 4317 collector2.example.com.

# 查询
dig _otlp._tcp.example.com SRV
```

#### Go 实现

```go
package discovery

import (
    "context"
    "fmt"
    "net"
)

// DiscoverEndpoints 通过 DNS SRV 发现端点
func DiscoverEndpoints(service, proto, domain string) ([]string, error) {
    _, srvs, err := net.LookupSRV(service, proto, domain)
    if err != nil {
        return nil, err
    }

    endpoints := make([]string, 0, len(srvs))
    for _, srv := range srvs {
        endpoint := fmt.Sprintf("%s:%d", srv.Target, srv.Port)
        endpoints = append(endpoints, endpoint)
    }

    return endpoints, nil
}

// 使用示例
func Example() {
    endpoints, err := DiscoverEndpoints("otlp", "tcp", "example.com")
    if err != nil {
        panic(err)
    }
    
    for _, endpoint := range endpoints {
        fmt.Println(endpoint)
    }
    // 输出:
    // collector1.example.com:4317
    // collector2.example.com:4317
}
```

---

## 最佳实践

### 1. 端点配置

```go
package config

import (
    "fmt"
    "net/url"
    "os"
    "strings"
)

// EndpointConfig 端点配置
type EndpointConfig struct {
    // 基础配置
    Endpoint string
    Protocol string  // grpc, http/protobuf
    Insecure bool
    
    // 认证
    Headers map[string]string
    
    // 超时
    Timeout string
    
    // 重试
    RetryEnabled bool
    RetryMax     int
}

// LoadFromEnv 从环境变量加载配置
func LoadFromEnv() *EndpointConfig {
    cfg := &EndpointConfig{
        Endpoint: getEnv("OTEL_EXPORTER_OTLP_ENDPOINT", "localhost:4317"),
        Protocol: getEnv("OTEL_EXPORTER_OTLP_PROTOCOL", "grpc"),
        Insecure: getEnv("OTEL_EXPORTER_OTLP_INSECURE", "false") == "true",
        Timeout:  getEnv("OTEL_EXPORTER_OTLP_TIMEOUT", "10s"),
        Headers:  parseHeaders(os.Getenv("OTEL_EXPORTER_OTLP_HEADERS")),
    }
    
    return cfg
}

// Validate 验证配置
func (cfg *EndpointConfig) Validate() error {
    // 验证 URL
    if _, err := url.Parse(cfg.Endpoint); err != nil {
        return fmt.Errorf("invalid endpoint: %w", err)
    }
    
    // 验证协议
    validProtocols := map[string]bool{
        "grpc":          true,
        "http/protobuf": true,
        "http/json":     true,
    }
    if !validProtocols[cfg.Protocol] {
        return fmt.Errorf("invalid protocol: %s", cfg.Protocol)
    }
    
    return nil
}

func getEnv(key, fallback string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return fallback
}

func parseHeaders(headers string) map[string]string {
    result := make(map[string]string)
    for _, header := range strings.Split(headers, ",") {
        parts := strings.SplitN(header, "=", 2)
        if len(parts) == 2 {
            result[parts[0]] = parts[1]
        }
    }
    return result
}
```

### 2. 多端点负载均衡

```go
package loadbalancer

import (
    "context"
    "sync/atomic"
)

// RoundRobinBalancer 轮询负载均衡器
type RoundRobinBalancer struct {
    endpoints []string
    counter   uint64
}

// NewRoundRobinBalancer 创建轮询负载均衡器
func NewRoundRobinBalancer(endpoints []string) *RoundRobinBalancer {
    return &RoundRobinBalancer{
        endpoints: endpoints,
        counter:   0,
    }
}

// Next 获取下一个端点
func (rb *RoundRobinBalancer) Next() string {
    n := atomic.AddUint64(&rb.counter, 1)
    return rb.endpoints[(n-1)%uint64(len(rb.endpoints))]
}

// 使用示例
func Example() {
    endpoints := []string{
        "collector1.example.com:4317",
        "collector2.example.com:4317",
        "collector3.example.com:4317",
    }
    
    lb := NewRoundRobinBalancer(endpoints)
    
    for i := 0; i < 6; i++ {
        fmt.Println(lb.Next())
    }
    // 输出 (循环):
    // collector1.example.com:4317
    // collector2.example.com:4317
    // collector3.example.com:4317
    // collector1.example.com:4317
    // ...
}
```

### 3. 端点健康检查

```go
package healthcheck

import (
    "context"
    "fmt"
    "time"
    
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
    "google.golang.org/grpc/health/grpc_health_v1"
)

// HealthChecker 健康检查器
type HealthChecker struct {
    endpoint string
    timeout  time.Duration
}

// NewHealthChecker 创建健康检查器
func NewHealthChecker(endpoint string, timeout time.Duration) *HealthChecker {
    return &HealthChecker{
        endpoint: endpoint,
        timeout:  timeout,
    }
}

// Check 执行健康检查
func (hc *HealthChecker) Check(ctx context.Context) error {
    ctx, cancel := context.WithTimeout(ctx, hc.timeout)
    defer cancel()

    // 建立连接
    conn, err := grpc.DialContext(ctx, hc.endpoint,
        grpc.WithTransportCredentials(insecure.NewCredentials()),
        grpc.WithBlock(),
    )
    if err != nil {
        return fmt.Errorf("failed to connect: %w", err)
    }
    defer conn.Close()

    // 健康检查
    client := grpc_health_v1.NewHealthClient(conn)
    resp, err := client.Check(ctx, &grpc_health_v1.HealthCheckRequest{
        Service: "opentelemetry.proto.collector.trace.v1.TraceService",
    })
    if err != nil {
        return fmt.Errorf("health check failed: %w", err)
    }

    if resp.Status != grpc_health_v1.HealthCheckResponse_SERVING {
        return fmt.Errorf("service not serving: %v", resp.Status)
    }

    return nil
}

// 使用示例
func Example() {
    hc := NewHealthChecker("localhost:4317", 5*time.Second)
    
    if err := hc.Check(context.Background()); err != nil {
        fmt.Println("Health check failed:", err)
    } else {
        fmt.Println("Service is healthy")
    }
}
```

---

## 参考资源

### 官方文档

- [OTLP Specification](https://github.com/open-telemetry/opentelemetry-proto)
- [Protocol Specification](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/otlp.md)
- [Exporter Specification](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/exporter.md)

### 实现参考

- [OpenTelemetry Collector](https://github.com/open-telemetry/opentelemetry-collector)
- [Go SDK Exporters](https://github.com/open-telemetry/opentelemetry-go/tree/main/exporters/otlp)

---

**文档版本**: v1.0.0  
**最后更新**: 2025年10月9日  
**维护者**: OTLP 标准化项目组
