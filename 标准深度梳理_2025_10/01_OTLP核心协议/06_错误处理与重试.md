# OTLP 错误处理与重试策略

> **文档版本**: v1.0.0  
> **OTLP 版本**: v1.3.x  
> **最后更新**: 2025年10月9日

---

## 📋 目录

- [OTLP 错误处理与重试策略](#otlp-错误处理与重试策略)
  - [📋 目录](#-目录)
  - [概述](#概述)
    - [错误处理的重要性](#错误处理的重要性)
    - [错误处理原则](#错误处理原则)
  - [错误分类体系](#错误分类体系)
    - [1. 按严重性分类](#1-按严重性分类)
    - [2. 按可重试性分类](#2-按可重试性分类)
    - [3. 错误分类树](#3-错误分类树)
  - [gRPC 错误处理](#grpc-错误处理)
    - [1. gRPC 状态码](#1-grpc-状态码)
    - [2. Go 错误处理实现](#2-go-错误处理实现)
    - [3. 服务端错误生成](#3-服务端错误生成)
  - [HTTP 错误处理](#http-错误处理)
    - [1. HTTP 状态码映射](#1-http-状态码映射)
    - [2. Go HTTP 错误处理](#2-go-http-错误处理)
  - [重试策略](#重试策略)
    - [1. 指数退避算法](#1-指数退避算法)
    - [2. 重试预算](#2-重试预算)
  - [断路器模式](#断路器模式)
    - [1. 断路器状态机](#1-断路器状态机)
    - [2. Go 实现](#2-go-实现)
  - [最佳实践](#最佳实践)
    - [1. 综合错误处理策略](#1-综合错误处理策略)
    - [2. 错误监控与告警](#2-错误监控与告警)
  - [参考资源](#参考资源)
    - [官方文档](#官方文档)
    - [设计模式](#设计模式)

---

## 概述

### 错误处理的重要性

**形式化定义**:

```text
ErrorHandling = (Detection, Classification, Recovery, Reporting)

其中:
- Detection: 错误检测机制
- Classification: 错误分类体系
- Recovery: 恢复策略 (重试、降级、熔断)
- Reporting: 错误上报与监控
```

### 错误处理原则

```text
1. 快速失败 (Fail Fast)
   - 尽早发现错误
   - 避免级联失败

2. 优雅降级 (Graceful Degradation)
   - 部分功能可用
   - 保护核心服务

3. 自动恢复 (Auto Recovery)
   - 自动重试
   - 断路器保护

4. 可观测性 (Observability)
   - 详细错误日志
   - 监控告警
```

---

## 错误分类体系

### 1. 按严重性分类

```text
Critical (致命错误):
  - 数据损坏
  - 安全漏洞
  - 系统崩溃
  处理: 立即停止,人工介入

Error (错误):
  - 请求失败
  - 连接中断
  - 超时
  处理: 记录日志,触发告警

Warning (警告):
  - 性能下降
  - 资源不足
  - 部分失败
  处理: 记录日志,继续执行

Info (信息):
  - 状态变更
  - 配置更新
  处理: 记录日志
```

### 2. 按可重试性分类

```text
Transient (瞬时错误) - 可重试:
  ✅ 网络抖动
  ✅ 服务暂时不可用
  ✅ 超时
  ✅ 429 Too Many Requests
  ✅ 503 Service Unavailable

Permanent (永久错误) - 不可重试:
  ❌ 401 Unauthorized
  ❌ 403 Forbidden
  ❌ 404 Not Found
  ❌ 400 Bad Request
  ❌ 数据格式错误
  ❌ 认证失败
```

### 3. 错误分类树

```text
OTLP Errors
├── Network Errors (网络错误)
│   ├── Connection Refused
│   ├── Connection Timeout
│   ├── Connection Reset
│   └── DNS Resolution Failed
│
├── Protocol Errors (协议错误)
│   ├── Invalid Request
│   ├── Unsupported Version
│   ├── Encoding Error
│   └── Decoding Error
│
├── Authentication Errors (认证错误)
│   ├── Unauthorized
│   ├── Invalid Credentials
│   └── Token Expired
│
├── Authorization Errors (授权错误)
│   ├── Forbidden
│   ├── Insufficient Permissions
│   └── Quota Exceeded
│
├── Resource Errors (资源错误)
│   ├── Not Found
│   ├── Conflict
│   └── Resource Exhausted
│
└── Server Errors (服务器错误)
    ├── Internal Error
    ├── Service Unavailable
    ├── Gateway Timeout
    └── Overloaded
```

---

## gRPC 错误处理

### 1. gRPC 状态码

| 状态码 | 名称 | 说明 | 是否重试 |
|-------|------|------|---------|
| 0 | `OK` | 成功 | ❌ |
| 1 | `CANCELLED` | 请求取消 | ❌ |
| 2 | `UNKNOWN` | 未知错误 | ✅ |
| 3 | `INVALID_ARGUMENT` | 无效参数 | ❌ |
| 4 | `DEADLINE_EXCEEDED` | 超时 | ✅ |
| 5 | `NOT_FOUND` | 未找到 | ❌ |
| 6 | `ALREADY_EXISTS` | 已存在 | ❌ |
| 7 | `PERMISSION_DENIED` | 权限拒绝 | ❌ |
| 8 | `RESOURCE_EXHAUSTED` | 资源耗尽 | ✅ |
| 9 | `FAILED_PRECONDITION` | 前置条件失败 | ❌ |
| 10 | `ABORTED` | 中止 | ✅ |
| 11 | `OUT_OF_RANGE` | 超出范围 | ❌ |
| 12 | `UNIMPLEMENTED` | 未实现 | ❌ |
| 13 | `INTERNAL` | 内部错误 | ✅ |
| 14 | `UNAVAILABLE` | 不可用 | ✅ |
| 15 | `DATA_LOSS` | 数据丢失 | ❌ |
| 16 | `UNAUTHENTICATED` | 未认证 | ❌ |

### 2. Go 错误处理实现

```go
package grpcerror

import (
    "context"
    "fmt"
    "time"

    "google.golang.org/grpc"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)

// IsRetryable 判断 gRPC 错误是否可重试
func IsRetryable(err error) bool {
    st, ok := status.FromError(err)
    if !ok {
        return false
    }

    switch st.Code() {
    case codes.DeadlineExceeded,
        codes.ResourceExhausted,
        codes.Aborted,
        codes.Internal,
        codes.Unavailable:
        return true
    default:
        return false
    }
}

// HandleGRPCError 处理 gRPC 错误
func HandleGRPCError(err error) error {
    if err == nil {
        return nil
    }

    st, ok := status.FromError(err)
    if !ok {
        return fmt.Errorf("unknown error: %w", err)
    }

    switch st.Code() {
    case codes.OK:
        return nil

    case codes.InvalidArgument:
        return fmt.Errorf("invalid argument: %s", st.Message())

    case codes.Unauthenticated:
        return fmt.Errorf("authentication failed: %s", st.Message())

    case codes.PermissionDenied:
        return fmt.Errorf("permission denied: %s", st.Message())

    case codes.NotFound:
        return fmt.Errorf("resource not found: %s", st.Message())

    case codes.DeadlineExceeded:
        return fmt.Errorf("request timeout: %s", st.Message())

    case codes.Unavailable:
        return fmt.Errorf("service unavailable: %s", st.Message())

    case codes.Internal:
        return fmt.Errorf("internal error: %s", st.Message())

    default:
        return fmt.Errorf("grpc error [%s]: %s", st.Code(), st.Message())
    }
}

// RetryableInterceptor gRPC 重试拦截器
func RetryableInterceptor(maxRetries int, backoff time.Duration) grpc.UnaryClientInterceptor {
    return func(
        ctx context.Context,
        method string,
        req, reply interface{},
        cc *grpc.ClientConn,
        invoker grpc.UnaryInvoker,
        opts ...grpc.CallOption,
    ) error {
        var err error
        
        for attempt := 0; attempt <= maxRetries; attempt++ {
            err = invoker(ctx, method, req, reply, cc, opts...)
            
            if err == nil {
                return nil
            }

            // 检查是否可重试
            if !IsRetryable(err) {
                return err
            }

            // 最后一次尝试
            if attempt == maxRetries {
                return err
            }

            // 指数退避
            waitTime := backoff * time.Duration(1<<uint(attempt))
            select {
            case <-time.After(waitTime):
                // 继续重试
            case <-ctx.Done():
                return ctx.Err()
            }
        }

        return err
    }
}

// 使用示例
func Example() {
    conn, err := grpc.Dial("localhost:4317",
        grpc.WithUnaryInterceptor(
            RetryableInterceptor(3, 100*time.Millisecond),
        ),
    )
    if err != nil {
        panic(err)
    }
    defer conn.Close()
}
```

### 3. 服务端错误生成

```go
package grpcserver

import (
    "context"

    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)

// 返回不同类型的错误
func ExampleErrorHandling(ctx context.Context) error {
    // 1. 无效参数
    if invalidInput {
        return status.Error(codes.InvalidArgument, "invalid trace ID")
    }

    // 2. 未认证
    if !authenticated {
        return status.Error(codes.Unauthenticated, "missing authentication token")
    }

    // 3. 权限拒绝
    if !authorized {
        return status.Error(codes.PermissionDenied, "insufficient permissions")
    }

    // 4. 资源未找到
    if !found {
        return status.Error(codes.NotFound, "resource not found")
    }

    // 5. 超时
    if timeout {
        return status.Error(codes.DeadlineExceeded, "request timeout")
    }

    // 6. 限流
    if rateLimited {
        return status.Error(codes.ResourceExhausted, "rate limit exceeded")
    }

    // 7. 服务不可用
    if unavailable {
        return status.Error(codes.Unavailable, "service temporarily unavailable")
    }

    // 8. 内部错误
    if internalError {
        return status.Error(codes.Internal, "internal server error")
    }

    return nil
}
```

---

## HTTP 错误处理

### 1. HTTP 状态码映射

| HTTP 状态码 | 说明 | gRPC 等价 | 是否重试 |
|-----------|------|-----------|---------|
| 200 | OK | `OK` | ❌ |
| 400 | Bad Request | `INVALID_ARGUMENT` | ❌ |
| 401 | Unauthorized | `UNAUTHENTICATED` | ❌ |
| 403 | Forbidden | `PERMISSION_DENIED` | ❌ |
| 404 | Not Found | `NOT_FOUND` | ❌ |
| 408 | Request Timeout | `DEADLINE_EXCEEDED` | ✅ |
| 409 | Conflict | `ALREADY_EXISTS` | ❌ |
| 429 | Too Many Requests | `RESOURCE_EXHAUSTED` | ✅ |
| 500 | Internal Server Error | `INTERNAL` | ✅ |
| 502 | Bad Gateway | `UNAVAILABLE` | ✅ |
| 503 | Service Unavailable | `UNAVAILABLE` | ✅ |
| 504 | Gateway Timeout | `DEADLINE_EXCEEDED` | ✅ |

### 2. Go HTTP 错误处理

```go
package httperror

import (
    "encoding/json"
    "fmt"
    "net/http"
    "time"
)

// ErrorResponse HTTP 错误响应
type ErrorResponse struct {
    Code    int    `json:"code"`
    Message string `json:"message"`
    Details string `json:"details,omitempty"`
}

// IsRetryable 判断 HTTP 错误是否可重试
func IsRetryable(statusCode int) bool {
    switch statusCode {
    case http.StatusRequestTimeout,        // 408
        http.StatusTooManyRequests,        // 429
        http.StatusInternalServerError,    // 500
        http.StatusBadGateway,             // 502
        http.StatusServiceUnavailable,     // 503
        http.StatusGatewayTimeout:         // 504
        return true
    default:
        return false
    }
}

// HTTPRetryTransport HTTP 重试传输层
type HTTPRetryTransport struct {
    Transport  http.RoundTripper
    MaxRetries int
    Backoff    time.Duration
}

// RoundTrip 实现 http.RoundTripper
func (t *HTTPRetryTransport) RoundTrip(req *http.Request) (*http.Response, error) {
    var resp *http.Response
    var err error

    for attempt := 0; attempt <= t.MaxRetries; attempt++ {
        resp, err = t.Transport.RoundTrip(req)

        // 请求成功
        if err == nil && resp.StatusCode < 500 {
            return resp, nil
        }

        // 检查是否可重试
        if err == nil && !IsRetryable(resp.StatusCode) {
            return resp, nil
        }

        // 最后一次尝试
        if attempt == t.MaxRetries {
            return resp, err
        }

        // 指数退避
        waitTime := t.Backoff * time.Duration(1<<uint(attempt))
        time.Sleep(waitTime)
    }

    return resp, err
}

// HandleHTTPError 处理 HTTP 错误响应
func HandleHTTPError(resp *http.Response) error {
    if resp.StatusCode >= 200 && resp.StatusCode < 300 {
        return nil
    }

    var errResp ErrorResponse
    if err := json.NewDecoder(resp.Body).Decode(&errResp); err != nil {
        return fmt.Errorf("HTTP %d: failed to decode error response", resp.StatusCode)
    }

    return fmt.Errorf("HTTP %d: %s - %s", errResp.Code, errResp.Message, errResp.Details)
}

// 使用示例
func Example() {
    client := &http.Client{
        Transport: &HTTPRetryTransport{
            Transport:  http.DefaultTransport,
            MaxRetries: 3,
            Backoff:    100 * time.Millisecond,
        },
        Timeout: 10 * time.Second,
    }

    resp, err := client.Get("http://localhost:4318/v1/traces")
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()

    if err := HandleHTTPError(resp); err != nil {
        panic(err)
    }
}
```

---

## 重试策略

### 1. 指数退避算法

**原理**: 每次重试后,等待时间呈指数增长。

```text
公式: wait_time = base_delay * (2 ^ attempt) + random_jitter

示例:
  attempt 0: 100ms
  attempt 1: 200ms + jitter
  attempt 2: 400ms + jitter
  attempt 3: 800ms + jitter
  attempt 4: 1600ms + jitter
```

**Go 实现**:

```go
package retry

import (
    "context"
    "math/rand"
    "time"
)

// ExponentialBackoff 指数退避
type ExponentialBackoff struct {
    BaseDelay  time.Duration  // 基础延迟
    MaxDelay   time.Duration  // 最大延迟
    Multiplier float64        // 乘数
    Jitter     float64        // 抖动因子 [0, 1]
}

// DefaultBackoff 默认配置
func DefaultBackoff() *ExponentialBackoff {
    return &ExponentialBackoff{
        BaseDelay:  100 * time.Millisecond,
        MaxDelay:   30 * time.Second,
        Multiplier: 2.0,
        Jitter:     0.1,
    }
}

// Delay 计算第 n 次重试的延迟
func (eb *ExponentialBackoff) Delay(attempt int) time.Duration {
    if attempt < 0 {
        return 0
    }

    // 计算基础延迟: base_delay * multiplier^attempt
    delay := float64(eb.BaseDelay) * float64(1<<uint(attempt))

    // 限制最大延迟
    if delay > float64(eb.MaxDelay) {
        delay = float64(eb.MaxDelay)
    }

    // 添加随机抖动 [-jitter, +jitter]
    jitter := delay * eb.Jitter * (2*rand.Float64() - 1)
    delay += jitter

    return time.Duration(delay)
}

// Wait 等待指定时间或上下文取消
func (eb *ExponentialBackoff) Wait(ctx context.Context, attempt int) error {
    delay := eb.Delay(attempt)

    select {
    case <-time.After(delay):
        return nil
    case <-ctx.Done():
        return ctx.Err()
    }
}

// Retry 重试函数
func Retry(
    ctx context.Context,
    maxAttempts int,
    backoff *ExponentialBackoff,
    fn func() error,
) error {
    var err error

    for attempt := 0; attempt < maxAttempts; attempt++ {
        err = fn()
        if err == nil {
            return nil
        }

        // 最后一次尝试
        if attempt == maxAttempts-1 {
            return err
        }

        // 等待后重试
        if waitErr := backoff.Wait(ctx, attempt); waitErr != nil {
            return waitErr
        }
    }

    return err
}

// 使用示例
func Example() {
    ctx := context.Background()
    backoff := DefaultBackoff()

    err := Retry(ctx, 5, backoff, func() error {
        // 执行可能失败的操作
        return performOperation()
    })

    if err != nil {
        fmt.Println("All retries failed:", err)
    }
}
```

### 2. 重试预算

**概念**: 限制重试次数占总请求的比例,避免重试风暴。

```go
package retry

import (
    "sync"
    "time"
)

// RetryBudget 重试预算
type RetryBudget struct {
    mu sync.Mutex
    
    // 配置
    maxRetryRatio float64       // 最大重试比例 (例如 0.1 = 10%)
    minRequests   int            // 最小请求数
    
    // 统计
    totalRequests int
    totalRetries  int
    windowStart   time.Time
    windowSize    time.Duration
}

// NewRetryBudget 创建重试预算
func NewRetryBudget(maxRetryRatio float64, minRequests int, windowSize time.Duration) *RetryBudget {
    return &RetryBudget{
        maxRetryRatio: maxRetryRatio,
        minRequests:   minRequests,
        windowStart:   time.Now(),
        windowSize:    windowSize,
    }
}

// CanRetry 检查是否可以重试
func (rb *RetryBudget) CanRetry() bool {
    rb.mu.Lock()
    defer rb.mu.Unlock()

    rb.maybeResetWindow()

    // 请求数不足,允许重试
    if rb.totalRequests < rb.minRequests {
        return true
    }

    // 检查重试比例
    retryRatio := float64(rb.totalRetries) / float64(rb.totalRequests)
    return retryRatio < rb.maxRetryRatio
}

// RecordRequest 记录请求
func (rb *RetryBudget) RecordRequest() {
    rb.mu.Lock()
    defer rb.mu.Unlock()

    rb.maybeResetWindow()
    rb.totalRequests++
}

// RecordRetry 记录重试
func (rb *RetryBudget) RecordRetry() {
    rb.mu.Lock()
    defer rb.mu.Unlock()

    rb.maybeResetWindow()
    rb.totalRetries++
}

// maybeResetWindow 可能重置时间窗口
func (rb *RetryBudget) maybeResetWindow() {
    if time.Since(rb.windowStart) >= rb.windowSize {
        rb.totalRequests = 0
        rb.totalRetries = 0
        rb.windowStart = time.Now()
    }
}

// 使用示例
func Example() {
    // 允许 10% 的请求重试,窗口期 1 分钟
    budget := NewRetryBudget(0.1, 10, time.Minute)

    for i := 0; i < 100; i++ {
        budget.RecordRequest()

        err := performOperation()
        if err != nil && budget.CanRetry() {
            budget.RecordRetry()
            // 执行重试
        }
    }
}
```

---

## 断路器模式

### 1. 断路器状态机

```text
状态转换:

       成功次数 >= threshold
Closed ───────────────────────> Open
  │                               │
  │                               │ timeout
  │                               ↓
  └──────────────────────── Half-Open
         成功                      │
                                  │ 失败
                                  ↓
                                Open

状态说明:
- Closed: 正常状态,请求正常通过
- Open: 熔断状态,请求直接失败
- Half-Open: 半开状态,允许部分请求尝试
```

### 2. Go 实现

```go
package circuitbreaker

import (
    "errors"
    "sync"
    "time"
)

// State 断路器状态
type State int

const (
    StateClosed   State = iota // 关闭(正常)
    StateOpen                   // 打开(熔断)
    StateHalfOpen               // 半开(恢复中)
)

// CircuitBreaker 断路器
type CircuitBreaker struct {
    mu sync.Mutex
    
    state         State
    failureCount  int
    successCount  int
    lastFailTime  time.Time
    
    // 配置
    maxFailures   int           // 最大失败次数
    timeout       time.Duration // 熔断超时
    halfOpenMax   int           // 半开状态最大成功次数
}

// NewCircuitBreaker 创建断路器
func NewCircuitBreaker(maxFailures int, timeout time.Duration) *CircuitBreaker {
    return &CircuitBreaker{
        state:       StateClosed,
        maxFailures: maxFailures,
        timeout:     timeout,
        halfOpenMax: 1,
    }
}

// Execute 执行操作
func (cb *CircuitBreaker) Execute(fn func() error) error {
    if err := cb.beforeRequest(); err != nil {
        return err
    }

    err := fn()
    cb.afterRequest(err)
    
    return err
}

// beforeRequest 请求前检查
func (cb *CircuitBreaker) beforeRequest() error {
    cb.mu.Lock()
    defer cb.mu.Unlock()

    switch cb.state {
    case StateClosed:
        return nil

    case StateOpen:
        // 检查是否可以进入半开状态
        if time.Since(cb.lastFailTime) >= cb.timeout {
            cb.state = StateHalfOpen
            cb.successCount = 0
            return nil
        }
        return errors.New("circuit breaker is open")

    case StateHalfOpen:
        return nil

    default:
        return errors.New("unknown state")
    }
}

// afterRequest 请求后处理
func (cb *CircuitBreaker) afterRequest(err error) {
    cb.mu.Lock()
    defer cb.mu.Unlock()

    if err == nil {
        cb.onSuccess()
    } else {
        cb.onFailure()
    }
}

// onSuccess 成功处理
func (cb *CircuitBreaker) onSuccess() {
    switch cb.state {
    case StateClosed:
        cb.failureCount = 0

    case StateHalfOpen:
        cb.successCount++
        if cb.successCount >= cb.halfOpenMax {
            cb.state = StateClosed
            cb.failureCount = 0
        }
    }
}

// onFailure 失败处理
func (cb *CircuitBreaker) onFailure() {
    cb.lastFailTime = time.Now()

    switch cb.state {
    case StateClosed:
        cb.failureCount++
        if cb.failureCount >= cb.maxFailures {
            cb.state = StateOpen
        }

    case StateHalfOpen:
        cb.state = StateOpen
        cb.failureCount = cb.maxFailures
    }
}

// State 返回当前状态
func (cb *CircuitBreaker) State() State {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    return cb.state
}

// 使用示例
func Example() {
    cb := NewCircuitBreaker(5, 30*time.Second)

    for i := 0; i < 100; i++ {
        err := cb.Execute(func() error {
            return performOperation()
        })

        if err != nil {
            fmt.Printf("Request %d failed: %v (state: %v)\n", i, err, cb.State())
        }
    }
}
```

---

## 最佳实践

### 1. 综合错误处理策略

```go
package errorhandling

import (
    "context"
    "fmt"
    "time"
)

// ResilientClient 弹性客户端
type ResilientClient struct {
    client         *OTLPClient
    retryBudget    *RetryBudget
    circuitBreaker *CircuitBreaker
    backoff        *ExponentialBackoff
}

// NewResilientClient 创建弹性客户端
func NewResilientClient(endpoint string) *ResilientClient {
    return &ResilientClient{
        client:         NewOTLPClient(endpoint),
        retryBudget:    NewRetryBudget(0.1, 10, time.Minute),
        circuitBreaker: NewCircuitBreaker(5, 30*time.Second),
        backoff:        DefaultBackoff(),
    }
}

// Export 导出数据 (带完整错误处理)
func (rc *ResilientClient) Export(ctx context.Context, data []byte) error {
    rc.retryBudget.RecordRequest()

    return rc.circuitBreaker.Execute(func() error {
        return Retry(ctx, 3, rc.backoff, func() error {
            err := rc.client.Export(ctx, data)

            if err != nil && IsRetryable(err) && rc.retryBudget.CanRetry() {
                rc.retryBudget.RecordRetry()
                return err
            }

            return err
        })
    })
}
```

### 2. 错误监控与告警

```go
package monitoring

import (
    "go.opentelemetry.io/otel/metric"
)

// ErrorMonitor 错误监控
type ErrorMonitor struct {
    errorCounter    metric.Int64Counter
    retryCounter    metric.Int64Counter
    circuitBreaker  metric.Int64ObservableGauge
}

// NewErrorMonitor 创建错误监控
func NewErrorMonitor(meter metric.Meter) (*ErrorMonitor, error) {
    errorCounter, err := meter.Int64Counter("otlp.errors",
        metric.WithDescription("Total OTLP errors"),
    )
    if err != nil {
        return nil, err
    }

    retryCounter, err := meter.Int64Counter("otlp.retries",
        metric.WithDescription("Total OTLP retries"),
    )
    if err != nil {
        return nil, err
    }

    return &ErrorMonitor{
        errorCounter: errorCounter,
        retryCounter: retryCounter,
    }, nil
}

// RecordError 记录错误
func (em *ErrorMonitor) RecordError(ctx context.Context, errorType string) {
    em.errorCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("error.type", errorType),
        ),
    )
}

// RecordRetry 记录重试
func (em *ErrorMonitor) RecordRetry(ctx context.Context, attempt int) {
    em.retryCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.Int("retry.attempt", attempt),
        ),
    )
}
```

---

## 参考资源

### 官方文档

- [gRPC Error Handling](https://grpc.io/docs/guides/error/)
- [gRPC Status Codes](https://grpc.github.io/grpc/core/md_doc_statuscodes.html)
- [HTTP Status Codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)

### 设计模式

- [Circuit Breaker Pattern](https://martinfowler.com/bliki/CircuitBreaker.html)
- [Retry Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/retry)
- [Exponential Backoff](https://en.wikipedia.org/wiki/Exponential_backoff)

---

**文档版本**: v1.0.0  
**最后更新**: 2025年10月9日  
**维护者**: OTLP 标准化项目组
