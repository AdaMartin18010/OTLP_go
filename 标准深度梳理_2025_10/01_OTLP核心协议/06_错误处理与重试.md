# OTLP é”™è¯¯å¤„ç†ä¸é‡è¯•ç­–ç•¥

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
> **OTLP ç‰ˆæœ¬**: v1.3.x  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ9æ—¥

---

## ğŸ“‹ ç›®å½•

- [OTLP é”™è¯¯å¤„ç†ä¸é‡è¯•ç­–ç•¥](#otlp-é”™è¯¯å¤„ç†ä¸é‡è¯•ç­–ç•¥)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [é”™è¯¯å¤„ç†çš„é‡è¦æ€§](#é”™è¯¯å¤„ç†çš„é‡è¦æ€§)
    - [é”™è¯¯å¤„ç†åŸåˆ™](#é”™è¯¯å¤„ç†åŸåˆ™)
  - [é”™è¯¯åˆ†ç±»ä½“ç³»](#é”™è¯¯åˆ†ç±»ä½“ç³»)
    - [1. æŒ‰ä¸¥é‡æ€§åˆ†ç±»](#1-æŒ‰ä¸¥é‡æ€§åˆ†ç±»)
    - [2. æŒ‰å¯é‡è¯•æ€§åˆ†ç±»](#2-æŒ‰å¯é‡è¯•æ€§åˆ†ç±»)
    - [3. é”™è¯¯åˆ†ç±»æ ‘](#3-é”™è¯¯åˆ†ç±»æ ‘)
  - [gRPC é”™è¯¯å¤„ç†](#grpc-é”™è¯¯å¤„ç†)
    - [1. gRPC çŠ¶æ€ç ](#1-grpc-çŠ¶æ€ç )
    - [2. Go é”™è¯¯å¤„ç†å®ç°](#2-go-é”™è¯¯å¤„ç†å®ç°)
    - [3. æœåŠ¡ç«¯é”™è¯¯ç”Ÿæˆ](#3-æœåŠ¡ç«¯é”™è¯¯ç”Ÿæˆ)
  - [HTTP é”™è¯¯å¤„ç†](#http-é”™è¯¯å¤„ç†)
    - [1. HTTP çŠ¶æ€ç æ˜ å°„](#1-http-çŠ¶æ€ç æ˜ å°„)
    - [2. Go HTTP é”™è¯¯å¤„ç†](#2-go-http-é”™è¯¯å¤„ç†)
  - [é‡è¯•ç­–ç•¥](#é‡è¯•ç­–ç•¥)
    - [1. æŒ‡æ•°é€€é¿ç®—æ³•](#1-æŒ‡æ•°é€€é¿ç®—æ³•)
    - [2. é‡è¯•é¢„ç®—](#2-é‡è¯•é¢„ç®—)
  - [æ–­è·¯å™¨æ¨¡å¼](#æ–­è·¯å™¨æ¨¡å¼)
    - [1. æ–­è·¯å™¨çŠ¶æ€æœº](#1-æ–­è·¯å™¨çŠ¶æ€æœº)
    - [2. Go å®ç°](#2-go-å®ç°)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [1. ç»¼åˆé”™è¯¯å¤„ç†ç­–ç•¥](#1-ç»¼åˆé”™è¯¯å¤„ç†ç­–ç•¥)
    - [2. é”™è¯¯ç›‘æ§ä¸å‘Šè­¦](#2-é”™è¯¯ç›‘æ§ä¸å‘Šè­¦)
  - [å‚è€ƒèµ„æº](#å‚è€ƒèµ„æº)
    - [å®˜æ–¹æ–‡æ¡£](#å®˜æ–¹æ–‡æ¡£)
    - [è®¾è®¡æ¨¡å¼](#è®¾è®¡æ¨¡å¼)

---

## æ¦‚è¿°

### é”™è¯¯å¤„ç†çš„é‡è¦æ€§

**å½¢å¼åŒ–å®šä¹‰**:

```text
ErrorHandling = (Detection, Classification, Recovery, Reporting)

å…¶ä¸­:
- Detection: é”™è¯¯æ£€æµ‹æœºåˆ¶
- Classification: é”™è¯¯åˆ†ç±»ä½“ç³»
- Recovery: æ¢å¤ç­–ç•¥ (é‡è¯•ã€é™çº§ã€ç†”æ–­)
- Reporting: é”™è¯¯ä¸ŠæŠ¥ä¸ç›‘æ§
```

### é”™è¯¯å¤„ç†åŸåˆ™

```text
1. å¿«é€Ÿå¤±è´¥ (Fail Fast)
   - å°½æ—©å‘ç°é”™è¯¯
   - é¿å…çº§è”å¤±è´¥

2. ä¼˜é›…é™çº§ (Graceful Degradation)
   - éƒ¨åˆ†åŠŸèƒ½å¯ç”¨
   - ä¿æŠ¤æ ¸å¿ƒæœåŠ¡

3. è‡ªåŠ¨æ¢å¤ (Auto Recovery)
   - è‡ªåŠ¨é‡è¯•
   - æ–­è·¯å™¨ä¿æŠ¤

4. å¯è§‚æµ‹æ€§ (Observability)
   - è¯¦ç»†é”™è¯¯æ—¥å¿—
   - ç›‘æ§å‘Šè­¦
```

---

## é”™è¯¯åˆ†ç±»ä½“ç³»

### 1. æŒ‰ä¸¥é‡æ€§åˆ†ç±»

```text
Critical (è‡´å‘½é”™è¯¯):
  - æ•°æ®æŸå
  - å®‰å…¨æ¼æ´
  - ç³»ç»Ÿå´©æºƒ
  å¤„ç†: ç«‹å³åœæ­¢,äººå·¥ä»‹å…¥

Error (é”™è¯¯):
  - è¯·æ±‚å¤±è´¥
  - è¿æ¥ä¸­æ–­
  - è¶…æ—¶
  å¤„ç†: è®°å½•æ—¥å¿—,è§¦å‘å‘Šè­¦

Warning (è­¦å‘Š):
  - æ€§èƒ½ä¸‹é™
  - èµ„æºä¸è¶³
  - éƒ¨åˆ†å¤±è´¥
  å¤„ç†: è®°å½•æ—¥å¿—,ç»§ç»­æ‰§è¡Œ

Info (ä¿¡æ¯):
  - çŠ¶æ€å˜æ›´
  - é…ç½®æ›´æ–°
  å¤„ç†: è®°å½•æ—¥å¿—
```

### 2. æŒ‰å¯é‡è¯•æ€§åˆ†ç±»

```text
Transient (ç¬æ—¶é”™è¯¯) - å¯é‡è¯•:
  âœ… ç½‘ç»œæŠ–åŠ¨
  âœ… æœåŠ¡æš‚æ—¶ä¸å¯ç”¨
  âœ… è¶…æ—¶
  âœ… 429 Too Many Requests
  âœ… 503 Service Unavailable

Permanent (æ°¸ä¹…é”™è¯¯) - ä¸å¯é‡è¯•:
  âŒ 401 Unauthorized
  âŒ 403 Forbidden
  âŒ 404 Not Found
  âŒ 400 Bad Request
  âŒ æ•°æ®æ ¼å¼é”™è¯¯
  âŒ è®¤è¯å¤±è´¥
```

### 3. é”™è¯¯åˆ†ç±»æ ‘

```text
OTLP Errors
â”œâ”€â”€ Network Errors (ç½‘ç»œé”™è¯¯)
â”‚   â”œâ”€â”€ Connection Refused
â”‚   â”œâ”€â”€ Connection Timeout
â”‚   â”œâ”€â”€ Connection Reset
â”‚   â””â”€â”€ DNS Resolution Failed
â”‚
â”œâ”€â”€ Protocol Errors (åè®®é”™è¯¯)
â”‚   â”œâ”€â”€ Invalid Request
â”‚   â”œâ”€â”€ Unsupported Version
â”‚   â”œâ”€â”€ Encoding Error
â”‚   â””â”€â”€ Decoding Error
â”‚
â”œâ”€â”€ Authentication Errors (è®¤è¯é”™è¯¯)
â”‚   â”œâ”€â”€ Unauthorized
â”‚   â”œâ”€â”€ Invalid Credentials
â”‚   â””â”€â”€ Token Expired
â”‚
â”œâ”€â”€ Authorization Errors (æˆæƒé”™è¯¯)
â”‚   â”œâ”€â”€ Forbidden
â”‚   â”œâ”€â”€ Insufficient Permissions
â”‚   â””â”€â”€ Quota Exceeded
â”‚
â”œâ”€â”€ Resource Errors (èµ„æºé”™è¯¯)
â”‚   â”œâ”€â”€ Not Found
â”‚   â”œâ”€â”€ Conflict
â”‚   â””â”€â”€ Resource Exhausted
â”‚
â””â”€â”€ Server Errors (æœåŠ¡å™¨é”™è¯¯)
    â”œâ”€â”€ Internal Error
    â”œâ”€â”€ Service Unavailable
    â”œâ”€â”€ Gateway Timeout
    â””â”€â”€ Overloaded
```

---

## gRPC é”™è¯¯å¤„ç†

### 1. gRPC çŠ¶æ€ç 

| çŠ¶æ€ç  | åç§° | è¯´æ˜ | æ˜¯å¦é‡è¯• |
|-------|------|------|---------|
| 0 | `OK` | æˆåŠŸ | âŒ |
| 1 | `CANCELLED` | è¯·æ±‚å–æ¶ˆ | âŒ |
| 2 | `UNKNOWN` | æœªçŸ¥é”™è¯¯ | âœ… |
| 3 | `INVALID_ARGUMENT` | æ— æ•ˆå‚æ•° | âŒ |
| 4 | `DEADLINE_EXCEEDED` | è¶…æ—¶ | âœ… |
| 5 | `NOT_FOUND` | æœªæ‰¾åˆ° | âŒ |
| 6 | `ALREADY_EXISTS` | å·²å­˜åœ¨ | âŒ |
| 7 | `PERMISSION_DENIED` | æƒé™æ‹’ç» | âŒ |
| 8 | `RESOURCE_EXHAUSTED` | èµ„æºè€—å°½ | âœ… |
| 9 | `FAILED_PRECONDITION` | å‰ç½®æ¡ä»¶å¤±è´¥ | âŒ |
| 10 | `ABORTED` | ä¸­æ­¢ | âœ… |
| 11 | `OUT_OF_RANGE` | è¶…å‡ºèŒƒå›´ | âŒ |
| 12 | `UNIMPLEMENTED` | æœªå®ç° | âŒ |
| 13 | `INTERNAL` | å†…éƒ¨é”™è¯¯ | âœ… |
| 14 | `UNAVAILABLE` | ä¸å¯ç”¨ | âœ… |
| 15 | `DATA_LOSS` | æ•°æ®ä¸¢å¤± | âŒ |
| 16 | `UNAUTHENTICATED` | æœªè®¤è¯ | âŒ |

### 2. Go é”™è¯¯å¤„ç†å®ç°

```go
package grpcerror

import (
    "context"
    "fmt"
    "time"

    "google.golang.org/grpc"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)

// IsRetryable åˆ¤æ–­ gRPC é”™è¯¯æ˜¯å¦å¯é‡è¯•
func IsRetryable(err error) bool {
    st, ok := status.FromError(err)
    if !ok {
        return false
    }

    switch st.Code() {
    case codes.DeadlineExceeded,
        codes.ResourceExhausted,
        codes.Aborted,
        codes.Internal,
        codes.Unavailable:
        return true
    default:
        return false
    }
}

// HandleGRPCError å¤„ç† gRPC é”™è¯¯
func HandleGRPCError(err error) error {
    if err == nil {
        return nil
    }

    st, ok := status.FromError(err)
    if !ok {
        return fmt.Errorf("unknown error: %w", err)
    }

    switch st.Code() {
    case codes.OK:
        return nil

    case codes.InvalidArgument:
        return fmt.Errorf("invalid argument: %s", st.Message())

    case codes.Unauthenticated:
        return fmt.Errorf("authentication failed: %s", st.Message())

    case codes.PermissionDenied:
        return fmt.Errorf("permission denied: %s", st.Message())

    case codes.NotFound:
        return fmt.Errorf("resource not found: %s", st.Message())

    case codes.DeadlineExceeded:
        return fmt.Errorf("request timeout: %s", st.Message())

    case codes.Unavailable:
        return fmt.Errorf("service unavailable: %s", st.Message())

    case codes.Internal:
        return fmt.Errorf("internal error: %s", st.Message())

    default:
        return fmt.Errorf("grpc error [%s]: %s", st.Code(), st.Message())
    }
}

// RetryableInterceptor gRPC é‡è¯•æ‹¦æˆªå™¨
func RetryableInterceptor(maxRetries int, backoff time.Duration) grpc.UnaryClientInterceptor {
    return func(
        ctx context.Context,
        method string,
        req, reply interface{},
        cc *grpc.ClientConn,
        invoker grpc.UnaryInvoker,
        opts ...grpc.CallOption,
    ) error {
        var err error
        
        for attempt := 0; attempt <= maxRetries; attempt++ {
            err = invoker(ctx, method, req, reply, cc, opts...)
            
            if err == nil {
                return nil
            }

            // æ£€æŸ¥æ˜¯å¦å¯é‡è¯•
            if !IsRetryable(err) {
                return err
            }

            // æœ€åä¸€æ¬¡å°è¯•
            if attempt == maxRetries {
                return err
            }

            // æŒ‡æ•°é€€é¿
            waitTime := backoff * time.Duration(1<<uint(attempt))
            select {
            case <-time.After(waitTime):
                // ç»§ç»­é‡è¯•
            case <-ctx.Done():
                return ctx.Err()
            }
        }

        return err
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    conn, err := grpc.Dial("localhost:4317",
        grpc.WithUnaryInterceptor(
            RetryableInterceptor(3, 100*time.Millisecond),
        ),
    )
    if err != nil {
        panic(err)
    }
    defer conn.Close()
}
```

### 3. æœåŠ¡ç«¯é”™è¯¯ç”Ÿæˆ

```go
package grpcserver

import (
    "context"

    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)

// è¿”å›ä¸åŒç±»å‹çš„é”™è¯¯
func ExampleErrorHandling(ctx context.Context) error {
    // 1. æ— æ•ˆå‚æ•°
    if invalidInput {
        return status.Error(codes.InvalidArgument, "invalid trace ID")
    }

    // 2. æœªè®¤è¯
    if !authenticated {
        return status.Error(codes.Unauthenticated, "missing authentication token")
    }

    // 3. æƒé™æ‹’ç»
    if !authorized {
        return status.Error(codes.PermissionDenied, "insufficient permissions")
    }

    // 4. èµ„æºæœªæ‰¾åˆ°
    if !found {
        return status.Error(codes.NotFound, "resource not found")
    }

    // 5. è¶…æ—¶
    if timeout {
        return status.Error(codes.DeadlineExceeded, "request timeout")
    }

    // 6. é™æµ
    if rateLimited {
        return status.Error(codes.ResourceExhausted, "rate limit exceeded")
    }

    // 7. æœåŠ¡ä¸å¯ç”¨
    if unavailable {
        return status.Error(codes.Unavailable, "service temporarily unavailable")
    }

    // 8. å†…éƒ¨é”™è¯¯
    if internalError {
        return status.Error(codes.Internal, "internal server error")
    }

    return nil
}
```

---

## HTTP é”™è¯¯å¤„ç†

### 1. HTTP çŠ¶æ€ç æ˜ å°„

| HTTP çŠ¶æ€ç  | è¯´æ˜ | gRPC ç­‰ä»· | æ˜¯å¦é‡è¯• |
|-----------|------|-----------|---------|
| 200 | OK | `OK` | âŒ |
| 400 | Bad Request | `INVALID_ARGUMENT` | âŒ |
| 401 | Unauthorized | `UNAUTHENTICATED` | âŒ |
| 403 | Forbidden | `PERMISSION_DENIED` | âŒ |
| 404 | Not Found | `NOT_FOUND` | âŒ |
| 408 | Request Timeout | `DEADLINE_EXCEEDED` | âœ… |
| 409 | Conflict | `ALREADY_EXISTS` | âŒ |
| 429 | Too Many Requests | `RESOURCE_EXHAUSTED` | âœ… |
| 500 | Internal Server Error | `INTERNAL` | âœ… |
| 502 | Bad Gateway | `UNAVAILABLE` | âœ… |
| 503 | Service Unavailable | `UNAVAILABLE` | âœ… |
| 504 | Gateway Timeout | `DEADLINE_EXCEEDED` | âœ… |

### 2. Go HTTP é”™è¯¯å¤„ç†

```go
package httperror

import (
    "encoding/json"
    "fmt"
    "net/http"
    "time"
)

// ErrorResponse HTTP é”™è¯¯å“åº”
type ErrorResponse struct {
    Code    int    `json:"code"`
    Message string `json:"message"`
    Details string `json:"details,omitempty"`
}

// IsRetryable åˆ¤æ–­ HTTP é”™è¯¯æ˜¯å¦å¯é‡è¯•
func IsRetryable(statusCode int) bool {
    switch statusCode {
    case http.StatusRequestTimeout,        // 408
        http.StatusTooManyRequests,        // 429
        http.StatusInternalServerError,    // 500
        http.StatusBadGateway,             // 502
        http.StatusServiceUnavailable,     // 503
        http.StatusGatewayTimeout:         // 504
        return true
    default:
        return false
    }
}

// HTTPRetryTransport HTTP é‡è¯•ä¼ è¾“å±‚
type HTTPRetryTransport struct {
    Transport  http.RoundTripper
    MaxRetries int
    Backoff    time.Duration
}

// RoundTrip å®ç° http.RoundTripper
func (t *HTTPRetryTransport) RoundTrip(req *http.Request) (*http.Response, error) {
    var resp *http.Response
    var err error

    for attempt := 0; attempt <= t.MaxRetries; attempt++ {
        resp, err = t.Transport.RoundTrip(req)

        // è¯·æ±‚æˆåŠŸ
        if err == nil && resp.StatusCode < 500 {
            return resp, nil
        }

        // æ£€æŸ¥æ˜¯å¦å¯é‡è¯•
        if err == nil && !IsRetryable(resp.StatusCode) {
            return resp, nil
        }

        // æœ€åä¸€æ¬¡å°è¯•
        if attempt == t.MaxRetries {
            return resp, err
        }

        // æŒ‡æ•°é€€é¿
        waitTime := t.Backoff * time.Duration(1<<uint(attempt))
        time.Sleep(waitTime)
    }

    return resp, err
}

// HandleHTTPError å¤„ç† HTTP é”™è¯¯å“åº”
func HandleHTTPError(resp *http.Response) error {
    if resp.StatusCode >= 200 && resp.StatusCode < 300 {
        return nil
    }

    var errResp ErrorResponse
    if err := json.NewDecoder(resp.Body).Decode(&errResp); err != nil {
        return fmt.Errorf("HTTP %d: failed to decode error response", resp.StatusCode)
    }

    return fmt.Errorf("HTTP %d: %s - %s", errResp.Code, errResp.Message, errResp.Details)
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    client := &http.Client{
        Transport: &HTTPRetryTransport{
            Transport:  http.DefaultTransport,
            MaxRetries: 3,
            Backoff:    100 * time.Millisecond,
        },
        Timeout: 10 * time.Second,
    }

    resp, err := client.Get("http://localhost:4318/v1/traces")
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()

    if err := HandleHTTPError(resp); err != nil {
        panic(err)
    }
}
```

---

## é‡è¯•ç­–ç•¥

### 1. æŒ‡æ•°é€€é¿ç®—æ³•

**åŸç†**: æ¯æ¬¡é‡è¯•å,ç­‰å¾…æ—¶é—´å‘ˆæŒ‡æ•°å¢é•¿ã€‚

```text
å…¬å¼: wait_time = base_delay * (2 ^ attempt) + random_jitter

ç¤ºä¾‹:
  attempt 0: 100ms
  attempt 1: 200ms + jitter
  attempt 2: 400ms + jitter
  attempt 3: 800ms + jitter
  attempt 4: 1600ms + jitter
```

**Go å®ç°**:

```go
package retry

import (
    "context"
    "math/rand"
    "time"
)

// ExponentialBackoff æŒ‡æ•°é€€é¿
type ExponentialBackoff struct {
    BaseDelay  time.Duration  // åŸºç¡€å»¶è¿Ÿ
    MaxDelay   time.Duration  // æœ€å¤§å»¶è¿Ÿ
    Multiplier float64        // ä¹˜æ•°
    Jitter     float64        // æŠ–åŠ¨å› å­ [0, 1]
}

// DefaultBackoff é»˜è®¤é…ç½®
func DefaultBackoff() *ExponentialBackoff {
    return &ExponentialBackoff{
        BaseDelay:  100 * time.Millisecond,
        MaxDelay:   30 * time.Second,
        Multiplier: 2.0,
        Jitter:     0.1,
    }
}

// Delay è®¡ç®—ç¬¬ n æ¬¡é‡è¯•çš„å»¶è¿Ÿ
func (eb *ExponentialBackoff) Delay(attempt int) time.Duration {
    if attempt < 0 {
        return 0
    }

    // è®¡ç®—åŸºç¡€å»¶è¿Ÿ: base_delay * multiplier^attempt
    delay := float64(eb.BaseDelay) * float64(1<<uint(attempt))

    // é™åˆ¶æœ€å¤§å»¶è¿Ÿ
    if delay > float64(eb.MaxDelay) {
        delay = float64(eb.MaxDelay)
    }

    // æ·»åŠ éšæœºæŠ–åŠ¨ [-jitter, +jitter]
    jitter := delay * eb.Jitter * (2*rand.Float64() - 1)
    delay += jitter

    return time.Duration(delay)
}

// Wait ç­‰å¾…æŒ‡å®šæ—¶é—´æˆ–ä¸Šä¸‹æ–‡å–æ¶ˆ
func (eb *ExponentialBackoff) Wait(ctx context.Context, attempt int) error {
    delay := eb.Delay(attempt)

    select {
    case <-time.After(delay):
        return nil
    case <-ctx.Done():
        return ctx.Err()
    }
}

// Retry é‡è¯•å‡½æ•°
func Retry(
    ctx context.Context,
    maxAttempts int,
    backoff *ExponentialBackoff,
    fn func() error,
) error {
    var err error

    for attempt := 0; attempt < maxAttempts; attempt++ {
        err = fn()
        if err == nil {
            return nil
        }

        // æœ€åä¸€æ¬¡å°è¯•
        if attempt == maxAttempts-1 {
            return err
        }

        // ç­‰å¾…åé‡è¯•
        if waitErr := backoff.Wait(ctx, attempt); waitErr != nil {
            return waitErr
        }
    }

    return err
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    ctx := context.Background()
    backoff := DefaultBackoff()

    err := Retry(ctx, 5, backoff, func() error {
        // æ‰§è¡Œå¯èƒ½å¤±è´¥çš„æ“ä½œ
        return performOperation()
    })

    if err != nil {
        fmt.Println("All retries failed:", err)
    }
}
```

### 2. é‡è¯•é¢„ç®—

**æ¦‚å¿µ**: é™åˆ¶é‡è¯•æ¬¡æ•°å æ€»è¯·æ±‚çš„æ¯”ä¾‹,é¿å…é‡è¯•é£æš´ã€‚

```go
package retry

import (
    "sync"
    "time"
)

// RetryBudget é‡è¯•é¢„ç®—
type RetryBudget struct {
    mu sync.Mutex
    
    // é…ç½®
    maxRetryRatio float64       // æœ€å¤§é‡è¯•æ¯”ä¾‹ (ä¾‹å¦‚ 0.1 = 10%)
    minRequests   int            // æœ€å°è¯·æ±‚æ•°
    
    // ç»Ÿè®¡
    totalRequests int
    totalRetries  int
    windowStart   time.Time
    windowSize    time.Duration
}

// NewRetryBudget åˆ›å»ºé‡è¯•é¢„ç®—
func NewRetryBudget(maxRetryRatio float64, minRequests int, windowSize time.Duration) *RetryBudget {
    return &RetryBudget{
        maxRetryRatio: maxRetryRatio,
        minRequests:   minRequests,
        windowStart:   time.Now(),
        windowSize:    windowSize,
    }
}

// CanRetry æ£€æŸ¥æ˜¯å¦å¯ä»¥é‡è¯•
func (rb *RetryBudget) CanRetry() bool {
    rb.mu.Lock()
    defer rb.mu.Unlock()

    rb.maybeResetWindow()

    // è¯·æ±‚æ•°ä¸è¶³,å…è®¸é‡è¯•
    if rb.totalRequests < rb.minRequests {
        return true
    }

    // æ£€æŸ¥é‡è¯•æ¯”ä¾‹
    retryRatio := float64(rb.totalRetries) / float64(rb.totalRequests)
    return retryRatio < rb.maxRetryRatio
}

// RecordRequest è®°å½•è¯·æ±‚
func (rb *RetryBudget) RecordRequest() {
    rb.mu.Lock()
    defer rb.mu.Unlock()

    rb.maybeResetWindow()
    rb.totalRequests++
}

// RecordRetry è®°å½•é‡è¯•
func (rb *RetryBudget) RecordRetry() {
    rb.mu.Lock()
    defer rb.mu.Unlock()

    rb.maybeResetWindow()
    rb.totalRetries++
}

// maybeResetWindow å¯èƒ½é‡ç½®æ—¶é—´çª—å£
func (rb *RetryBudget) maybeResetWindow() {
    if time.Since(rb.windowStart) >= rb.windowSize {
        rb.totalRequests = 0
        rb.totalRetries = 0
        rb.windowStart = time.Now()
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    // å…è®¸ 10% çš„è¯·æ±‚é‡è¯•,çª—å£æœŸ 1 åˆ†é’Ÿ
    budget := NewRetryBudget(0.1, 10, time.Minute)

    for i := 0; i < 100; i++ {
        budget.RecordRequest()

        err := performOperation()
        if err != nil && budget.CanRetry() {
            budget.RecordRetry()
            // æ‰§è¡Œé‡è¯•
        }
    }
}
```

---

## æ–­è·¯å™¨æ¨¡å¼

### 1. æ–­è·¯å™¨çŠ¶æ€æœº

```text
çŠ¶æ€è½¬æ¢:

       æˆåŠŸæ¬¡æ•° >= threshold
Closed â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Open
  â”‚                               â”‚
  â”‚                               â”‚ timeout
  â”‚                               â†“
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Half-Open
         æˆåŠŸ                      â”‚
                                  â”‚ å¤±è´¥
                                  â†“
                                Open

çŠ¶æ€è¯´æ˜:
- Closed: æ­£å¸¸çŠ¶æ€,è¯·æ±‚æ­£å¸¸é€šè¿‡
- Open: ç†”æ–­çŠ¶æ€,è¯·æ±‚ç›´æ¥å¤±è´¥
- Half-Open: åŠå¼€çŠ¶æ€,å…è®¸éƒ¨åˆ†è¯·æ±‚å°è¯•
```

### 2. Go å®ç°

```go
package circuitbreaker

import (
    "errors"
    "sync"
    "time"
)

// State æ–­è·¯å™¨çŠ¶æ€
type State int

const (
    StateClosed   State = iota // å…³é—­(æ­£å¸¸)
    StateOpen                   // æ‰“å¼€(ç†”æ–­)
    StateHalfOpen               // åŠå¼€(æ¢å¤ä¸­)
)

// CircuitBreaker æ–­è·¯å™¨
type CircuitBreaker struct {
    mu sync.Mutex
    
    state         State
    failureCount  int
    successCount  int
    lastFailTime  time.Time
    
    // é…ç½®
    maxFailures   int           // æœ€å¤§å¤±è´¥æ¬¡æ•°
    timeout       time.Duration // ç†”æ–­è¶…æ—¶
    halfOpenMax   int           // åŠå¼€çŠ¶æ€æœ€å¤§æˆåŠŸæ¬¡æ•°
}

// NewCircuitBreaker åˆ›å»ºæ–­è·¯å™¨
func NewCircuitBreaker(maxFailures int, timeout time.Duration) *CircuitBreaker {
    return &CircuitBreaker{
        state:       StateClosed,
        maxFailures: maxFailures,
        timeout:     timeout,
        halfOpenMax: 1,
    }
}

// Execute æ‰§è¡Œæ“ä½œ
func (cb *CircuitBreaker) Execute(fn func() error) error {
    if err := cb.beforeRequest(); err != nil {
        return err
    }

    err := fn()
    cb.afterRequest(err)
    
    return err
}

// beforeRequest è¯·æ±‚å‰æ£€æŸ¥
func (cb *CircuitBreaker) beforeRequest() error {
    cb.mu.Lock()
    defer cb.mu.Unlock()

    switch cb.state {
    case StateClosed:
        return nil

    case StateOpen:
        // æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿›å…¥åŠå¼€çŠ¶æ€
        if time.Since(cb.lastFailTime) >= cb.timeout {
            cb.state = StateHalfOpen
            cb.successCount = 0
            return nil
        }
        return errors.New("circuit breaker is open")

    case StateHalfOpen:
        return nil

    default:
        return errors.New("unknown state")
    }
}

// afterRequest è¯·æ±‚åå¤„ç†
func (cb *CircuitBreaker) afterRequest(err error) {
    cb.mu.Lock()
    defer cb.mu.Unlock()

    if err == nil {
        cb.onSuccess()
    } else {
        cb.onFailure()
    }
}

// onSuccess æˆåŠŸå¤„ç†
func (cb *CircuitBreaker) onSuccess() {
    switch cb.state {
    case StateClosed:
        cb.failureCount = 0

    case StateHalfOpen:
        cb.successCount++
        if cb.successCount >= cb.halfOpenMax {
            cb.state = StateClosed
            cb.failureCount = 0
        }
    }
}

// onFailure å¤±è´¥å¤„ç†
func (cb *CircuitBreaker) onFailure() {
    cb.lastFailTime = time.Now()

    switch cb.state {
    case StateClosed:
        cb.failureCount++
        if cb.failureCount >= cb.maxFailures {
            cb.state = StateOpen
        }

    case StateHalfOpen:
        cb.state = StateOpen
        cb.failureCount = cb.maxFailures
    }
}

// State è¿”å›å½“å‰çŠ¶æ€
func (cb *CircuitBreaker) State() State {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    return cb.state
}

// ä½¿ç”¨ç¤ºä¾‹
func Example() {
    cb := NewCircuitBreaker(5, 30*time.Second)

    for i := 0; i < 100; i++ {
        err := cb.Execute(func() error {
            return performOperation()
        })

        if err != nil {
            fmt.Printf("Request %d failed: %v (state: %v)\n", i, err, cb.State())
        }
    }
}
```

---

## æœ€ä½³å®è·µ

### 1. ç»¼åˆé”™è¯¯å¤„ç†ç­–ç•¥

```go
package errorhandling

import (
    "context"
    "fmt"
    "time"
)

// ResilientClient å¼¹æ€§å®¢æˆ·ç«¯
type ResilientClient struct {
    client         *OTLPClient
    retryBudget    *RetryBudget
    circuitBreaker *CircuitBreaker
    backoff        *ExponentialBackoff
}

// NewResilientClient åˆ›å»ºå¼¹æ€§å®¢æˆ·ç«¯
func NewResilientClient(endpoint string) *ResilientClient {
    return &ResilientClient{
        client:         NewOTLPClient(endpoint),
        retryBudget:    NewRetryBudget(0.1, 10, time.Minute),
        circuitBreaker: NewCircuitBreaker(5, 30*time.Second),
        backoff:        DefaultBackoff(),
    }
}

// Export å¯¼å‡ºæ•°æ® (å¸¦å®Œæ•´é”™è¯¯å¤„ç†)
func (rc *ResilientClient) Export(ctx context.Context, data []byte) error {
    rc.retryBudget.RecordRequest()

    return rc.circuitBreaker.Execute(func() error {
        return Retry(ctx, 3, rc.backoff, func() error {
            err := rc.client.Export(ctx, data)

            if err != nil && IsRetryable(err) && rc.retryBudget.CanRetry() {
                rc.retryBudget.RecordRetry()
                return err
            }

            return err
        })
    })
}
```

### 2. é”™è¯¯ç›‘æ§ä¸å‘Šè­¦

```go
package monitoring

import (
    "go.opentelemetry.io/otel/metric"
)

// ErrorMonitor é”™è¯¯ç›‘æ§
type ErrorMonitor struct {
    errorCounter    metric.Int64Counter
    retryCounter    metric.Int64Counter
    circuitBreaker  metric.Int64ObservableGauge
}

// NewErrorMonitor åˆ›å»ºé”™è¯¯ç›‘æ§
func NewErrorMonitor(meter metric.Meter) (*ErrorMonitor, error) {
    errorCounter, err := meter.Int64Counter("otlp.errors",
        metric.WithDescription("Total OTLP errors"),
    )
    if err != nil {
        return nil, err
    }

    retryCounter, err := meter.Int64Counter("otlp.retries",
        metric.WithDescription("Total OTLP retries"),
    )
    if err != nil {
        return nil, err
    }

    return &ErrorMonitor{
        errorCounter: errorCounter,
        retryCounter: retryCounter,
    }, nil
}

// RecordError è®°å½•é”™è¯¯
func (em *ErrorMonitor) RecordError(ctx context.Context, errorType string) {
    em.errorCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("error.type", errorType),
        ),
    )
}

// RecordRetry è®°å½•é‡è¯•
func (em *ErrorMonitor) RecordRetry(ctx context.Context, attempt int) {
    em.retryCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.Int("retry.attempt", attempt),
        ),
    )
}
```

---

## å‚è€ƒèµ„æº

### å®˜æ–¹æ–‡æ¡£

- [gRPC Error Handling](https://grpc.io/docs/guides/error/)
- [gRPC Status Codes](https://grpc.github.io/grpc/core/md_doc_statuscodes.html)
- [HTTP Status Codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)

### è®¾è®¡æ¨¡å¼

- [Circuit Breaker Pattern](https://martinfowler.com/bliki/CircuitBreaker.html)
- [Retry Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/retry)
- [Exponential Backoff](https://en.wikipedia.org/wiki/Exponential_backoff)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ9æ—¥  
**ç»´æŠ¤è€…**: OTLP æ ‡å‡†åŒ–é¡¹ç›®ç»„
