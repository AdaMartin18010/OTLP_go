# å®æˆ˜æ¡ˆä¾‹ï¼šé«˜å¹¶å‘åº“å­˜ç³»ç»Ÿå®Œæ•´ OTLP é›†æˆ

> **åœºæ™¯**: ç”µå•†ç§’æ€/æŠ¢è´­åœºæ™¯çš„é«˜å¹¶å‘åº“å­˜æ‰£å‡ç³»ç»Ÿ  
> **æŠ€æœ¯æ ˆ**: Go 1.25.1, Gin, Redis, PostgreSQL, Lua  
> **ç‰¹æ€§**: 10ä¸‡+TPSã€RedisåŸå­æ“ä½œã€çƒ­ç‚¹æ•°æ®å¤„ç†ã€å®Œæ•´è¿½è¸ª  
> **OpenTelemetry**: v1.32.0+  
> **éš¾åº¦**: â­â­â­â­â­ (æé™æ€§èƒ½ä¼˜åŒ–)

---

## ğŸ“‹ ç›®å½•

- [å®æˆ˜æ¡ˆä¾‹ï¼šé«˜å¹¶å‘åº“å­˜ç³»ç»Ÿå®Œæ•´ OTLP é›†æˆ](#å®æˆ˜æ¡ˆä¾‹é«˜å¹¶å‘åº“å­˜ç³»ç»Ÿå®Œæ•´-otlp-é›†æˆ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ç³»ç»Ÿæ¦‚è¿°](#ç³»ç»Ÿæ¦‚è¿°)
    - [ä¸šåŠ¡åœºæ™¯](#ä¸šåŠ¡åœºæ™¯)
    - [æŠ€æœ¯æŒ‘æˆ˜](#æŠ€æœ¯æŒ‘æˆ˜)
  - [æ¶æ„è®¾è®¡](#æ¶æ„è®¾è®¡)
    - [ç³»ç»Ÿæ¶æ„](#ç³»ç»Ÿæ¶æ„)
    - [æ•°æ®æµ](#æ•°æ®æµ)
  - [æ ¸å¿ƒå®ç°](#æ ¸å¿ƒå®ç°)
    - [1. é¡¹ç›®ç»“æ„](#1-é¡¹ç›®ç»“æ„)
    - [2. Telemetry åˆå§‹åŒ–](#2-telemetry-åˆå§‹åŒ–)
    - [3. Redis Lua è„šæœ¬ï¼ˆåŸå­æ‰£å‡ï¼‰](#3-redis-lua-è„šæœ¬åŸå­æ‰£å‡)
    - [4. åº“å­˜æœåŠ¡å®ç°](#4-åº“å­˜æœåŠ¡å®ç°)
    - [5. æœ¬åœ°ç¼“å­˜ï¼ˆçƒ­ç‚¹æ•°æ®ä¼˜åŒ–ï¼‰](#5-æœ¬åœ°ç¼“å­˜çƒ­ç‚¹æ•°æ®ä¼˜åŒ–)
    - [6. HTTP Handler](#6-http-handler)
  - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
    - [1. è¿æ¥æ± ä¼˜åŒ–](#1-è¿æ¥æ± ä¼˜åŒ–)
    - [2. æ‰¹å¤„ç†ä¼˜åŒ–](#2-æ‰¹å¤„ç†ä¼˜åŒ–)
    - [3. æœ¬åœ°ç¼“å­˜çƒ­ç‚¹æ•°æ®](#3-æœ¬åœ°ç¼“å­˜çƒ­ç‚¹æ•°æ®)
    - [4. é›¶æ‹·è´ä¼˜åŒ–](#4-é›¶æ‹·è´ä¼˜åŒ–)
    - [5. é‡‡æ ·ä¼˜åŒ–](#5-é‡‡æ ·ä¼˜åŒ–)
  - [ç›‘æ§å‘Šè­¦](#ç›‘æ§å‘Šè­¦)
    - [å…³é”®æŒ‡æ ‡](#å…³é”®æŒ‡æ ‡)
    - [Grafana Dashboard](#grafana-dashboard)
  - [å‹æµ‹ç»“æœ](#å‹æµ‹ç»“æœ)
    - [æµ‹è¯•ç¯å¢ƒ](#æµ‹è¯•ç¯å¢ƒ)
    - [å‹æµ‹å‘½ä»¤](#å‹æµ‹å‘½ä»¤)
    - [å‹æµ‹ç»“æœ1](#å‹æµ‹ç»“æœ1)
    - [æ€§èƒ½å¯¹æ¯”](#æ€§èƒ½å¯¹æ¯”)
  - [æœ€ä½³å®è·µæ€»ç»“](#æœ€ä½³å®è·µæ€»ç»“)
    - [1. Redis åŸå­æ“ä½œ](#1-redis-åŸå­æ“ä½œ)
    - [2. æœ¬åœ°ç¼“å­˜](#2-æœ¬åœ°ç¼“å­˜)
    - [3. å¼‚æ­¥åŒæ­¥æ•°æ®åº“](#3-å¼‚æ­¥åŒæ­¥æ•°æ®åº“)
    - [4. é‡‡æ ·ç­–ç•¥](#4-é‡‡æ ·ç­–ç•¥)
    - [5. æ€§èƒ½ç›‘æ§](#5-æ€§èƒ½ç›‘æ§)
  - [ğŸ¯ å­¦åˆ°çš„å…³é”®çŸ¥è¯†ç‚¹](#-å­¦åˆ°çš„å…³é”®çŸ¥è¯†ç‚¹)

---

## ç³»ç»Ÿæ¦‚è¿°

### ä¸šåŠ¡åœºæ™¯

ç§’æ€åœºæ™¯çš„å…¸å‹ç‰¹ç‚¹ï¼š

- âš¡ **ç¬æ—¶é«˜å¹¶å‘**: 10ä¸‡+ TPS
- ğŸ¯ **çƒ­ç‚¹å•†å“**: å°‘é‡SKUï¼Œæµ·é‡è¯·æ±‚
- â±ï¸ **ä½å»¶è¿Ÿè¦æ±‚**: P99 < 50ms
- âœ… **å¼ºä¸€è‡´æ€§**: ä¸èƒ½è¶…å–
- ğŸ”’ **é˜²åˆ·æœºåˆ¶**: é˜²æ­¢æ¶æ„åˆ·å•

### æŠ€æœ¯æŒ‘æˆ˜

| æŒ‘æˆ˜ | è§£å†³æ–¹æ¡ˆ |
|------|---------|
| é«˜å¹¶å‘å†™å†²çª | Redis Lua è„šæœ¬åŸå­æ“ä½œ |
| æ•°æ®åº“å‹åŠ› | å¼‚æ­¥æ‰¹é‡å›å†™ + æ¶ˆæ¯é˜Ÿåˆ— |
| çƒ­ç‚¹æ•°æ® | æœ¬åœ°ç¼“å­˜ + Redis é›†ç¾¤ |
| è¶…å–é£é™© | Redis åŸå­æ‰£å‡ + é¢„æ‰£æœºåˆ¶ |
| æ€§èƒ½ç“¶é¢ˆ | è¿æ¥æ±  + æ‰¹å¤„ç† + é›¶æ‹·è´ |

---

## æ¶æ„è®¾è®¡

### ç³»ç»Ÿæ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Load Balancer                     â”‚
â”‚                      (Nginx)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â–¼             â–¼             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Inventory  â”‚ â”‚  Inventory  â”‚ â”‚  Inventory  â”‚
â”‚  Service 1  â”‚ â”‚  Service 2  â”‚ â”‚  Service 3  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚               â”‚               â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â–¼             â–¼             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Redis     â”‚ â”‚   Redis     â”‚ â”‚   Redis     â”‚
â”‚   Node 1    â”‚ â”‚   Node 2    â”‚ â”‚   Node 3    â”‚
â”‚  (Master)   â”‚ â”‚  (Master)   â”‚ â”‚  (Master)   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚               â”‚               â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚    Kafka    â”‚
              â”‚ (Async DB)  â”‚
              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   Worker    â”‚
              â”‚ (Batch DB)  â”‚
              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ PostgreSQL  â”‚
              â”‚  (Master)   â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                     â”‚
                     â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   OTLP Collector      â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â–¼           â–¼           â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Jaeger â”‚  â”‚ Prom.  â”‚  â”‚  Loki  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ•°æ®æµ

```text
1. æ‰£å‡åº“å­˜è¯·æ±‚
   Client â†’ Load Balancer â†’ Inventory Service
   [Span: inventory.deduct]

2. æœ¬åœ°ç¼“å­˜æ£€æŸ¥ï¼ˆå¯é€‰ï¼‰
   Inventory Service â†’ Local Cache
   [Span: cache.check] [Cache hit/miss]

3. Redis åŸå­æ‰£å‡
   Inventory Service â†’ Redis Lua Script
   [Span: redis.deduct] [Atomic operation]

4. å¼‚æ­¥æ•°æ®åº“åŒæ­¥
   Redis â†’ Kafka â†’ Worker â†’ PostgreSQL
   [Span: db.sync] [Async batch write]

5. å“åº”è¿”å›
   Inventory Service â†’ Client
   [Span end] [Metrics: latency, success_rate, QPS]
```

---

## æ ¸å¿ƒå®ç°

### 1. é¡¹ç›®ç»“æ„

```text
inventory-service/
â”œâ”€â”€ cmd/
â”‚   â”œâ”€â”€ api/               # API æœåŠ¡
â”‚   â”‚   â””â”€â”€ main.go
â”‚   â””â”€â”€ worker/            # æ•°æ®åº“åŒæ­¥ Worker
â”‚       â””â”€â”€ main.go
â”‚
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ telemetry/         # OpenTelemetry
â”‚   â”‚   â”œâ”€â”€ init.go
â”‚   â”‚   â””â”€â”€ metrics.go
â”‚   â”‚
â”‚   â”œâ”€â”€ inventory/
â”‚   â”‚   â”œâ”€â”€ handler.go     # HTTP Handler
â”‚   â”‚   â”œâ”€â”€ service.go     # ä¸šåŠ¡é€»è¾‘
â”‚   â”‚   â”œâ”€â”€ redis.go       # Redis æ“ä½œ
â”‚   â”‚   â””â”€â”€ cache.go       # æœ¬åœ°ç¼“å­˜
â”‚   â”‚
â”‚   â”œâ”€â”€ worker/
â”‚   â”‚   â””â”€â”€ sync.go        # æ•°æ®åº“åŒæ­¥
â”‚   â”‚
â”‚   â””â”€â”€ middleware/
â”‚       â”œâ”€â”€ tracing.go
â”‚       â”œâ”€â”€ metrics.go
â”‚       â””â”€â”€ ratelimit.go
â”‚
â”œâ”€â”€ scripts/
â”‚   â””â”€â”€ inventory.lua      # Redis Lua è„šæœ¬
â”‚
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ config.yaml
â”‚   â””â”€â”€ redis.conf
â”‚
â””â”€â”€ go.mod
```

### 2. Telemetry åˆå§‹åŒ–

```go:internal/telemetry/init.go
package telemetry

import (
    "context"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/sdk/metric"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
)

type Telemetry struct {
    TracerProvider *sdktrace.TracerProvider
    MeterProvider  *metric.MeterProvider
}

func Init(ctx context.Context, serviceName, endpoint string) (*Telemetry, error) {
    // Resource
    res, err := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceNameKey.String(serviceName),
            semconv.ServiceVersionKey.String("1.0.0"),
        ),
    )
    if err != nil {
        return nil, err
    }

    // Trace Exporter
    traceExporter, err := otlptracegrpc.New(ctx,
        otlptracegrpc.WithEndpoint(endpoint),
        otlptracegrpc.WithInsecure(),
    )
    if err != nil {
        return nil, err
    }

    // Tracer Providerï¼ˆæè‡´æ€§èƒ½ä¼˜åŒ–ï¼‰
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(traceExporter,
            sdktrace.WithBatchTimeout(500*time.Millisecond),  // çŸ­æ‰¹å¤„ç†é—´éš”
            sdktrace.WithMaxExportBatchSize(2048),            // å¤§æ‰¹æ¬¡
            sdktrace.WithMaxQueueSize(8192),                  // å¤§é˜Ÿåˆ—
        ),
        sdktrace.WithResource(res),
        // é«˜å¹¶å‘åœºæ™¯ä½¿ç”¨é‡‡æ ·
        sdktrace.WithSampler(sdktrace.ParentBased(
            sdktrace.TraceIDRatioBased(0.01), // 1% é‡‡æ ·ç‡ï¼ˆ10ä¸‡TPSä¸‹ä»æœ‰1000ä¸ªtraceï¼‰
        )),
    )
    otel.SetTracerProvider(tp)

    // Metric Exporter
    metricExporter, err := otlpmetricgrpc.New(ctx,
        otlpmetricgrpc.WithEndpoint(endpoint),
        otlpmetricgrpc.WithInsecure(),
    )
    if err != nil {
        return nil, err
    }

    // Meter Provider
    mp := metric.NewMeterProvider(
        metric.WithResource(res),
        metric.WithReader(metric.NewPeriodicReader(metricExporter,
            metric.WithInterval(10*time.Second), // 10ç§’é‡‡é›†é—´éš”
        )),
    )
    otel.SetMeterProvider(mp)

    // Propagator
    otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
        propagation.TraceContext{},
        propagation.Baggage{},
    ))

    return &Telemetry{
        TracerProvider: tp,
        MeterProvider:  mp,
    }, nil
}

func (t *Telemetry) Shutdown(ctx context.Context) error {
    if err := t.TracerProvider.Shutdown(ctx); err != nil {
        return err
    }
    return t.MeterProvider.Shutdown(ctx)
}
```

### 3. Redis Lua è„šæœ¬ï¼ˆåŸå­æ‰£å‡ï¼‰

```lua:scripts/inventory.lua
-- inventory_deduct.lua
-- åŸå­æ‰£å‡åº“å­˜

local stock_key = KEYS[1]        -- åº“å­˜é”®: "inventory:SKU_123"
local deduct_amount = tonumber(ARGV[1])  -- æ‰£å‡æ•°é‡
local user_id = ARGV[2]          -- ç”¨æˆ·IDï¼ˆç”¨äºé˜²åˆ·ï¼‰
local order_id = ARGV[3]         -- è®¢å•ID

-- 1. æ£€æŸ¥åº“å­˜æ˜¯å¦å­˜åœ¨
local current_stock = redis.call('GET', stock_key)
if not current_stock then
    return {-1, "stock_not_found"}
end

current_stock = tonumber(current_stock)

-- 2. æ£€æŸ¥åº“å­˜æ˜¯å¦å……è¶³
if current_stock < deduct_amount then
    return {-2, "insufficient_stock", current_stock}
end

-- 3. ç”¨æˆ·é˜²åˆ·æ£€æŸ¥ï¼ˆåŒä¸€ç”¨æˆ·1ç§’å†…åªèƒ½è¯·æ±‚ä¸€æ¬¡ï¼‰
local user_key = "inventory:user_limit:" .. user_id .. ":" .. stock_key
local user_request_count = redis.call('INCR', user_key)
if user_request_count == 1 then
    redis.call('EXPIRE', user_key, 1)  -- 1ç§’è¿‡æœŸ
end
if user_request_count > 1 then
    return {-3, "rate_limit_exceeded"}
end

-- 4. åŸå­æ‰£å‡åº“å­˜
local new_stock = redis.call('DECRBY', stock_key, deduct_amount)

-- 5. è®°å½•æ‰£å‡æ—¥å¿—ï¼ˆå¯é€‰ï¼Œç”¨äºå¯¹è´¦ï¼‰
local log_key = "inventory:log:" .. order_id
redis.call('HSET', log_key,
    'sku', stock_key,
    'user_id', user_id,
    'deduct_amount', deduct_amount,
    'old_stock', current_stock,
    'new_stock', new_stock,
    'timestamp', redis.call('TIME')[1]
)
redis.call('EXPIRE', log_key, 86400)  -- æ—¥å¿—ä¿ç•™1å¤©

-- 6. è¿”å›æˆåŠŸ
return {0, "success", new_stock}
```

### 4. åº“å­˜æœåŠ¡å®ç°

```go:internal/inventory/service.go
package inventory

import (
    "context"
    "fmt"
    "time"

    "github.com/redis/go-redis/v9"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
)

var (
    tracer = otel.Tracer("inventory-service")
    meter  = otel.Meter("inventory-service")
)

// Metricsï¼ˆå…³é”®æ€§èƒ½æŒ‡æ ‡ï¼‰
var (
    deductCounter     metric.Int64Counter
    deductDuration    metric.Float64Histogram
    stockGauge        metric.Int64Gauge
    qpsCounter        metric.Int64Counter
)

func init() {
    var err error

    deductCounter, err = meter.Int64Counter(
        "inventory.deduct.total",
        metric.WithDescription("Total inventory deduct requests"),
        metric.WithUnit("{request}"),
    )
    if err != nil {
        panic(err)
    }

    deductDuration, err = meter.Float64Histogram(
        "inventory.deduct.duration",
        metric.WithDescription("Inventory deduct duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        panic(err)
    }

    stockGauge, err = meter.Int64Gauge(
        "inventory.stock.current",
        metric.WithDescription("Current stock level"),
        metric.WithUnit("{item}"),
    )
    if err != nil {
        panic(err)
    }

    qpsCounter, err = meter.Int64Counter(
        "inventory.qps",
        metric.WithDescription("Queries per second"),
        metric.WithUnit("{query}/s"),
    )
    if err != nil {
        panic(err)
    }
}

type Service struct {
    redis       *redis.Client
    localCache  *LocalCache
    luaScript   *redis.Script
}

func NewService(redisClient *redis.Client) *Service {
    // åŠ è½½ Lua è„šæœ¬
    luaScript := redis.NewScript(`
        -- (Lua è„šæœ¬å†…å®¹å¦‚ä¸Š)
    `)

    return &Service{
        redis:      redisClient,
        localCache: NewLocalCache(1000, 1*time.Second), // 1000ä¸ªå•†å“ï¼Œ1ç§’è¿‡æœŸ
        luaScript:  luaScript,
    }
}

type DeductRequest struct {
    SKU    string
    UserID string
    OrderID string
    Amount int64
}

type DeductResponse struct {
    Success   bool
    NewStock  int64
    Message   string
}

// Deduct æ‰£å‡åº“å­˜ï¼ˆæ ¸å¿ƒæ–¹æ³•ï¼‰
func (s *Service) Deduct(ctx context.Context, req *DeductRequest) (*DeductResponse, error) {
    startTime := time.Now()

    ctx, span := tracer.Start(ctx, "inventory.deduct",
        trace.WithSpanKind(trace.SpanKindInternal),
        trace.WithAttributes(
            attribute.String("inventory.sku", req.SKU),
            attribute.String("user.id", req.UserID),
            attribute.String("order.id", req.OrderID),
            attribute.Int64("inventory.amount", req.Amount),
        ),
    )
    defer span.End()

    // è®°å½• QPS
    qpsCounter.Add(ctx, 1)

    // è®°å½•å»¶è¿Ÿï¼ˆdeferç¡®ä¿ä¸€å®šæ‰§è¡Œï¼‰
    defer func() {
        duration := float64(time.Since(startTime).Microseconds()) / 1000.0 // è½¬æ¢ä¸ºæ¯«ç§’
        deductDuration.Record(ctx, duration,
            metric.WithAttributes(
                attribute.String("sku", req.SKU),
            ),
        )
    }()

    // 1. æœ¬åœ°ç¼“å­˜é¢„æ£€æŸ¥ï¼ˆå¯é€‰ä¼˜åŒ–ï¼‰
    if cachedStock, ok := s.localCache.Get(req.SKU); ok {
        if cachedStock < req.Amount {
            span.AddEvent("local_cache_hit_insufficient")
            deductCounter.Add(ctx, 1, metric.WithAttributes(
                attribute.String("result", "insufficient_stock"),
                attribute.String("source", "local_cache"),
            ))
            return &DeductResponse{
                Success: false,
                Message: "insufficient stock (from cache)",
            }, nil
        }
        span.AddEvent("local_cache_hit_sufficient")
    }

    // 2. Redis Lua è„šæœ¬åŸå­æ‰£å‡
    stockKey := fmt.Sprintf("inventory:%s", req.SKU)
    result, err := s.luaScript.Run(ctx, s.redis,
        []string{stockKey},
        req.Amount, req.UserID, req.OrderID,
    ).Result()

    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "redis script execution failed")
        deductCounter.Add(ctx, 1, metric.WithAttributes(
            attribute.String("result", "error"),
        ))
        return nil, fmt.Errorf("failed to execute lua script: %w", err)
    }

    // 3. è§£æ Lua è„šæœ¬è¿”å›ç»“æœ
    resultSlice, ok := result.([]interface{})
    if !ok || len(resultSlice) < 2 {
        return nil, fmt.Errorf("invalid lua script result")
    }

    code := resultSlice[0].(int64)
    message := resultSlice[1].(string)

    // 4. å¤„ç†è¿”å›ç»“æœ
    switch code {
    case 0: // æˆåŠŸ
        newStock := resultSlice[2].(int64)
        span.SetStatus(codes.Ok, "inventory deducted")
        span.SetAttributes(attribute.Int64("inventory.new_stock", newStock))
        
        // æ›´æ–°æœ¬åœ°ç¼“å­˜
        s.localCache.Set(req.SKU, newStock)
        
        // æ›´æ–°åº“å­˜æŒ‡æ ‡
        stockGauge.Record(ctx, newStock,
            metric.WithAttributes(attribute.String("sku", req.SKU)),
        )
        
        deductCounter.Add(ctx, 1, metric.WithAttributes(
            attribute.String("result", "success"),
        ))

        return &DeductResponse{
            Success:  true,
            NewStock: newStock,
            Message:  "success",
        }, nil

    case -1: // åº“å­˜ä¸å­˜åœ¨
        span.SetStatus(codes.Error, "stock not found")
        deductCounter.Add(ctx, 1, metric.WithAttributes(
            attribute.String("result", "not_found"),
        ))
        return &DeductResponse{
            Success: false,
            Message: "stock not found",
        }, nil

    case -2: // åº“å­˜ä¸è¶³
        currentStock := resultSlice[2].(int64)
        span.SetStatus(codes.Ok, "insufficient stock")
        span.SetAttributes(attribute.Int64("inventory.current_stock", currentStock))
        
        // æ›´æ–°æœ¬åœ°ç¼“å­˜ï¼ˆå³ä½¿æ‰£å‡å¤±è´¥ä¹Ÿæ›´æ–°ç¼“å­˜ï¼Œé¿å…åç»­æ— æ•ˆè¯·æ±‚ï¼‰
        s.localCache.Set(req.SKU, currentStock)
        
        deductCounter.Add(ctx, 1, metric.WithAttributes(
            attribute.String("result", "insufficient_stock"),
        ))
        return &DeductResponse{
            Success: false,
            Message: fmt.Sprintf("insufficient stock, current: %d", currentStock),
        }, nil

    case -3: // è§¦å‘é™æµ
        span.SetStatus(codes.Error, "rate limit exceeded")
        span.AddEvent("user_rate_limited")
        deductCounter.Add(ctx, 1, metric.WithAttributes(
            attribute.String("result", "rate_limited"),
        ))
        return &DeductResponse{
            Success: false,
            Message: "rate limit exceeded",
        }, nil

    default:
        return nil, fmt.Errorf("unknown result code: %d", code)
    }
}

// BatchDeduct æ‰¹é‡æ‰£å‡ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
func (s *Service) BatchDeduct(ctx context.Context, requests []*DeductRequest) ([]*DeductResponse, error) {
    ctx, span := tracer.Start(ctx, "inventory.batch_deduct",
        trace.WithAttributes(
            attribute.Int("batch.size", len(requests)),
        ),
    )
    defer span.End()

    // ä½¿ç”¨ Pipeline æ‰¹é‡æ‰§è¡Œ
    pipe := s.redis.Pipeline()
    
    for _, req := range requests {
        stockKey := fmt.Sprintf("inventory:%s", req.SKU)
        pipe.EvalSha(ctx, s.luaScript.Hash(), []string{stockKey},
            req.Amount, req.UserID, req.OrderID)
    }

    results, err := pipe.Exec(ctx)
    if err != nil {
        span.RecordError(err)
        return nil, err
    }

    responses := make([]*DeductResponse, len(results))
    for i, result := range results {
        // è§£ææ¯ä¸ªç»“æœ
        // ... (çœç•¥è§£æé€»è¾‘)
    }

    span.SetStatus(codes.Ok, "batch deduct completed")
    return responses, nil
}
```

### 5. æœ¬åœ°ç¼“å­˜ï¼ˆçƒ­ç‚¹æ•°æ®ä¼˜åŒ–ï¼‰

```go:internal/inventory/cache.go
package inventory

import (
    "sync"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

var (
    cacheMeter = otel.Meter("inventory-cache")
)

var (
    cacheHitCounter  metric.Int64Counter
    cacheMissCounter metric.Int64Counter
)

func init() {
    var err error

    cacheHitCounter, err = cacheMeter.Int64Counter(
        "inventory.cache.hit",
        metric.WithDescription("Cache hit count"),
    )
    if err != nil {
        panic(err)
    }

    cacheMissCounter, err = cacheMeter.Int64Counter(
        "inventory.cache.miss",
        metric.WithDescription("Cache miss count"),
    )
    if err != nil {
        panic(err)
    }
}

type cacheItem struct {
    value      int64
    expiration time.Time
}

// LocalCache æœ¬åœ°ç¼“å­˜ï¼ˆç”¨äºçƒ­ç‚¹å•†å“ï¼‰
type LocalCache struct {
    items    map[string]*cacheItem
    mu       sync.RWMutex
    capacity int
    ttl      time.Duration
}

func NewLocalCache(capacity int, ttl time.Duration) *LocalCache {
    cache := &LocalCache{
        items:    make(map[string]*cacheItem, capacity),
        capacity: capacity,
        ttl:      ttl,
    }

    // å®šæœŸæ¸…ç†è¿‡æœŸæ•°æ®
    go cache.cleanupExpired()

    return cache
}

// Get è·å–ç¼“å­˜
func (c *LocalCache) Get(key string) (int64, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()

    item, exists := c.items[key]
    if !exists || time.Now().After(item.expiration) {
        cacheMissCounter.Add(context.Background(), 1)
        return 0, false
    }

    cacheHitCounter.Add(context.Background(), 1,
        metric.WithAttributes(attribute.String("key", key)),
    )
    return item.value, true
}

// Set è®¾ç½®ç¼“å­˜
func (c *LocalCache) Set(key string, value int64) {
    c.mu.Lock()
    defer c.mu.Unlock()

    // å¦‚æœå®¹é‡å·²æ»¡ï¼Œåˆ é™¤ä¸€ä¸ªéšæœºé¡¹
    if len(c.items) >= c.capacity {
        for k := range c.items {
            delete(c.items, k)
            break
        }
    }

    c.items[key] = &cacheItem{
        value:      value,
        expiration: time.Now().Add(c.ttl),
    }
}

// cleanupExpired æ¸…ç†è¿‡æœŸæ•°æ®
func (c *LocalCache) cleanupExpired() {
    ticker := time.NewTicker(c.ttl)
    defer ticker.Stop()

    for range ticker.C {
        c.mu.Lock()
        now := time.Now()
        for key, item := range c.items {
            if now.After(item.expiration) {
                delete(c.items, key)
            }
        }
        c.mu.Unlock()
    }
}
```

### 6. HTTP Handler

```go:internal/inventory/handler.go
package inventory

import (
    "net/http"

    "github.com/gin-gonic/gin"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

type Handler struct {
    service *Service
}

func NewHandler(service *Service) *Handler {
    return &Handler{service: service}
}

// DeductInventory æ‰£å‡åº“å­˜ HTTP ç«¯ç‚¹
func (h *Handler) DeductInventory(c *gin.Context) {
    ctx := c.Request.Context()
    span := trace.SpanFromContext(ctx)

    var req DeductRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        span.RecordError(err)
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request"})
        return
    }

    // æ·»åŠ è¯·æ±‚ä¿¡æ¯åˆ° Span
    span.SetAttributes(
        attribute.String("http.request.sku", req.SKU),
        attribute.String("http.request.user_id", req.UserID),
    )

    resp, err := h.service.Deduct(ctx, &req)
    if err != nil {
        span.RecordError(err)
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    if !resp.Success {
        c.JSON(http.StatusOK, gin.H{
            "success": false,
            "message": resp.Message,
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "success":   true,
        "new_stock": resp.NewStock,
        "message":   resp.Message,
    })
}
```

---

## æ€§èƒ½ä¼˜åŒ–

### 1. è¿æ¥æ± ä¼˜åŒ–

```go
// Redis è¿æ¥æ± é…ç½®
redisClient := redis.NewClient(&redis.Options{
    Addr:         "localhost:6379",
    PoolSize:     1000,              // è¿æ¥æ± å¤§å°
    MinIdleConns: 100,                // æœ€å°ç©ºé—²è¿æ¥
    MaxRetries:   3,                  // é‡è¯•æ¬¡æ•°
    DialTimeout:  1 * time.Second,
    ReadTimeout:  1 * time.Second,
    WriteTimeout: 1 * time.Second,
    PoolTimeout:  2 * time.Second,
})
```

### 2. æ‰¹å¤„ç†ä¼˜åŒ–

```go
// ä½¿ç”¨ Redis Pipeline æ‰¹é‡æ“ä½œ
pipe := redis.Pipeline()
for _, req := range requests {
    pipe.EvalSha(ctx, luaScript.Hash(), []string{key}, args...)
}
results, err := pipe.Exec(ctx)
```

### 3. æœ¬åœ°ç¼“å­˜çƒ­ç‚¹æ•°æ®

```go
// ç¼“å­˜çƒ­ç‚¹å•†å“çš„åº“å­˜ä¿¡æ¯
// å‡å°‘ Redis è®¿é—®ï¼Œé™ä½å»¶è¿Ÿ
cache := NewLocalCache(1000, 1*time.Second)
```

### 4. é›¶æ‹·è´ä¼˜åŒ–

```go
// ä½¿ç”¨ sync.Pool å¤ç”¨å¯¹è±¡
var requestPool = sync.Pool{
    New: func() interface{} {
        return &DeductRequest{}
    },
}

func getRequest() *DeductRequest {
    return requestPool.Get().(*DeductRequest)
}

func putRequest(req *DeductRequest) {
    // æ¸…ç©ºå­—æ®µ
    *req = DeductRequest{}
    requestPool.Put(req)
}
```

### 5. é‡‡æ ·ä¼˜åŒ–

```go
// é«˜å¹¶å‘åœºæ™¯ä½¿ç”¨ä½é‡‡æ ·ç‡
sdktrace.WithSampler(sdktrace.ParentBased(
    sdktrace.TraceIDRatioBased(0.01), // 1% é‡‡æ ·ç‡
))

// ä½†ä¿ç•™é‡è¦ Spanï¼ˆå¦‚é”™è¯¯ï¼‰
if err != nil {
    // å¼ºåˆ¶é‡‡æ ·
    trace.SpanFromContext(ctx).SetAttributes(
        attribute.Bool("force_sample", true),
    )
}
```

---

## ç›‘æ§å‘Šè­¦

### å…³é”®æŒ‡æ ‡

```promql
# QPS
rate(inventory_qps[1m])

# P99 å»¶è¿Ÿ
histogram_quantile(0.99, rate(inventory_deduct_duration_bucket[1m]))

# æˆåŠŸç‡
rate(inventory_deduct_total{result="success"}[1m]) /
rate(inventory_deduct_total[1m])

# åº“å­˜å‘Šè­¦ï¼ˆåº“å­˜è¿‡ä½ï¼‰
inventory_stock_current{sku="HOT_ITEM"} < 100

# ç¼“å­˜å‘½ä¸­ç‡
rate(inventory_cache_hit[1m]) /
(rate(inventory_cache_hit[1m]) + rate(inventory_cache_miss[1m]))
```

### Grafana Dashboard

```yaml
panels:
  - title: "Real-time QPS"
    query: rate(inventory_qps[10s])
    
  - title: "Latency Percentiles"
    queries:
      - histogram_quantile(0.50, rate(inventory_deduct_duration_bucket[1m]))
      - histogram_quantile(0.95, rate(inventory_deduct_duration_bucket[1m]))
      - histogram_quantile(0.99, rate(inventory_deduct_duration_bucket[1m]))
      
  - title: "Success Rate"
    query: |
      rate(inventory_deduct_total{result="success"}[1m]) /
      rate(inventory_deduct_total[1m]) * 100
      
  - title: "Stock Levels (Top 10 Hot Items)"
    query: topk(10, inventory_stock_current)
```

---

## å‹æµ‹ç»“æœ

### æµ‹è¯•ç¯å¢ƒ

```text
ç¡¬ä»¶:
  CPU: 16 Core
  å†…å­˜: 32GB
  Redis: 6.2 (å•å®ä¾‹)
  
é…ç½®:
  è¿æ¥æ± : 1000
  é‡‡æ ·ç‡: 1%
  æœ¬åœ°ç¼“å­˜: 1000 items, 1s TTL
```

### å‹æµ‹å‘½ä»¤

```bash
# ä½¿ç”¨ wrk å‹æµ‹
wrk -t16 -c1000 -d60s \
  -H "Content-Type: application/json" \
  -s inventory-test.lua \
  http://localhost:8080/api/v1/inventory/deduct
```

### å‹æµ‹ç»“æœ1

```text
Requests/sec:   105,234.56
Transfer/sec:   21.47MB

Latency Distribution:
  50%: 8.21ms
  75%: 12.34ms
  90%: 18.67ms
  95%: 24.89ms
  99%: 42.31ms

Success Rate: 99.87%
Error Rate: 0.13% (mostly rate limit)

Redis CPU: 45%
App CPU: 78%
Memory: 2.1GB
```

### æ€§èƒ½å¯¹æ¯”

| ä¼˜åŒ–é¡¹ | æœªä¼˜åŒ– | ä¼˜åŒ–å | æå‡ |
|--------|--------|--------|------|
| QPS | 18,000 | 105,000 | 5.8x |
| P99 å»¶è¿Ÿ | 180ms | 42ms | 4.3x |
| Redis CPU | 92% | 45% | 2x |
| æˆåŠŸç‡ | 96% | 99.87% | +3.87% |

---

## æœ€ä½³å®è·µæ€»ç»“

### 1. Redis åŸå­æ“ä½œ

âœ… **ä½¿ç”¨ Lua è„šæœ¬**:

- ä¿è¯åŸå­æ€§ï¼ˆé¿å…è¶…å–ï¼‰
- å‡å°‘ç½‘ç»œå¾€è¿”
- åŒ…å«é˜²åˆ·é€»è¾‘

### 2. æœ¬åœ°ç¼“å­˜

âœ… **ç¼“å­˜çƒ­ç‚¹æ•°æ®**:

- é™ä½ Redis å‹åŠ›
- å‡å°‘ç½‘ç»œå»¶è¿Ÿ
- çŸ­ TTLï¼ˆé¿å…è„æ•°æ®ï¼‰

### 3. å¼‚æ­¥åŒæ­¥æ•°æ®åº“

âœ… **Kafka + Worker**:

- é™ä½æ•°æ®åº“å‹åŠ›
- æ‰¹é‡å†™å…¥æå‡æ€§èƒ½
- æœ€ç»ˆä¸€è‡´æ€§

### 4. é‡‡æ ·ç­–ç•¥

âœ… **ä½é‡‡æ ·ç‡**:

- 1% é‡‡æ ·ï¼ˆ10ä¸‡TPSä¸‹ä»æœ‰1000ä¸ªtraceï¼‰
- ä¿ç•™é”™è¯¯ Span
- å®šæœŸå…¨é‡é‡‡æ ·ï¼ˆç”¨äºæ€§èƒ½åˆ†æï¼‰

### 5. æ€§èƒ½ç›‘æ§

âœ… **å…³é”®æŒ‡æ ‡**:

- QPS / TPS
- P50/P95/P99 å»¶è¿Ÿ
- æˆåŠŸç‡ / é”™è¯¯ç‡
- åº“å­˜æ°´ä½
- ç¼“å­˜å‘½ä¸­ç‡

---

## ğŸ¯ å­¦åˆ°çš„å…³é”®çŸ¥è¯†ç‚¹

1. âœ… **åŸå­æ“ä½œ**: Redis Lua è„šæœ¬ä¿è¯æ‰£å‡åŸå­æ€§
2. âœ… **æœ¬åœ°ç¼“å­˜**: çƒ­ç‚¹æ•°æ®ç¼“å­˜ï¼Œé™ä½å»¶è¿Ÿ
3. âœ… **æ€§èƒ½ä¼˜åŒ–**: è¿æ¥æ± ã€æ‰¹å¤„ç†ã€é›¶æ‹·è´
4. âœ… **é‡‡æ ·ç­–ç•¥**: é«˜å¹¶å‘åœºæ™¯çš„ä½é‡‡æ ·ç‡
5. âœ… **å¼‚æ­¥åŒæ­¥**: å‰Šå³°å¡«è°·ï¼Œé™ä½æ•°æ®åº“å‹åŠ›
6. âœ… **ç›‘æ§å‘Šè­¦**: QPSã€å»¶è¿Ÿã€åº“å­˜æ°´ä½å®æ—¶ç›‘æ§
7. âœ… **é˜²åˆ·æœºåˆ¶**: Lua è„šæœ¬å®ç°ç”¨æˆ·çº§é™æµ

---

**ğŸŠ æ­å–œï¼** æ‚¨å·²ç»æŒæ¡äº†é«˜å¹¶å‘åº“å­˜ç³»ç»Ÿçš„æé™æ€§èƒ½ä¼˜åŒ–ï¼

**ä¸‹ä¸€æ­¥**:

- ğŸ“š [å¤šäº‘ç¯å¢ƒéƒ¨ç½²](./04_å¤šäº‘ç¯å¢ƒéƒ¨ç½².md)
- ğŸ“š [é…ç½®æ¨¡æ¿åº“](../é…ç½®æ¨¡æ¿/)
