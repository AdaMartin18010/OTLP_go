# 🎯 微服务完整示例 - 电商订单系统

**场景**: 电商订单处理微服务架构  
**技术栈**: Gin, GORM, Redis, Kafka, Go 1.25.1  
**难度**: ⭐⭐⭐⭐  
**学习时间**: 2-3小时

---

## 📋 目录

- [🎯 微服务完整示例 - 电商订单系统](#-微服务完整示例---电商订单系统)
  - [📋 目录](#-目录)
  - [🏗️ 系统架构](#️-系统架构)
  - [📦 服务清单](#-服务清单)
    - [1. API Gateway](#1-api-gateway)
    - [2. Order Service](#2-order-service)
    - [3. Inventory Service](#3-inventory-service)
    - [4. Payment Service](#4-payment-service)
    - [5. Notification Service](#5-notification-service)
  - [💻 完整实现](#-完整实现)
    - [项目结构](#项目结构)
    - [通用 Telemetry 初始化](#通用-telemetry-初始化)
    - [1. API Gateway1](#1-api-gateway1)
    - [2. Order Service1](#2-order-service1)
    - [3. Inventory Service1](#3-inventory-service1)
    - [4. Payment Service (简化版)](#4-payment-service-简化版)
    - [5. Notification Service (Kafka Consumer)](#5-notification-service-kafka-consumer)
  - [🚀 运行指南](#-运行指南)
    - [1. 启动基础设施](#1-启动基础设施)
    - [2. 启动微服务](#2-启动微服务)
    - [3. 发送测试请求](#3-发送测试请求)
  - [📊 监控观测](#-监控观测)
    - [1. Jaeger UI](#1-jaeger-ui)
    - [2. 关键指标](#2-关键指标)
  - [💡 最佳实践](#-最佳实践)
    - [1. Context 传播](#1-context-传播)
    - [2. 错误处理](#2-错误处理)
    - [3. 属性添加](#3-属性添加)
    - [4. 采样策略](#4-采样策略)
  - [📚 相关文档](#-相关文档)

---

## 🏗️ 系统架构

```text
┌──────────┐
│  Client  │
└─────┬────┘
      │ HTTP
┌─────▼──────────┐
│  API Gateway   │ (Span: gateway.request)
└─────┬──────────┘
      │
      ├──────────────────┬──────────────────┐
      │                  │                  │
┌─────▼─────┐   ┌───────▼────────┐   ┌────▼──────┐
│Order Svc  │   │ Inventory Svc  │   │ Payment   │
│(Span: 2)  │   │  (Span: 3)     │   │(Span: 4)  │
└─────┬─────┘   └────────┬───────┘   └───────┬───┘
      │                  │                   │
      ├──────────────────┴───────────────────┘
      │
┌─────▼──────┐
│   Kafka    │ (Producer)
└─────┬──────┘
      │
┌─────▼──────────┐
│Notification Svc│ (Consumer, Span: 5)
└────────────────┘
```

---

## 📦 服务清单

### 1. API Gateway

- **职责**: 路由、认证、限流
- **端口**: 8080
- **技术**: Gin + otelgin

### 2. Order Service

- **职责**: 订单管理、库存检查、支付调用
- **端口**: 8081
- **技术**: Gin + GORM + otelgorm

### 3. Inventory Service

- **职责**: 库存查询、库存扣减
- **端口**: 8082
- **数据库**: PostgreSQL

### 4. Payment Service

- **职责**: 支付处理、支付验证
- **端口**: 8083
- **缓存**: Redis

### 5. Notification Service

- **职责**: 订单通知、消息发送
- **消息队列**: Kafka

---

## 💻 完整实现

### 项目结构

```text
ecommerce-microservices/
├── cmd/
│   ├── gateway/
│   │   └── main.go
│   ├── order/
│   │   └── main.go
│   ├── inventory/
│   │   └── main.go
│   ├── payment/
│   │   └── main.go
│   └── notification/
│       └── main.go
├── pkg/
│   ├── telemetry/
│   │   ├── tracer.go
│   │   ├── meter.go
│   │   └── logger.go
│   ├── middleware/
│   │   └── gin.go
│   └── models/
│       └── order.go
├── docker-compose.yml
└── go.mod
```

---

### 通用 Telemetry 初始化

**`pkg/telemetry/tracer.go`**

```go
package telemetry

import (
    "context"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.21.0"
)

// InitTracer 初始化 Tracer
func InitTracer(serviceName, serviceVersion, collectorEndpoint string) (*sdktrace.TracerProvider, error) {
    // 创建 Resource
    res, err := resource.New(
        context.Background(),
        resource.WithFromEnv(),
        resource.WithHost(),
        resource.WithProcess(),
        resource.WithAttributes(
            semconv.ServiceName(serviceName),
            semconv.ServiceVersion(serviceVersion),
            semconv.DeploymentEnvironment("production"),
        ),
    )
    if err != nil {
        return nil, err
    }

    // 创建 Exporter
    exporter, err := otlptracegrpc.New(
        context.Background(),
        otlptracegrpc.WithEndpoint(collectorEndpoint),
        otlptracegrpc.WithInsecure(),
        otlptracegrpc.WithCompressor("gzip"),
    )
    if err != nil {
        return nil, err
    }

    // 创建 TracerProvider
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithResource(res),
        sdktrace.WithSampler(sdktrace.ParentBased(
            sdktrace.TraceIDRatioBased(0.1), // 10% 采样
        )),
        sdktrace.WithBatcher(exporter,
            sdktrace.WithBatchTimeout(5*time.Second),
            sdktrace.WithMaxExportBatchSize(512),
            sdktrace.WithMaxQueueSize(2048),
        ),
    )

    // 设置全局 TracerProvider
    otel.SetTracerProvider(tp)

    // 设置 Propagator
    otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
        propagation.TraceContext{},
        propagation.Baggage{},
    ))

    return tp, nil
}
```

---

### 1. API Gateway1

**`cmd/gateway/main.go`**

```go
package main

import (
    "context"
    "log"
    "net/http"
    "time"

    "github.com/gin-gonic/gin"
    "go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"

    "ecommerce/pkg/telemetry"
)

func main() {
    // 初始化 Tracer
    tp, err := telemetry.InitTracer("gateway", "1.0.0", "localhost:4317")
    if err != nil {
        log.Fatal(err)
    }
    defer tp.Shutdown(context.Background())

    // 创建 Gin 路由
    router := gin.Default()

    // 添加 OpenTelemetry 中间件
    router.Use(otelgin.Middleware("gateway"))

    // 路由
    router.POST("/api/orders", handleCreateOrder)

    // 启动服务
    log.Println("Gateway started on :8080")
    router.Run(":8080")
}

func handleCreateOrder(c *gin.Context) {
    ctx := c.Request.Context()
    tracer := otel.Tracer("gateway")

    // 创建 Span
    ctx, span := tracer.Start(ctx, "gateway.createOrder")
    defer span.End()

    // 解析请求
    var req struct {
        UserID    string  `json:"user_id"`
        ProductID string  `json:"product_id"`
        Quantity  int     `json:"quantity"`
        Amount    float64 `json:"amount"`
    }
    if err := c.ShouldBindJSON(&req); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "invalid request")
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    // 添加属性
    span.SetAttributes(
        attribute.String("user.id", req.UserID),
        attribute.String("product.id", req.ProductID),
        attribute.Int("quantity", req.Quantity),
        attribute.Float64("amount", req.Amount),
    )

    // 调用 Order Service
    orderID, err := callOrderService(ctx, req)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "order service failed")
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    span.SetStatus(codes.Ok, "success")
    c.JSON(http.StatusOK, gin.H{
        "order_id": orderID,
        "status":   "created",
    })
}

func callOrderService(ctx context.Context, req interface{}) (string, error) {
    tracer := otel.Tracer("gateway")
    ctx, span := tracer.Start(ctx, "gateway.callOrderService")
    defer span.End()

    // 创建 HTTP 请求
    // (实际项目中使用 otelhttp.NewTransport)
    client := &http.Client{Timeout: 5 * time.Second}

    // ... HTTP 调用逻辑 ...
    
    return "ORDER-12345", nil
}
```

---

### 2. Order Service1

**`cmd/order/main.go`**

```go
package main

import (
    "context"
    "log"
    "net/http"

    "github.com/gin-gonic/gin"
    "go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
    "go.opentelemetry.io/contrib/instrumentation/gorm.io/driver/postgres"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "gorm.io/gorm"

    "ecommerce/pkg/telemetry"
)

type Order struct {
    ID        string  `gorm:"primaryKey"`
    UserID    string
    ProductID string
    Quantity  int
    Amount    float64
    Status    string
}

var db *gorm.DB

func main() {
    // 初始化 Tracer
    tp, err := telemetry.InitTracer("order-service", "1.0.0", "localhost:4317")
    if err != nil {
        log.Fatal(err)
    }
    defer tp.Shutdown(context.Background())

    // 初始化数据库 (带追踪)
    db, err = gorm.Open(postgres.Open("host=localhost user=postgres dbname=orders"), &gorm.Config{})
    if err != nil {
        log.Fatal(err)
    }

    // 创建 Gin 路由
    router := gin.Default()
    router.Use(otelgin.Middleware("order-service"))

    // 路由
    router.POST("/orders", handleCreateOrder)
    router.GET("/orders/:id", handleGetOrder)

    // 启动服务
    log.Println("Order Service started on :8081")
    router.Run(":8081")
}

func handleCreateOrder(c *gin.Context) {
    ctx := c.Request.Context()
    tracer := otel.Tracer("order-service")

    ctx, span := tracer.Start(ctx, "order.create")
    defer span.End()

    var req Order
    if err := c.ShouldBindJSON(&req); err != nil {
        span.RecordError(err)
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    // 检查库存
    available, err := checkInventory(ctx, req.ProductID, req.Quantity)
    if err != nil || !available {
        span.RecordError(err)
        span.SetStatus(codes.Error, "inventory check failed")
        c.JSON(http.StatusBadRequest, gin.H{"error": "insufficient inventory"})
        return
    }

    // 处理支付
    paymentSuccess, err := processPayment(ctx, req.UserID, req.Amount)
    if err != nil || !paymentSuccess {
        span.RecordError(err)
        span.SetStatus(codes.Error, "payment failed")
        c.JSON(http.StatusPaymentRequired, gin.H{"error": "payment failed"})
        return
    }

    // 创建订单
    req.ID = generateOrderID()
    req.Status = "created"

    if err := db.WithContext(ctx).Create(&req).Error; err != nil {
        span.RecordError(err)
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    // 发送 Kafka 消息
    if err := sendOrderNotification(ctx, req); err != nil {
        log.Printf("Failed to send notification: %v", err)
        // 不影响订单创建
    }

    span.SetAttributes(
        attribute.String("order.id", req.ID),
        attribute.String("order.status", req.Status),
    )
    span.SetStatus(codes.Ok, "success")

    c.JSON(http.StatusOK, req)
}

func checkInventory(ctx context.Context, productID string, quantity int) (bool, error) {
    tracer := otel.Tracer("order-service")
    ctx, span := tracer.Start(ctx, "order.checkInventory")
    defer span.End()

    span.SetAttributes(
        attribute.String("product.id", productID),
        attribute.Int("quantity", quantity),
    )

    // 调用 Inventory Service
    // (使用 otelhttp.NewTransport)
    
    return true, nil
}

func processPayment(ctx context.Context, userID string, amount float64) (bool, error) {
    tracer := otel.Tracer("order-service")
    ctx, span := tracer.Start(ctx, "order.processPayment")
    defer span.End()

    span.SetAttributes(
        attribute.String("user.id", userID),
        attribute.Float64("amount", amount),
    )

    // 调用 Payment Service
    
    return true, nil
}

func sendOrderNotification(ctx context.Context, order Order) error {
    tracer := otel.Tracer("order-service")
    ctx, span := tracer.Start(ctx, "order.sendNotification")
    defer span.End()

    // 发送到 Kafka
    // (使用 Kafka Producer 带追踪)
    
    return nil
}

func generateOrderID() string {
    return "ORDER-" + time.Now().Format("20060102150405")
}
```

---

### 3. Inventory Service1

**`cmd/inventory/main.go`**

```go
package main

import (
    "context"
    "log"
    "net/http"

    "github.com/gin-gonic/gin"
    "go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "gorm.io/gorm"

    "ecommerce/pkg/telemetry"
)

type Inventory struct {
    ProductID string `gorm:"primaryKey"`
    Stock     int
}

var db *gorm.DB

func main() {
    // 初始化 Tracer
    tp, err := telemetry.InitTracer("inventory-service", "1.0.0", "localhost:4317")
    if err != nil {
        log.Fatal(err)
    }
    defer tp.Shutdown(context.Background())

    // 初始化数据库
    db, err = gorm.Open(postgres.Open("host=localhost user=postgres dbname=inventory"), &gorm.Config{})
    if err != nil {
        log.Fatal(err)
    }

    // 创建 Gin 路由
    router := gin.Default()
    router.Use(otelgin.Middleware("inventory-service"))

    // 路由
    router.GET("/inventory/:product_id", handleGetInventory)
    router.POST("/inventory/deduct", handleDeductInventory)

    // 启动服务
    log.Println("Inventory Service started on :8082")
    router.Run(":8082")
}

func handleGetInventory(c *gin.Context) {
    ctx := c.Request.Context()
    tracer := otel.Tracer("inventory-service")

    ctx, span := tracer.Start(ctx, "inventory.get")
    defer span.End()

    productID := c.Param("product_id")
    span.SetAttributes(attribute.String("product.id", productID))

    var inventory Inventory
    if err := db.WithContext(ctx).Where("product_id = ?", productID).First(&inventory).Error; err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "product not found")
        c.JSON(http.StatusNotFound, gin.H{"error": "product not found"})
        return
    }

    span.SetAttributes(attribute.Int("stock", inventory.Stock))
    span.SetStatus(codes.Ok, "success")

    c.JSON(http.StatusOK, inventory)
}

func handleDeductInventory(c *gin.Context) {
    ctx := c.Request.Context()
    tracer := otel.Tracer("inventory-service")

    ctx, span := tracer.Start(ctx, "inventory.deduct")
    defer span.End()

    var req struct {
        ProductID string `json:"product_id"`
        Quantity  int    `json:"quantity"`
    }
    if err := c.ShouldBindJSON(&req); err != nil {
        span.RecordError(err)
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    span.SetAttributes(
        attribute.String("product.id", req.ProductID),
        attribute.Int("quantity", req.Quantity),
    )

    // 使用事务扣减库存
    err := db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        var inventory Inventory
        if err := tx.Where("product_id = ?", req.ProductID).First(&inventory).Error; err != nil {
            return err
        }

        if inventory.Stock < req.Quantity {
            return gorm.ErrRecordNotFound
        }

        inventory.Stock -= req.Quantity
        return tx.Save(&inventory).Error
    })

    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "insufficient stock")
        c.JSON(http.StatusBadRequest, gin.H{"error": "insufficient stock"})
        return
    }

    span.SetStatus(codes.Ok, "success")
    c.JSON(http.StatusOK, gin.H{"status": "success"})
}
```

---

### 4. Payment Service (简化版)

**`cmd/payment/main.go`**

```go
package main

import (
    "context"
    "log"
    "net/http"
    "time"

    "github.com/gin-gonic/gin"
    "go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"

    "ecommerce/pkg/telemetry"
)

func main() {
    // 初始化 Tracer
    tp, err := telemetry.InitTracer("payment-service", "1.0.0", "localhost:4317")
    if err != nil {
        log.Fatal(err)
    }
    defer tp.Shutdown(context.Background())

    // 创建 Gin 路由
    router := gin.Default()
    router.Use(otelgin.Middleware("payment-service"))

    // 路由
    router.POST("/payment/process", handleProcessPayment)

    // 启动服务
    log.Println("Payment Service started on :8083")
    router.Run(":8083")
}

func handleProcessPayment(c *gin.Context) {
    ctx := c.Request.Context()
    tracer := otel.Tracer("payment-service")

    ctx, span := tracer.Start(ctx, "payment.process")
    defer span.End()

    var req struct {
        UserID string  `json:"user_id"`
        Amount float64 `json:"amount"`
    }
    if err := c.ShouldBindJSON(&req); err != nil {
        span.RecordError(err)
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    span.SetAttributes(
        attribute.String("user.id", req.UserID),
        attribute.Float64("amount", req.Amount),
    )

    // 模拟支付处理
    time.Sleep(100 * time.Millisecond)

    // 假设支付成功
    transactionID := "TXN-" + time.Now().Format("20060102150405")
    span.SetAttributes(attribute.String("transaction.id", transactionID))
    span.SetStatus(codes.Ok, "payment successful")

    c.JSON(http.StatusOK, gin.H{
        "transaction_id": transactionID,
        "status":         "success",
    })
}
```

---

### 5. Notification Service (Kafka Consumer)

**`cmd/notification/main.go`**

```go
package main

import (
    "context"
    "log"

    "github.com/segmentio/kafka-go"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/propagation"

    "ecommerce/pkg/telemetry"
)

func main() {
    // 初始化 Tracer
    tp, err := telemetry.InitTracer("notification-service", "1.0.0", "localhost:4317")
    if err != nil {
        log.Fatal(err)
    }
    defer tp.Shutdown(context.Background())

    // 创建 Kafka Reader
    reader := kafka.NewReader(kafka.ReaderConfig{
        Brokers: []string{"localhost:9092"},
        Topic:   "order-notifications",
        GroupID: "notification-service",
    })
    defer reader.Close()

    log.Println("Notification Service started, waiting for messages...")

    // 消费消息
    for {
        msg, err := reader.ReadMessage(context.Background())
        if err != nil {
            log.Printf("Error reading message: %v", err)
            continue
        }

        // 提取 Trace Context
        ctx := otel.GetTextMapPropagator().Extract(
            context.Background(),
            propagation.MapCarrier(extractHeaders(msg.Headers)),
        )

        // 处理消息
        handleMessage(ctx, msg)
    }
}

func handleMessage(ctx context.Context, msg kafka.Message) {
    tracer := otel.Tracer("notification-service")
    ctx, span := tracer.Start(ctx, "notification.process")
    defer span.End()

    span.SetAttributes(
        attribute.String("kafka.topic", msg.Topic),
        attribute.Int("kafka.partition", msg.Partition),
        attribute.Int64("kafka.offset", msg.Offset),
    )

    log.Printf("Processing order notification: %s", string(msg.Value))

    // 发送通知 (邮件/SMS)
    if err := sendNotification(ctx, string(msg.Value)); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "notification failed")
        return
    }

    span.SetStatus(codes.Ok, "notification sent")
}

func sendNotification(ctx context.Context, message string) error {
    tracer := otel.Tracer("notification-service")
    ctx, span := tracer.Start(ctx, "notification.send")
    defer span.End()

    // 模拟发送通知
    log.Printf("Sending notification: %s", message)

    return nil
}

func extractHeaders(headers []kafka.Header) map[string]string {
    result := make(map[string]string)
    for _, h := range headers {
        result[h.Key] = string(h.Value)
    }
    return result
}
```

---

## 🚀 运行指南

### 1. 启动基础设施

**`docker-compose.yml`**

```yaml
version: '3.8'

services:
  # OpenTelemetry Collector
  otel-collector:
    image: otel/opentelemetry-collector-contrib:latest
    ports:
      - "4317:4317"   # OTLP gRPC
      - "4318:4318"   # OTLP HTTP
    volumes:
      - ./otel-collector-config.yaml:/etc/otel-collector-config.yaml
    command: ["--config=/etc/otel-collector-config.yaml"]

  # Jaeger
  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686"  # UI
      - "14250:14250"  # gRPC

  # Kafka
  kafka:
    image: confluentinc/cp-kafka:latest
    ports:
      - "9092:9092"
    environment:
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092

  # PostgreSQL
  postgres:
    image: postgres:15
    ports:
      - "5432:5432"
    environment:
      POSTGRES_PASSWORD: postgres

  # Redis
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
```

启动：

```bash
docker-compose up -d
```

### 2. 启动微服务

```bash
# 启动 Gateway
go run cmd/gateway/main.go

# 启动 Order Service
go run cmd/order/main.go

# 启动 Inventory Service
go run cmd/inventory/main.go

# 启动 Payment Service
go run cmd/payment/main.go

# 启动 Notification Service
go run cmd/notification/main.go
```

### 3. 发送测试请求

```bash
curl -X POST http://localhost:8080/api/orders \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": "USER-001",
    "product_id": "PROD-123",
    "quantity": 2,
    "amount": 199.99
  }'
```

---

## 📊 监控观测

### 1. Jaeger UI

打开 <http://localhost:16686>

**追踪视图**:

```text
gateway.createOrder (200ms)
  ├─ gateway.callOrderService (180ms)
  │   ├─ order.create (150ms)
  │   │   ├─ order.checkInventory (30ms)
  │   │   │   └─ inventory.get (20ms)
  │   │   ├─ order.processPayment (40ms)
  │   │   │   └─ payment.process (30ms)
  │   │   ├─ order.saveDatabase (50ms)
  │   │   └─ order.sendNotification (10ms)
  │   └─ notification.process (20ms)
```

### 2. 关键指标

**HTTP 请求指标**:

- `http.server.duration` - 请求延迟
- `http.server.request.count` - 请求数
- `http.server.response.size` - 响应大小

**数据库指标**:

- `db.client.connections.usage` - 连接池使用率
- `db.client.operation.duration` - 查询延迟

**Kafka 指标**:

- `messaging.publish.duration` - 消息发送延迟
- `messaging.process.duration` - 消息处理延迟

---

## 💡 最佳实践

### 1. Context 传播

```go
// ✅ 正确: 始终传播 Context
func handleRequest(ctx context.Context) {
    ctx, span := tracer.Start(ctx, "operation")
    defer span.End()
    
    // 传播到下游
    callService(ctx)
}

// ❌ 错误: 丢失 Context
func handleRequest(ctx context.Context) {
    callService(context.Background())
}
```

### 2. 错误处理

```go
// ✅ 正确: 记录错误详情
if err != nil {
    span.RecordError(err)
    span.SetStatus(codes.Error, err.Error())
    span.SetAttributes(
        attribute.String("error.type", fmt.Sprintf("%T", err)),
    )
}
```

### 3. 属性添加

```go
// ✅ 正确: 使用语义约定
span.SetAttributes(
    semconv.HTTPMethod("POST"),
    semconv.HTTPStatusCode(200),
    semconv.HTTPRoute("/api/orders"),
)

// ❌ 错误: 自定义属性名
span.SetAttributes(
    attribute.String("method", "POST"),
)
```

### 4. 采样策略

```go
// 生产环境: 10% 采样
sdktrace.ParentBased(sdktrace.TraceIDRatioBased(0.1))

// 关键路径: 100% 采样
sdktrace.AlwaysSample()
```

---

## 📚 相关文档

- [Gin 中间件集成](../../02_Semantic_Conventions/02_Trace属性/02_HTTP服务器.md)
- [GORM 追踪](../../02_Semantic_Conventions/02_Trace属性/04_数据库.md)
- [Kafka 追踪](../../02_Semantic_Conventions/02_Trace属性/05_消息队列.md)
- [Context 管理](../../04_SDK与实现/04_通用组件/01_Context管理.md)

---

**🎉 完成！你已经掌握了微服务 OpenTelemetry 完整集成！**

**下一步**: [电商系统完整案例](./02_电商系统完整案例.md)
