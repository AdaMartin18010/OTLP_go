# ğŸ¯ å¾®æœåŠ¡å®Œæ•´ç¤ºä¾‹ - ç”µå•†è®¢å•ç³»ç»Ÿ

**åœºæ™¯**: ç”µå•†è®¢å•å¤„ç†å¾®æœåŠ¡æ¶æ„  
**æŠ€æœ¯æ ˆ**: Gin, GORM, Redis, Kafka, Go 1.25.1  
**éš¾åº¦**: â­â­â­â­  
**å­¦ä¹ æ—¶é—´**: 2-3å°æ—¶

---

## ğŸ“‹ ç›®å½•

- [ğŸ¯ å¾®æœåŠ¡å®Œæ•´ç¤ºä¾‹ - ç”µå•†è®¢å•ç³»ç»Ÿ](#-å¾®æœåŠ¡å®Œæ•´ç¤ºä¾‹---ç”µå•†è®¢å•ç³»ç»Ÿ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ—ï¸ ç³»ç»Ÿæ¶æ„](#ï¸-ç³»ç»Ÿæ¶æ„)
  - [ğŸ“¦ æœåŠ¡æ¸…å•](#-æœåŠ¡æ¸…å•)
    - [1. API Gateway](#1-api-gateway)
    - [2. Order Service](#2-order-service)
    - [3. Inventory Service](#3-inventory-service)
    - [4. Payment Service](#4-payment-service)
    - [5. Notification Service](#5-notification-service)
  - [ğŸ’» å®Œæ•´å®ç°](#-å®Œæ•´å®ç°)
    - [é¡¹ç›®ç»“æ„](#é¡¹ç›®ç»“æ„)
    - [é€šç”¨ Telemetry åˆå§‹åŒ–](#é€šç”¨-telemetry-åˆå§‹åŒ–)
    - [1. API Gateway1](#1-api-gateway1)
    - [2. Order Service1](#2-order-service1)
    - [3. Inventory Service1](#3-inventory-service1)
    - [4. Payment Service (ç®€åŒ–ç‰ˆ)](#4-payment-service-ç®€åŒ–ç‰ˆ)
    - [5. Notification Service (Kafka Consumer)](#5-notification-service-kafka-consumer)
  - [ğŸš€ è¿è¡ŒæŒ‡å—](#-è¿è¡ŒæŒ‡å—)
    - [1. å¯åŠ¨åŸºç¡€è®¾æ–½](#1-å¯åŠ¨åŸºç¡€è®¾æ–½)
    - [2. å¯åŠ¨å¾®æœåŠ¡](#2-å¯åŠ¨å¾®æœåŠ¡)
    - [3. å‘é€æµ‹è¯•è¯·æ±‚](#3-å‘é€æµ‹è¯•è¯·æ±‚)
  - [ğŸ“Š ç›‘æ§è§‚æµ‹](#-ç›‘æ§è§‚æµ‹)
    - [1. Jaeger UI](#1-jaeger-ui)
    - [2. å…³é”®æŒ‡æ ‡](#2-å…³é”®æŒ‡æ ‡)
  - [ğŸ’¡ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [1. Context ä¼ æ’­](#1-context-ä¼ æ’­)
    - [2. é”™è¯¯å¤„ç†](#2-é”™è¯¯å¤„ç†)
    - [3. å±æ€§æ·»åŠ ](#3-å±æ€§æ·»åŠ )
    - [4. é‡‡æ ·ç­–ç•¥](#4-é‡‡æ ·ç­–ç•¥)
  - [ğŸ“š ç›¸å…³æ–‡æ¡£](#-ç›¸å…³æ–‡æ¡£)

---

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Client  â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
      â”‚ HTTP
â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  API Gateway   â”‚ (Span: gateway.request)
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚                  â”‚                  â”‚
â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚Order Svc  â”‚   â”‚ Inventory Svc  â”‚   â”‚ Payment   â”‚
â”‚(Span: 2)  â”‚   â”‚  (Span: 3)     â”‚   â”‚(Span: 4)  â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”˜
      â”‚                  â”‚                   â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚   Kafka    â”‚ (Producer)
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
      â”‚
â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Notification Svcâ”‚ (Consumer, Span: 5)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“¦ æœåŠ¡æ¸…å•

### 1. API Gateway

- **èŒè´£**: è·¯ç”±ã€è®¤è¯ã€é™æµ
- **ç«¯å£**: 8080
- **æŠ€æœ¯**: Gin + otelgin

### 2. Order Service

- **èŒè´£**: è®¢å•ç®¡ç†ã€åº“å­˜æ£€æŸ¥ã€æ”¯ä»˜è°ƒç”¨
- **ç«¯å£**: 8081
- **æŠ€æœ¯**: Gin + GORM + otelgorm

### 3. Inventory Service

- **èŒè´£**: åº“å­˜æŸ¥è¯¢ã€åº“å­˜æ‰£å‡
- **ç«¯å£**: 8082
- **æ•°æ®åº“**: PostgreSQL

### 4. Payment Service

- **èŒè´£**: æ”¯ä»˜å¤„ç†ã€æ”¯ä»˜éªŒè¯
- **ç«¯å£**: 8083
- **ç¼“å­˜**: Redis

### 5. Notification Service

- **èŒè´£**: è®¢å•é€šçŸ¥ã€æ¶ˆæ¯å‘é€
- **æ¶ˆæ¯é˜Ÿåˆ—**: Kafka

---

## ğŸ’» å®Œæ•´å®ç°

### é¡¹ç›®ç»“æ„

```text
ecommerce-microservices/
â”œâ”€â”€ cmd/
â”‚   â”œâ”€â”€ gateway/
â”‚   â”‚   â””â”€â”€ main.go
â”‚   â”œâ”€â”€ order/
â”‚   â”‚   â””â”€â”€ main.go
â”‚   â”œâ”€â”€ inventory/
â”‚   â”‚   â””â”€â”€ main.go
â”‚   â”œâ”€â”€ payment/
â”‚   â”‚   â””â”€â”€ main.go
â”‚   â””â”€â”€ notification/
â”‚       â””â”€â”€ main.go
â”œâ”€â”€ pkg/
â”‚   â”œâ”€â”€ telemetry/
â”‚   â”‚   â”œâ”€â”€ tracer.go
â”‚   â”‚   â”œâ”€â”€ meter.go
â”‚   â”‚   â””â”€â”€ logger.go
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â””â”€â”€ gin.go
â”‚   â””â”€â”€ models/
â”‚       â””â”€â”€ order.go
â”œâ”€â”€ docker-compose.yml
â””â”€â”€ go.mod
```

---

### é€šç”¨ Telemetry åˆå§‹åŒ–

**`pkg/telemetry/tracer.go`**

```go
package telemetry

import (
    "context"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.21.0"
)

// InitTracer åˆå§‹åŒ– Tracer
func InitTracer(serviceName, serviceVersion, collectorEndpoint string) (*sdktrace.TracerProvider, error) {
    // åˆ›å»º Resource
    res, err := resource.New(
        context.Background(),
        resource.WithFromEnv(),
        resource.WithHost(),
        resource.WithProcess(),
        resource.WithAttributes(
            semconv.ServiceName(serviceName),
            semconv.ServiceVersion(serviceVersion),
            semconv.DeploymentEnvironment("production"),
        ),
    )
    if err != nil {
        return nil, err
    }

    // åˆ›å»º Exporter
    exporter, err := otlptracegrpc.New(
        context.Background(),
        otlptracegrpc.WithEndpoint(collectorEndpoint),
        otlptracegrpc.WithInsecure(),
        otlptracegrpc.WithCompressor("gzip"),
    )
    if err != nil {
        return nil, err
    }

    // åˆ›å»º TracerProvider
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithResource(res),
        sdktrace.WithSampler(sdktrace.ParentBased(
            sdktrace.TraceIDRatioBased(0.1), // 10% é‡‡æ ·
        )),
        sdktrace.WithBatcher(exporter,
            sdktrace.WithBatchTimeout(5*time.Second),
            sdktrace.WithMaxExportBatchSize(512),
            sdktrace.WithMaxQueueSize(2048),
        ),
    )

    // è®¾ç½®å…¨å±€ TracerProvider
    otel.SetTracerProvider(tp)

    // è®¾ç½® Propagator
    otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
        propagation.TraceContext{},
        propagation.Baggage{},
    ))

    return tp, nil
}
```

---

### 1. API Gateway1

**`cmd/gateway/main.go`**

```go
package main

import (
    "context"
    "log"
    "net/http"
    "time"

    "github.com/gin-gonic/gin"
    "go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"

    "ecommerce/pkg/telemetry"
)

func main() {
    // åˆå§‹åŒ– Tracer
    tp, err := telemetry.InitTracer("gateway", "1.0.0", "localhost:4317")
    if err != nil {
        log.Fatal(err)
    }
    defer tp.Shutdown(context.Background())

    // åˆ›å»º Gin è·¯ç”±
    router := gin.Default()

    // æ·»åŠ  OpenTelemetry ä¸­é—´ä»¶
    router.Use(otelgin.Middleware("gateway"))

    // è·¯ç”±
    router.POST("/api/orders", handleCreateOrder)

    // å¯åŠ¨æœåŠ¡
    log.Println("Gateway started on :8080")
    router.Run(":8080")
}

func handleCreateOrder(c *gin.Context) {
    ctx := c.Request.Context()
    tracer := otel.Tracer("gateway")

    // åˆ›å»º Span
    ctx, span := tracer.Start(ctx, "gateway.createOrder")
    defer span.End()

    // è§£æè¯·æ±‚
    var req struct {
        UserID    string  `json:"user_id"`
        ProductID string  `json:"product_id"`
        Quantity  int     `json:"quantity"`
        Amount    float64 `json:"amount"`
    }
    if err := c.ShouldBindJSON(&req); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "invalid request")
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    // æ·»åŠ å±æ€§
    span.SetAttributes(
        attribute.String("user.id", req.UserID),
        attribute.String("product.id", req.ProductID),
        attribute.Int("quantity", req.Quantity),
        attribute.Float64("amount", req.Amount),
    )

    // è°ƒç”¨ Order Service
    orderID, err := callOrderService(ctx, req)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "order service failed")
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    span.SetStatus(codes.Ok, "success")
    c.JSON(http.StatusOK, gin.H{
        "order_id": orderID,
        "status":   "created",
    })
}

func callOrderService(ctx context.Context, req interface{}) (string, error) {
    tracer := otel.Tracer("gateway")
    ctx, span := tracer.Start(ctx, "gateway.callOrderService")
    defer span.End()

    // åˆ›å»º HTTP è¯·æ±‚
    // (å®é™…é¡¹ç›®ä¸­ä½¿ç”¨ otelhttp.NewTransport)
    client := &http.Client{Timeout: 5 * time.Second}

    // ... HTTP è°ƒç”¨é€»è¾‘ ...
    
    return "ORDER-12345", nil
}
```

---

### 2. Order Service1

**`cmd/order/main.go`**

```go
package main

import (
    "context"
    "log"
    "net/http"

    "github.com/gin-gonic/gin"
    "go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
    "go.opentelemetry.io/contrib/instrumentation/gorm.io/driver/postgres"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "gorm.io/gorm"

    "ecommerce/pkg/telemetry"
)

type Order struct {
    ID        string  `gorm:"primaryKey"`
    UserID    string
    ProductID string
    Quantity  int
    Amount    float64
    Status    string
}

var db *gorm.DB

func main() {
    // åˆå§‹åŒ– Tracer
    tp, err := telemetry.InitTracer("order-service", "1.0.0", "localhost:4317")
    if err != nil {
        log.Fatal(err)
    }
    defer tp.Shutdown(context.Background())

    // åˆå§‹åŒ–æ•°æ®åº“ (å¸¦è¿½è¸ª)
    db, err = gorm.Open(postgres.Open("host=localhost user=postgres dbname=orders"), &gorm.Config{})
    if err != nil {
        log.Fatal(err)
    }

    // åˆ›å»º Gin è·¯ç”±
    router := gin.Default()
    router.Use(otelgin.Middleware("order-service"))

    // è·¯ç”±
    router.POST("/orders", handleCreateOrder)
    router.GET("/orders/:id", handleGetOrder)

    // å¯åŠ¨æœåŠ¡
    log.Println("Order Service started on :8081")
    router.Run(":8081")
}

func handleCreateOrder(c *gin.Context) {
    ctx := c.Request.Context()
    tracer := otel.Tracer("order-service")

    ctx, span := tracer.Start(ctx, "order.create")
    defer span.End()

    var req Order
    if err := c.ShouldBindJSON(&req); err != nil {
        span.RecordError(err)
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    // æ£€æŸ¥åº“å­˜
    available, err := checkInventory(ctx, req.ProductID, req.Quantity)
    if err != nil || !available {
        span.RecordError(err)
        span.SetStatus(codes.Error, "inventory check failed")
        c.JSON(http.StatusBadRequest, gin.H{"error": "insufficient inventory"})
        return
    }

    // å¤„ç†æ”¯ä»˜
    paymentSuccess, err := processPayment(ctx, req.UserID, req.Amount)
    if err != nil || !paymentSuccess {
        span.RecordError(err)
        span.SetStatus(codes.Error, "payment failed")
        c.JSON(http.StatusPaymentRequired, gin.H{"error": "payment failed"})
        return
    }

    // åˆ›å»ºè®¢å•
    req.ID = generateOrderID()
    req.Status = "created"

    if err := db.WithContext(ctx).Create(&req).Error; err != nil {
        span.RecordError(err)
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    // å‘é€ Kafka æ¶ˆæ¯
    if err := sendOrderNotification(ctx, req); err != nil {
        log.Printf("Failed to send notification: %v", err)
        // ä¸å½±å“è®¢å•åˆ›å»º
    }

    span.SetAttributes(
        attribute.String("order.id", req.ID),
        attribute.String("order.status", req.Status),
    )
    span.SetStatus(codes.Ok, "success")

    c.JSON(http.StatusOK, req)
}

func checkInventory(ctx context.Context, productID string, quantity int) (bool, error) {
    tracer := otel.Tracer("order-service")
    ctx, span := tracer.Start(ctx, "order.checkInventory")
    defer span.End()

    span.SetAttributes(
        attribute.String("product.id", productID),
        attribute.Int("quantity", quantity),
    )

    // è°ƒç”¨ Inventory Service
    // (ä½¿ç”¨ otelhttp.NewTransport)
    
    return true, nil
}

func processPayment(ctx context.Context, userID string, amount float64) (bool, error) {
    tracer := otel.Tracer("order-service")
    ctx, span := tracer.Start(ctx, "order.processPayment")
    defer span.End()

    span.SetAttributes(
        attribute.String("user.id", userID),
        attribute.Float64("amount", amount),
    )

    // è°ƒç”¨ Payment Service
    
    return true, nil
}

func sendOrderNotification(ctx context.Context, order Order) error {
    tracer := otel.Tracer("order-service")
    ctx, span := tracer.Start(ctx, "order.sendNotification")
    defer span.End()

    // å‘é€åˆ° Kafka
    // (ä½¿ç”¨ Kafka Producer å¸¦è¿½è¸ª)
    
    return nil
}

func generateOrderID() string {
    return "ORDER-" + time.Now().Format("20060102150405")
}
```

---

### 3. Inventory Service1

**`cmd/inventory/main.go`**

```go
package main

import (
    "context"
    "log"
    "net/http"

    "github.com/gin-gonic/gin"
    "go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "gorm.io/gorm"

    "ecommerce/pkg/telemetry"
)

type Inventory struct {
    ProductID string `gorm:"primaryKey"`
    Stock     int
}

var db *gorm.DB

func main() {
    // åˆå§‹åŒ– Tracer
    tp, err := telemetry.InitTracer("inventory-service", "1.0.0", "localhost:4317")
    if err != nil {
        log.Fatal(err)
    }
    defer tp.Shutdown(context.Background())

    // åˆå§‹åŒ–æ•°æ®åº“
    db, err = gorm.Open(postgres.Open("host=localhost user=postgres dbname=inventory"), &gorm.Config{})
    if err != nil {
        log.Fatal(err)
    }

    // åˆ›å»º Gin è·¯ç”±
    router := gin.Default()
    router.Use(otelgin.Middleware("inventory-service"))

    // è·¯ç”±
    router.GET("/inventory/:product_id", handleGetInventory)
    router.POST("/inventory/deduct", handleDeductInventory)

    // å¯åŠ¨æœåŠ¡
    log.Println("Inventory Service started on :8082")
    router.Run(":8082")
}

func handleGetInventory(c *gin.Context) {
    ctx := c.Request.Context()
    tracer := otel.Tracer("inventory-service")

    ctx, span := tracer.Start(ctx, "inventory.get")
    defer span.End()

    productID := c.Param("product_id")
    span.SetAttributes(attribute.String("product.id", productID))

    var inventory Inventory
    if err := db.WithContext(ctx).Where("product_id = ?", productID).First(&inventory).Error; err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "product not found")
        c.JSON(http.StatusNotFound, gin.H{"error": "product not found"})
        return
    }

    span.SetAttributes(attribute.Int("stock", inventory.Stock))
    span.SetStatus(codes.Ok, "success")

    c.JSON(http.StatusOK, inventory)
}

func handleDeductInventory(c *gin.Context) {
    ctx := c.Request.Context()
    tracer := otel.Tracer("inventory-service")

    ctx, span := tracer.Start(ctx, "inventory.deduct")
    defer span.End()

    var req struct {
        ProductID string `json:"product_id"`
        Quantity  int    `json:"quantity"`
    }
    if err := c.ShouldBindJSON(&req); err != nil {
        span.RecordError(err)
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    span.SetAttributes(
        attribute.String("product.id", req.ProductID),
        attribute.Int("quantity", req.Quantity),
    )

    // ä½¿ç”¨äº‹åŠ¡æ‰£å‡åº“å­˜
    err := db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        var inventory Inventory
        if err := tx.Where("product_id = ?", req.ProductID).First(&inventory).Error; err != nil {
            return err
        }

        if inventory.Stock < req.Quantity {
            return gorm.ErrRecordNotFound
        }

        inventory.Stock -= req.Quantity
        return tx.Save(&inventory).Error
    })

    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "insufficient stock")
        c.JSON(http.StatusBadRequest, gin.H{"error": "insufficient stock"})
        return
    }

    span.SetStatus(codes.Ok, "success")
    c.JSON(http.StatusOK, gin.H{"status": "success"})
}
```

---

### 4. Payment Service (ç®€åŒ–ç‰ˆ)

**`cmd/payment/main.go`**

```go
package main

import (
    "context"
    "log"
    "net/http"
    "time"

    "github.com/gin-gonic/gin"
    "go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"

    "ecommerce/pkg/telemetry"
)

func main() {
    // åˆå§‹åŒ– Tracer
    tp, err := telemetry.InitTracer("payment-service", "1.0.0", "localhost:4317")
    if err != nil {
        log.Fatal(err)
    }
    defer tp.Shutdown(context.Background())

    // åˆ›å»º Gin è·¯ç”±
    router := gin.Default()
    router.Use(otelgin.Middleware("payment-service"))

    // è·¯ç”±
    router.POST("/payment/process", handleProcessPayment)

    // å¯åŠ¨æœåŠ¡
    log.Println("Payment Service started on :8083")
    router.Run(":8083")
}

func handleProcessPayment(c *gin.Context) {
    ctx := c.Request.Context()
    tracer := otel.Tracer("payment-service")

    ctx, span := tracer.Start(ctx, "payment.process")
    defer span.End()

    var req struct {
        UserID string  `json:"user_id"`
        Amount float64 `json:"amount"`
    }
    if err := c.ShouldBindJSON(&req); err != nil {
        span.RecordError(err)
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    span.SetAttributes(
        attribute.String("user.id", req.UserID),
        attribute.Float64("amount", req.Amount),
    )

    // æ¨¡æ‹Ÿæ”¯ä»˜å¤„ç†
    time.Sleep(100 * time.Millisecond)

    // å‡è®¾æ”¯ä»˜æˆåŠŸ
    transactionID := "TXN-" + time.Now().Format("20060102150405")
    span.SetAttributes(attribute.String("transaction.id", transactionID))
    span.SetStatus(codes.Ok, "payment successful")

    c.JSON(http.StatusOK, gin.H{
        "transaction_id": transactionID,
        "status":         "success",
    })
}
```

---

### 5. Notification Service (Kafka Consumer)

**`cmd/notification/main.go`**

```go
package main

import (
    "context"
    "log"

    "github.com/segmentio/kafka-go"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/propagation"

    "ecommerce/pkg/telemetry"
)

func main() {
    // åˆå§‹åŒ– Tracer
    tp, err := telemetry.InitTracer("notification-service", "1.0.0", "localhost:4317")
    if err != nil {
        log.Fatal(err)
    }
    defer tp.Shutdown(context.Background())

    // åˆ›å»º Kafka Reader
    reader := kafka.NewReader(kafka.ReaderConfig{
        Brokers: []string{"localhost:9092"},
        Topic:   "order-notifications",
        GroupID: "notification-service",
    })
    defer reader.Close()

    log.Println("Notification Service started, waiting for messages...")

    // æ¶ˆè´¹æ¶ˆæ¯
    for {
        msg, err := reader.ReadMessage(context.Background())
        if err != nil {
            log.Printf("Error reading message: %v", err)
            continue
        }

        // æå– Trace Context
        ctx := otel.GetTextMapPropagator().Extract(
            context.Background(),
            propagation.MapCarrier(extractHeaders(msg.Headers)),
        )

        // å¤„ç†æ¶ˆæ¯
        handleMessage(ctx, msg)
    }
}

func handleMessage(ctx context.Context, msg kafka.Message) {
    tracer := otel.Tracer("notification-service")
    ctx, span := tracer.Start(ctx, "notification.process")
    defer span.End()

    span.SetAttributes(
        attribute.String("kafka.topic", msg.Topic),
        attribute.Int("kafka.partition", msg.Partition),
        attribute.Int64("kafka.offset", msg.Offset),
    )

    log.Printf("Processing order notification: %s", string(msg.Value))

    // å‘é€é€šçŸ¥ (é‚®ä»¶/SMS)
    if err := sendNotification(ctx, string(msg.Value)); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "notification failed")
        return
    }

    span.SetStatus(codes.Ok, "notification sent")
}

func sendNotification(ctx context.Context, message string) error {
    tracer := otel.Tracer("notification-service")
    ctx, span := tracer.Start(ctx, "notification.send")
    defer span.End()

    // æ¨¡æ‹Ÿå‘é€é€šçŸ¥
    log.Printf("Sending notification: %s", message)

    return nil
}

func extractHeaders(headers []kafka.Header) map[string]string {
    result := make(map[string]string)
    for _, h := range headers {
        result[h.Key] = string(h.Value)
    }
    return result
}
```

---

## ğŸš€ è¿è¡ŒæŒ‡å—

### 1. å¯åŠ¨åŸºç¡€è®¾æ–½

**`docker-compose.yml`**

```yaml
version: '3.8'

services:
  # OpenTelemetry Collector
  otel-collector:
    image: otel/opentelemetry-collector-contrib:latest
    ports:
      - "4317:4317"   # OTLP gRPC
      - "4318:4318"   # OTLP HTTP
    volumes:
      - ./otel-collector-config.yaml:/etc/otel-collector-config.yaml
    command: ["--config=/etc/otel-collector-config.yaml"]

  # Jaeger
  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686"  # UI
      - "14250:14250"  # gRPC

  # Kafka
  kafka:
    image: confluentinc/cp-kafka:latest
    ports:
      - "9092:9092"
    environment:
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092

  # PostgreSQL
  postgres:
    image: postgres:15
    ports:
      - "5432:5432"
    environment:
      POSTGRES_PASSWORD: postgres

  # Redis
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
```

å¯åŠ¨ï¼š

```bash
docker-compose up -d
```

### 2. å¯åŠ¨å¾®æœåŠ¡

```bash
# å¯åŠ¨ Gateway
go run cmd/gateway/main.go

# å¯åŠ¨ Order Service
go run cmd/order/main.go

# å¯åŠ¨ Inventory Service
go run cmd/inventory/main.go

# å¯åŠ¨ Payment Service
go run cmd/payment/main.go

# å¯åŠ¨ Notification Service
go run cmd/notification/main.go
```

### 3. å‘é€æµ‹è¯•è¯·æ±‚

```bash
curl -X POST http://localhost:8080/api/orders \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": "USER-001",
    "product_id": "PROD-123",
    "quantity": 2,
    "amount": 199.99
  }'
```

---

## ğŸ“Š ç›‘æ§è§‚æµ‹

### 1. Jaeger UI

æ‰“å¼€ <http://localhost:16686>

**è¿½è¸ªè§†å›¾**:

```text
gateway.createOrder (200ms)
  â”œâ”€ gateway.callOrderService (180ms)
  â”‚   â”œâ”€ order.create (150ms)
  â”‚   â”‚   â”œâ”€ order.checkInventory (30ms)
  â”‚   â”‚   â”‚   â””â”€ inventory.get (20ms)
  â”‚   â”‚   â”œâ”€ order.processPayment (40ms)
  â”‚   â”‚   â”‚   â””â”€ payment.process (30ms)
  â”‚   â”‚   â”œâ”€ order.saveDatabase (50ms)
  â”‚   â”‚   â””â”€ order.sendNotification (10ms)
  â”‚   â””â”€ notification.process (20ms)
```

### 2. å…³é”®æŒ‡æ ‡

**HTTP è¯·æ±‚æŒ‡æ ‡**:

- `http.server.duration` - è¯·æ±‚å»¶è¿Ÿ
- `http.server.request.count` - è¯·æ±‚æ•°
- `http.server.response.size` - å“åº”å¤§å°

**æ•°æ®åº“æŒ‡æ ‡**:

- `db.client.connections.usage` - è¿æ¥æ± ä½¿ç”¨ç‡
- `db.client.operation.duration` - æŸ¥è¯¢å»¶è¿Ÿ

**Kafka æŒ‡æ ‡**:

- `messaging.publish.duration` - æ¶ˆæ¯å‘é€å»¶è¿Ÿ
- `messaging.process.duration` - æ¶ˆæ¯å¤„ç†å»¶è¿Ÿ

---

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. Context ä¼ æ’­

```go
// âœ… æ­£ç¡®: å§‹ç»ˆä¼ æ’­ Context
func handleRequest(ctx context.Context) {
    ctx, span := tracer.Start(ctx, "operation")
    defer span.End()
    
    // ä¼ æ’­åˆ°ä¸‹æ¸¸
    callService(ctx)
}

// âŒ é”™è¯¯: ä¸¢å¤± Context
func handleRequest(ctx context.Context) {
    callService(context.Background())
}
```

### 2. é”™è¯¯å¤„ç†

```go
// âœ… æ­£ç¡®: è®°å½•é”™è¯¯è¯¦æƒ…
if err != nil {
    span.RecordError(err)
    span.SetStatus(codes.Error, err.Error())
    span.SetAttributes(
        attribute.String("error.type", fmt.Sprintf("%T", err)),
    )
}
```

### 3. å±æ€§æ·»åŠ 

```go
// âœ… æ­£ç¡®: ä½¿ç”¨è¯­ä¹‰çº¦å®š
span.SetAttributes(
    semconv.HTTPMethod("POST"),
    semconv.HTTPStatusCode(200),
    semconv.HTTPRoute("/api/orders"),
)

// âŒ é”™è¯¯: è‡ªå®šä¹‰å±æ€§å
span.SetAttributes(
    attribute.String("method", "POST"),
)
```

### 4. é‡‡æ ·ç­–ç•¥

```go
// ç”Ÿäº§ç¯å¢ƒ: 10% é‡‡æ ·
sdktrace.ParentBased(sdktrace.TraceIDRatioBased(0.1))

// å…³é”®è·¯å¾„: 100% é‡‡æ ·
sdktrace.AlwaysSample()
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [Gin ä¸­é—´ä»¶é›†æˆ](../../02_Semantic_Conventions/02_Traceå±æ€§/02_HTTPæœåŠ¡å™¨.md)
- [GORM è¿½è¸ª](../../02_Semantic_Conventions/02_Traceå±æ€§/04_æ•°æ®åº“.md)
- [Kafka è¿½è¸ª](../../02_Semantic_Conventions/02_Traceå±æ€§/05_æ¶ˆæ¯é˜Ÿåˆ—.md)
- [Context ç®¡ç†](../../04_SDKä¸å®ç°/04_é€šç”¨ç»„ä»¶/01_Contextç®¡ç†.md)

---

**ğŸ‰ å®Œæˆï¼ä½ å·²ç»æŒæ¡äº†å¾®æœåŠ¡ OpenTelemetry å®Œæ•´é›†æˆï¼**

**ä¸‹ä¸€æ­¥**: [ç”µå•†ç³»ç»Ÿå®Œæ•´æ¡ˆä¾‹](./02_ç”µå•†ç³»ç»Ÿå®Œæ•´æ¡ˆä¾‹.md)
