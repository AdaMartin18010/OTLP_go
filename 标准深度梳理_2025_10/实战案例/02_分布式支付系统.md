# å®æˆ˜æ¡ˆä¾‹ï¼šåˆ†å¸ƒå¼æ”¯ä»˜ç³»ç»Ÿå®Œæ•´ OTLP é›†æˆ

> **åœºæ™¯**: é«˜å¯ç”¨åˆ†å¸ƒå¼æ”¯ä»˜å¤„ç†ç³»ç»Ÿ  
> **æŠ€æœ¯æ ˆ**: Go 1.25.1, Gin, GORM, Redis, Kafka, PostgreSQL  
> **ç‰¹æ€§**: äº‹åŠ¡ä¸€è‡´æ€§ã€å¹‚ç­‰æ€§ã€è¶…æ—¶æ§åˆ¶ã€é™æµç†”æ–­ã€å®Œæ•´è¿½è¸ª  
> **OpenTelemetry**: v1.32.0+  
> **éš¾åº¦**: â­â­â­â­â­ (ç”Ÿäº§çº§)

---

## ğŸ“‹ ç›®å½•

- [å®æˆ˜æ¡ˆä¾‹ï¼šåˆ†å¸ƒå¼æ”¯ä»˜ç³»ç»Ÿå®Œæ•´ OTLP é›†æˆ](#å®æˆ˜æ¡ˆä¾‹åˆ†å¸ƒå¼æ”¯ä»˜ç³»ç»Ÿå®Œæ•´-otlp-é›†æˆ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ç³»ç»Ÿæ¦‚è¿°](#ç³»ç»Ÿæ¦‚è¿°)
    - [ä¸šåŠ¡åœºæ™¯](#ä¸šåŠ¡åœºæ™¯)
    - [ç³»ç»Ÿè¦æ±‚](#ç³»ç»Ÿè¦æ±‚)
    - [OpenTelemetry é›†æˆç›®æ ‡](#opentelemetry-é›†æˆç›®æ ‡)
  - [æ¶æ„è®¾è®¡](#æ¶æ„è®¾è®¡)
    - [ç³»ç»Ÿæ¶æ„å›¾](#ç³»ç»Ÿæ¶æ„å›¾)
    - [æ•°æ®æµ](#æ•°æ®æµ)
  - [é¡¹ç›®ç»“æ„](#é¡¹ç›®ç»“æ„)
  - [æ ¸å¿ƒæœåŠ¡å®ç°](#æ ¸å¿ƒæœåŠ¡å®ç°)
    - [1. Telemetry åˆå§‹åŒ–](#1-telemetry-åˆå§‹åŒ–)
    - [2. è¿½è¸ªä¸­é—´ä»¶](#2-è¿½è¸ªä¸­é—´ä»¶)
    - [3. æ”¯ä»˜æœåŠ¡å®ç°](#3-æ”¯ä»˜æœåŠ¡å®ç°)
    - [4. è´¦æˆ·æœåŠ¡å®ç°](#4-è´¦æˆ·æœåŠ¡å®ç°)
    - [5. å¹‚ç­‰æ€§ç®¡ç†](#5-å¹‚ç­‰æ€§ç®¡ç†)
  - [å…³é”®ç‰¹æ€§](#å…³é”®ç‰¹æ€§)
    - [1. åˆ†å¸ƒå¼è¿½è¸ª](#1-åˆ†å¸ƒå¼è¿½è¸ª)
    - [2. æŒ‡æ ‡ç›‘æ§](#2-æŒ‡æ ‡ç›‘æ§)
    - [3. å¹‚ç­‰æ€§ä¿è¯](#3-å¹‚ç­‰æ€§ä¿è¯)
    - [4. è¶…æ—¶æ§åˆ¶](#4-è¶…æ—¶æ§åˆ¶)
  - [ç›‘æ§ä¸å‘Šè­¦](#ç›‘æ§ä¸å‘Šè­¦)
    - [Prometheus æŸ¥è¯¢ç¤ºä¾‹](#prometheus-æŸ¥è¯¢ç¤ºä¾‹)
    - [Grafana Dashboard](#grafana-dashboard)
    - [å‘Šè­¦è§„åˆ™](#å‘Šè­¦è§„åˆ™)
  - [éƒ¨ç½²é…ç½®](#éƒ¨ç½²é…ç½®)
    - [Docker Compose](#docker-compose)
  - [æµ‹è¯•éªŒè¯](#æµ‹è¯•éªŒè¯)
    - [1. å‹åŠ›æµ‹è¯•](#1-å‹åŠ›æµ‹è¯•)
    - [2. éªŒè¯è¿½è¸ª](#2-éªŒè¯è¿½è¸ª)
    - [3. éªŒè¯æŒ‡æ ‡](#3-éªŒè¯æŒ‡æ ‡)
  - [æœ€ä½³å®è·µæ€»ç»“](#æœ€ä½³å®è·µæ€»ç»“)
    - [1. è¿½è¸ªæœ€ä½³å®è·µ](#1-è¿½è¸ªæœ€ä½³å®è·µ)
    - [2. æŒ‡æ ‡æœ€ä½³å®è·µ](#2-æŒ‡æ ‡æœ€ä½³å®è·µ)
    - [3. æ€§èƒ½ä¼˜åŒ–](#3-æ€§èƒ½ä¼˜åŒ–)
    - [4. å¯é æ€§ä¿éšœ](#4-å¯é æ€§ä¿éšœ)
  - [ğŸ¯ å­¦åˆ°çš„å…³é”®çŸ¥è¯†ç‚¹](#-å­¦åˆ°çš„å…³é”®çŸ¥è¯†ç‚¹)

---

## ç³»ç»Ÿæ¦‚è¿°

### ä¸šåŠ¡åœºæ™¯

åˆ†å¸ƒå¼æ”¯ä»˜ç³»ç»Ÿå¤„ç†ä»¥ä¸‹æ”¯ä»˜æµç¨‹ï¼š

```text
ç”¨æˆ·å‘èµ·æ”¯ä»˜
    â†“
æ”¯ä»˜ç½‘å…³ (API Gateway)
    â†“
æ”¯ä»˜æœåŠ¡ (Payment Service)
    â”œâ†’ è´¦æˆ·æœåŠ¡ (Account Service) - ä½™é¢æ£€æŸ¥ä¸æ‰£æ¬¾
    â”œâ†’ é£æ§æœåŠ¡ (Risk Service) - é£é™©è¯„ä¼°
    â”œâ†’ æ¸ é“æœåŠ¡ (Channel Service) - ç¬¬ä¸‰æ–¹æ”¯ä»˜
    â””â†’ é€šçŸ¥æœåŠ¡ (Notification Service) - æ”¯ä»˜ç»“æœé€šçŸ¥
```

### ç³»ç»Ÿè¦æ±‚

- âœ… **é«˜å¯ç”¨**: 99.99% SLA
- âœ… **é«˜æ€§èƒ½**: P99 < 200ms
- âœ… **å¼ºä¸€è‡´æ€§**: ACID äº‹åŠ¡ä¿è¯
- âœ… **å¹‚ç­‰æ€§**: é˜²æ­¢é‡å¤æ”¯ä»˜
- âœ… **å¯è¿½è¸ª**: å®Œæ•´çš„åˆ†å¸ƒå¼è¿½è¸ª
- âœ… **å¯è§‚æµ‹**: å®æ—¶ç›‘æ§ä¸å‘Šè­¦

### OpenTelemetry é›†æˆç›®æ ‡

- ğŸ¯ **Traces**: æ”¯ä»˜é“¾è·¯å®Œæ•´è¿½è¸ªï¼ˆè·¨æœåŠ¡ã€è·¨ä¸­é—´ä»¶ï¼‰
- ğŸ¯ **Metrics**: æ”¯ä»˜æˆåŠŸç‡ã€å»¶è¿Ÿã€TPS ç›‘æ§
- ğŸ¯ **Logs**: ç»“æ„åŒ–æ—¥å¿—ä¸ Trace å…³è”
- ğŸ¯ **Context**: è·¨æœåŠ¡ä¸Šä¸‹æ–‡ä¼ æ’­ï¼ˆå«ç”¨æˆ·ä¿¡æ¯ã€è¯·æ±‚IDï¼‰

---

## æ¶æ„è®¾è®¡

### ç³»ç»Ÿæ¶æ„å›¾

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Client (Web/Mobile)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Payment Gateway (Gin)                   â”‚
â”‚  - Rate Limiting                                         â”‚
â”‚  - Authentication                                        â”‚
â”‚  - Request Validation                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â–¼             â–¼             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Payment    â”‚ â”‚     Risk     â”‚ â”‚   Channel    â”‚
â”‚   Service    â”‚ â”‚   Service    â”‚ â”‚   Service    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                â”‚                â”‚
       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
       â–¼                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Account    â”‚                  â”‚ Notification â”‚
â”‚   Service    â”‚                  â”‚   Service    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Data Layer                       â”‚
â”‚  PostgreSQL  â”‚  Redis  â”‚  Kafka                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           OpenTelemetry Collector                 â”‚
â”‚  - Traces   - Metrics   - Logs                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â–¼             â–¼             â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Jaeger â”‚    â”‚Prometheusâ”‚  â”‚  Loki  â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ•°æ®æµ

```text
1. æ”¯ä»˜è¯·æ±‚
   Client â†’ Gateway â†’ Payment Service
   [Span: payment.request] [Baggage: user_id, request_id]

2. é£æ§æ£€æŸ¥
   Payment â†’ Risk Service
   [Span: risk.check] [Links: payment.request]

3. ä½™é¢æ£€æŸ¥ä¸æ‰£æ¬¾
   Payment â†’ Account Service â†’ PostgreSQL
   [Span: account.deduct] [DB spans] [Transaction trace]

4. ç¬¬ä¸‰æ–¹æ”¯ä»˜
   Payment â†’ Channel Service â†’ External API
   [Span: channel.pay] [HTTP client spans]

5. æ”¯ä»˜ç»“æœé€šçŸ¥
   Payment â†’ Kafka â†’ Notification Service
   [Span: notification.send] [Messaging spans]

6. å“åº”è¿”å›
   Payment â†’ Gateway â†’ Client
   [Span end] [Metrics recorded]
```

---

## é¡¹ç›®ç»“æ„

```text
payment-system/
â”œâ”€â”€ cmd/
â”‚   â”œâ”€â”€ gateway/           # API ç½‘å…³
â”‚   â”‚   â””â”€â”€ main.go
â”‚   â”œâ”€â”€ payment/           # æ”¯ä»˜æœåŠ¡
â”‚   â”‚   â””â”€â”€ main.go
â”‚   â”œâ”€â”€ account/           # è´¦æˆ·æœåŠ¡
â”‚   â”‚   â””â”€â”€ main.go
â”‚   â”œâ”€â”€ risk/              # é£æ§æœåŠ¡
â”‚   â”‚   â””â”€â”€ main.go
â”‚   â”œâ”€â”€ channel/           # æ¸ é“æœåŠ¡
â”‚   â”‚   â””â”€â”€ main.go
â”‚   â””â”€â”€ notification/      # é€šçŸ¥æœåŠ¡
â”‚       â””â”€â”€ main.go
â”‚
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ telemetry/         # OpenTelemetry åˆå§‹åŒ–
â”‚   â”‚   â”œâ”€â”€ tracer.go
â”‚   â”‚   â”œâ”€â”€ meter.go
â”‚   â”‚   â”œâ”€â”€ logger.go
â”‚   â”‚   â””â”€â”€ propagation.go
â”‚   â”‚
â”‚   â”œâ”€â”€ middleware/        # ä¸­é—´ä»¶
â”‚   â”‚   â”œâ”€â”€ tracing.go     # è¿½è¸ªä¸­é—´ä»¶
â”‚   â”‚   â”œâ”€â”€ metrics.go     # æŒ‡æ ‡ä¸­é—´ä»¶
â”‚   â”‚   â”œâ”€â”€ logging.go     # æ—¥å¿—ä¸­é—´ä»¶
â”‚   â”‚   â”œâ”€â”€ ratelimit.go   # é™æµä¸­é—´ä»¶
â”‚   â”‚   â””â”€â”€ circuit.go     # ç†”æ–­ä¸­é—´ä»¶
â”‚   â”‚
â”‚   â”œâ”€â”€ payment/           # æ”¯ä»˜æœåŠ¡å®ç°
â”‚   â”‚   â”œâ”€â”€ handler.go     # HTTP å¤„ç†å™¨
â”‚   â”‚   â”œâ”€â”€ service.go     # ä¸šåŠ¡é€»è¾‘
â”‚   â”‚   â”œâ”€â”€ repository.go  # æ•°æ®è®¿é—®
â”‚   â”‚   â””â”€â”€ models.go      # æ•°æ®æ¨¡å‹
â”‚   â”‚
â”‚   â”œâ”€â”€ account/           # è´¦æˆ·æœåŠ¡å®ç°
â”‚   â”œâ”€â”€ risk/              # é£æ§æœåŠ¡å®ç°
â”‚   â”œâ”€â”€ channel/           # æ¸ é“æœåŠ¡å®ç°
â”‚   â””â”€â”€ notification/      # é€šçŸ¥æœåŠ¡å®ç°
â”‚
â”œâ”€â”€ pkg/
â”‚   â”œâ”€â”€ client/            # æœåŠ¡å®¢æˆ·ç«¯
â”‚   â”‚   â”œâ”€â”€ account.go
â”‚   â”‚   â”œâ”€â”€ risk.go
â”‚   â”‚   â””â”€â”€ channel.go
â”‚   â”‚
â”‚   â”œâ”€â”€ idempotency/       # å¹‚ç­‰æ€§å®ç°
â”‚   â”‚   â””â”€â”€ idempotency.go
â”‚   â”‚
â”‚   â””â”€â”€ transaction/       # åˆ†å¸ƒå¼äº‹åŠ¡
â”‚       â””â”€â”€ saga.go
â”‚
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ dev.yaml           # å¼€å‘ç¯å¢ƒé…ç½®
â”‚   â”œâ”€â”€ prod.yaml          # ç”Ÿäº§ç¯å¢ƒé…ç½®
â”‚   â””â”€â”€ otel.yaml          # OTLP é…ç½®
â”‚
â”œâ”€â”€ deployments/
â”‚   â”œâ”€â”€ docker-compose.yml # æœ¬åœ°éƒ¨ç½²
â”‚   â””â”€â”€ k8s/               # Kubernetes éƒ¨ç½²
â”‚
â”œâ”€â”€ go.mod
â””â”€â”€ go.sum
```

---

## æ ¸å¿ƒæœåŠ¡å®ç°

### 1. Telemetry åˆå§‹åŒ–

```go:internal/telemetry/tracer.go
package telemetry

import (
    "context"
    "fmt"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
    "go.opentelemetry.io/otel/trace"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
)

type Config struct {
    ServiceName    string
    ServiceVersion string
    Environment    string
    OTLPEndpoint   string
}

type Telemetry struct {
    TracerProvider *sdktrace.TracerProvider
    Tracer         trace.Tracer
}

// InitTracer åˆå§‹åŒ–è¿½è¸ªå™¨
func InitTracer(ctx context.Context, cfg Config) (*Telemetry, error) {
    // åˆ›å»º Resource
    res, err := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceNameKey.String(cfg.ServiceName),
            semconv.ServiceVersionKey.String(cfg.ServiceVersion),
            semconv.DeploymentEnvironmentKey.String(cfg.Environment),
        ),
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create resource: %w", err)
    }

    // åˆ›å»º OTLP Exporter
    conn, err := grpc.NewClient(
        cfg.OTLPEndpoint,
        grpc.WithTransportCredentials(insecure.NewCredentials()),
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create gRPC client: %w", err)
    }

    exporter, err := otlptracegrpc.New(ctx, otlptracegrpc.WithGRPCConn(conn))
    if err != nil {
        return nil, fmt.Errorf("failed to create OTLP exporter: %w", err)
    }

    // åˆ›å»º TracerProvider
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter,
            sdktrace.WithBatchTimeout(time.Second),
            sdktrace.WithMaxExportBatchSize(512),
        ),
        sdktrace.WithResource(res),
        // ç”Ÿäº§ç¯å¢ƒé‡‡æ ·ç­–ç•¥
        sdktrace.WithSampler(sdktrace.ParentBased(
            sdktrace.TraceIDRatioBased(0.1), // 10% é‡‡æ ·ç‡
        )),
    )

    // è®¾ç½®å…¨å±€ TracerProvider
    otel.SetTracerProvider(tp)

    // è®¾ç½®å…¨å±€ Propagatorï¼ˆæ”¯æŒ W3C Trace Context å’Œ Baggageï¼‰
    otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
        propagation.TraceContext{},
        propagation.Baggage{},
    ))

    return &Telemetry{
        TracerProvider: tp,
        Tracer:         tp.Tracer(cfg.ServiceName),
    }, nil
}

// Shutdown å…³é—­è¿½è¸ªå™¨
func (t *Telemetry) Shutdown(ctx context.Context) error {
    return t.TracerProvider.Shutdown(ctx)
}
```

### 2. è¿½è¸ªä¸­é—´ä»¶

```go:internal/middleware/tracing.go
package middleware

import (
    "fmt"

    "github.com/gin-gonic/gin"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/baggage"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/propagation"
    semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
    "go.opentelemetry.io/otel/trace"
)

// TracingMiddleware åˆ›å»ºè¿½è¸ªä¸­é—´ä»¶
func TracingMiddleware(serviceName string) gin.HandlerFunc {
    tracer := otel.Tracer(serviceName)
    propagator := otel.GetTextMapPropagator()

    return func(c *gin.Context) {
        // ä» HTTP Headers æå–ä¸Šä¸‹æ–‡
        ctx := propagator.Extract(c.Request.Context(), propagation.HeaderCarrier(c.Request.Header))

        // åˆ›å»º Span
        spanName := fmt.Sprintf("%s %s", c.Request.Method, c.FullPath())
        ctx, span := tracer.Start(ctx, spanName,
            trace.WithSpanKind(trace.SpanKindServer),
            trace.WithAttributes(
                semconv.HTTPMethodKey.String(c.Request.Method),
                semconv.HTTPURLKey.String(c.Request.URL.String()),
                semconv.HTTPRouteKey.String(c.FullPath()),
                semconv.HTTPTargetKey.String(c.Request.URL.Path),
                semconv.HTTPSchemeKey.String(c.Request.URL.Scheme),
                semconv.NetHostNameKey.String(c.Request.Host),
                semconv.HTTPUserAgentKey.String(c.Request.UserAgent()),
                semconv.HTTPClientIPKey.String(c.ClientIP()),
            ),
        )
        defer span.End()

        // å°†ä¸Šä¸‹æ–‡å­˜å‚¨åˆ° Gin Context
        c.Request = c.Request.WithContext(ctx)

        // å¤„ç†è¯·æ±‚
        c.Next()

        // è®°å½•å“åº”çŠ¶æ€
        status := c.Writer.Status()
        span.SetAttributes(
            semconv.HTTPStatusCodeKey.Int(status),
            attribute.Int("http.response.body.size", c.Writer.Size()),
        )

        // å¦‚æœæœ‰é”™è¯¯ï¼Œè®°å½•é”™è¯¯ä¿¡æ¯
        if status >= 400 {
            span.SetStatus(codes.Error, fmt.Sprintf("HTTP %d", status))
            if len(c.Errors) > 0 {
                span.RecordError(c.Errors.Last())
            }
        } else {
            span.SetStatus(codes.Ok, "success")
        }
    }
}

// ExtractBaggage æå– Baggage ä¿¡æ¯
func ExtractBaggage(c *gin.Context) map[string]string {
    ctx := c.Request.Context()
    bag := baggage.FromContext(ctx)
    
    result := make(map[string]string)
    for _, member := range bag.Members() {
        result[member.Key()] = member.Value()
    }
    return result
}

// SetBaggage è®¾ç½® Baggage
func SetBaggage(c *gin.Context, key, value string) error {
    ctx := c.Request.Context()
    bag := baggage.FromContext(ctx)
    
    member, err := baggage.NewMember(key, value)
    if err != nil {
        return err
    }
    
    bag, err = bag.SetMember(member)
    if err != nil {
        return err
    }
    
    c.Request = c.Request.WithContext(baggage.ContextWithBaggage(ctx, bag))
    return nil
}
```

### 3. æ”¯ä»˜æœåŠ¡å®ç°

```go:internal/payment/service.go
package payment

import (
    "context"
    "fmt"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
)

var (
    tracer = otel.Tracer("payment-service")
    meter  = otel.Meter("payment-service")
)

// Metrics
var (
    paymentCounter     metric.Int64Counter
    paymentDuration    metric.Float64Histogram
    paymentSuccessRate metric.Float64Gauge
)

func init() {
    var err error
    
    paymentCounter, err = meter.Int64Counter(
        "payment.requests.total",
        metric.WithDescription("Total number of payment requests"),
        metric.WithUnit("{request}"),
    )
    if err != nil {
        panic(err)
    }

    paymentDuration, err = meter.Float64Histogram(
        "payment.duration",
        metric.WithDescription("Payment processing duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        panic(err)
    }

    paymentSuccessRate, err = meter.Float64Gauge(
        "payment.success_rate",
        metric.WithDescription("Payment success rate"),
        metric.WithUnit("1"),
    )
    if err != nil {
        panic(err)
    }
}

type Service struct {
    accountClient      *AccountClient
    riskClient         *RiskClient
    channelClient      *ChannelClient
    notificationClient *NotificationClient
    repository         *Repository
    idempotency        *IdempotencyManager
}

type PaymentRequest struct {
    PaymentID     string
    UserID        string
    Amount        float64
    Currency      string
    PaymentMethod string
    IdempotencyKey string
}

type PaymentResponse struct {
    PaymentID     string
    Status        string
    TransactionID string
    Message       string
}

// ProcessPayment å¤„ç†æ”¯ä»˜è¯·æ±‚
func (s *Service) ProcessPayment(ctx context.Context, req *PaymentRequest) (*PaymentResponse, error) {
    startTime := time.Now()
    
    ctx, span := tracer.Start(ctx, "payment.process",
        trace.WithAttributes(
            attribute.String("payment.id", req.PaymentID),
            attribute.String("user.id", req.UserID),
            attribute.Float64("payment.amount", req.Amount),
            attribute.String("payment.currency", req.Currency),
            attribute.String("payment.method", req.PaymentMethod),
        ),
    )
    defer span.End()

    // è®°å½• Metric
    defer func() {
        duration := time.Since(startTime).Milliseconds()
        paymentDuration.Record(ctx, float64(duration),
            metric.WithAttributes(
                attribute.String("payment.method", req.PaymentMethod),
            ),
        )
    }()

    // 1. å¹‚ç­‰æ€§æ£€æŸ¥
    if err := s.checkIdempotency(ctx, req.IdempotencyKey); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "idempotency check failed")
        paymentCounter.Add(ctx, 1, metric.WithAttributes(
            attribute.String("status", "duplicate"),
        ))
        return nil, err
    }

    // 2. é£æ§æ£€æŸ¥
    if err := s.checkRisk(ctx, req); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "risk check failed")
        paymentCounter.Add(ctx, 1, metric.WithAttributes(
            attribute.String("status", "rejected"),
        ))
        return nil, err
    }

    // 3. è´¦æˆ·ä½™é¢æ£€æŸ¥ä¸æ‰£æ¬¾
    if err := s.deductBalance(ctx, req); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "balance deduction failed")
        paymentCounter.Add(ctx, 1, metric.WithAttributes(
            attribute.String("status", "failed"),
        ))
        return nil, err
    }

    // 4. ç¬¬ä¸‰æ–¹æ”¯ä»˜æ¸ é“
    txnID, err := s.processChannel(ctx, req)
    if err != nil {
        // æ‰£æ¬¾å¤±è´¥ï¼Œå›æ»š
        s.refundBalance(ctx, req)
        span.RecordError(err)
        span.SetStatus(codes.Error, "channel payment failed")
        paymentCounter.Add(ctx, 1, metric.WithAttributes(
            attribute.String("status", "failed"),
        ))
        return nil, err
    }

    // 5. å‘é€æ”¯ä»˜æˆåŠŸé€šçŸ¥
    go s.sendNotification(context.WithoutCancel(ctx), req, txnID)

    // 6. è®°å½•æ”¯ä»˜æˆåŠŸ
    span.SetStatus(codes.Ok, "payment successful")
    span.SetAttributes(attribute.String("transaction.id", txnID))
    paymentCounter.Add(ctx, 1, metric.WithAttributes(
        attribute.String("status", "success"),
    ))

    return &PaymentResponse{
        PaymentID:     req.PaymentID,
        Status:        "success",
        TransactionID: txnID,
        Message:       "Payment processed successfully",
    }, nil
}

// checkIdempotency å¹‚ç­‰æ€§æ£€æŸ¥
func (s *Service) checkIdempotency(ctx context.Context, key string) error {
    ctx, span := tracer.Start(ctx, "payment.idempotency_check")
    defer span.End()

    exists, err := s.idempotency.CheckKey(ctx, key)
    if err != nil {
        return fmt.Errorf("idempotency check error: %w", err)
    }

    if exists {
        return fmt.Errorf("duplicate request: idempotency key already used")
    }

    // è®°å½•å¹‚ç­‰æ€§é”®
    if err := s.idempotency.StoreKey(ctx, key, 24*time.Hour); err != nil {
        return fmt.Errorf("failed to store idempotency key: %w", err)
    }

    span.SetStatus(codes.Ok, "idempotency check passed")
    return nil
}

// checkRisk é£æ§æ£€æŸ¥
func (s *Service) checkRisk(ctx context.Context, req *PaymentRequest) error {
    ctx, span := tracer.Start(ctx, "payment.risk_check")
    defer span.End()

    result, err := s.riskClient.Evaluate(ctx, &RiskRequest{
        UserID:        req.UserID,
        Amount:        req.Amount,
        PaymentMethod: req.PaymentMethod,
    })
    if err != nil {
        span.RecordError(err)
        return fmt.Errorf("risk evaluation failed: %w", err)
    }

    span.SetAttributes(
        attribute.String("risk.level", result.RiskLevel),
        attribute.Float64("risk.score", result.RiskScore),
    )

    if result.RiskLevel == "high" {
        return fmt.Errorf("payment rejected: high risk detected")
    }

    span.SetStatus(codes.Ok, "risk check passed")
    return nil
}

// deductBalance æ‰£é™¤è´¦æˆ·ä½™é¢
func (s *Service) deductBalance(ctx context.Context, req *PaymentRequest) error {
    ctx, span := tracer.Start(ctx, "payment.balance_deduct")
    defer span.End()

    err := s.accountClient.Deduct(ctx, &DeductRequest{
        UserID:   req.UserID,
        Amount:   req.Amount,
        Currency: req.Currency,
        Reason:   fmt.Sprintf("Payment %s", req.PaymentID),
    })
    if err != nil {
        span.RecordError(err)
        return fmt.Errorf("balance deduction failed: %w", err)
    }

    span.SetStatus(codes.Ok, "balance deducted")
    return nil
}

// refundBalance é€€æ¬¾ï¼ˆå›æ»šï¼‰
func (s *Service) refundBalance(ctx context.Context, req *PaymentRequest) {
    ctx, span := tracer.Start(ctx, "payment.balance_refund")
    defer span.End()

    err := s.accountClient.Refund(ctx, &RefundRequest{
        UserID:   req.UserID,
        Amount:   req.Amount,
        Currency: req.Currency,
        Reason:   fmt.Sprintf("Payment rollback %s", req.PaymentID),
    })
    if err != nil {
        span.RecordError(err)
        // é€€æ¬¾å¤±è´¥éœ€è¦å‘Šè­¦
        span.SetStatus(codes.Error, "refund failed - manual intervention required")
    } else {
        span.SetStatus(codes.Ok, "balance refunded")
    }
}

// processChannel ç¬¬ä¸‰æ–¹æ”¯ä»˜æ¸ é“å¤„ç†
func (s *Service) processChannel(ctx context.Context, req *PaymentRequest) (string, error) {
    ctx, span := tracer.Start(ctx, "payment.channel_process")
    defer span.End()

    result, err := s.channelClient.Pay(ctx, &ChannelRequest{
        PaymentID:     req.PaymentID,
        Amount:        req.Amount,
        Currency:      req.Currency,
        PaymentMethod: req.PaymentMethod,
    })
    if err != nil {
        span.RecordError(err)
        return "", fmt.Errorf("channel payment failed: %w", err)
    }

    span.SetAttributes(attribute.String("transaction.id", result.TransactionID))
    span.SetStatus(codes.Ok, "channel payment successful")
    return result.TransactionID, nil
}

// sendNotification å‘é€æ”¯ä»˜é€šçŸ¥
func (s *Service) sendNotification(ctx context.Context, req *PaymentRequest, txnID string) {
    ctx, span := tracer.Start(ctx, "payment.send_notification")
    defer span.End()

    err := s.notificationClient.Send(ctx, &NotificationRequest{
        UserID:        req.UserID,
        PaymentID:     req.PaymentID,
        TransactionID: txnID,
        Amount:        req.Amount,
        Currency:      req.Currency,
        Status:        "success",
    })
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "notification failed")
    } else {
        span.SetStatus(codes.Ok, "notification sent")
    }
}
```

### 4. è´¦æˆ·æœåŠ¡å®ç°

```go:internal/account/service.go
package account

import (
    "context"
    "fmt"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
    "gorm.io/gorm"
)

var tracer = otel.Tracer("account-service")

type Service struct {
    db *gorm.DB
}

type Account struct {
    ID       string
    UserID   string
    Balance  float64
    Currency string
    Version  int // ä¹è§‚é”ç‰ˆæœ¬å·
}

type DeductRequest struct {
    UserID   string
    Amount   float64
    Currency string
    Reason   string
}

// Deduct æ‰£é™¤ä½™é¢ï¼ˆå¸¦äº‹åŠ¡è¿½è¸ªï¼‰
func (s *Service) Deduct(ctx context.Context, req *DeductRequest) error {
    ctx, span := tracer.Start(ctx, "account.deduct",
        trace.WithAttributes(
            attribute.String("user.id", req.UserID),
            attribute.Float64("amount", req.Amount),
            attribute.String("currency", req.Currency),
        ),
    )
    defer span.End()

    // å¼€å§‹æ•°æ®åº“äº‹åŠ¡
    tx := s.db.WithContext(ctx).Begin()
    txSpan := trace.SpanFromContext(ctx)
    txSpan.AddEvent("database.transaction.begin")

    defer func() {
        if r := recover(); r != nil {
            tx.Rollback()
            txSpan.AddEvent("database.transaction.rollback")
            span.SetStatus(codes.Error, "transaction rolled back due to panic")
        }
    }()

    // 1. æŸ¥è¯¢è´¦æˆ·ï¼ˆå¸¦è¡Œé”ï¼‰
    var account Account
    err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).
        Where("user_id = ? AND currency = ?", req.UserID, req.Currency).
        First(&account).Error
    if err != nil {
        tx.Rollback()
        txSpan.AddEvent("database.transaction.rollback")
        span.RecordError(err)
        span.SetStatus(codes.Error, "account not found")
        return fmt.Errorf("account not found: %w", err)
    }

    span.SetAttributes(
        attribute.String("account.id", account.ID),
        attribute.Float64("account.balance.before", account.Balance),
    )

    // 2. ä½™é¢æ£€æŸ¥
    if account.Balance < req.Amount {
        tx.Rollback()
        txSpan.AddEvent("database.transaction.rollback")
        err := fmt.Errorf("insufficient balance: have %.2f, need %.2f", 
            account.Balance, req.Amount)
        span.RecordError(err)
        span.SetStatus(codes.Error, "insufficient balance")
        return err
    }

    // 3. æ‰£é™¤ä½™é¢ï¼ˆä¹è§‚é”æ›´æ–°ï¼‰
    result := tx.Model(&Account{}).
        Where("id = ? AND version = ?", account.ID, account.Version).
        Updates(map[string]interface{}{
            "balance": gorm.Expr("balance - ?", req.Amount),
            "version": gorm.Expr("version + 1"),
        })

    if result.Error != nil {
        tx.Rollback()
        txSpan.AddEvent("database.transaction.rollback")
        span.RecordError(result.Error)
        span.SetStatus(codes.Error, "failed to update balance")
        return fmt.Errorf("failed to update balance: %w", result.Error)
    }

    if result.RowsAffected == 0 {
        tx.Rollback()
        txSpan.AddEvent("database.transaction.rollback")
        err := fmt.Errorf("concurrent modification detected")
        span.RecordError(err)
        span.SetStatus(codes.Error, "concurrent modification")
        return err
    }

    // 4. è®°å½•äº¤æ˜“æ—¥å¿—
    transaction := &Transaction{
        AccountID: account.ID,
        Amount:    -req.Amount,
        Type:      "deduct",
        Reason:    req.Reason,
    }
    if err := tx.Create(transaction).Error; err != nil {
        tx.Rollback()
        txSpan.AddEvent("database.transaction.rollback")
        span.RecordError(err)
        span.SetStatus(codes.Error, "failed to create transaction log")
        return fmt.Errorf("failed to create transaction log: %w", err)
    }

    // 5. æäº¤äº‹åŠ¡
    if err := tx.Commit().Error; err != nil {
        txSpan.AddEvent("database.transaction.rollback")
        span.RecordError(err)
        span.SetStatus(codes.Error, "failed to commit transaction")
        return fmt.Errorf("failed to commit transaction: %w", err)
    }

    txSpan.AddEvent("database.transaction.commit")
    span.SetAttributes(
        attribute.Float64("account.balance.after", account.Balance-req.Amount),
    )
    span.SetStatus(codes.Ok, "balance deducted successfully")
    return nil
}
```

### 5. å¹‚ç­‰æ€§ç®¡ç†

```go:pkg/idempotency/idempotency.go
package idempotency

import (
    "context"
    "fmt"
    "time"

    "github.com/redis/go-redis/v9"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

var tracer = otel.Tracer("idempotency")

type Manager struct {
    redis *redis.Client
}

func NewManager(redisClient *redis.Client) *Manager {
    return &Manager{redis: redisClient}
}

// CheckKey æ£€æŸ¥å¹‚ç­‰æ€§é”®æ˜¯å¦å­˜åœ¨
func (m *Manager) CheckKey(ctx context.Context, key string) (bool, error) {
    ctx, span := tracer.Start(ctx, "idempotency.check",
        trace.WithAttributes(
            attribute.String("idempotency.key", key),
        ),
    )
    defer span.End()

    exists, err := m.redis.Exists(ctx, m.formatKey(key)).Result()
    if err != nil {
        span.RecordError(err)
        return false, err
    }

    span.SetAttributes(attribute.Bool("idempotency.exists", exists > 0))
    return exists > 0, nil
}

// StoreKey å­˜å‚¨å¹‚ç­‰æ€§é”®
func (m *Manager) StoreKey(ctx context.Context, key string, ttl time.Duration) error {
    ctx, span := tracer.Start(ctx, "idempotency.store",
        trace.WithAttributes(
            attribute.String("idempotency.key", key),
            attribute.Int64("idempotency.ttl", int64(ttl.Seconds())),
        ),
    )
    defer span.End()

    err := m.redis.Set(ctx, m.formatKey(key), time.Now().Unix(), ttl).Err()
    if err != nil {
        span.RecordError(err)
        return err
    }

    return nil
}

func (m *Manager) formatKey(key string) string {
    return fmt.Sprintf("idempotency:%s", key)
}
```

---

## å…³é”®ç‰¹æ€§

### 1. åˆ†å¸ƒå¼è¿½è¸ª

**å®Œæ•´çš„æ”¯ä»˜é“¾è·¯è¿½è¸ª**:

```text
payment.request
â”œâ”€â”€ risk.check
â”‚   â””â”€â”€ risk.evaluate
â”œâ”€â”€ account.deduct
â”‚   â”œâ”€â”€ database.transaction.begin
â”‚   â”œâ”€â”€ database.query (SELECT ... FOR UPDATE)
â”‚   â”œâ”€â”€ database.update (UPDATE balance)
â”‚   â”œâ”€â”€ database.insert (INSERT transaction_log)
â”‚   â””â”€â”€ database.transaction.commit
â”œâ”€â”€ channel.pay
â”‚   â””â”€â”€ http.client (POST to external API)
â””â”€â”€ notification.send
    â””â”€â”€ kafka.produce
```

**Trace Context ä¼ æ’­**:

- HTTP Headers: `traceparent`, `tracestate`
- Baggage: `user_id`, `request_id`, `session_id`

### 2. æŒ‡æ ‡ç›‘æ§

```go
// å…³é”®æŒ‡æ ‡
payment.requests.total          // æ”¯ä»˜è¯·æ±‚æ€»æ•°
payment.duration                // æ”¯ä»˜å¤„ç†å»¶è¿Ÿ
payment.success_rate            // æ”¯ä»˜æˆåŠŸç‡
account.balance.operations      // è´¦æˆ·æ“ä½œæ¬¡æ•°
risk.rejection_rate             // é£æ§æ‹’ç»ç‡
channel.latency                 // ç¬¬ä¸‰æ–¹æ¸ é“å»¶è¿Ÿ
```

### 3. å¹‚ç­‰æ€§ä¿è¯

```go
// Redis å¹‚ç­‰æ€§é”®
idempotency:{key}  TTL=24h

// æ£€æŸ¥æµç¨‹
1. æ£€æŸ¥ key æ˜¯å¦å­˜åœ¨
2. å¦‚æœå­˜åœ¨ â†’ è¿”å› 409 Conflict
3. å¦‚æœä¸å­˜åœ¨ â†’ å­˜å‚¨ key + å¤„ç†è¯·æ±‚
```

### 4. è¶…æ—¶æ§åˆ¶

```go
// ä¸Šä¸‹æ–‡è¶…æ—¶
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

// åˆ†çº§è¶…æ—¶
Gateway:     10s
Payment:     5s
Account:     2s
Risk:        1s
Channel:     3s
```

---

## ç›‘æ§ä¸å‘Šè­¦

### Prometheus æŸ¥è¯¢ç¤ºä¾‹

```promql
# æ”¯ä»˜æˆåŠŸç‡
rate(payment_requests_total{status="success"}[5m]) / 
rate(payment_requests_total[5m])

# P99 å»¶è¿Ÿ
histogram_quantile(0.99, rate(payment_duration_bucket[5m]))

# é”™è¯¯ç‡
rate(payment_requests_total{status="failed"}[5m])

# è´¦æˆ·å¹¶å‘å†²çªç‡
rate(account_concurrent_modification_total[5m])
```

### Grafana Dashboard

```yaml
panels:
  - title: Payment Success Rate
    type: graph
    query: rate(payment_requests_total{status="success"}[5m])
    
  - title: Payment Latency (P50/P95/P99)
    type: graph
    queries:
      - histogram_quantile(0.50, rate(payment_duration_bucket[5m]))
      - histogram_quantile(0.95, rate(payment_duration_bucket[5m]))
      - histogram_quantile(0.99, rate(payment_duration_bucket[5m]))
      
  - title: Error Rate by Service
    type: graph
    query: rate(payment_errors_total[5m]) by (service)
```

### å‘Šè­¦è§„åˆ™

```yaml
groups:
  - name: payment_alerts
    rules:
      - alert: HighErrorRate
        expr: rate(payment_requests_total{status="failed"}[5m]) > 0.05
        for: 2m
        annotations:
          summary: "High payment error rate detected"
          
      - alert: HighLatency
        expr: histogram_quantile(0.99, rate(payment_duration_bucket[5m])) > 1000
        for: 5m
        annotations:
          summary: "Payment P99 latency > 1s"
          
      - alert: LowSuccessRate
        expr: rate(payment_requests_total{status="success"}[5m]) / rate(payment_requests_total[5m]) < 0.95
        for: 5m
        annotations:
          summary: "Payment success rate < 95%"
```

---

## éƒ¨ç½²é…ç½®

### Docker Compose

```yaml:deployments/docker-compose.yml
version: '3.8'

services:
  # OpenTelemetry Collector
  otel-collector:
    image: otel/opentelemetry-collector-contrib:0.96.0
    command: ["--config=/etc/otel-collector-config.yaml"]
    volumes:
      - ./otel-collector-config.yaml:/etc/otel-collector-config.yaml
    ports:
      - "4317:4317"   # OTLP gRPC
      - "4318:4318"   # OTLP HTTP
      - "8888:8888"   # Prometheus metrics
      - "8889:8889"   # Prometheus exporter

  # Jaeger
  jaeger:
    image: jaegertracing/all-in-one:1.54
    ports:
      - "16686:16686"  # UI
      - "14250:14250"  # gRPC

  # Prometheus
  prometheus:
    image: prom/prometheus:v2.49.0
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - "9090:9090"

  # Grafana
  grafana:
    image: grafana/grafana:10.3.0
    ports:
      - "3000:3000"
    environment:
      - GF_AUTH_ANONYMOUS_ENABLED=true

  # PostgreSQL
  postgres:
    image: postgres:16
    environment:
      POSTGRES_PASSWORD: password
      POSTGRES_DB: payment
    ports:
      - "5432:5432"

  # Redis
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  # Kafka
  kafka:
    image: confluentinc/cp-kafka:7.6.0
    environment:
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
    ports:
      - "9092:9092"

  zookeeper:
    image: confluentinc/cp-zookeeper:7.6.0
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181

  # Payment Services
  gateway:
    build: ./cmd/gateway
    ports:
      - "8080:8080"
    environment:
      OTEL_EXPORTER_OTLP_ENDPOINT: "otel-collector:4317"
      
  payment:
    build: ./cmd/payment
    environment:
      OTEL_EXPORTER_OTLP_ENDPOINT: "otel-collector:4317"
      
  account:
    build: ./cmd/account
    environment:
      OTEL_EXPORTER_OTLP_ENDPOINT: "otel-collector:4317"
```

---

## æµ‹è¯•éªŒè¯

### 1. å‹åŠ›æµ‹è¯•

```bash
# ä½¿ç”¨ wrk è¿›è¡Œå‹åŠ›æµ‹è¯•
wrk -t12 -c400 -d30s \
  -H "Content-Type: application/json" \
  -s payment-test.lua \
  http://localhost:8080/api/v1/payment
```

**payment-test.lua**:

```lua
request = function()
    local body = string.format([[
        {
            "payment_id": "PAY_%d",
            "user_id": "USER_%d",
            "amount": %.2f,
            "currency": "USD",
            "payment_method": "credit_card",
            "idempotency_key": "KEY_%d"
        }
    ]], 
    math.random(1, 100000),
    math.random(1, 1000),
    math.random(1, 1000) / 100.0,
    math.random(1, 100000))
    
    return wrk.format("POST", "/api/v1/payment", nil, body)
end
```

### 2. éªŒè¯è¿½è¸ª

```bash
# è®¿é—® Jaeger UI
open http://localhost:16686

# æœç´¢ Service: payment-service
# æŸ¥çœ‹å®Œæ•´çš„æ”¯ä»˜é“¾è·¯è¿½è¸ª
```

### 3. éªŒè¯æŒ‡æ ‡

```bash
# è®¿é—® Prometheus
open http://localhost:9090

# æŸ¥è¯¢æ”¯ä»˜æˆåŠŸç‡
rate(payment_requests_total{status="success"}[5m])

# æŸ¥è¯¢ P99 å»¶è¿Ÿ
histogram_quantile(0.99, rate(payment_duration_bucket[5m]))
```

---

## æœ€ä½³å®è·µæ€»ç»“

### 1. è¿½è¸ªæœ€ä½³å®è·µ

âœ… **DO**:

- ä½¿ç”¨æœ‰æ„ä¹‰çš„ Span åç§°ï¼ˆå¦‚ `payment.process`, `account.deduct`ï¼‰
- æ·»åŠ å…³é”®ä¸šåŠ¡å±æ€§ï¼ˆå¦‚ `payment.id`, `user.id`, `amount`ï¼‰
- è®°å½•é‡è¦äº‹ä»¶ï¼ˆå¦‚ `transaction.begin`, `transaction.commit`ï¼‰
- ä½¿ç”¨ Baggage ä¼ é€’ç”¨æˆ·ä¿¡æ¯å’Œè¯·æ±‚ID

âŒ **DON'T**:

- ä¸è¦åœ¨ Span ä¸­å­˜å‚¨æ•æ„Ÿä¿¡æ¯ï¼ˆå¦‚å¯†ç ã€Tokenï¼‰
- ä¸è¦åˆ›å»ºè¿‡å¤šçš„ Spanï¼ˆå½±å“æ€§èƒ½ï¼‰
- ä¸è¦å¿˜è®°è°ƒç”¨ `span.End()`

### 2. æŒ‡æ ‡æœ€ä½³å®è·µ

âœ… **DO**:

- ä½¿ç”¨æ ‡å‡†çš„ Metric ç±»å‹ï¼ˆCounter, Histogram, Gaugeï¼‰
- æ·»åŠ æœ‰æ„ä¹‰çš„æ ‡ç­¾ï¼ˆå¦‚ `status`, `payment_method`ï¼‰
- ä½¿ç”¨ Histogram è®°å½•å»¶è¿Ÿåˆ†å¸ƒ
- å®šæœŸè®¡ç®—èšåˆæŒ‡æ ‡ï¼ˆå¦‚æˆåŠŸç‡ï¼‰

âŒ **DON'T**:

- ä¸è¦ä½¿ç”¨é«˜åŸºæ•°æ ‡ç­¾ï¼ˆå¦‚ `payment_id`ï¼‰
- ä¸è¦é¢‘ç¹åˆ›å»ºæ–°çš„ Metricï¼ˆæ€§èƒ½é—®é¢˜ï¼‰

### 3. æ€§èƒ½ä¼˜åŒ–

- âœ… ä½¿ç”¨æ‰¹å¤„ç†å¯¼å‡ºï¼ˆ`WithBatchTimeout`, `WithMaxExportBatchSize`ï¼‰
- âœ… é…ç½®åˆç†çš„é‡‡æ ·ç‡ï¼ˆç”Ÿäº§ç¯å¢ƒ 10%-20%ï¼‰
- âœ… ä½¿ç”¨è¿æ¥æ± ï¼ˆgRPC, HTTP, Databaseï¼‰
- âœ… å¯ç”¨å‹ç¼©ï¼ˆgRPC gzipï¼‰
- âœ… å¼‚æ­¥å‘é€é€šçŸ¥ï¼ˆä½¿ç”¨ `context.WithoutCancel`ï¼‰

### 4. å¯é æ€§ä¿éšœ

- âœ… å¹‚ç­‰æ€§ä¿è¯ï¼ˆRedis å­˜å‚¨å¹‚ç­‰æ€§é”®ï¼‰
- âœ… äº‹åŠ¡ä¸€è‡´æ€§ï¼ˆæ•°æ®åº“ ACID äº‹åŠ¡ + ä¹è§‚é”ï¼‰
- âœ… è¶…æ—¶æ§åˆ¶ï¼ˆåˆ†çº§è¶…æ—¶ç­–ç•¥ï¼‰
- âœ… é™æµç†”æ–­ï¼ˆä¸­é—´ä»¶ä¿æŠ¤ï¼‰
- âœ… ä¼˜é›…é™çº§ï¼ˆé£æ§å¤±è´¥æ—¶ä»å¯å¤„ç†ä½é£é™©æ”¯ä»˜ï¼‰

---

## ğŸ¯ å­¦åˆ°çš„å…³é”®çŸ¥è¯†ç‚¹

1. âœ… **åˆ†å¸ƒå¼è¿½è¸ª**: è·¨æœåŠ¡ã€è·¨ä¸­é—´ä»¶çš„å®Œæ•´é“¾è·¯è¿½è¸ª
2. âœ… **äº‹åŠ¡è¿½è¸ª**: æ•°æ®åº“äº‹åŠ¡çš„ç»†ç²’åº¦è¿½è¸ª
3. âœ… **ä¸Šä¸‹æ–‡ä¼ æ’­**: HTTP Headers + Baggage ä¼ æ’­ç”¨æˆ·ä¿¡æ¯
4. âœ… **æŒ‡æ ‡ç›‘æ§**: æ”¯ä»˜æˆåŠŸç‡ã€å»¶è¿Ÿã€é”™è¯¯ç‡çš„å®æ—¶ç›‘æ§
5. âœ… **å¹‚ç­‰æ€§**: ä½¿ç”¨ Redis å®ç°åˆ†å¸ƒå¼å¹‚ç­‰æ€§
6. âœ… **è¶…æ—¶æ§åˆ¶**: åˆ†çº§è¶…æ—¶ç­–ç•¥
7. âœ… **é”™è¯¯å¤„ç†**: è‡ªåŠ¨å›æ»šä¸å‘Šè­¦
8. âœ… **æ€§èƒ½ä¼˜åŒ–**: æ‰¹å¤„ç†ã€é‡‡æ ·ã€è¿æ¥æ± 

---

**ğŸŠ æ­å–œï¼** æ‚¨å·²ç»æŒæ¡äº†ç”Ÿäº§çº§åˆ†å¸ƒå¼æ”¯ä»˜ç³»ç»Ÿçš„ OpenTelemetry å®Œæ•´é›†æˆï¼

**ä¸‹ä¸€æ­¥**:

- ğŸ“š [é«˜å¹¶å‘åº“å­˜ç³»ç»Ÿ](./03_é«˜å¹¶å‘åº“å­˜ç³»ç»Ÿ.md)
- ğŸ“š [å¤šäº‘ç¯å¢ƒéƒ¨ç½²](./04_å¤šäº‘ç¯å¢ƒéƒ¨ç½².md)
- ğŸ“š [é…ç½®æ¨¡æ¿åº“](../é…ç½®æ¨¡æ¿/)
