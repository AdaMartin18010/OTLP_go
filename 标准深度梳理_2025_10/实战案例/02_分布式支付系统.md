# 实战案例：分布式支付系统完整 OTLP 集成

> **场景**: 高可用分布式支付处理系统  
> **技术栈**: Go 1.25.1, Gin, GORM, Redis, Kafka, PostgreSQL  
> **特性**: 事务一致性、幂等性、超时控制、限流熔断、完整追踪  
> **OpenTelemetry**: v1.32.0+  
> **难度**: ⭐⭐⭐⭐⭐ (生产级)

---

## 📋 目录

- [实战案例：分布式支付系统完整 OTLP 集成](#实战案例分布式支付系统完整-otlp-集成)
  - [📋 目录](#-目录)
  - [系统概述](#系统概述)
    - [业务场景](#业务场景)
    - [系统要求](#系统要求)
    - [OpenTelemetry 集成目标](#opentelemetry-集成目标)
  - [架构设计](#架构设计)
    - [系统架构图](#系统架构图)
    - [数据流](#数据流)
  - [项目结构](#项目结构)
  - [核心服务实现](#核心服务实现)
    - [1. Telemetry 初始化](#1-telemetry-初始化)
    - [2. 追踪中间件](#2-追踪中间件)
    - [3. 支付服务实现](#3-支付服务实现)
    - [4. 账户服务实现](#4-账户服务实现)
    - [5. 幂等性管理](#5-幂等性管理)
  - [关键特性](#关键特性)
    - [1. 分布式追踪](#1-分布式追踪)
    - [2. 指标监控](#2-指标监控)
    - [3. 幂等性保证](#3-幂等性保证)
    - [4. 超时控制](#4-超时控制)
  - [监控与告警](#监控与告警)
    - [Prometheus 查询示例](#prometheus-查询示例)
    - [Grafana Dashboard](#grafana-dashboard)
    - [告警规则](#告警规则)
  - [部署配置](#部署配置)
    - [Docker Compose](#docker-compose)
  - [测试验证](#测试验证)
    - [1. 压力测试](#1-压力测试)
    - [2. 验证追踪](#2-验证追踪)
    - [3. 验证指标](#3-验证指标)
  - [最佳实践总结](#最佳实践总结)
    - [1. 追踪最佳实践](#1-追踪最佳实践)
    - [2. 指标最佳实践](#2-指标最佳实践)
    - [3. 性能优化](#3-性能优化)
    - [4. 可靠性保障](#4-可靠性保障)
  - [🎯 学到的关键知识点](#-学到的关键知识点)

---

## 系统概述

### 业务场景

分布式支付系统处理以下支付流程：

```text
用户发起支付
    ↓
支付网关 (API Gateway)
    ↓
支付服务 (Payment Service)
    ├→ 账户服务 (Account Service) - 余额检查与扣款
    ├→ 风控服务 (Risk Service) - 风险评估
    ├→ 渠道服务 (Channel Service) - 第三方支付
    └→ 通知服务 (Notification Service) - 支付结果通知
```

### 系统要求

- ✅ **高可用**: 99.99% SLA
- ✅ **高性能**: P99 < 200ms
- ✅ **强一致性**: ACID 事务保证
- ✅ **幂等性**: 防止重复支付
- ✅ **可追踪**: 完整的分布式追踪
- ✅ **可观测**: 实时监控与告警

### OpenTelemetry 集成目标

- 🎯 **Traces**: 支付链路完整追踪（跨服务、跨中间件）
- 🎯 **Metrics**: 支付成功率、延迟、TPS 监控
- 🎯 **Logs**: 结构化日志与 Trace 关联
- 🎯 **Context**: 跨服务上下文传播（含用户信息、请求ID）

---

## 架构设计

### 系统架构图

```text
┌─────────────────────────────────────────────────────────┐
│                     Client (Web/Mobile)                  │
└─────────────────────┬───────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────┐
│                  Payment Gateway (Gin)                   │
│  - Rate Limiting                                         │
│  - Authentication                                        │
│  - Request Validation                                    │
└─────────────────────┬───────────────────────────────────┘
                      │
        ┌─────────────┼─────────────┐
        ▼             ▼             ▼
┌──────────────┐ ┌──────────────┐ ┌──────────────┐
│   Payment    │ │     Risk     │ │   Channel    │
│   Service    │ │   Service    │ │   Service    │
└──────┬───────┘ └──────┬───────┘ └──────┬───────┘
       │                │                │
       ├────────────────┴────────────────┤
       ▼                                 ▼
┌──────────────┐                  ┌──────────────┐
│   Account    │                  │ Notification │
│   Service    │                  │   Service    │
└──────┬───────┘                  └──────────────┘
       │
┌──────┴───────────────────────────────────────────┐
│                  Data Layer                       │
│  PostgreSQL  │  Redis  │  Kafka                  │
└───────────────────────────────────────────────────┘

                      ▼
┌───────────────────────────────────────────────────┐
│           OpenTelemetry Collector                 │
│  - Traces   - Metrics   - Logs                    │
└─────────────────────┬─────────────────────────────┘
                      │
        ┌─────────────┼─────────────┐
        ▼             ▼             ▼
   ┌────────┐    ┌────────┐    ┌────────┐
   │ Jaeger │    │Prometheus│  │  Loki  │
   └────────┘    └────────┘    └────────┘
```

### 数据流

```text
1. 支付请求
   Client → Gateway → Payment Service
   [Span: payment.request] [Baggage: user_id, request_id]

2. 风控检查
   Payment → Risk Service
   [Span: risk.check] [Links: payment.request]

3. 余额检查与扣款
   Payment → Account Service → PostgreSQL
   [Span: account.deduct] [DB spans] [Transaction trace]

4. 第三方支付
   Payment → Channel Service → External API
   [Span: channel.pay] [HTTP client spans]

5. 支付结果通知
   Payment → Kafka → Notification Service
   [Span: notification.send] [Messaging spans]

6. 响应返回
   Payment → Gateway → Client
   [Span end] [Metrics recorded]
```

---

## 项目结构

```text
payment-system/
├── cmd/
│   ├── gateway/           # API 网关
│   │   └── main.go
│   ├── payment/           # 支付服务
│   │   └── main.go
│   ├── account/           # 账户服务
│   │   └── main.go
│   ├── risk/              # 风控服务
│   │   └── main.go
│   ├── channel/           # 渠道服务
│   │   └── main.go
│   └── notification/      # 通知服务
│       └── main.go
│
├── internal/
│   ├── telemetry/         # OpenTelemetry 初始化
│   │   ├── tracer.go
│   │   ├── meter.go
│   │   ├── logger.go
│   │   └── propagation.go
│   │
│   ├── middleware/        # 中间件
│   │   ├── tracing.go     # 追踪中间件
│   │   ├── metrics.go     # 指标中间件
│   │   ├── logging.go     # 日志中间件
│   │   ├── ratelimit.go   # 限流中间件
│   │   └── circuit.go     # 熔断中间件
│   │
│   ├── payment/           # 支付服务实现
│   │   ├── handler.go     # HTTP 处理器
│   │   ├── service.go     # 业务逻辑
│   │   ├── repository.go  # 数据访问
│   │   └── models.go      # 数据模型
│   │
│   ├── account/           # 账户服务实现
│   ├── risk/              # 风控服务实现
│   ├── channel/           # 渠道服务实现
│   └── notification/      # 通知服务实现
│
├── pkg/
│   ├── client/            # 服务客户端
│   │   ├── account.go
│   │   ├── risk.go
│   │   └── channel.go
│   │
│   ├── idempotency/       # 幂等性实现
│   │   └── idempotency.go
│   │
│   └── transaction/       # 分布式事务
│       └── saga.go
│
├── config/
│   ├── dev.yaml           # 开发环境配置
│   ├── prod.yaml          # 生产环境配置
│   └── otel.yaml          # OTLP 配置
│
├── deployments/
│   ├── docker-compose.yml # 本地部署
│   └── k8s/               # Kubernetes 部署
│
├── go.mod
└── go.sum
```

---

## 核心服务实现

### 1. Telemetry 初始化

```go:internal/telemetry/tracer.go
package telemetry

import (
    "context"
    "fmt"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
    "go.opentelemetry.io/otel/trace"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
)

type Config struct {
    ServiceName    string
    ServiceVersion string
    Environment    string
    OTLPEndpoint   string
}

type Telemetry struct {
    TracerProvider *sdktrace.TracerProvider
    Tracer         trace.Tracer
}

// InitTracer 初始化追踪器
func InitTracer(ctx context.Context, cfg Config) (*Telemetry, error) {
    // 创建 Resource
    res, err := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceNameKey.String(cfg.ServiceName),
            semconv.ServiceVersionKey.String(cfg.ServiceVersion),
            semconv.DeploymentEnvironmentKey.String(cfg.Environment),
        ),
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create resource: %w", err)
    }

    // 创建 OTLP Exporter
    conn, err := grpc.NewClient(
        cfg.OTLPEndpoint,
        grpc.WithTransportCredentials(insecure.NewCredentials()),
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create gRPC client: %w", err)
    }

    exporter, err := otlptracegrpc.New(ctx, otlptracegrpc.WithGRPCConn(conn))
    if err != nil {
        return nil, fmt.Errorf("failed to create OTLP exporter: %w", err)
    }

    // 创建 TracerProvider
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter,
            sdktrace.WithBatchTimeout(time.Second),
            sdktrace.WithMaxExportBatchSize(512),
        ),
        sdktrace.WithResource(res),
        // 生产环境采样策略
        sdktrace.WithSampler(sdktrace.ParentBased(
            sdktrace.TraceIDRatioBased(0.1), // 10% 采样率
        )),
    )

    // 设置全局 TracerProvider
    otel.SetTracerProvider(tp)

    // 设置全局 Propagator（支持 W3C Trace Context 和 Baggage）
    otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
        propagation.TraceContext{},
        propagation.Baggage{},
    ))

    return &Telemetry{
        TracerProvider: tp,
        Tracer:         tp.Tracer(cfg.ServiceName),
    }, nil
}

// Shutdown 关闭追踪器
func (t *Telemetry) Shutdown(ctx context.Context) error {
    return t.TracerProvider.Shutdown(ctx)
}
```

### 2. 追踪中间件

```go:internal/middleware/tracing.go
package middleware

import (
    "fmt"

    "github.com/gin-gonic/gin"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/baggage"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/propagation"
    semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
    "go.opentelemetry.io/otel/trace"
)

// TracingMiddleware 创建追踪中间件
func TracingMiddleware(serviceName string) gin.HandlerFunc {
    tracer := otel.Tracer(serviceName)
    propagator := otel.GetTextMapPropagator()

    return func(c *gin.Context) {
        // 从 HTTP Headers 提取上下文
        ctx := propagator.Extract(c.Request.Context(), propagation.HeaderCarrier(c.Request.Header))

        // 创建 Span
        spanName := fmt.Sprintf("%s %s", c.Request.Method, c.FullPath())
        ctx, span := tracer.Start(ctx, spanName,
            trace.WithSpanKind(trace.SpanKindServer),
            trace.WithAttributes(
                semconv.HTTPMethodKey.String(c.Request.Method),
                semconv.HTTPURLKey.String(c.Request.URL.String()),
                semconv.HTTPRouteKey.String(c.FullPath()),
                semconv.HTTPTargetKey.String(c.Request.URL.Path),
                semconv.HTTPSchemeKey.String(c.Request.URL.Scheme),
                semconv.NetHostNameKey.String(c.Request.Host),
                semconv.HTTPUserAgentKey.String(c.Request.UserAgent()),
                semconv.HTTPClientIPKey.String(c.ClientIP()),
            ),
        )
        defer span.End()

        // 将上下文存储到 Gin Context
        c.Request = c.Request.WithContext(ctx)

        // 处理请求
        c.Next()

        // 记录响应状态
        status := c.Writer.Status()
        span.SetAttributes(
            semconv.HTTPStatusCodeKey.Int(status),
            attribute.Int("http.response.body.size", c.Writer.Size()),
        )

        // 如果有错误，记录错误信息
        if status >= 400 {
            span.SetStatus(codes.Error, fmt.Sprintf("HTTP %d", status))
            if len(c.Errors) > 0 {
                span.RecordError(c.Errors.Last())
            }
        } else {
            span.SetStatus(codes.Ok, "success")
        }
    }
}

// ExtractBaggage 提取 Baggage 信息
func ExtractBaggage(c *gin.Context) map[string]string {
    ctx := c.Request.Context()
    bag := baggage.FromContext(ctx)
    
    result := make(map[string]string)
    for _, member := range bag.Members() {
        result[member.Key()] = member.Value()
    }
    return result
}

// SetBaggage 设置 Baggage
func SetBaggage(c *gin.Context, key, value string) error {
    ctx := c.Request.Context()
    bag := baggage.FromContext(ctx)
    
    member, err := baggage.NewMember(key, value)
    if err != nil {
        return err
    }
    
    bag, err = bag.SetMember(member)
    if err != nil {
        return err
    }
    
    c.Request = c.Request.WithContext(baggage.ContextWithBaggage(ctx, bag))
    return nil
}
```

### 3. 支付服务实现

```go:internal/payment/service.go
package payment

import (
    "context"
    "fmt"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
)

var (
    tracer = otel.Tracer("payment-service")
    meter  = otel.Meter("payment-service")
)

// Metrics
var (
    paymentCounter     metric.Int64Counter
    paymentDuration    metric.Float64Histogram
    paymentSuccessRate metric.Float64Gauge
)

func init() {
    var err error
    
    paymentCounter, err = meter.Int64Counter(
        "payment.requests.total",
        metric.WithDescription("Total number of payment requests"),
        metric.WithUnit("{request}"),
    )
    if err != nil {
        panic(err)
    }

    paymentDuration, err = meter.Float64Histogram(
        "payment.duration",
        metric.WithDescription("Payment processing duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        panic(err)
    }

    paymentSuccessRate, err = meter.Float64Gauge(
        "payment.success_rate",
        metric.WithDescription("Payment success rate"),
        metric.WithUnit("1"),
    )
    if err != nil {
        panic(err)
    }
}

type Service struct {
    accountClient      *AccountClient
    riskClient         *RiskClient
    channelClient      *ChannelClient
    notificationClient *NotificationClient
    repository         *Repository
    idempotency        *IdempotencyManager
}

type PaymentRequest struct {
    PaymentID     string
    UserID        string
    Amount        float64
    Currency      string
    PaymentMethod string
    IdempotencyKey string
}

type PaymentResponse struct {
    PaymentID     string
    Status        string
    TransactionID string
    Message       string
}

// ProcessPayment 处理支付请求
func (s *Service) ProcessPayment(ctx context.Context, req *PaymentRequest) (*PaymentResponse, error) {
    startTime := time.Now()
    
    ctx, span := tracer.Start(ctx, "payment.process",
        trace.WithAttributes(
            attribute.String("payment.id", req.PaymentID),
            attribute.String("user.id", req.UserID),
            attribute.Float64("payment.amount", req.Amount),
            attribute.String("payment.currency", req.Currency),
            attribute.String("payment.method", req.PaymentMethod),
        ),
    )
    defer span.End()

    // 记录 Metric
    defer func() {
        duration := time.Since(startTime).Milliseconds()
        paymentDuration.Record(ctx, float64(duration),
            metric.WithAttributes(
                attribute.String("payment.method", req.PaymentMethod),
            ),
        )
    }()

    // 1. 幂等性检查
    if err := s.checkIdempotency(ctx, req.IdempotencyKey); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "idempotency check failed")
        paymentCounter.Add(ctx, 1, metric.WithAttributes(
            attribute.String("status", "duplicate"),
        ))
        return nil, err
    }

    // 2. 风控检查
    if err := s.checkRisk(ctx, req); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "risk check failed")
        paymentCounter.Add(ctx, 1, metric.WithAttributes(
            attribute.String("status", "rejected"),
        ))
        return nil, err
    }

    // 3. 账户余额检查与扣款
    if err := s.deductBalance(ctx, req); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "balance deduction failed")
        paymentCounter.Add(ctx, 1, metric.WithAttributes(
            attribute.String("status", "failed"),
        ))
        return nil, err
    }

    // 4. 第三方支付渠道
    txnID, err := s.processChannel(ctx, req)
    if err != nil {
        // 扣款失败，回滚
        s.refundBalance(ctx, req)
        span.RecordError(err)
        span.SetStatus(codes.Error, "channel payment failed")
        paymentCounter.Add(ctx, 1, metric.WithAttributes(
            attribute.String("status", "failed"),
        ))
        return nil, err
    }

    // 5. 发送支付成功通知
    go s.sendNotification(context.WithoutCancel(ctx), req, txnID)

    // 6. 记录支付成功
    span.SetStatus(codes.Ok, "payment successful")
    span.SetAttributes(attribute.String("transaction.id", txnID))
    paymentCounter.Add(ctx, 1, metric.WithAttributes(
        attribute.String("status", "success"),
    ))

    return &PaymentResponse{
        PaymentID:     req.PaymentID,
        Status:        "success",
        TransactionID: txnID,
        Message:       "Payment processed successfully",
    }, nil
}

// checkIdempotency 幂等性检查
func (s *Service) checkIdempotency(ctx context.Context, key string) error {
    ctx, span := tracer.Start(ctx, "payment.idempotency_check")
    defer span.End()

    exists, err := s.idempotency.CheckKey(ctx, key)
    if err != nil {
        return fmt.Errorf("idempotency check error: %w", err)
    }

    if exists {
        return fmt.Errorf("duplicate request: idempotency key already used")
    }

    // 记录幂等性键
    if err := s.idempotency.StoreKey(ctx, key, 24*time.Hour); err != nil {
        return fmt.Errorf("failed to store idempotency key: %w", err)
    }

    span.SetStatus(codes.Ok, "idempotency check passed")
    return nil
}

// checkRisk 风控检查
func (s *Service) checkRisk(ctx context.Context, req *PaymentRequest) error {
    ctx, span := tracer.Start(ctx, "payment.risk_check")
    defer span.End()

    result, err := s.riskClient.Evaluate(ctx, &RiskRequest{
        UserID:        req.UserID,
        Amount:        req.Amount,
        PaymentMethod: req.PaymentMethod,
    })
    if err != nil {
        span.RecordError(err)
        return fmt.Errorf("risk evaluation failed: %w", err)
    }

    span.SetAttributes(
        attribute.String("risk.level", result.RiskLevel),
        attribute.Float64("risk.score", result.RiskScore),
    )

    if result.RiskLevel == "high" {
        return fmt.Errorf("payment rejected: high risk detected")
    }

    span.SetStatus(codes.Ok, "risk check passed")
    return nil
}

// deductBalance 扣除账户余额
func (s *Service) deductBalance(ctx context.Context, req *PaymentRequest) error {
    ctx, span := tracer.Start(ctx, "payment.balance_deduct")
    defer span.End()

    err := s.accountClient.Deduct(ctx, &DeductRequest{
        UserID:   req.UserID,
        Amount:   req.Amount,
        Currency: req.Currency,
        Reason:   fmt.Sprintf("Payment %s", req.PaymentID),
    })
    if err != nil {
        span.RecordError(err)
        return fmt.Errorf("balance deduction failed: %w", err)
    }

    span.SetStatus(codes.Ok, "balance deducted")
    return nil
}

// refundBalance 退款（回滚）
func (s *Service) refundBalance(ctx context.Context, req *PaymentRequest) {
    ctx, span := tracer.Start(ctx, "payment.balance_refund")
    defer span.End()

    err := s.accountClient.Refund(ctx, &RefundRequest{
        UserID:   req.UserID,
        Amount:   req.Amount,
        Currency: req.Currency,
        Reason:   fmt.Sprintf("Payment rollback %s", req.PaymentID),
    })
    if err != nil {
        span.RecordError(err)
        // 退款失败需要告警
        span.SetStatus(codes.Error, "refund failed - manual intervention required")
    } else {
        span.SetStatus(codes.Ok, "balance refunded")
    }
}

// processChannel 第三方支付渠道处理
func (s *Service) processChannel(ctx context.Context, req *PaymentRequest) (string, error) {
    ctx, span := tracer.Start(ctx, "payment.channel_process")
    defer span.End()

    result, err := s.channelClient.Pay(ctx, &ChannelRequest{
        PaymentID:     req.PaymentID,
        Amount:        req.Amount,
        Currency:      req.Currency,
        PaymentMethod: req.PaymentMethod,
    })
    if err != nil {
        span.RecordError(err)
        return "", fmt.Errorf("channel payment failed: %w", err)
    }

    span.SetAttributes(attribute.String("transaction.id", result.TransactionID))
    span.SetStatus(codes.Ok, "channel payment successful")
    return result.TransactionID, nil
}

// sendNotification 发送支付通知
func (s *Service) sendNotification(ctx context.Context, req *PaymentRequest, txnID string) {
    ctx, span := tracer.Start(ctx, "payment.send_notification")
    defer span.End()

    err := s.notificationClient.Send(ctx, &NotificationRequest{
        UserID:        req.UserID,
        PaymentID:     req.PaymentID,
        TransactionID: txnID,
        Amount:        req.Amount,
        Currency:      req.Currency,
        Status:        "success",
    })
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "notification failed")
    } else {
        span.SetStatus(codes.Ok, "notification sent")
    }
}
```

### 4. 账户服务实现

```go:internal/account/service.go
package account

import (
    "context"
    "fmt"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
    "gorm.io/gorm"
)

var tracer = otel.Tracer("account-service")

type Service struct {
    db *gorm.DB
}

type Account struct {
    ID       string
    UserID   string
    Balance  float64
    Currency string
    Version  int // 乐观锁版本号
}

type DeductRequest struct {
    UserID   string
    Amount   float64
    Currency string
    Reason   string
}

// Deduct 扣除余额（带事务追踪）
func (s *Service) Deduct(ctx context.Context, req *DeductRequest) error {
    ctx, span := tracer.Start(ctx, "account.deduct",
        trace.WithAttributes(
            attribute.String("user.id", req.UserID),
            attribute.Float64("amount", req.Amount),
            attribute.String("currency", req.Currency),
        ),
    )
    defer span.End()

    // 开始数据库事务
    tx := s.db.WithContext(ctx).Begin()
    txSpan := trace.SpanFromContext(ctx)
    txSpan.AddEvent("database.transaction.begin")

    defer func() {
        if r := recover(); r != nil {
            tx.Rollback()
            txSpan.AddEvent("database.transaction.rollback")
            span.SetStatus(codes.Error, "transaction rolled back due to panic")
        }
    }()

    // 1. 查询账户（带行锁）
    var account Account
    err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).
        Where("user_id = ? AND currency = ?", req.UserID, req.Currency).
        First(&account).Error
    if err != nil {
        tx.Rollback()
        txSpan.AddEvent("database.transaction.rollback")
        span.RecordError(err)
        span.SetStatus(codes.Error, "account not found")
        return fmt.Errorf("account not found: %w", err)
    }

    span.SetAttributes(
        attribute.String("account.id", account.ID),
        attribute.Float64("account.balance.before", account.Balance),
    )

    // 2. 余额检查
    if account.Balance < req.Amount {
        tx.Rollback()
        txSpan.AddEvent("database.transaction.rollback")
        err := fmt.Errorf("insufficient balance: have %.2f, need %.2f", 
            account.Balance, req.Amount)
        span.RecordError(err)
        span.SetStatus(codes.Error, "insufficient balance")
        return err
    }

    // 3. 扣除余额（乐观锁更新）
    result := tx.Model(&Account{}).
        Where("id = ? AND version = ?", account.ID, account.Version).
        Updates(map[string]interface{}{
            "balance": gorm.Expr("balance - ?", req.Amount),
            "version": gorm.Expr("version + 1"),
        })

    if result.Error != nil {
        tx.Rollback()
        txSpan.AddEvent("database.transaction.rollback")
        span.RecordError(result.Error)
        span.SetStatus(codes.Error, "failed to update balance")
        return fmt.Errorf("failed to update balance: %w", result.Error)
    }

    if result.RowsAffected == 0 {
        tx.Rollback()
        txSpan.AddEvent("database.transaction.rollback")
        err := fmt.Errorf("concurrent modification detected")
        span.RecordError(err)
        span.SetStatus(codes.Error, "concurrent modification")
        return err
    }

    // 4. 记录交易日志
    transaction := &Transaction{
        AccountID: account.ID,
        Amount:    -req.Amount,
        Type:      "deduct",
        Reason:    req.Reason,
    }
    if err := tx.Create(transaction).Error; err != nil {
        tx.Rollback()
        txSpan.AddEvent("database.transaction.rollback")
        span.RecordError(err)
        span.SetStatus(codes.Error, "failed to create transaction log")
        return fmt.Errorf("failed to create transaction log: %w", err)
    }

    // 5. 提交事务
    if err := tx.Commit().Error; err != nil {
        txSpan.AddEvent("database.transaction.rollback")
        span.RecordError(err)
        span.SetStatus(codes.Error, "failed to commit transaction")
        return fmt.Errorf("failed to commit transaction: %w", err)
    }

    txSpan.AddEvent("database.transaction.commit")
    span.SetAttributes(
        attribute.Float64("account.balance.after", account.Balance-req.Amount),
    )
    span.SetStatus(codes.Ok, "balance deducted successfully")
    return nil
}
```

### 5. 幂等性管理

```go:pkg/idempotency/idempotency.go
package idempotency

import (
    "context"
    "fmt"
    "time"

    "github.com/redis/go-redis/v9"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

var tracer = otel.Tracer("idempotency")

type Manager struct {
    redis *redis.Client
}

func NewManager(redisClient *redis.Client) *Manager {
    return &Manager{redis: redisClient}
}

// CheckKey 检查幂等性键是否存在
func (m *Manager) CheckKey(ctx context.Context, key string) (bool, error) {
    ctx, span := tracer.Start(ctx, "idempotency.check",
        trace.WithAttributes(
            attribute.String("idempotency.key", key),
        ),
    )
    defer span.End()

    exists, err := m.redis.Exists(ctx, m.formatKey(key)).Result()
    if err != nil {
        span.RecordError(err)
        return false, err
    }

    span.SetAttributes(attribute.Bool("idempotency.exists", exists > 0))
    return exists > 0, nil
}

// StoreKey 存储幂等性键
func (m *Manager) StoreKey(ctx context.Context, key string, ttl time.Duration) error {
    ctx, span := tracer.Start(ctx, "idempotency.store",
        trace.WithAttributes(
            attribute.String("idempotency.key", key),
            attribute.Int64("idempotency.ttl", int64(ttl.Seconds())),
        ),
    )
    defer span.End()

    err := m.redis.Set(ctx, m.formatKey(key), time.Now().Unix(), ttl).Err()
    if err != nil {
        span.RecordError(err)
        return err
    }

    return nil
}

func (m *Manager) formatKey(key string) string {
    return fmt.Sprintf("idempotency:%s", key)
}
```

---

## 关键特性

### 1. 分布式追踪

**完整的支付链路追踪**:

```text
payment.request
├── risk.check
│   └── risk.evaluate
├── account.deduct
│   ├── database.transaction.begin
│   ├── database.query (SELECT ... FOR UPDATE)
│   ├── database.update (UPDATE balance)
│   ├── database.insert (INSERT transaction_log)
│   └── database.transaction.commit
├── channel.pay
│   └── http.client (POST to external API)
└── notification.send
    └── kafka.produce
```

**Trace Context 传播**:

- HTTP Headers: `traceparent`, `tracestate`
- Baggage: `user_id`, `request_id`, `session_id`

### 2. 指标监控

```go
// 关键指标
payment.requests.total          // 支付请求总数
payment.duration                // 支付处理延迟
payment.success_rate            // 支付成功率
account.balance.operations      // 账户操作次数
risk.rejection_rate             // 风控拒绝率
channel.latency                 // 第三方渠道延迟
```

### 3. 幂等性保证

```go
// Redis 幂等性键
idempotency:{key}  TTL=24h

// 检查流程
1. 检查 key 是否存在
2. 如果存在 → 返回 409 Conflict
3. 如果不存在 → 存储 key + 处理请求
```

### 4. 超时控制

```go
// 上下文超时
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

// 分级超时
Gateway:     10s
Payment:     5s
Account:     2s
Risk:        1s
Channel:     3s
```

---

## 监控与告警

### Prometheus 查询示例

```promql
# 支付成功率
rate(payment_requests_total{status="success"}[5m]) / 
rate(payment_requests_total[5m])

# P99 延迟
histogram_quantile(0.99, rate(payment_duration_bucket[5m]))

# 错误率
rate(payment_requests_total{status="failed"}[5m])

# 账户并发冲突率
rate(account_concurrent_modification_total[5m])
```

### Grafana Dashboard

```yaml
panels:
  - title: Payment Success Rate
    type: graph
    query: rate(payment_requests_total{status="success"}[5m])
    
  - title: Payment Latency (P50/P95/P99)
    type: graph
    queries:
      - histogram_quantile(0.50, rate(payment_duration_bucket[5m]))
      - histogram_quantile(0.95, rate(payment_duration_bucket[5m]))
      - histogram_quantile(0.99, rate(payment_duration_bucket[5m]))
      
  - title: Error Rate by Service
    type: graph
    query: rate(payment_errors_total[5m]) by (service)
```

### 告警规则

```yaml
groups:
  - name: payment_alerts
    rules:
      - alert: HighErrorRate
        expr: rate(payment_requests_total{status="failed"}[5m]) > 0.05
        for: 2m
        annotations:
          summary: "High payment error rate detected"
          
      - alert: HighLatency
        expr: histogram_quantile(0.99, rate(payment_duration_bucket[5m])) > 1000
        for: 5m
        annotations:
          summary: "Payment P99 latency > 1s"
          
      - alert: LowSuccessRate
        expr: rate(payment_requests_total{status="success"}[5m]) / rate(payment_requests_total[5m]) < 0.95
        for: 5m
        annotations:
          summary: "Payment success rate < 95%"
```

---

## 部署配置

### Docker Compose

```yaml:deployments/docker-compose.yml
version: '3.8'

services:
  # OpenTelemetry Collector
  otel-collector:
    image: otel/opentelemetry-collector-contrib:0.96.0
    command: ["--config=/etc/otel-collector-config.yaml"]
    volumes:
      - ./otel-collector-config.yaml:/etc/otel-collector-config.yaml
    ports:
      - "4317:4317"   # OTLP gRPC
      - "4318:4318"   # OTLP HTTP
      - "8888:8888"   # Prometheus metrics
      - "8889:8889"   # Prometheus exporter

  # Jaeger
  jaeger:
    image: jaegertracing/all-in-one:1.54
    ports:
      - "16686:16686"  # UI
      - "14250:14250"  # gRPC

  # Prometheus
  prometheus:
    image: prom/prometheus:v2.49.0
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - "9090:9090"

  # Grafana
  grafana:
    image: grafana/grafana:10.3.0
    ports:
      - "3000:3000"
    environment:
      - GF_AUTH_ANONYMOUS_ENABLED=true

  # PostgreSQL
  postgres:
    image: postgres:16
    environment:
      POSTGRES_PASSWORD: password
      POSTGRES_DB: payment
    ports:
      - "5432:5432"

  # Redis
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  # Kafka
  kafka:
    image: confluentinc/cp-kafka:7.6.0
    environment:
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
    ports:
      - "9092:9092"

  zookeeper:
    image: confluentinc/cp-zookeeper:7.6.0
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181

  # Payment Services
  gateway:
    build: ./cmd/gateway
    ports:
      - "8080:8080"
    environment:
      OTEL_EXPORTER_OTLP_ENDPOINT: "otel-collector:4317"
      
  payment:
    build: ./cmd/payment
    environment:
      OTEL_EXPORTER_OTLP_ENDPOINT: "otel-collector:4317"
      
  account:
    build: ./cmd/account
    environment:
      OTEL_EXPORTER_OTLP_ENDPOINT: "otel-collector:4317"
```

---

## 测试验证

### 1. 压力测试

```bash
# 使用 wrk 进行压力测试
wrk -t12 -c400 -d30s \
  -H "Content-Type: application/json" \
  -s payment-test.lua \
  http://localhost:8080/api/v1/payment
```

**payment-test.lua**:

```lua
request = function()
    local body = string.format([[
        {
            "payment_id": "PAY_%d",
            "user_id": "USER_%d",
            "amount": %.2f,
            "currency": "USD",
            "payment_method": "credit_card",
            "idempotency_key": "KEY_%d"
        }
    ]], 
    math.random(1, 100000),
    math.random(1, 1000),
    math.random(1, 1000) / 100.0,
    math.random(1, 100000))
    
    return wrk.format("POST", "/api/v1/payment", nil, body)
end
```

### 2. 验证追踪

```bash
# 访问 Jaeger UI
open http://localhost:16686

# 搜索 Service: payment-service
# 查看完整的支付链路追踪
```

### 3. 验证指标

```bash
# 访问 Prometheus
open http://localhost:9090

# 查询支付成功率
rate(payment_requests_total{status="success"}[5m])

# 查询 P99 延迟
histogram_quantile(0.99, rate(payment_duration_bucket[5m]))
```

---

## 最佳实践总结

### 1. 追踪最佳实践

✅ **DO**:

- 使用有意义的 Span 名称（如 `payment.process`, `account.deduct`）
- 添加关键业务属性（如 `payment.id`, `user.id`, `amount`）
- 记录重要事件（如 `transaction.begin`, `transaction.commit`）
- 使用 Baggage 传递用户信息和请求ID

❌ **DON'T**:

- 不要在 Span 中存储敏感信息（如密码、Token）
- 不要创建过多的 Span（影响性能）
- 不要忘记调用 `span.End()`

### 2. 指标最佳实践

✅ **DO**:

- 使用标准的 Metric 类型（Counter, Histogram, Gauge）
- 添加有意义的标签（如 `status`, `payment_method`）
- 使用 Histogram 记录延迟分布
- 定期计算聚合指标（如成功率）

❌ **DON'T**:

- 不要使用高基数标签（如 `payment_id`）
- 不要频繁创建新的 Metric（性能问题）

### 3. 性能优化

- ✅ 使用批处理导出（`WithBatchTimeout`, `WithMaxExportBatchSize`）
- ✅ 配置合理的采样率（生产环境 10%-20%）
- ✅ 使用连接池（gRPC, HTTP, Database）
- ✅ 启用压缩（gRPC gzip）
- ✅ 异步发送通知（使用 `context.WithoutCancel`）

### 4. 可靠性保障

- ✅ 幂等性保证（Redis 存储幂等性键）
- ✅ 事务一致性（数据库 ACID 事务 + 乐观锁）
- ✅ 超时控制（分级超时策略）
- ✅ 限流熔断（中间件保护）
- ✅ 优雅降级（风控失败时仍可处理低风险支付）

---

## 🎯 学到的关键知识点

1. ✅ **分布式追踪**: 跨服务、跨中间件的完整链路追踪
2. ✅ **事务追踪**: 数据库事务的细粒度追踪
3. ✅ **上下文传播**: HTTP Headers + Baggage 传播用户信息
4. ✅ **指标监控**: 支付成功率、延迟、错误率的实时监控
5. ✅ **幂等性**: 使用 Redis 实现分布式幂等性
6. ✅ **超时控制**: 分级超时策略
7. ✅ **错误处理**: 自动回滚与告警
8. ✅ **性能优化**: 批处理、采样、连接池

---

**🎊 恭喜！** 您已经掌握了生产级分布式支付系统的 OpenTelemetry 完整集成！

**下一步**:

- 📚 [高并发库存系统](./03_高并发库存系统.md)
- 📚 [多云环境部署](./04_多云环境部署.md)
- 📚 [配置模板库](../配置模板/)
