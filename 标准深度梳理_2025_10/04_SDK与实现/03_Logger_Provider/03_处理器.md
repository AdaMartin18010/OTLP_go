# LogRecordProcessor 处理器

## 📋 目录

- [LogRecordProcessor 处理器](#logrecordprocessor-处理器)
  - [📋 目录](#-目录)
  - [概述](#概述)
  - [内置处理器](#内置处理器)
    - [1. SimpleLogRecordProcessor](#1-simplelogrecordprocessor)
    - [2. BatchLogRecordProcessor](#2-batchlogrecordprocessor)
    - [3. 多处理器](#3-多处理器)
  - [处理器配置](#处理器配置)
  - [Go 1.25.1 实现](#go-1251-实现)
    - [1. 自定义处理器](#1-自定义处理器)
    - [2. 过滤处理器](#2-过滤处理器)
    - [3. 链式处理器](#3-链式处理器)
  - [性能优化](#性能优化)
  - [最佳实践](#最佳实践)
  - [常见问题](#常见问题)
  - [参考资源](#参考资源)

---

## 概述

**LogRecordProcessor** 负责处理 LogRecord 的生命周期并将其导出到后端。与 SpanProcessor 类似，但专门用于日志。

```text
LogRecord
    ↓
Processor.OnEmit()
    ↓ (批处理/立即)
Exporter.Export()
    ↓
Backend
```

---

## 内置处理器

### 1. SimpleLogRecordProcessor

同步导出（每条日志立即导出）：

```go
import (
    "go.opentelemetry.io/otel/sdk/log"
    "go.opentelemetry.io/otel/exporters/stdout/stdoutlog"
)

func main() {
    exporter, _ := stdoutlog.New()
    
    // 创建 SimpleProcessor
    processor := log.NewSimpleProcessor(exporter)
    
    lp := log.NewLoggerProvider(
        log.WithProcessor(processor),
    )
    defer lp.Shutdown(context.Background())
}
```

**特点**:

```text
✅ 优点:
  - 简单直接
  - 立即可见
  - 适合调试

❌ 缺点:
  - 同步阻塞
  - 性能开销大
  - 不适合高频日志

使用场景:
✅ 开发环境
✅ 调试
✅ 低频日志 (< 10/s)
❌ 生产环境（高频）
```

### 2. BatchLogRecordProcessor

批量异步导出（推荐生产环境）：

```go
import (
    "time"
    "go.opentelemetry.io/otel/sdk/log"
)

func main() {
    exporter, _ := stdoutlog.New()
    
    // 创建 BatchProcessor
    processor := log.NewBatchProcessor(
        exporter,
        log.WithBatchTimeout(5*time.Second),
        log.WithMaxQueueSize(2048),
        log.WithExportMaxBatchSize(512),
        log.WithExportTimeout(30*time.Second),
    )
    
    lp := log.NewLoggerProvider(
        log.WithProcessor(processor),
    )
    defer lp.Shutdown(context.Background())
}
```

**配置参数**:

```text
BatchTimeout: 5秒
MaxQueueSize: 2048
ExportMaxBatchSize: 512
ExportTimeout: 30秒
```

### 3. 多处理器

```go
// 同时配置多个处理器
func main() {
    // 处理器 1: 导出到 OTLP
    otlpExporter, _ := otlploggrpc.New(context.Background())
    otlpProcessor := log.NewBatchProcessor(otlpExporter)
    
    // 处理器 2: 导出到文件（调试）
    fileExporter, _ := filelogexporter.New("app.log")
    fileProcessor := log.NewSimpleProcessor(fileExporter)
    
    lp := log.NewLoggerProvider(
        log.WithProcessor(otlpProcessor),
        log.WithProcessor(fileProcessor),
    )
}
```

---

## 处理器配置

```go
// 开发环境: 快速导出
processor := log.NewBatchProcessor(exporter,
    log.WithBatchTimeout(1*time.Second),
    log.WithMaxQueueSize(100),
)

// 生产环境: 平衡性能
processor := log.NewBatchProcessor(exporter,
    log.WithBatchTimeout(5*time.Second),
    log.WithMaxQueueSize(2048),
    log.WithExportMaxBatchSize(512),
)

// 高频日志: 大批次
processor := log.NewBatchProcessor(exporter,
    log.WithBatchTimeout(10*time.Second),
    log.WithMaxQueueSize(4096),
    log.WithExportMaxBatchSize(1024),
)
```

---

## Go 1.25.1 实现

### 1. 自定义处理器

```go
package processor

import (
    "context"
    "go.opentelemetry.io/otel/sdk/log"
)

// CustomProcessor 自定义处理器
type CustomProcessor struct {
    exporter log.Exporter
}

func NewCustomProcessor(exporter log.Exporter) log.Processor {
    return &CustomProcessor{
        exporter: exporter,
    }
}

// OnEmit 处理日志记录
func (p *CustomProcessor) OnEmit(ctx context.Context, record log.Record) error {
    // 自定义处理逻辑
    // 例如: 添加额外属性、过滤等
    
    // 导出
    return p.exporter.Export(ctx, []log.Record{record})
}

// Shutdown 关闭处理器
func (p *CustomProcessor) Shutdown(ctx context.Context) error {
    return p.exporter.Shutdown(ctx)
}

// ForceFlush 强制刷新
func (p *CustomProcessor) ForceFlush(ctx context.Context) error {
    return nil
}
```

### 2. 过滤处理器

```go
package processor

// FilterProcessor 过滤处理器
type FilterProcessor struct {
    next   log.Processor
    filter func(log.Record) bool
}

func NewFilterProcessor(next log.Processor, filter func(log.Record) bool) log.Processor {
    return &FilterProcessor{
        next:   next,
        filter: filter,
    }
}

func (p *FilterProcessor) OnEmit(ctx context.Context, record log.Record) error {
    // 应用过滤器
    if p.filter(record) {
        return p.next.OnEmit(ctx, record)
    }
    return nil
}

func (p *FilterProcessor) Shutdown(ctx context.Context) error {
    return p.next.Shutdown(ctx)
}

func (p *FilterProcessor) ForceFlush(ctx context.Context) error {
    return p.next.ForceFlush(ctx)
}

// 使用示例: 只导出 ERROR 级别日志
func main() {
    exporter, _ := stdoutlog.New()
    batchProcessor := log.NewBatchProcessor(exporter)
    
    filterProcessor := NewFilterProcessor(
        batchProcessor,
        func(r log.Record) bool {
            return r.SeverityNumber >= log.SeverityError
        },
    )
    
    lp := log.NewLoggerProvider(
        log.WithProcessor(filterProcessor),
    )
}
```

### 3. 链式处理器

```go
package processor

// ChainProcessor 链式处理器
type ChainProcessor struct {
    processors []log.Processor
}

func NewChainProcessor(processors ...log.Processor) log.Processor {
    return &ChainProcessor{
        processors: processors,
    }
}

func (p *ChainProcessor) OnEmit(ctx context.Context, record log.Record) error {
    for _, processor := range p.processors {
        if err := processor.OnEmit(ctx, record); err != nil {
            return err
        }
    }
    return nil
}

func (p *ChainProcessor) Shutdown(ctx context.Context) error {
    for _, processor := range p.processors {
        if err := processor.Shutdown(ctx); err != nil {
            return err
        }
    }
    return nil
}

func (p *ChainProcessor) ForceFlush(ctx context.Context) error {
    for _, processor := range p.processors {
        if err := processor.ForceFlush(ctx); err != nil {
            return err
        }
    }
    return nil
}
```

---

## 性能优化

```go
// 1. 使用 BatchProcessor（生产环境）
processor := log.NewBatchProcessor(exporter,
    log.WithBatchTimeout(5*time.Second),
)

// 2. 调整批次大小
// 高频日志: 大批次
log.WithExportMaxBatchSize(1024)

// 3. 调整队列大小
log.WithMaxQueueSize(4096) // ~8MB (假设 2KB/log)

// 4. 避免阻塞操作
func (p *CustomProcessor) OnEmit(ctx context.Context, r log.Record) error {
    // ❌ 错误: 阻塞操作
    time.Sleep(1*time.Second)
    
    // ✅ 正确: 异步处理
    go func() {
        p.next.OnEmit(ctx, r)
    }()
    return nil
}
```

---

## 最佳实践

```go
// ✅ 正确: 生产环境使用 BatchProcessor
processor := log.NewBatchProcessor(exporter,
    log.WithBatchTimeout(5*time.Second),
    log.WithMaxQueueSize(2048),
)

// ✅ 正确: 开发环境使用 SimpleProcessor
if os.Getenv("ENV") == "development" {
    processor = log.NewSimpleProcessor(exporter)
}

// ✅ 正确: 正确关闭
defer func() {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    if err := lp.Shutdown(ctx); err != nil {
        log.Printf("Error shutting down: %v", err)
    }
}()

// ❌ 错误: 忘记关闭
func main() {
    lp := log.NewLoggerProvider(...)
    // 缺少 defer lp.Shutdown()
}
```

---

## 常见问题

**Q1: SimpleProcessor vs BatchProcessor？**

```text
SimpleProcessor:
✅ 开发环境
✅ 调试
✅ 低频日志
❌ 生产环境（高频）

BatchProcessor (推荐):
✅ 生产环境
✅ 高频日志
✅ 性能敏感

配置推荐:
- 开发: SimpleProcessor
- 生产: BatchProcessor (5s)
```

**Q2: 如何确保日志不丢失？**

```go
// 1. 设置合理队列大小
log.WithMaxQueueSize(4096)

// 2. 正确关闭
defer lp.Shutdown(context.Background())

// 3. 监控队列
// 如果队列满，日志会被丢弃
```

---

## 参考资源

- [OpenTelemetry Logs SDK](https://opentelemetry.io/docs/specs/otel/logs/sdk/)
- [02_Logger创建.md](./02_Logger创建.md)
- [04_导出器.md](./04_导出器.md)

---

**🎉 完成！LogRecordProcessor 知识掌握！**
