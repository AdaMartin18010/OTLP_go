# SpanProcessor å¤„ç†å™¨

## ğŸ“‹ ç›®å½•

- [SpanProcessor å¤„ç†å™¨](#spanprocessor-å¤„ç†å™¨)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [ä»€ä¹ˆæ˜¯ SpanProcessor](#ä»€ä¹ˆæ˜¯-spanprocessor)
    - [å¤„ç†æµç¨‹](#å¤„ç†æµç¨‹)
  - [å†…ç½®å¤„ç†å™¨](#å†…ç½®å¤„ç†å™¨)
    - [1. SimpleSpanProcessor](#1-simplespanprocessor)
    - [2. BatchSpanProcessor](#2-batchspanprocessor)
    - [3. å¤šå¤„ç†å™¨](#3-å¤šå¤„ç†å™¨)
  - [å¤„ç†å™¨é…ç½®](#å¤„ç†å™¨é…ç½®)
    - [1. æ‰¹å¤„ç†é…ç½®](#1-æ‰¹å¤„ç†é…ç½®)
    - [2. è¶…æ—¶é…ç½®](#2-è¶…æ—¶é…ç½®)
    - [3. é˜Ÿåˆ—é…ç½®](#3-é˜Ÿåˆ—é…ç½®)
  - [Go 1.25.1 å®ç°](#go-1251-å®ç°)
    - [1. è‡ªå®šä¹‰å¤„ç†å™¨](#1-è‡ªå®šä¹‰å¤„ç†å™¨)
    - [2. è¿‡æ»¤å¤„ç†å™¨](#2-è¿‡æ»¤å¤„ç†å™¨)
    - [3. é“¾å¼å¤„ç†å™¨](#3-é“¾å¼å¤„ç†å™¨)
  - [å¤„ç†å™¨æ¨¡å¼](#å¤„ç†å™¨æ¨¡å¼)
    - [1. æ—¥å¿—å¤„ç†å™¨](#1-æ—¥å¿—å¤„ç†å™¨)
    - [2. é‡‡æ ·å¤„ç†å™¨](#2-é‡‡æ ·å¤„ç†å™¨)
    - [3. å±æ€§å¤„ç†å™¨](#3-å±æ€§å¤„ç†å™¨)
  - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)
  - [å‚è€ƒèµ„æº](#å‚è€ƒèµ„æº)

---

## æ¦‚è¿°

### ä»€ä¹ˆæ˜¯ SpanProcessor

**SpanProcessor** è´Ÿè´£å¤„ç† Span çš„ç”Ÿå‘½å‘¨æœŸäº‹ä»¶ï¼ˆå¼€å§‹ã€ç»“æŸï¼‰å¹¶å°† Span å¯¼å‡ºåˆ°åç«¯ã€‚

```text
Span ç”Ÿå‘½å‘¨æœŸ:
1. Span.Start()  â†’ OnStart()
2. Span.End()    â†’ OnEnd()
3. Batch/Export  â†’ Exporter
4. Shutdown      â†’ ForceFlush()
```

### å¤„ç†æµç¨‹

```text
Application
    â†“
Span.End()
    â†“
SpanProcessor.OnEnd()
    â†“ (æ‰¹å¤„ç†/ç«‹å³)
Exporter.ExportSpans()
    â†“
Backend (Jaeger, Collector, etc.)
```

---

## å†…ç½®å¤„ç†å™¨

### 1. SimpleSpanProcessor

åŒæ­¥å¯¼å‡º Spanï¼ˆæ¯ä¸ª Span ç«‹å³å¯¼å‡ºï¼‰ï¼š

```go
import (
    "go.opentelemetry.io/otel/sdk/trace"
    "go.opentelemetry.io/otel/exporters/stdout/stdouttrace"
)

func main() {
    // åˆ›å»ºå¯¼å‡ºå™¨
    exporter, _ := stdouttrace.New()
    
    // åˆ›å»º SimpleSpanProcessor
    processor := trace.NewSimpleSpanProcessor(exporter)
    
    // é…ç½® TracerProvider
    tp := trace.NewTracerProvider(
        trace.WithSpanProcessor(processor),
    )
    defer tp.Shutdown(context.Background())
}
```

**ç‰¹ç‚¹**:

```text
âœ… ä¼˜ç‚¹:
  - ç®€å•ç›´æ¥
  - æ— ç¼“å†²å»¶è¿Ÿ
  - é€‚åˆè°ƒè¯•

âŒ ç¼ºç‚¹:
  - åŒæ­¥é˜»å¡
  - æ€§èƒ½å¼€é”€å¤§
  - ä¸é€‚åˆç”Ÿäº§ç¯å¢ƒ

ä½¿ç”¨åœºæ™¯:
âœ… å¼€å‘ç¯å¢ƒ
âœ… è°ƒè¯•
âœ… æµ‹è¯•
âŒ ç”Ÿäº§ç¯å¢ƒï¼ˆé«˜æµé‡ï¼‰
```

### 2. BatchSpanProcessor

æ‰¹é‡å¼‚æ­¥å¯¼å‡º Spanï¼ˆæ¨èç”Ÿäº§ç¯å¢ƒï¼‰ï¼š

```go
import (
    "time"
    "go.opentelemetry.io/otel/sdk/trace"
)

func main() {
    exporter, _ := stdouttrace.New()
    
    // åˆ›å»º BatchSpanProcessor
    processor := trace.NewBatchSpanProcessor(
        exporter,
        // æ‰¹å¤„ç†è¶…æ—¶
        trace.WithBatchTimeout(5*time.Second),
        
        // æœ€å¤§æ‰¹æ¬¡å¤§å°
        trace.WithMaxExportBatchSize(512),
        
        // æœ€å¤§é˜Ÿåˆ—å¤§å°
        trace.WithMaxQueueSize(2048),
        
        // å¯¼å‡ºè¶…æ—¶
        trace.WithExportTimeout(30*time.Second),
    )
    
    tp := trace.NewTracerProvider(
        trace.WithSpanProcessor(processor),
    )
    defer tp.Shutdown(context.Background())
}
```

**ç‰¹ç‚¹**:

```text
âœ… ä¼˜ç‚¹:
  - å¼‚æ­¥éé˜»å¡
  - æ‰¹é‡å¯¼å‡ºï¼ˆé«˜æ•ˆï¼‰
  - é€‚åˆé«˜æµé‡

âš ï¸  æ³¨æ„:
  - æœ‰ç¼“å†²å»¶è¿Ÿ
  - å†…å­˜å ç”¨

ä½¿ç”¨åœºæ™¯:
âœ… ç”Ÿäº§ç¯å¢ƒï¼ˆæ¨èï¼‰
âœ… é«˜æµé‡åœºæ™¯
âœ… æ€§èƒ½æ•æ„Ÿåº”ç”¨
```

**é…ç½®å‚æ•°**:

```go
const (
    // é»˜è®¤æ‰¹å¤„ç†è¶…æ—¶: 5ç§’
    DefaultBatchTimeout = 5 * time.Second
    
    // é»˜è®¤æœ€å¤§æ‰¹æ¬¡å¤§å°: 512
    DefaultMaxExportBatchSize = 512
    
    // é»˜è®¤æœ€å¤§é˜Ÿåˆ—å¤§å°: 2048
    DefaultMaxQueueSize = 2048
    
    // é»˜è®¤å¯¼å‡ºè¶…æ—¶: 30ç§’
    DefaultExportTimeout = 30 * time.Second
)
```

### 3. å¤šå¤„ç†å™¨

ä½¿ç”¨å¤šä¸ªå¤„ç†å™¨ï¼š

```go
func main() {
    // å¤„ç†å™¨ 1: å¯¼å‡ºåˆ° OTLP
    otlpExporter, _ := otlptracegrpc.New(context.Background())
    otlpProcessor := trace.NewBatchSpanProcessor(otlpExporter)
    
    // å¤„ç†å™¨ 2: å¯¼å‡ºåˆ°æ ‡å‡†è¾“å‡ºï¼ˆè°ƒè¯•ï¼‰
    stdoutExporter, _ := stdouttrace.New()
    stdoutProcessor := trace.NewSimpleSpanProcessor(stdoutExporter)
    
    // é…ç½®å¤šä¸ªå¤„ç†å™¨
    tp := trace.NewTracerProvider(
        trace.WithSpanProcessor(otlpProcessor),
        trace.WithSpanProcessor(stdoutProcessor),
    )
    defer tp.Shutdown(context.Background())
}
```

---

## å¤„ç†å™¨é…ç½®

### 1. æ‰¹å¤„ç†é…ç½®

```go
// å¼€å‘ç¯å¢ƒ: å¿«é€Ÿå¯¼å‡º
processor := trace.NewBatchSpanProcessor(exporter,
    trace.WithBatchTimeout(1*time.Second),
    trace.WithMaxExportBatchSize(10),
    trace.WithMaxQueueSize(100),
)

// ç”Ÿäº§ç¯å¢ƒ: å¹³è¡¡æ€§èƒ½å’Œå»¶è¿Ÿ
processor := trace.NewBatchSpanProcessor(exporter,
    trace.WithBatchTimeout(5*time.Second),
    trace.WithMaxExportBatchSize(512),
    trace.WithMaxQueueSize(2048),
)

// é«˜æµé‡ç¯å¢ƒ: å¤§æ‰¹æ¬¡
processor := trace.NewBatchSpanProcessor(exporter,
    trace.WithBatchTimeout(10*time.Second),
    trace.WithMaxExportBatchSize(1024),
    trace.WithMaxQueueSize(4096),
)
```

### 2. è¶…æ—¶é…ç½®

```go
processor := trace.NewBatchSpanProcessor(exporter,
    // æ‰¹å¤„ç†è¶…æ—¶: è¾¾åˆ°æ—¶é—´åå¯¼å‡º
    trace.WithBatchTimeout(5*time.Second),
    
    // å¯¼å‡ºè¶…æ—¶: å•æ¬¡å¯¼å‡ºçš„æœ€å¤§æ—¶é—´
    trace.WithExportTimeout(30*time.Second),
)
```

### 3. é˜Ÿåˆ—é…ç½®

```go
processor := trace.NewBatchSpanProcessor(exporter,
    // é˜Ÿåˆ—å¤§å°
    trace.WithMaxQueueSize(2048),
    
    // æ‰¹æ¬¡å¤§å°
    trace.WithMaxExportBatchSize(512),
)

// å†…å­˜ä½¿ç”¨ä¼°ç®—:
// Memory â‰ˆ MaxQueueSize Ã— AvgSpanSize
// ä¾‹å¦‚: 2048 Ã— 2KB = ~4MB
```

---

## Go 1.25.1 å®ç°

### 1. è‡ªå®šä¹‰å¤„ç†å™¨

```go
package processor

import (
    "context"
    "go.opentelemetry.io/otel/sdk/trace"
)

// CustomProcessor è‡ªå®šä¹‰å¤„ç†å™¨
type CustomProcessor struct {
    exporter trace.SpanExporter
}

// NewCustomProcessor åˆ›å»ºè‡ªå®šä¹‰å¤„ç†å™¨
func NewCustomProcessor(exporter trace.SpanExporter) trace.SpanProcessor {
    return &CustomProcessor{
        exporter: exporter,
    }
}

// OnStart åœ¨ Span å¼€å§‹æ—¶è°ƒç”¨
func (p *CustomProcessor) OnStart(parent context.Context, s trace.ReadWriteSpan) {
    // åœ¨ Span å¼€å§‹æ—¶çš„è‡ªå®šä¹‰é€»è¾‘
    // ä¾‹å¦‚: æ·»åŠ è‡ªåŠ¨å±æ€§
    s.SetAttributes(
        attribute.String("processor.name", "custom"),
        attribute.Int64("processor.timestamp", time.Now().Unix()),
    )
}

// OnEnd åœ¨ Span ç»“æŸæ—¶è°ƒç”¨
func (p *CustomProcessor) OnEnd(s trace.ReadOnlySpan) {
    // è‡ªå®šä¹‰å¯¼å‡ºé€»è¾‘
    if s.SpanContext().IsSampled() {
        p.exporter.ExportSpans(context.Background(), []trace.ReadOnlySpan{s})
    }
}

// Shutdown å…³é—­å¤„ç†å™¨
func (p *CustomProcessor) Shutdown(ctx context.Context) error {
    return p.exporter.Shutdown(ctx)
}

// ForceFlush å¼ºåˆ¶åˆ·æ–°
func (p *CustomProcessor) ForceFlush(ctx context.Context) error {
    return nil
}
```

### 2. è¿‡æ»¤å¤„ç†å™¨

```go
package processor

// FilterProcessor è¿‡æ»¤ç‰¹å®š Span
type FilterProcessor struct {
    next   trace.SpanProcessor
    filter func(trace.ReadOnlySpan) bool
}

// NewFilterProcessor åˆ›å»ºè¿‡æ»¤å¤„ç†å™¨
func NewFilterProcessor(next trace.SpanProcessor, filter func(trace.ReadOnlySpan) bool) trace.SpanProcessor {
    return &FilterProcessor{
        next:   next,
        filter: filter,
    }
}

func (p *FilterProcessor) OnStart(parent context.Context, s trace.ReadWriteSpan) {
    p.next.OnStart(parent, s)
}

func (p *FilterProcessor) OnEnd(s trace.ReadOnlySpan) {
    // åº”ç”¨è¿‡æ»¤å™¨
    if p.filter(s) {
        p.next.OnEnd(s)
    }
}

func (p *FilterProcessor) Shutdown(ctx context.Context) error {
    return p.next.Shutdown(ctx)
}

func (p *FilterProcessor) ForceFlush(ctx context.Context) error {
    return p.next.ForceFlush(ctx)
}

// ä½¿ç”¨ç¤ºä¾‹: åªå¯¼å‡ºé”™è¯¯ Span
func main() {
    exporter, _ := stdouttrace.New()
    batchProcessor := trace.NewBatchSpanProcessor(exporter)
    
    // è¿‡æ»¤å™¨: åªä¿ç•™é”™è¯¯ Span
    filterProcessor := NewFilterProcessor(
        batchProcessor,
        func(s trace.ReadOnlySpan) bool {
            return s.Status().Code == codes.Error
        },
    )
    
    tp := trace.NewTracerProvider(
        trace.WithSpanProcessor(filterProcessor),
    )
}
```

### 3. é“¾å¼å¤„ç†å™¨

```go
package processor

// ChainProcessor é“¾å¼å¤„ç†å™¨
type ChainProcessor struct {
    processors []trace.SpanProcessor
}

// NewChainProcessor åˆ›å»ºé“¾å¼å¤„ç†å™¨
func NewChainProcessor(processors ...trace.SpanProcessor) trace.SpanProcessor {
    return &ChainProcessor{
        processors: processors,
    }
}

func (p *ChainProcessor) OnStart(parent context.Context, s trace.ReadWriteSpan) {
    for _, processor := range p.processors {
        processor.OnStart(parent, s)
    }
}

func (p *ChainProcessor) OnEnd(s trace.ReadOnlySpan) {
    for _, processor := range p.processors {
        processor.OnEnd(s)
    }
}

func (p *ChainProcessor) Shutdown(ctx context.Context) error {
    for _, processor := range p.processors {
        if err := processor.Shutdown(ctx); err != nil {
            return err
        }
    }
    return nil
}

func (p *ChainProcessor) ForceFlush(ctx context.Context) error {
    for _, processor := range p.processors {
        if err := processor.ForceFlush(ctx); err != nil {
            return err
        }
    }
    return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    // å¤„ç†å™¨ 1: æ—¥å¿—
    logProcessor := NewLoggingProcessor()
    
    // å¤„ç†å™¨ 2: è¿‡æ»¤
    filterProcessor := NewFilterProcessor(...)
    
    // å¤„ç†å™¨ 3: å¯¼å‡º
    exportProcessor := trace.NewBatchSpanProcessor(exporter)
    
    // é“¾å¼ç»„åˆ
    chainProcessor := NewChainProcessor(
        logProcessor,
        filterProcessor,
        exportProcessor,
    )
    
    tp := trace.NewTracerProvider(
        trace.WithSpanProcessor(chainProcessor),
    )
}
```

---

## å¤„ç†å™¨æ¨¡å¼

### 1. æ—¥å¿—å¤„ç†å™¨

```go
package processor

import (
    "log"
)

// LoggingProcessor æ—¥å¿—å¤„ç†å™¨
type LoggingProcessor struct{}

func NewLoggingProcessor() trace.SpanProcessor {
    return &LoggingProcessor{}
}

func (p *LoggingProcessor) OnStart(parent context.Context, s trace.ReadWriteSpan) {
    log.Printf("Span started: %s", s.Name())
}

func (p *LoggingProcessor) OnEnd(s trace.ReadOnlySpan) {
    duration := s.EndTime().Sub(s.StartTime())
    log.Printf("Span ended: %s (duration: %v)", s.Name(), duration)
}

func (p *LoggingProcessor) Shutdown(ctx context.Context) error {
    return nil
}

func (p *LoggingProcessor) ForceFlush(ctx context.Context) error {
    return nil
}
```

### 2. é‡‡æ ·å¤„ç†å™¨

```go
package processor

// SamplingProcessor é‡‡æ ·å¤„ç†å™¨
type SamplingProcessor struct {
    next trace.SpanProcessor
    rate float64
}

func NewSamplingProcessor(next trace.SpanProcessor, rate float64) trace.SpanProcessor {
    return &SamplingProcessor{
        next: next,
        rate: rate,
    }
}

func (p *SamplingProcessor) OnStart(parent context.Context, s trace.ReadWriteSpan) {
    p.next.OnStart(parent, s)
}

func (p *SamplingProcessor) OnEnd(s trace.ReadOnlySpan) {
    // åé‡‡æ ·ï¼šåœ¨å¤„ç†å™¨çº§åˆ«å†æ¬¡é‡‡æ ·
    if rand.Float64() < p.rate {
        p.next.OnEnd(s)
    }
}

func (p *SamplingProcessor) Shutdown(ctx context.Context) error {
    return p.next.Shutdown(ctx)
}

func (p *SamplingProcessor) ForceFlush(ctx context.Context) error {
    return p.next.ForceFlush(ctx)
}
```

### 3. å±æ€§å¤„ç†å™¨

```go
package processor

// AttributeProcessor å±æ€§å¤„ç†å™¨
type AttributeProcessor struct {
    next       trace.SpanProcessor
    addAttrs   []attribute.KeyValue
    removeKeys []attribute.Key
}

func NewAttributeProcessor(
    next trace.SpanProcessor,
    addAttrs []attribute.KeyValue,
    removeKeys []attribute.Key,
) trace.SpanProcessor {
    return &AttributeProcessor{
        next:       next,
        addAttrs:   addAttrs,
        removeKeys: removeKeys,
    }
}

func (p *AttributeProcessor) OnStart(parent context.Context, s trace.ReadWriteSpan) {
    // æ·»åŠ å±æ€§
    if len(p.addAttrs) > 0 {
        s.SetAttributes(p.addAttrs...)
    }
    
    p.next.OnStart(parent, s)
}

func (p *AttributeProcessor) OnEnd(s trace.ReadOnlySpan) {
    // æ³¨æ„: ReadOnlySpan ä¸èƒ½ä¿®æ”¹
    // å¦‚æœéœ€è¦ä¿®æ”¹ï¼Œåº”åœ¨ OnStart ä¸­å¤„ç†
    p.next.OnEnd(s)
}

func (p *AttributeProcessor) Shutdown(ctx context.Context) error {
    return p.next.Shutdown(ctx)
}

func (p *AttributeProcessor) ForceFlush(ctx context.Context) error {
    return p.next.ForceFlush(ctx)
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    exporter, _ := stdouttrace.New()
    batchProcessor := trace.NewBatchSpanProcessor(exporter)
    
    // è‡ªåŠ¨æ·»åŠ ç¯å¢ƒä¿¡æ¯
    attrProcessor := NewAttributeProcessor(
        batchProcessor,
        []attribute.KeyValue{
            attribute.String("deployment.environment", "production"),
            attribute.String("service.version", "1.0.0"),
        },
        []attribute.Key{}, // ä¸åˆ é™¤ä»»ä½•å±æ€§
    )
    
    tp := trace.NewTracerProvider(
        trace.WithSpanProcessor(attrProcessor),
    )
}
```

---

## æ€§èƒ½ä¼˜åŒ–

```go
// 1. ä½¿ç”¨ BatchSpanProcessorï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰
processor := trace.NewBatchSpanProcessor(exporter,
    trace.WithBatchTimeout(5*time.Second),
    trace.WithMaxExportBatchSize(512),
)

// 2. è°ƒæ•´æ‰¹æ¬¡å¤§å°
// å°æ‰¹æ¬¡: ä½å»¶è¿Ÿï¼Œé«˜å¼€é”€
trace.WithMaxExportBatchSize(128)

// å¤§æ‰¹æ¬¡: é«˜å»¶è¿Ÿï¼Œä½å¼€é”€
trace.WithMaxExportBatchSize(1024)

// 3. è°ƒæ•´é˜Ÿåˆ—å¤§å°
// æ ¹æ®æµé‡å’Œå†…å­˜é™åˆ¶
trace.WithMaxQueueSize(2048) // ~4MB (å‡è®¾ 2KB/span)

// 4. è®¾ç½®åˆç†çš„è¶…æ—¶
trace.WithBatchTimeout(5*time.Second)      // æ‰¹å¤„ç†è¶…æ—¶
trace.WithExportTimeout(30*time.Second)    // å¯¼å‡ºè¶…æ—¶

// 5. é¿å…é˜»å¡æ“ä½œ
// âŒ é”™è¯¯: åœ¨ OnEnd ä¸­æ‰§è¡Œè€—æ—¶æ“ä½œ
func (p *SlowProcessor) OnEnd(s trace.ReadOnlySpan) {
    time.Sleep(1*time.Second) // é˜»å¡ï¼
    p.next.OnEnd(s)
}

// âœ… æ­£ç¡®: å¼‚æ­¥å¤„ç†
func (p *AsyncProcessor) OnEnd(s trace.ReadOnlySpan) {
    go func() {
        // å¼‚æ­¥å¤„ç†
        time.Sleep(1*time.Second)
        p.next.OnEnd(s)
    }()
}
```

---

## æœ€ä½³å®è·µ

```go
// âœ… æ­£ç¡®: ç”Ÿäº§ç¯å¢ƒä½¿ç”¨ BatchSpanProcessor
processor := trace.NewBatchSpanProcessor(exporter,
    trace.WithBatchTimeout(5*time.Second),
    trace.WithMaxExportBatchSize(512),
    trace.WithMaxQueueSize(2048),
)

// âœ… æ­£ç¡®: å¼€å‘ç¯å¢ƒä½¿ç”¨ SimpleSpanProcessor
if os.Getenv("ENV") == "development" {
    processor = trace.NewSimpleSpanProcessor(exporter)
}

// âœ… æ­£ç¡®: æ­£ç¡®å…³é—­å¤„ç†å™¨
defer func() {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := tp.Shutdown(ctx); err != nil {
        log.Printf("Error shutting down: %v", err)
    }
}()

// âœ… æ­£ç¡®: å¼ºåˆ¶åˆ·æ–°
func gracefulShutdown(tp *trace.TracerProvider) {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    // å…ˆåˆ·æ–°
    if err := tp.ForceFlush(ctx); err != nil {
        log.Printf("Error flushing: %v", err)
    }
    
    // å†å…³é—­
    if err := tp.Shutdown(ctx); err != nil {
        log.Printf("Error shutting down: %v", err)
    }
}

// âŒ é”™è¯¯: å¿˜è®°å…³é—­
func main() {
    tp := trace.NewTracerProvider(...)
    // ç¼ºå°‘ defer tp.Shutdown()
}

// âŒ é”™è¯¯: åœ¨ OnEnd ä¸­é˜»å¡
func (p *BadProcessor) OnEnd(s trace.ReadOnlySpan) {
    http.Get("http://example.com") // é˜»å¡ï¼
}
```

---

## å¸¸è§é—®é¢˜

**Q1: SimpleSpanProcessor å’Œ BatchSpanProcessor å¦‚ä½•é€‰æ‹©ï¼Ÿ**

```text
SimpleSpanProcessor:
âœ… é€‚ç”¨åœºæ™¯:
  - å¼€å‘ç¯å¢ƒ
  - è°ƒè¯•
  - ä½æµé‡ (< 10 RPS)
  - éœ€è¦ç«‹å³å¯è§æ€§

âŒ ä¸é€‚ç”¨:
  - ç”Ÿäº§ç¯å¢ƒ
  - é«˜æµé‡
  - æ€§èƒ½æ•æ„Ÿ

BatchSpanProcessor:
âœ… é€‚ç”¨åœºæ™¯:
  - ç”Ÿäº§ç¯å¢ƒï¼ˆæ¨èï¼‰
  - é«˜æµé‡
  - æ€§èƒ½æ•æ„Ÿ
  - ä»»ä½•è§„æ¨¡çš„åº”ç”¨

âš ï¸  æ³¨æ„:
  - æœ‰å»¶è¿Ÿï¼ˆæœ€å¤š BatchTimeoutï¼‰
  - éœ€è¦åˆç†é…ç½®

æ¨è:
- å¼€å‘: SimpleSpanProcessor
- ç”Ÿäº§: BatchSpanProcessor
```

**Q2: å¦‚ä½•ç¡®ä¿ Span ä¸ä¸¢å¤±ï¼Ÿ**

```go
// 1. è®¾ç½®åˆç†çš„é˜Ÿåˆ—å¤§å°
processor := trace.NewBatchSpanProcessor(exporter,
    trace.WithMaxQueueSize(4096), // è¶³å¤Ÿå¤§
)

// 2. æ­£ç¡®å…³é—­
defer tp.Shutdown(context.Background())

// 3. ç›‘æ§é˜Ÿåˆ—
// å¦‚æœé˜Ÿåˆ—æ»¡ï¼ŒSpan ä¼šè¢«ä¸¢å¼ƒ
// å¯ä»¥é€šè¿‡ metrics ç›‘æ§

// 4. ä½¿ç”¨å¤šä¸ªå¤„ç†å™¨ï¼ˆå†—ä½™ï¼‰
tp := trace.NewTracerProvider(
    trace.WithSpanProcessor(primaryProcessor),
    trace.WithSpanProcessor(backupProcessor),
)
```

**Q3: å¤„ç†å™¨çš„æ‰§è¡Œé¡ºåºï¼Ÿ**

```text
é…ç½®é¡ºåº:
tp := trace.NewTracerProvider(
    trace.WithSpanProcessor(processor1),
    trace.WithSpanProcessor(processor2),
    trace.WithSpanProcessor(processor3),
)

OnStart æ‰§è¡Œ: processor1 â†’ processor2 â†’ processor3
OnEnd æ‰§è¡Œ:   processor1 â†’ processor2 â†’ processor3

æ³¨æ„: éƒ½æ˜¯é¡ºåºæ‰§è¡Œï¼Œä¸æ˜¯å¹¶è¡Œ
```

---

## å‚è€ƒèµ„æº

- [OpenTelemetry SpanProcessor](https://opentelemetry.io/docs/specs/otel/trace/sdk/#span-processor)
- [Go SDK SpanProcessor](https://pkg.go.dev/go.opentelemetry.io/otel/sdk/trace#SpanProcessor)
- [03_é‡‡æ ·å™¨.md](./03_é‡‡æ ·å™¨.md)
- [05_å¯¼å‡ºå™¨.md](./05_å¯¼å‡ºå™¨.md)

---

**ğŸ‰ æ­å–œï¼ä½ å·²ç»æŒæ¡äº† SpanProcessor çš„å®Œæ•´çŸ¥è¯†ï¼**

ç°åœ¨ä½ å¯ä»¥ï¼š

- âœ… ä½¿ç”¨å†…ç½®å¤„ç†å™¨
- âœ… å®ç°è‡ªå®šä¹‰å¤„ç†å™¨
- âœ… é…ç½®æ‰¹å¤„ç†å‚æ•°
- âœ… å®ç°è¿‡æ»¤å’Œé“¾å¼å¤„ç†
- âœ… ä¼˜åŒ–å¤„ç†å™¨æ€§èƒ½
