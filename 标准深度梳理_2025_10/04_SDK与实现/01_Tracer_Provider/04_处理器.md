# SpanProcessor 处理器

## 📋 目录

- [SpanProcessor 处理器](#spanprocessor-处理器)
  - [📋 目录](#-目录)
  - [概述](#概述)
    - [什么是 SpanProcessor](#什么是-spanprocessor)
    - [处理流程](#处理流程)
  - [内置处理器](#内置处理器)
    - [1. SimpleSpanProcessor](#1-simplespanprocessor)
    - [2. BatchSpanProcessor](#2-batchspanprocessor)
    - [3. 多处理器](#3-多处理器)
  - [处理器配置](#处理器配置)
    - [1. 批处理配置](#1-批处理配置)
    - [2. 超时配置](#2-超时配置)
    - [3. 队列配置](#3-队列配置)
  - [Go 1.25.1 实现](#go-1251-实现)
    - [1. 自定义处理器](#1-自定义处理器)
    - [2. 过滤处理器](#2-过滤处理器)
    - [3. 链式处理器](#3-链式处理器)
  - [处理器模式](#处理器模式)
    - [1. 日志处理器](#1-日志处理器)
    - [2. 采样处理器](#2-采样处理器)
    - [3. 属性处理器](#3-属性处理器)
  - [性能优化](#性能优化)
  - [最佳实践](#最佳实践)
  - [常见问题](#常见问题)
  - [参考资源](#参考资源)

---

## 概述

### 什么是 SpanProcessor

**SpanProcessor** 负责处理 Span 的生命周期事件（开始、结束）并将 Span 导出到后端。

```text
Span 生命周期:
1. Span.Start()  → OnStart()
2. Span.End()    → OnEnd()
3. Batch/Export  → Exporter
4. Shutdown      → ForceFlush()
```

### 处理流程

```text
Application
    ↓
Span.End()
    ↓
SpanProcessor.OnEnd()
    ↓ (批处理/立即)
Exporter.ExportSpans()
    ↓
Backend (Jaeger, Collector, etc.)
```

---

## 内置处理器

### 1. SimpleSpanProcessor

同步导出 Span（每个 Span 立即导出）：

```go
import (
    "go.opentelemetry.io/otel/sdk/trace"
    "go.opentelemetry.io/otel/exporters/stdout/stdouttrace"
)

func main() {
    // 创建导出器
    exporter, _ := stdouttrace.New()
    
    // 创建 SimpleSpanProcessor
    processor := trace.NewSimpleSpanProcessor(exporter)
    
    // 配置 TracerProvider
    tp := trace.NewTracerProvider(
        trace.WithSpanProcessor(processor),
    )
    defer tp.Shutdown(context.Background())
}
```

**特点**:

```text
✅ 优点:
  - 简单直接
  - 无缓冲延迟
  - 适合调试

❌ 缺点:
  - 同步阻塞
  - 性能开销大
  - 不适合生产环境

使用场景:
✅ 开发环境
✅ 调试
✅ 测试
❌ 生产环境（高流量）
```

### 2. BatchSpanProcessor

批量异步导出 Span（推荐生产环境）：

```go
import (
    "time"
    "go.opentelemetry.io/otel/sdk/trace"
)

func main() {
    exporter, _ := stdouttrace.New()
    
    // 创建 BatchSpanProcessor
    processor := trace.NewBatchSpanProcessor(
        exporter,
        // 批处理超时
        trace.WithBatchTimeout(5*time.Second),
        
        // 最大批次大小
        trace.WithMaxExportBatchSize(512),
        
        // 最大队列大小
        trace.WithMaxQueueSize(2048),
        
        // 导出超时
        trace.WithExportTimeout(30*time.Second),
    )
    
    tp := trace.NewTracerProvider(
        trace.WithSpanProcessor(processor),
    )
    defer tp.Shutdown(context.Background())
}
```

**特点**:

```text
✅ 优点:
  - 异步非阻塞
  - 批量导出（高效）
  - 适合高流量

⚠️  注意:
  - 有缓冲延迟
  - 内存占用

使用场景:
✅ 生产环境（推荐）
✅ 高流量场景
✅ 性能敏感应用
```

**配置参数**:

```go
const (
    // 默认批处理超时: 5秒
    DefaultBatchTimeout = 5 * time.Second
    
    // 默认最大批次大小: 512
    DefaultMaxExportBatchSize = 512
    
    // 默认最大队列大小: 2048
    DefaultMaxQueueSize = 2048
    
    // 默认导出超时: 30秒
    DefaultExportTimeout = 30 * time.Second
)
```

### 3. 多处理器

使用多个处理器：

```go
func main() {
    // 处理器 1: 导出到 OTLP
    otlpExporter, _ := otlptracegrpc.New(context.Background())
    otlpProcessor := trace.NewBatchSpanProcessor(otlpExporter)
    
    // 处理器 2: 导出到标准输出（调试）
    stdoutExporter, _ := stdouttrace.New()
    stdoutProcessor := trace.NewSimpleSpanProcessor(stdoutExporter)
    
    // 配置多个处理器
    tp := trace.NewTracerProvider(
        trace.WithSpanProcessor(otlpProcessor),
        trace.WithSpanProcessor(stdoutProcessor),
    )
    defer tp.Shutdown(context.Background())
}
```

---

## 处理器配置

### 1. 批处理配置

```go
// 开发环境: 快速导出
processor := trace.NewBatchSpanProcessor(exporter,
    trace.WithBatchTimeout(1*time.Second),
    trace.WithMaxExportBatchSize(10),
    trace.WithMaxQueueSize(100),
)

// 生产环境: 平衡性能和延迟
processor := trace.NewBatchSpanProcessor(exporter,
    trace.WithBatchTimeout(5*time.Second),
    trace.WithMaxExportBatchSize(512),
    trace.WithMaxQueueSize(2048),
)

// 高流量环境: 大批次
processor := trace.NewBatchSpanProcessor(exporter,
    trace.WithBatchTimeout(10*time.Second),
    trace.WithMaxExportBatchSize(1024),
    trace.WithMaxQueueSize(4096),
)
```

### 2. 超时配置

```go
processor := trace.NewBatchSpanProcessor(exporter,
    // 批处理超时: 达到时间后导出
    trace.WithBatchTimeout(5*time.Second),
    
    // 导出超时: 单次导出的最大时间
    trace.WithExportTimeout(30*time.Second),
)
```

### 3. 队列配置

```go
processor := trace.NewBatchSpanProcessor(exporter,
    // 队列大小
    trace.WithMaxQueueSize(2048),
    
    // 批次大小
    trace.WithMaxExportBatchSize(512),
)

// 内存使用估算:
// Memory ≈ MaxQueueSize × AvgSpanSize
// 例如: 2048 × 2KB = ~4MB
```

---

## Go 1.25.1 实现

### 1. 自定义处理器

```go
package processor

import (
    "context"
    "go.opentelemetry.io/otel/sdk/trace"
)

// CustomProcessor 自定义处理器
type CustomProcessor struct {
    exporter trace.SpanExporter
}

// NewCustomProcessor 创建自定义处理器
func NewCustomProcessor(exporter trace.SpanExporter) trace.SpanProcessor {
    return &CustomProcessor{
        exporter: exporter,
    }
}

// OnStart 在 Span 开始时调用
func (p *CustomProcessor) OnStart(parent context.Context, s trace.ReadWriteSpan) {
    // 在 Span 开始时的自定义逻辑
    // 例如: 添加自动属性
    s.SetAttributes(
        attribute.String("processor.name", "custom"),
        attribute.Int64("processor.timestamp", time.Now().Unix()),
    )
}

// OnEnd 在 Span 结束时调用
func (p *CustomProcessor) OnEnd(s trace.ReadOnlySpan) {
    // 自定义导出逻辑
    if s.SpanContext().IsSampled() {
        p.exporter.ExportSpans(context.Background(), []trace.ReadOnlySpan{s})
    }
}

// Shutdown 关闭处理器
func (p *CustomProcessor) Shutdown(ctx context.Context) error {
    return p.exporter.Shutdown(ctx)
}

// ForceFlush 强制刷新
func (p *CustomProcessor) ForceFlush(ctx context.Context) error {
    return nil
}
```

### 2. 过滤处理器

```go
package processor

// FilterProcessor 过滤特定 Span
type FilterProcessor struct {
    next   trace.SpanProcessor
    filter func(trace.ReadOnlySpan) bool
}

// NewFilterProcessor 创建过滤处理器
func NewFilterProcessor(next trace.SpanProcessor, filter func(trace.ReadOnlySpan) bool) trace.SpanProcessor {
    return &FilterProcessor{
        next:   next,
        filter: filter,
    }
}

func (p *FilterProcessor) OnStart(parent context.Context, s trace.ReadWriteSpan) {
    p.next.OnStart(parent, s)
}

func (p *FilterProcessor) OnEnd(s trace.ReadOnlySpan) {
    // 应用过滤器
    if p.filter(s) {
        p.next.OnEnd(s)
    }
}

func (p *FilterProcessor) Shutdown(ctx context.Context) error {
    return p.next.Shutdown(ctx)
}

func (p *FilterProcessor) ForceFlush(ctx context.Context) error {
    return p.next.ForceFlush(ctx)
}

// 使用示例: 只导出错误 Span
func main() {
    exporter, _ := stdouttrace.New()
    batchProcessor := trace.NewBatchSpanProcessor(exporter)
    
    // 过滤器: 只保留错误 Span
    filterProcessor := NewFilterProcessor(
        batchProcessor,
        func(s trace.ReadOnlySpan) bool {
            return s.Status().Code == codes.Error
        },
    )
    
    tp := trace.NewTracerProvider(
        trace.WithSpanProcessor(filterProcessor),
    )
}
```

### 3. 链式处理器

```go
package processor

// ChainProcessor 链式处理器
type ChainProcessor struct {
    processors []trace.SpanProcessor
}

// NewChainProcessor 创建链式处理器
func NewChainProcessor(processors ...trace.SpanProcessor) trace.SpanProcessor {
    return &ChainProcessor{
        processors: processors,
    }
}

func (p *ChainProcessor) OnStart(parent context.Context, s trace.ReadWriteSpan) {
    for _, processor := range p.processors {
        processor.OnStart(parent, s)
    }
}

func (p *ChainProcessor) OnEnd(s trace.ReadOnlySpan) {
    for _, processor := range p.processors {
        processor.OnEnd(s)
    }
}

func (p *ChainProcessor) Shutdown(ctx context.Context) error {
    for _, processor := range p.processors {
        if err := processor.Shutdown(ctx); err != nil {
            return err
        }
    }
    return nil
}

func (p *ChainProcessor) ForceFlush(ctx context.Context) error {
    for _, processor := range p.processors {
        if err := processor.ForceFlush(ctx); err != nil {
            return err
        }
    }
    return nil
}

// 使用示例
func main() {
    // 处理器 1: 日志
    logProcessor := NewLoggingProcessor()
    
    // 处理器 2: 过滤
    filterProcessor := NewFilterProcessor(...)
    
    // 处理器 3: 导出
    exportProcessor := trace.NewBatchSpanProcessor(exporter)
    
    // 链式组合
    chainProcessor := NewChainProcessor(
        logProcessor,
        filterProcessor,
        exportProcessor,
    )
    
    tp := trace.NewTracerProvider(
        trace.WithSpanProcessor(chainProcessor),
    )
}
```

---

## 处理器模式

### 1. 日志处理器

```go
package processor

import (
    "log"
)

// LoggingProcessor 日志处理器
type LoggingProcessor struct{}

func NewLoggingProcessor() trace.SpanProcessor {
    return &LoggingProcessor{}
}

func (p *LoggingProcessor) OnStart(parent context.Context, s trace.ReadWriteSpan) {
    log.Printf("Span started: %s", s.Name())
}

func (p *LoggingProcessor) OnEnd(s trace.ReadOnlySpan) {
    duration := s.EndTime().Sub(s.StartTime())
    log.Printf("Span ended: %s (duration: %v)", s.Name(), duration)
}

func (p *LoggingProcessor) Shutdown(ctx context.Context) error {
    return nil
}

func (p *LoggingProcessor) ForceFlush(ctx context.Context) error {
    return nil
}
```

### 2. 采样处理器

```go
package processor

// SamplingProcessor 采样处理器
type SamplingProcessor struct {
    next trace.SpanProcessor
    rate float64
}

func NewSamplingProcessor(next trace.SpanProcessor, rate float64) trace.SpanProcessor {
    return &SamplingProcessor{
        next: next,
        rate: rate,
    }
}

func (p *SamplingProcessor) OnStart(parent context.Context, s trace.ReadWriteSpan) {
    p.next.OnStart(parent, s)
}

func (p *SamplingProcessor) OnEnd(s trace.ReadOnlySpan) {
    // 后采样：在处理器级别再次采样
    if rand.Float64() < p.rate {
        p.next.OnEnd(s)
    }
}

func (p *SamplingProcessor) Shutdown(ctx context.Context) error {
    return p.next.Shutdown(ctx)
}

func (p *SamplingProcessor) ForceFlush(ctx context.Context) error {
    return p.next.ForceFlush(ctx)
}
```

### 3. 属性处理器

```go
package processor

// AttributeProcessor 属性处理器
type AttributeProcessor struct {
    next       trace.SpanProcessor
    addAttrs   []attribute.KeyValue
    removeKeys []attribute.Key
}

func NewAttributeProcessor(
    next trace.SpanProcessor,
    addAttrs []attribute.KeyValue,
    removeKeys []attribute.Key,
) trace.SpanProcessor {
    return &AttributeProcessor{
        next:       next,
        addAttrs:   addAttrs,
        removeKeys: removeKeys,
    }
}

func (p *AttributeProcessor) OnStart(parent context.Context, s trace.ReadWriteSpan) {
    // 添加属性
    if len(p.addAttrs) > 0 {
        s.SetAttributes(p.addAttrs...)
    }
    
    p.next.OnStart(parent, s)
}

func (p *AttributeProcessor) OnEnd(s trace.ReadOnlySpan) {
    // 注意: ReadOnlySpan 不能修改
    // 如果需要修改，应在 OnStart 中处理
    p.next.OnEnd(s)
}

func (p *AttributeProcessor) Shutdown(ctx context.Context) error {
    return p.next.Shutdown(ctx)
}

func (p *AttributeProcessor) ForceFlush(ctx context.Context) error {
    return p.next.ForceFlush(ctx)
}

// 使用示例
func main() {
    exporter, _ := stdouttrace.New()
    batchProcessor := trace.NewBatchSpanProcessor(exporter)
    
    // 自动添加环境信息
    attrProcessor := NewAttributeProcessor(
        batchProcessor,
        []attribute.KeyValue{
            attribute.String("deployment.environment", "production"),
            attribute.String("service.version", "1.0.0"),
        },
        []attribute.Key{}, // 不删除任何属性
    )
    
    tp := trace.NewTracerProvider(
        trace.WithSpanProcessor(attrProcessor),
    )
}
```

---

## 性能优化

```go
// 1. 使用 BatchSpanProcessor（生产环境）
processor := trace.NewBatchSpanProcessor(exporter,
    trace.WithBatchTimeout(5*time.Second),
    trace.WithMaxExportBatchSize(512),
)

// 2. 调整批次大小
// 小批次: 低延迟，高开销
trace.WithMaxExportBatchSize(128)

// 大批次: 高延迟，低开销
trace.WithMaxExportBatchSize(1024)

// 3. 调整队列大小
// 根据流量和内存限制
trace.WithMaxQueueSize(2048) // ~4MB (假设 2KB/span)

// 4. 设置合理的超时
trace.WithBatchTimeout(5*time.Second)      // 批处理超时
trace.WithExportTimeout(30*time.Second)    // 导出超时

// 5. 避免阻塞操作
// ❌ 错误: 在 OnEnd 中执行耗时操作
func (p *SlowProcessor) OnEnd(s trace.ReadOnlySpan) {
    time.Sleep(1*time.Second) // 阻塞！
    p.next.OnEnd(s)
}

// ✅ 正确: 异步处理
func (p *AsyncProcessor) OnEnd(s trace.ReadOnlySpan) {
    go func() {
        // 异步处理
        time.Sleep(1*time.Second)
        p.next.OnEnd(s)
    }()
}
```

---

## 最佳实践

```go
// ✅ 正确: 生产环境使用 BatchSpanProcessor
processor := trace.NewBatchSpanProcessor(exporter,
    trace.WithBatchTimeout(5*time.Second),
    trace.WithMaxExportBatchSize(512),
    trace.WithMaxQueueSize(2048),
)

// ✅ 正确: 开发环境使用 SimpleSpanProcessor
if os.Getenv("ENV") == "development" {
    processor = trace.NewSimpleSpanProcessor(exporter)
}

// ✅ 正确: 正确关闭处理器
defer func() {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := tp.Shutdown(ctx); err != nil {
        log.Printf("Error shutting down: %v", err)
    }
}()

// ✅ 正确: 强制刷新
func gracefulShutdown(tp *trace.TracerProvider) {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    // 先刷新
    if err := tp.ForceFlush(ctx); err != nil {
        log.Printf("Error flushing: %v", err)
    }
    
    // 再关闭
    if err := tp.Shutdown(ctx); err != nil {
        log.Printf("Error shutting down: %v", err)
    }
}

// ❌ 错误: 忘记关闭
func main() {
    tp := trace.NewTracerProvider(...)
    // 缺少 defer tp.Shutdown()
}

// ❌ 错误: 在 OnEnd 中阻塞
func (p *BadProcessor) OnEnd(s trace.ReadOnlySpan) {
    http.Get("http://example.com") // 阻塞！
}
```

---

## 常见问题

**Q1: SimpleSpanProcessor 和 BatchSpanProcessor 如何选择？**

```text
SimpleSpanProcessor:
✅ 适用场景:
  - 开发环境
  - 调试
  - 低流量 (< 10 RPS)
  - 需要立即可见性

❌ 不适用:
  - 生产环境
  - 高流量
  - 性能敏感

BatchSpanProcessor:
✅ 适用场景:
  - 生产环境（推荐）
  - 高流量
  - 性能敏感
  - 任何规模的应用

⚠️  注意:
  - 有延迟（最多 BatchTimeout）
  - 需要合理配置

推荐:
- 开发: SimpleSpanProcessor
- 生产: BatchSpanProcessor
```

**Q2: 如何确保 Span 不丢失？**

```go
// 1. 设置合理的队列大小
processor := trace.NewBatchSpanProcessor(exporter,
    trace.WithMaxQueueSize(4096), // 足够大
)

// 2. 正确关闭
defer tp.Shutdown(context.Background())

// 3. 监控队列
// 如果队列满，Span 会被丢弃
// 可以通过 metrics 监控

// 4. 使用多个处理器（冗余）
tp := trace.NewTracerProvider(
    trace.WithSpanProcessor(primaryProcessor),
    trace.WithSpanProcessor(backupProcessor),
)
```

**Q3: 处理器的执行顺序？**

```text
配置顺序:
tp := trace.NewTracerProvider(
    trace.WithSpanProcessor(processor1),
    trace.WithSpanProcessor(processor2),
    trace.WithSpanProcessor(processor3),
)

OnStart 执行: processor1 → processor2 → processor3
OnEnd 执行:   processor1 → processor2 → processor3

注意: 都是顺序执行，不是并行
```

---

## 参考资源

- [OpenTelemetry SpanProcessor](https://opentelemetry.io/docs/specs/otel/trace/sdk/#span-processor)
- [Go SDK SpanProcessor](https://pkg.go.dev/go.opentelemetry.io/otel/sdk/trace#SpanProcessor)
- [03_采样器.md](./03_采样器.md)
- [05_导出器.md](./05_导出器.md)

---

**🎉 恭喜！你已经掌握了 SpanProcessor 的完整知识！**

现在你可以：

- ✅ 使用内置处理器
- ✅ 实现自定义处理器
- ✅ 配置批处理参数
- ✅ 实现过滤和链式处理
- ✅ 优化处理器性能
