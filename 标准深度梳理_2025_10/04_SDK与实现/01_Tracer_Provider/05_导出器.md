# SpanExporter å¯¼å‡ºå™¨

## ğŸ“‹ ç›®å½•

- [SpanExporter å¯¼å‡ºå™¨](#spanexporter-å¯¼å‡ºå™¨)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [ä»€ä¹ˆæ˜¯ SpanExporter](#ä»€ä¹ˆæ˜¯-spanexporter)
    - [å¯¼å‡ºæµç¨‹](#å¯¼å‡ºæµç¨‹)
  - [å†…ç½®å¯¼å‡ºå™¨](#å†…ç½®å¯¼å‡ºå™¨)
    - [1. OTLP Exporter](#1-otlp-exporter)
    - [2. Stdout Exporter](#2-stdout-exporter)
    - [3. Jaeger Exporter](#3-jaeger-exporter)
  - [OTLP é…ç½®](#otlp-é…ç½®)
    - [1. gRPC å¯¼å‡ºå™¨](#1-grpc-å¯¼å‡ºå™¨)
    - [2. HTTP å¯¼å‡ºå™¨](#2-http-å¯¼å‡ºå™¨)
    - [3. è®¤è¯é…ç½®](#3-è®¤è¯é…ç½®)
  - [Go 1.25.1 å®ç°](#go-1251-å®ç°)
    - [1. è‡ªå®šä¹‰å¯¼å‡ºå™¨](#1-è‡ªå®šä¹‰å¯¼å‡ºå™¨)
    - [2. å¤šå¯¼å‡ºå™¨](#2-å¤šå¯¼å‡ºå™¨)
    - [3. å¯¼å‡ºå™¨è£…é¥°å™¨](#3-å¯¼å‡ºå™¨è£…é¥°å™¨)
  - [é”™è¯¯å¤„ç†](#é”™è¯¯å¤„ç†)
    - [1. é‡è¯•ç­–ç•¥](#1-é‡è¯•ç­–ç•¥)
    - [2. è¶…æ—¶å¤„ç†](#2-è¶…æ—¶å¤„ç†)
    - [3. é”™è¯¯æ¢å¤](#3-é”™è¯¯æ¢å¤)
  - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)
  - [å‚è€ƒèµ„æº](#å‚è€ƒèµ„æº)

---

## æ¦‚è¿°

### ä»€ä¹ˆæ˜¯ SpanExporter

**SpanExporter** è´Ÿè´£å°† Span æ•°æ®å‘é€åˆ°åç«¯ç³»ç»Ÿï¼ˆå¦‚ Jaegerã€Zipkinã€OpenTelemetry Collectorï¼‰ã€‚

```text
SpanProcessor
    â†“
SpanExporter.ExportSpans()
    â†“ (gRPC/HTTP)
Backend
  - Jaeger
  - Zipkin
  - OTLP Collector
  - Custom Backend
```

### å¯¼å‡ºæµç¨‹

```text
1. BatchSpanProcessor æ”¶é›† Span
2. è¾¾åˆ°æ‰¹æ¬¡å¤§å°æˆ–è¶…æ—¶
3. è°ƒç”¨ Exporter.ExportSpans(spans)
4. Exporter åºåˆ—åŒ–å¹¶å‘é€
5. åç«¯æ¥æ”¶å’Œå­˜å‚¨
```

---

## å†…ç½®å¯¼å‡ºå™¨

### 1. OTLP Exporter

OpenTelemetry Protocol å¯¼å‡ºå™¨ï¼ˆæ¨èï¼‰ï¼š

```go
import (
    "context"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/sdk/trace"
)

func main() {
    // åˆ›å»º OTLP gRPC å¯¼å‡ºå™¨
    exporter, err := otlptracegrpc.New(
        context.Background(),
        otlptracegrpc.WithEndpoint("localhost:4317"),
        otlptracegrpc.WithInsecure(),
    )
    if err != nil {
        log.Fatal(err)
    }
    
    // é…ç½® TracerProvider
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
    )
    defer tp.Shutdown(context.Background())
}
```

**ç‰¹ç‚¹**:

```text
âœ… ä¼˜ç‚¹:
  - OpenTelemetry æ ‡å‡†åè®®
  - é«˜æ•ˆçš„ Protocol Buffers
  - gRPC/HTTP åŒæ”¯æŒ
  - å®˜æ–¹æ¨è

ä½¿ç”¨åœºæ™¯:
âœ… å¯¼å‡ºåˆ° OpenTelemetry Collector
âœ… äº‘å‚å•† (AWS, GCP, Azure)
âœ… ä»»ä½•æ”¯æŒ OTLP çš„åç«¯
```

### 2. Stdout Exporter

æ ‡å‡†è¾“å‡ºå¯¼å‡ºå™¨ï¼ˆè°ƒè¯•ï¼‰ï¼š

```go
import (
    "go.opentelemetry.io/otel/exporters/stdout/stdouttrace"
)

func main() {
    // åˆ›å»º Stdout å¯¼å‡ºå™¨
    exporter, err := stdouttrace.New(
        stdouttrace.WithPrettyPrint(),
    )
    if err != nil {
        log.Fatal(err)
    }
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
    )
    defer tp.Shutdown(context.Background())
}
```

**ç‰¹ç‚¹**:

```text
âœ… é€‚ç”¨åœºæ™¯:
  - å¼€å‘ç¯å¢ƒ
  - è°ƒè¯•
  - æµ‹è¯•
  - æ¼”ç¤º

âŒ ä¸é€‚ç”¨:
  - ç”Ÿäº§ç¯å¢ƒ
```

### 3. Jaeger Exporter

Jaeger å¯¼å‡ºå™¨ï¼š

```go
import (
    "go.opentelemetry.io/otel/exporters/jaeger"
    "go.opentelemetry.io/otel/sdk/trace"
)

func main() {
    // åˆ›å»º Jaeger å¯¼å‡ºå™¨
    exporter, err := jaeger.New(
        jaeger.WithCollectorEndpoint(
            jaeger.WithEndpoint("http://localhost:14268/api/traces"),
        ),
    )
    if err != nil {
        log.Fatal(err)
    }
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
    )
    defer tp.Shutdown(context.Background())
}
```

---

## OTLP é…ç½®

### 1. gRPC å¯¼å‡ºå™¨

```go
import (
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "google.golang.org/grpc/credentials"
)

func NewOTLPgRPCExporter() (trace.SpanExporter, error) {
    return otlptracegrpc.New(
        context.Background(),
        
        // ç«¯ç‚¹é…ç½®
        otlptracegrpc.WithEndpoint("collector.example.com:4317"),
        
        // TLS é…ç½®
        otlptracegrpc.WithTLSCredentials(
            credentials.NewClientTLSFromCert(certPool, ""),
        ),
        
        // æˆ–ä¸ä½¿ç”¨ TLS
        // otlptracegrpc.WithInsecure(),
        
        // é‡è¯•é…ç½®
        otlptracegrpc.WithRetry(otlptracegrpc.RetryConfig{
            Enabled:         true,
            InitialInterval: 5 * time.Second,
            MaxInterval:     30 * time.Second,
            MaxElapsedTime:  time.Minute,
        }),
        
        // è¶…æ—¶é…ç½®
        otlptracegrpc.WithTimeout(30*time.Second),
        
        // å‹ç¼©
        otlptracegrpc.WithCompressor("gzip"),
        
        // HTTP å¤´
        otlptracegrpc.WithHeaders(map[string]string{
            "api-key": "your-api-key",
        }),
    )
}
```

### 2. HTTP å¯¼å‡ºå™¨

```go
import (
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
)

func NewOTLPHTTPExporter() (trace.SpanExporter, error) {
    return otlptracehttp.New(
        context.Background(),
        
        // ç«¯ç‚¹é…ç½®
        otlptracehttp.WithEndpoint("collector.example.com:4318"),
        
        // URL è·¯å¾„
        otlptracehttp.WithURLPath("/v1/traces"),
        
        // TLS é…ç½®
        otlptracehttp.WithTLSClientConfig(&tls.Config{
            InsecureSkipVerify: false,
        }),
        
        // æˆ–ä¸ä½¿ç”¨ TLS
        // otlptracehttp.WithInsecure(),
        
        // é‡è¯•é…ç½®
        otlptracehttp.WithRetry(otlptracehttp.RetryConfig{
            Enabled:         true,
            InitialInterval: 5 * time.Second,
            MaxInterval:     30 * time.Second,
            MaxElapsedTime:  time.Minute,
        }),
        
        // è¶…æ—¶
        otlptracehttp.WithTimeout(30*time.Second),
        
        // å‹ç¼©
        otlptracehttp.WithCompression(otlptracehttp.GzipCompression),
        
        // HTTP å¤´
        otlptracehttp.WithHeaders(map[string]string{
            "api-key": "your-api-key",
        }),
    )
}
```

### 3. è®¤è¯é…ç½®

```go
// 1. API Key è®¤è¯
exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithEndpoint("collector.example.com:4317"),
    otlptracegrpc.WithHeaders(map[string]string{
        "authorization": "Bearer YOUR_API_KEY",
    }),
)

// 2. mTLS è®¤è¯
cert, _ := tls.LoadX509KeyPair("client.crt", "client.key")
caCert, _ := os.ReadFile("ca.crt")
caCertPool := x509.NewCertPool()
caCertPool.AppendCertsFromPEM(caCert)

tlsConfig := &tls.Config{
    Certificates: []tls.Certificate{cert},
    RootCAs:      caCertPool,
}

exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithEndpoint("collector.example.com:4317"),
    otlptracegrpc.WithTLSCredentials(
        credentials.NewTLS(tlsConfig),
    ),
)

// 3. è‡ªå®šä¹‰è®¤è¯
type customAuthInterceptor struct{}

func (i *customAuthInterceptor) UnaryClientInterceptor(...) {
    // è‡ªå®šä¹‰è®¤è¯é€»è¾‘
}

exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithDialOption(
        grpc.WithUnaryInterceptor(interceptor),
    ),
)
```

---

## Go 1.25.1 å®ç°

### 1. è‡ªå®šä¹‰å¯¼å‡ºå™¨

```go
package exporter

import (
    "context"
    "go.opentelemetry.io/otel/sdk/trace"
)

// CustomExporter è‡ªå®šä¹‰å¯¼å‡ºå™¨
type CustomExporter struct {
    endpoint string
    client   *http.Client
}

// NewCustomExporter åˆ›å»ºè‡ªå®šä¹‰å¯¼å‡ºå™¨
func NewCustomExporter(endpoint string) trace.SpanExporter {
    return &CustomExporter{
        endpoint: endpoint,
        client:   &http.Client{Timeout: 30 * time.Second},
    }
}

// ExportSpans å¯¼å‡º Span
func (e *CustomExporter) ExportSpans(ctx context.Context, spans []trace.ReadOnlySpan) error {
    // 1. åºåˆ—åŒ– Span
    data, err := e.serializeSpans(spans)
    if err != nil {
        return fmt.Errorf("failed to serialize spans: %w", err)
    }
    
    // 2. å‘é€åˆ°åç«¯
    req, err := http.NewRequestWithContext(ctx, "POST", e.endpoint, bytes.NewReader(data))
    if err != nil {
        return err
    }
    
    req.Header.Set("Content-Type", "application/json")
    
    resp, err := e.client.Do(req)
    if err != nil {
        return fmt.Errorf("failed to send spans: %w", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
    }
    
    return nil
}

// Shutdown å…³é—­å¯¼å‡ºå™¨
func (e *CustomExporter) Shutdown(ctx context.Context) error {
    e.client.CloseIdleConnections()
    return nil
}

func (e *CustomExporter) serializeSpans(spans []trace.ReadOnlySpan) ([]byte, error) {
    // å®ç°åºåˆ—åŒ–é€»è¾‘
    // ä¾‹å¦‚ï¼šè½¬æ¢ä¸º JSON
    type spanData struct {
        Name     string            `json:"name"`
        TraceID  string            `json:"trace_id"`
        SpanID   string            `json:"span_id"`
        Duration time.Duration     `json:"duration"`
        Attrs    map[string]string `json:"attributes"`
    }
    
    data := make([]spanData, 0, len(spans))
    for _, span := range spans {
        attrs := make(map[string]string)
        for _, attr := range span.Attributes() {
            attrs[string(attr.Key)] = attr.Value.AsString()
        }
        
        data = append(data, spanData{
            Name:     span.Name(),
            TraceID:  span.SpanContext().TraceID().String(),
            SpanID:   span.SpanContext().SpanID().String(),
            Duration: span.EndTime().Sub(span.StartTime()),
            Attrs:    attrs,
        })
    }
    
    return json.Marshal(data)
}
```

### 2. å¤šå¯¼å‡ºå™¨

```go
package exporter

// MultiExporter å¤šå¯¼å‡ºå™¨
type MultiExporter struct {
    exporters []trace.SpanExporter
}

// NewMultiExporter åˆ›å»ºå¤šå¯¼å‡ºå™¨
func NewMultiExporter(exporters ...trace.SpanExporter) trace.SpanExporter {
    return &MultiExporter{
        exporters: exporters,
    }
}

// ExportSpans å¯¼å‡ºåˆ°æ‰€æœ‰å¯¼å‡ºå™¨
func (e *MultiExporter) ExportSpans(ctx context.Context, spans []trace.ReadOnlySpan) error {
    var errs []error
    
    for _, exporter := range e.exporters {
        if err := exporter.ExportSpans(ctx, spans); err != nil {
            errs = append(errs, err)
        }
    }
    
    if len(errs) > 0 {
        return fmt.Errorf("multiple export errors: %v", errs)
    }
    
    return nil
}

// Shutdown å…³é—­æ‰€æœ‰å¯¼å‡ºå™¨
func (e *MultiExporter) Shutdown(ctx context.Context) error {
    var errs []error
    
    for _, exporter := range e.exporters {
        if err := exporter.Shutdown(ctx); err != nil {
            errs = append(errs, err)
        }
    }
    
    if len(errs) > 0 {
        return fmt.Errorf("multiple shutdown errors: %v", errs)
    }
    
    return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    // å¯¼å‡ºå™¨ 1: OTLP
    otlpExporter, _ := otlptracegrpc.New(context.Background())
    
    // å¯¼å‡ºå™¨ 2: Jaeger
    jaegerExporter, _ := jaeger.New(...)
    
    // ç»„åˆå¯¼å‡ºå™¨
    multiExporter := NewMultiExporter(otlpExporter, jaegerExporter)
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(multiExporter),
    )
}
```

### 3. å¯¼å‡ºå™¨è£…é¥°å™¨

```go
package exporter

// LoggingExporter æ—¥å¿—è£…é¥°å™¨
type LoggingExporter struct {
    next trace.SpanExporter
}

func NewLoggingExporter(next trace.SpanExporter) trace.SpanExporter {
    return &LoggingExporter{next: next}
}

func (e *LoggingExporter) ExportSpans(ctx context.Context, spans []trace.ReadOnlySpan) error {
    log.Printf("Exporting %d spans", len(spans))
    
    start := time.Now()
    err := e.next.ExportSpans(ctx, spans)
    duration := time.Since(start)
    
    if err != nil {
        log.Printf("Export failed: %v (duration: %v)", err, duration)
    } else {
        log.Printf("Export successful (duration: %v)", duration)
    }
    
    return err
}

func (e *LoggingExporter) Shutdown(ctx context.Context) error {
    return e.next.Shutdown(ctx)
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    baseExporter, _ := otlptracegrpc.New(context.Background())
    loggingExporter := NewLoggingExporter(baseExporter)
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(loggingExporter),
    )
}
```

---

## é”™è¯¯å¤„ç†

### 1. é‡è¯•ç­–ç•¥

```go
package exporter

import (
    "time"
)

// RetryExporter é‡è¯•å¯¼å‡ºå™¨
type RetryExporter struct {
    next       trace.SpanExporter
    maxRetries int
    backoff    time.Duration
}

func NewRetryExporter(next trace.SpanExporter, maxRetries int) trace.SpanExporter {
    return &RetryExporter{
        next:       next,
        maxRetries: maxRetries,
        backoff:    time.Second,
    }
}

func (e *RetryExporter) ExportSpans(ctx context.Context, spans []trace.ReadOnlySpan) error {
    var lastErr error
    
    for i := 0; i <= e.maxRetries; i++ {
        err := e.next.ExportSpans(ctx, spans)
        if err == nil {
            return nil
        }
        
        lastErr = err
        
        // æœ€åä¸€æ¬¡å°è¯•ï¼Œä¸ç­‰å¾…
        if i == e.maxRetries {
            break
        }
        
        // æŒ‡æ•°é€€é¿
        backoff := e.backoff * time.Duration(1<<uint(i))
        log.Printf("Export failed, retrying in %v (attempt %d/%d): %v",
            backoff, i+1, e.maxRetries, err)
        
        select {
        case <-ctx.Done():
            return ctx.Err()
        case <-time.After(backoff):
        }
    }
    
    return fmt.Errorf("export failed after %d retries: %w", e.maxRetries, lastErr)
}

func (e *RetryExporter) Shutdown(ctx context.Context) error {
    return e.next.Shutdown(ctx)
}
```

### 2. è¶…æ—¶å¤„ç†

```go
// å¯¼å‡ºå™¨è¶…æ—¶é…ç½®
exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithTimeout(30*time.Second),
)

// æˆ–åœ¨ ExportSpans ä¸­è®¾ç½®
func (e *CustomExporter) ExportSpans(ctx context.Context, spans []trace.ReadOnlySpan) error {
    // è®¾ç½®è¶…æ—¶
    ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
    defer cancel()
    
    // å¯¼å‡ºé€»è¾‘
    return e.doExport(ctx, spans)
}
```

### 3. é”™è¯¯æ¢å¤

```go
package exporter

// FallbackExporter æ•…éšœè½¬ç§»å¯¼å‡ºå™¨
type FallbackExporter struct {
    primary   trace.SpanExporter
    fallback  trace.SpanExporter
}

func NewFallbackExporter(primary, fallback trace.SpanExporter) trace.SpanExporter {
    return &FallbackExporter{
        primary:  primary,
        fallback: fallback,
    }
}

func (e *FallbackExporter) ExportSpans(ctx context.Context, spans []trace.ReadOnlySpan) error {
    // å°è¯•ä¸»å¯¼å‡ºå™¨
    err := e.primary.ExportSpans(ctx, spans)
    if err == nil {
        return nil
    }
    
    log.Printf("Primary exporter failed: %v, using fallback", err)
    
    // æ•…éšœè½¬ç§»åˆ°å¤‡ç”¨å¯¼å‡ºå™¨
    return e.fallback.ExportSpans(ctx, spans)
}

func (e *FallbackExporter) Shutdown(ctx context.Context) error {
    err1 := e.primary.Shutdown(ctx)
    err2 := e.fallback.Shutdown(ctx)
    
    if err1 != nil {
        return err1
    }
    return err2
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    primaryExporter, _ := otlptracegrpc.New(context.Background(),
        otlptracegrpc.WithEndpoint("primary-collector:4317"),
    )
    
    fallbackExporter, _ := otlptracegrpc.New(context.Background(),
        otlptracegrpc.WithEndpoint("fallback-collector:4317"),
    )
    
    exporter := NewFallbackExporter(primaryExporter, fallbackExporter)
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
    )
}
```

---

## æ€§èƒ½ä¼˜åŒ–

```go
// 1. ä½¿ç”¨è¿æ¥æ± 
exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithDialOption(
        grpc.WithDefaultServiceConfig(`{"loadBalancingPolicy":"round_robin"}`),
    ),
)

// 2. å¯ç”¨å‹ç¼©
exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithCompressor("gzip"),
)

// 3. é…ç½®è¶…æ—¶
exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithTimeout(30*time.Second),
)

// 4. æ‰¹å¤„ç†é…ç½®ï¼ˆåœ¨ Processor çº§åˆ«ï¼‰
processor := trace.NewBatchSpanProcessor(exporter,
    trace.WithMaxExportBatchSize(512),  // å¤§æ‰¹æ¬¡
    trace.WithBatchTimeout(5*time.Second),
)

// 5. é‡ç”¨å¯¼å‡ºå™¨ï¼ˆä¸è¦é¢‘ç¹åˆ›å»ºï¼‰
var globalExporter trace.SpanExporter

func init() {
    var err error
    globalExporter, err = otlptracegrpc.New(context.Background())
    if err != nil {
        log.Fatal(err)
    }
}
```

---

## æœ€ä½³å®è·µ

```go
// âœ… æ­£ç¡®: ç”Ÿäº§ç¯å¢ƒä½¿ç”¨ OTLP
exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithEndpoint("collector:4317"),
    otlptracegrpc.WithTLSCredentials(...),
)

// âœ… æ­£ç¡®: é…ç½®é‡è¯•
exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithRetry(otlptracegrpc.RetryConfig{
        Enabled:         true,
        InitialInterval: 5 * time.Second,
        MaxInterval:     30 * time.Second,
    }),
)

// âœ… æ­£ç¡®: æ­£ç¡®å…³é—­
defer func() {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    if err := exporter.Shutdown(ctx); err != nil {
        log.Printf("Error shutting down exporter: %v", err)
    }
}()

// âœ… æ­£ç¡®: ä½¿ç”¨ç¯å¢ƒå˜é‡é…ç½®
endpoint := os.Getenv("OTEL_EXPORTER_OTLP_ENDPOINT")
if endpoint == "" {
    endpoint = "localhost:4317"
}

exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithEndpoint(endpoint),
)

// âŒ é”™è¯¯: ç¡¬ç¼–ç æ•æ„Ÿä¿¡æ¯
exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithHeaders(map[string]string{
        "api-key": "hardcoded-api-key", // ä¸è¦è¿™æ ·åš
    }),
)

// âœ… æ­£ç¡®: ä»ç¯å¢ƒå˜é‡è¯»å–
exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithHeaders(map[string]string{
        "api-key": os.Getenv("OTLP_API_KEY"),
    }),
)
```

---

## å¸¸è§é—®é¢˜

**Q1: gRPC å’Œ HTTP å¯¼å‡ºå™¨å¦‚ä½•é€‰æ‹©ï¼Ÿ**

```text
gRPC (æ¨è):
âœ… ä¼˜ç‚¹:
  - æ€§èƒ½æ›´å¥½
  - åŒå‘æµ
  - å†…ç½®è´Ÿè½½å‡è¡¡
  - Protocol Buffers é«˜æ•ˆ

âŒ ç¼ºç‚¹:
  - éœ€è¦ gRPC æ”¯æŒ
  - é…ç½®ç¨å¤æ‚

HTTP:
âœ… ä¼˜ç‚¹:
  - å…¼å®¹æ€§å¥½
  - æ˜“äºè°ƒè¯•
  - é˜²ç«å¢™å‹å¥½

âŒ ç¼ºç‚¹:
  - æ€§èƒ½ç¨å·®
  - å•å‘é€šä¿¡

æ¨è:
- é»˜è®¤ä½¿ç”¨ gRPC
- å¦‚æœæœ‰å…¼å®¹æ€§é—®é¢˜ï¼Œä½¿ç”¨ HTTP
```

**Q2: å¦‚ä½•ç›‘æ§å¯¼å‡ºå™¨çŠ¶æ€ï¼Ÿ**

```go
// ä½¿ç”¨è£…é¥°å™¨æ¨¡å¼æ·»åŠ ç›‘æ§
type MonitoredExporter struct {
    next          trace.SpanExporter
    successCount  atomic.Int64
    errorCount    atomic.Int64
    spanCount     atomic.Int64
}

func (e *MonitoredExporter) ExportSpans(ctx context.Context, spans []trace.ReadOnlySpan) error {
    e.spanCount.Add(int64(len(spans)))
    
    err := e.next.ExportSpans(ctx, spans)
    if err != nil {
        e.errorCount.Add(1)
    } else {
        e.successCount.Add(1)
    }
    
    return err
}

// å®šæœŸæŠ¥å‘Š
func (e *MonitoredExporter) ReportMetrics() {
    log.Printf("Exporter stats: success=%d, errors=%d, spans=%d",
        e.successCount.Load(),
        e.errorCount.Load(),
        e.spanCount.Load(),
    )
}
```

**Q3: å¦‚ä½•å¤„ç†ç½‘ç»œæ•…éšœï¼Ÿ**

```text
ç­–ç•¥:
1. å¯ç”¨é‡è¯•
   otlptracegrpc.WithRetry(...)

2. è®¾ç½®åˆç†è¶…æ—¶
   otlptracegrpc.WithTimeout(30*time.Second)

3. ä½¿ç”¨æ•…éšœè½¬ç§»
   NewFallbackExporter(primary, fallback)

4. ç›‘æ§å’Œå‘Šè­¦
   è®°å½•å¯¼å‡ºå¤±è´¥ç‡

5. æœ¬åœ°ç¼“å­˜ï¼ˆå¯é€‰ï¼‰
   åœ¨ç½‘ç»œæ•…éšœæ—¶ç¼“å­˜åˆ°æœ¬åœ°æ–‡ä»¶
```

---

## å‚è€ƒèµ„æº

- [OpenTelemetry Exporters](https://opentelemetry.io/docs/specs/otel/trace/sdk/#span-exporter)
- [OTLP Specification](https://opentelemetry.io/docs/specs/otlp/)
- [Go SDK Exporters](https://pkg.go.dev/go.opentelemetry.io/otel/sdk/trace#SpanExporter)
- [04_å¤„ç†å™¨.md](./04_å¤„ç†å™¨.md)

---

**ğŸ‰ æ­å–œï¼ä½ å·²ç»æŒæ¡äº† SpanExporter çš„å®Œæ•´çŸ¥è¯†ï¼**

**ğŸŠğŸŠğŸŠ Phase 4.1: Tracer Provider å…¨éƒ¨å®Œæˆï¼ğŸŠğŸŠğŸŠ**-

ç°åœ¨ä½ å¯ä»¥ï¼š

- âœ… ä½¿ç”¨å„ç§å†…ç½®å¯¼å‡ºå™¨
- âœ… é…ç½® OTLP gRPC/HTTP
- âœ… å®ç°è‡ªå®šä¹‰å¯¼å‡ºå™¨
- âœ… å¤„ç†é”™è¯¯å’Œé‡è¯•
- âœ… ä¼˜åŒ–å¯¼å‡ºæ€§èƒ½
