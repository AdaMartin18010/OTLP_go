# SpanExporter 导出器

## 📋 目录

- [SpanExporter 导出器](#spanexporter-导出器)
  - [📋 目录](#-目录)
  - [概述](#概述)
    - [什么是 SpanExporter](#什么是-spanexporter)
    - [导出流程](#导出流程)
  - [内置导出器](#内置导出器)
    - [1. OTLP Exporter](#1-otlp-exporter)
    - [2. Stdout Exporter](#2-stdout-exporter)
    - [3. Jaeger Exporter](#3-jaeger-exporter)
  - [OTLP 配置](#otlp-配置)
    - [1. gRPC 导出器](#1-grpc-导出器)
    - [2. HTTP 导出器](#2-http-导出器)
    - [3. 认证配置](#3-认证配置)
  - [Go 1.25.1 实现](#go-1251-实现)
    - [1. 自定义导出器](#1-自定义导出器)
    - [2. 多导出器](#2-多导出器)
    - [3. 导出器装饰器](#3-导出器装饰器)
  - [错误处理](#错误处理)
    - [1. 重试策略](#1-重试策略)
    - [2. 超时处理](#2-超时处理)
    - [3. 错误恢复](#3-错误恢复)
  - [性能优化](#性能优化)
  - [最佳实践](#最佳实践)
  - [常见问题](#常见问题)
  - [参考资源](#参考资源)

---

## 概述

### 什么是 SpanExporter

**SpanExporter** 负责将 Span 数据发送到后端系统（如 Jaeger、Zipkin、OpenTelemetry Collector）。

```text
SpanProcessor
    ↓
SpanExporter.ExportSpans()
    ↓ (gRPC/HTTP)
Backend
  - Jaeger
  - Zipkin
  - OTLP Collector
  - Custom Backend
```

### 导出流程

```text
1. BatchSpanProcessor 收集 Span
2. 达到批次大小或超时
3. 调用 Exporter.ExportSpans(spans)
4. Exporter 序列化并发送
5. 后端接收和存储
```

---

## 内置导出器

### 1. OTLP Exporter

OpenTelemetry Protocol 导出器（推荐）：

```go
import (
    "context"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/sdk/trace"
)

func main() {
    // 创建 OTLP gRPC 导出器
    exporter, err := otlptracegrpc.New(
        context.Background(),
        otlptracegrpc.WithEndpoint("localhost:4317"),
        otlptracegrpc.WithInsecure(),
    )
    if err != nil {
        log.Fatal(err)
    }
    
    // 配置 TracerProvider
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
    )
    defer tp.Shutdown(context.Background())
}
```

**特点**:

```text
✅ 优点:
  - OpenTelemetry 标准协议
  - 高效的 Protocol Buffers
  - gRPC/HTTP 双支持
  - 官方推荐

使用场景:
✅ 导出到 OpenTelemetry Collector
✅ 云厂商 (AWS, GCP, Azure)
✅ 任何支持 OTLP 的后端
```

### 2. Stdout Exporter

标准输出导出器（调试）：

```go
import (
    "go.opentelemetry.io/otel/exporters/stdout/stdouttrace"
)

func main() {
    // 创建 Stdout 导出器
    exporter, err := stdouttrace.New(
        stdouttrace.WithPrettyPrint(),
    )
    if err != nil {
        log.Fatal(err)
    }
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
    )
    defer tp.Shutdown(context.Background())
}
```

**特点**:

```text
✅ 适用场景:
  - 开发环境
  - 调试
  - 测试
  - 演示

❌ 不适用:
  - 生产环境
```

### 3. Jaeger Exporter

Jaeger 导出器：

```go
import (
    "go.opentelemetry.io/otel/exporters/jaeger"
    "go.opentelemetry.io/otel/sdk/trace"
)

func main() {
    // 创建 Jaeger 导出器
    exporter, err := jaeger.New(
        jaeger.WithCollectorEndpoint(
            jaeger.WithEndpoint("http://localhost:14268/api/traces"),
        ),
    )
    if err != nil {
        log.Fatal(err)
    }
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
    )
    defer tp.Shutdown(context.Background())
}
```

---

## OTLP 配置

### 1. gRPC 导出器

```go
import (
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "google.golang.org/grpc/credentials"
)

func NewOTLPgRPCExporter() (trace.SpanExporter, error) {
    return otlptracegrpc.New(
        context.Background(),
        
        // 端点配置
        otlptracegrpc.WithEndpoint("collector.example.com:4317"),
        
        // TLS 配置
        otlptracegrpc.WithTLSCredentials(
            credentials.NewClientTLSFromCert(certPool, ""),
        ),
        
        // 或不使用 TLS
        // otlptracegrpc.WithInsecure(),
        
        // 重试配置
        otlptracegrpc.WithRetry(otlptracegrpc.RetryConfig{
            Enabled:         true,
            InitialInterval: 5 * time.Second,
            MaxInterval:     30 * time.Second,
            MaxElapsedTime:  time.Minute,
        }),
        
        // 超时配置
        otlptracegrpc.WithTimeout(30*time.Second),
        
        // 压缩
        otlptracegrpc.WithCompressor("gzip"),
        
        // HTTP 头
        otlptracegrpc.WithHeaders(map[string]string{
            "api-key": "your-api-key",
        }),
    )
}
```

### 2. HTTP 导出器

```go
import (
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
)

func NewOTLPHTTPExporter() (trace.SpanExporter, error) {
    return otlptracehttp.New(
        context.Background(),
        
        // 端点配置
        otlptracehttp.WithEndpoint("collector.example.com:4318"),
        
        // URL 路径
        otlptracehttp.WithURLPath("/v1/traces"),
        
        // TLS 配置
        otlptracehttp.WithTLSClientConfig(&tls.Config{
            InsecureSkipVerify: false,
        }),
        
        // 或不使用 TLS
        // otlptracehttp.WithInsecure(),
        
        // 重试配置
        otlptracehttp.WithRetry(otlptracehttp.RetryConfig{
            Enabled:         true,
            InitialInterval: 5 * time.Second,
            MaxInterval:     30 * time.Second,
            MaxElapsedTime:  time.Minute,
        }),
        
        // 超时
        otlptracehttp.WithTimeout(30*time.Second),
        
        // 压缩
        otlptracehttp.WithCompression(otlptracehttp.GzipCompression),
        
        // HTTP 头
        otlptracehttp.WithHeaders(map[string]string{
            "api-key": "your-api-key",
        }),
    )
}
```

### 3. 认证配置

```go
// 1. API Key 认证
exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithEndpoint("collector.example.com:4317"),
    otlptracegrpc.WithHeaders(map[string]string{
        "authorization": "Bearer YOUR_API_KEY",
    }),
)

// 2. mTLS 认证
cert, _ := tls.LoadX509KeyPair("client.crt", "client.key")
caCert, _ := os.ReadFile("ca.crt")
caCertPool := x509.NewCertPool()
caCertPool.AppendCertsFromPEM(caCert)

tlsConfig := &tls.Config{
    Certificates: []tls.Certificate{cert},
    RootCAs:      caCertPool,
}

exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithEndpoint("collector.example.com:4317"),
    otlptracegrpc.WithTLSCredentials(
        credentials.NewTLS(tlsConfig),
    ),
)

// 3. 自定义认证
type customAuthInterceptor struct{}

func (i *customAuthInterceptor) UnaryClientInterceptor(...) {
    // 自定义认证逻辑
}

exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithDialOption(
        grpc.WithUnaryInterceptor(interceptor),
    ),
)
```

---

## Go 1.25.1 实现

### 1. 自定义导出器

```go
package exporter

import (
    "context"
    "go.opentelemetry.io/otel/sdk/trace"
)

// CustomExporter 自定义导出器
type CustomExporter struct {
    endpoint string
    client   *http.Client
}

// NewCustomExporter 创建自定义导出器
func NewCustomExporter(endpoint string) trace.SpanExporter {
    return &CustomExporter{
        endpoint: endpoint,
        client:   &http.Client{Timeout: 30 * time.Second},
    }
}

// ExportSpans 导出 Span
func (e *CustomExporter) ExportSpans(ctx context.Context, spans []trace.ReadOnlySpan) error {
    // 1. 序列化 Span
    data, err := e.serializeSpans(spans)
    if err != nil {
        return fmt.Errorf("failed to serialize spans: %w", err)
    }
    
    // 2. 发送到后端
    req, err := http.NewRequestWithContext(ctx, "POST", e.endpoint, bytes.NewReader(data))
    if err != nil {
        return err
    }
    
    req.Header.Set("Content-Type", "application/json")
    
    resp, err := e.client.Do(req)
    if err != nil {
        return fmt.Errorf("failed to send spans: %w", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
    }
    
    return nil
}

// Shutdown 关闭导出器
func (e *CustomExporter) Shutdown(ctx context.Context) error {
    e.client.CloseIdleConnections()
    return nil
}

func (e *CustomExporter) serializeSpans(spans []trace.ReadOnlySpan) ([]byte, error) {
    // 实现序列化逻辑
    // 例如：转换为 JSON
    type spanData struct {
        Name     string            `json:"name"`
        TraceID  string            `json:"trace_id"`
        SpanID   string            `json:"span_id"`
        Duration time.Duration     `json:"duration"`
        Attrs    map[string]string `json:"attributes"`
    }
    
    data := make([]spanData, 0, len(spans))
    for _, span := range spans {
        attrs := make(map[string]string)
        for _, attr := range span.Attributes() {
            attrs[string(attr.Key)] = attr.Value.AsString()
        }
        
        data = append(data, spanData{
            Name:     span.Name(),
            TraceID:  span.SpanContext().TraceID().String(),
            SpanID:   span.SpanContext().SpanID().String(),
            Duration: span.EndTime().Sub(span.StartTime()),
            Attrs:    attrs,
        })
    }
    
    return json.Marshal(data)
}
```

### 2. 多导出器

```go
package exporter

// MultiExporter 多导出器
type MultiExporter struct {
    exporters []trace.SpanExporter
}

// NewMultiExporter 创建多导出器
func NewMultiExporter(exporters ...trace.SpanExporter) trace.SpanExporter {
    return &MultiExporter{
        exporters: exporters,
    }
}

// ExportSpans 导出到所有导出器
func (e *MultiExporter) ExportSpans(ctx context.Context, spans []trace.ReadOnlySpan) error {
    var errs []error
    
    for _, exporter := range e.exporters {
        if err := exporter.ExportSpans(ctx, spans); err != nil {
            errs = append(errs, err)
        }
    }
    
    if len(errs) > 0 {
        return fmt.Errorf("multiple export errors: %v", errs)
    }
    
    return nil
}

// Shutdown 关闭所有导出器
func (e *MultiExporter) Shutdown(ctx context.Context) error {
    var errs []error
    
    for _, exporter := range e.exporters {
        if err := exporter.Shutdown(ctx); err != nil {
            errs = append(errs, err)
        }
    }
    
    if len(errs) > 0 {
        return fmt.Errorf("multiple shutdown errors: %v", errs)
    }
    
    return nil
}

// 使用示例
func main() {
    // 导出器 1: OTLP
    otlpExporter, _ := otlptracegrpc.New(context.Background())
    
    // 导出器 2: Jaeger
    jaegerExporter, _ := jaeger.New(...)
    
    // 组合导出器
    multiExporter := NewMultiExporter(otlpExporter, jaegerExporter)
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(multiExporter),
    )
}
```

### 3. 导出器装饰器

```go
package exporter

// LoggingExporter 日志装饰器
type LoggingExporter struct {
    next trace.SpanExporter
}

func NewLoggingExporter(next trace.SpanExporter) trace.SpanExporter {
    return &LoggingExporter{next: next}
}

func (e *LoggingExporter) ExportSpans(ctx context.Context, spans []trace.ReadOnlySpan) error {
    log.Printf("Exporting %d spans", len(spans))
    
    start := time.Now()
    err := e.next.ExportSpans(ctx, spans)
    duration := time.Since(start)
    
    if err != nil {
        log.Printf("Export failed: %v (duration: %v)", err, duration)
    } else {
        log.Printf("Export successful (duration: %v)", duration)
    }
    
    return err
}

func (e *LoggingExporter) Shutdown(ctx context.Context) error {
    return e.next.Shutdown(ctx)
}

// 使用示例
func main() {
    baseExporter, _ := otlptracegrpc.New(context.Background())
    loggingExporter := NewLoggingExporter(baseExporter)
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(loggingExporter),
    )
}
```

---

## 错误处理

### 1. 重试策略

```go
package exporter

import (
    "time"
)

// RetryExporter 重试导出器
type RetryExporter struct {
    next       trace.SpanExporter
    maxRetries int
    backoff    time.Duration
}

func NewRetryExporter(next trace.SpanExporter, maxRetries int) trace.SpanExporter {
    return &RetryExporter{
        next:       next,
        maxRetries: maxRetries,
        backoff:    time.Second,
    }
}

func (e *RetryExporter) ExportSpans(ctx context.Context, spans []trace.ReadOnlySpan) error {
    var lastErr error
    
    for i := 0; i <= e.maxRetries; i++ {
        err := e.next.ExportSpans(ctx, spans)
        if err == nil {
            return nil
        }
        
        lastErr = err
        
        // 最后一次尝试，不等待
        if i == e.maxRetries {
            break
        }
        
        // 指数退避
        backoff := e.backoff * time.Duration(1<<uint(i))
        log.Printf("Export failed, retrying in %v (attempt %d/%d): %v",
            backoff, i+1, e.maxRetries, err)
        
        select {
        case <-ctx.Done():
            return ctx.Err()
        case <-time.After(backoff):
        }
    }
    
    return fmt.Errorf("export failed after %d retries: %w", e.maxRetries, lastErr)
}

func (e *RetryExporter) Shutdown(ctx context.Context) error {
    return e.next.Shutdown(ctx)
}
```

### 2. 超时处理

```go
// 导出器超时配置
exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithTimeout(30*time.Second),
)

// 或在 ExportSpans 中设置
func (e *CustomExporter) ExportSpans(ctx context.Context, spans []trace.ReadOnlySpan) error {
    // 设置超时
    ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
    defer cancel()
    
    // 导出逻辑
    return e.doExport(ctx, spans)
}
```

### 3. 错误恢复

```go
package exporter

// FallbackExporter 故障转移导出器
type FallbackExporter struct {
    primary   trace.SpanExporter
    fallback  trace.SpanExporter
}

func NewFallbackExporter(primary, fallback trace.SpanExporter) trace.SpanExporter {
    return &FallbackExporter{
        primary:  primary,
        fallback: fallback,
    }
}

func (e *FallbackExporter) ExportSpans(ctx context.Context, spans []trace.ReadOnlySpan) error {
    // 尝试主导出器
    err := e.primary.ExportSpans(ctx, spans)
    if err == nil {
        return nil
    }
    
    log.Printf("Primary exporter failed: %v, using fallback", err)
    
    // 故障转移到备用导出器
    return e.fallback.ExportSpans(ctx, spans)
}

func (e *FallbackExporter) Shutdown(ctx context.Context) error {
    err1 := e.primary.Shutdown(ctx)
    err2 := e.fallback.Shutdown(ctx)
    
    if err1 != nil {
        return err1
    }
    return err2
}

// 使用示例
func main() {
    primaryExporter, _ := otlptracegrpc.New(context.Background(),
        otlptracegrpc.WithEndpoint("primary-collector:4317"),
    )
    
    fallbackExporter, _ := otlptracegrpc.New(context.Background(),
        otlptracegrpc.WithEndpoint("fallback-collector:4317"),
    )
    
    exporter := NewFallbackExporter(primaryExporter, fallbackExporter)
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
    )
}
```

---

## 性能优化

```go
// 1. 使用连接池
exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithDialOption(
        grpc.WithDefaultServiceConfig(`{"loadBalancingPolicy":"round_robin"}`),
    ),
)

// 2. 启用压缩
exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithCompressor("gzip"),
)

// 3. 配置超时
exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithTimeout(30*time.Second),
)

// 4. 批处理配置（在 Processor 级别）
processor := trace.NewBatchSpanProcessor(exporter,
    trace.WithMaxExportBatchSize(512),  // 大批次
    trace.WithBatchTimeout(5*time.Second),
)

// 5. 重用导出器（不要频繁创建）
var globalExporter trace.SpanExporter

func init() {
    var err error
    globalExporter, err = otlptracegrpc.New(context.Background())
    if err != nil {
        log.Fatal(err)
    }
}
```

---

## 最佳实践

```go
// ✅ 正确: 生产环境使用 OTLP
exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithEndpoint("collector:4317"),
    otlptracegrpc.WithTLSCredentials(...),
)

// ✅ 正确: 配置重试
exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithRetry(otlptracegrpc.RetryConfig{
        Enabled:         true,
        InitialInterval: 5 * time.Second,
        MaxInterval:     30 * time.Second,
    }),
)

// ✅ 正确: 正确关闭
defer func() {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    if err := exporter.Shutdown(ctx); err != nil {
        log.Printf("Error shutting down exporter: %v", err)
    }
}()

// ✅ 正确: 使用环境变量配置
endpoint := os.Getenv("OTEL_EXPORTER_OTLP_ENDPOINT")
if endpoint == "" {
    endpoint = "localhost:4317"
}

exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithEndpoint(endpoint),
)

// ❌ 错误: 硬编码敏感信息
exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithHeaders(map[string]string{
        "api-key": "hardcoded-api-key", // 不要这样做
    }),
)

// ✅ 正确: 从环境变量读取
exporter, _ := otlptracegrpc.New(
    context.Background(),
    otlptracegrpc.WithHeaders(map[string]string{
        "api-key": os.Getenv("OTLP_API_KEY"),
    }),
)
```

---

## 常见问题

**Q1: gRPC 和 HTTP 导出器如何选择？**

```text
gRPC (推荐):
✅ 优点:
  - 性能更好
  - 双向流
  - 内置负载均衡
  - Protocol Buffers 高效

❌ 缺点:
  - 需要 gRPC 支持
  - 配置稍复杂

HTTP:
✅ 优点:
  - 兼容性好
  - 易于调试
  - 防火墙友好

❌ 缺点:
  - 性能稍差
  - 单向通信

推荐:
- 默认使用 gRPC
- 如果有兼容性问题，使用 HTTP
```

**Q2: 如何监控导出器状态？**

```go
// 使用装饰器模式添加监控
type MonitoredExporter struct {
    next          trace.SpanExporter
    successCount  atomic.Int64
    errorCount    atomic.Int64
    spanCount     atomic.Int64
}

func (e *MonitoredExporter) ExportSpans(ctx context.Context, spans []trace.ReadOnlySpan) error {
    e.spanCount.Add(int64(len(spans)))
    
    err := e.next.ExportSpans(ctx, spans)
    if err != nil {
        e.errorCount.Add(1)
    } else {
        e.successCount.Add(1)
    }
    
    return err
}

// 定期报告
func (e *MonitoredExporter) ReportMetrics() {
    log.Printf("Exporter stats: success=%d, errors=%d, spans=%d",
        e.successCount.Load(),
        e.errorCount.Load(),
        e.spanCount.Load(),
    )
}
```

**Q3: 如何处理网络故障？**

```text
策略:
1. 启用重试
   otlptracegrpc.WithRetry(...)

2. 设置合理超时
   otlptracegrpc.WithTimeout(30*time.Second)

3. 使用故障转移
   NewFallbackExporter(primary, fallback)

4. 监控和告警
   记录导出失败率

5. 本地缓存（可选）
   在网络故障时缓存到本地文件
```

---

## 参考资源

- [OpenTelemetry Exporters](https://opentelemetry.io/docs/specs/otel/trace/sdk/#span-exporter)
- [OTLP Specification](https://opentelemetry.io/docs/specs/otlp/)
- [Go SDK Exporters](https://pkg.go.dev/go.opentelemetry.io/otel/sdk/trace#SpanExporter)
- [04_处理器.md](./04_处理器.md)

---

**🎉 恭喜！你已经掌握了 SpanExporter 的完整知识！**

**🎊🎊🎊 Phase 4.1: Tracer Provider 全部完成！🎊🎊🎊**-

现在你可以：

- ✅ 使用各种内置导出器
- ✅ 配置 OTLP gRPC/HTTP
- ✅ 实现自定义导出器
- ✅ 处理错误和重试
- ✅ 优化导出性能
