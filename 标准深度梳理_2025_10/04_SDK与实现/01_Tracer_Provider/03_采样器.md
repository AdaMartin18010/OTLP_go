# é‡‡æ ·å™¨ (Sampler)

## ğŸ“‹ ç›®å½•

- [é‡‡æ ·å™¨ (Sampler)](#é‡‡æ ·å™¨-sampler)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [ä»€ä¹ˆæ˜¯é‡‡æ ·](#ä»€ä¹ˆæ˜¯é‡‡æ ·)
    - [ä¸ºä»€ä¹ˆéœ€è¦é‡‡æ ·](#ä¸ºä»€ä¹ˆéœ€è¦é‡‡æ ·)
  - [å†…ç½®é‡‡æ ·å™¨](#å†…ç½®é‡‡æ ·å™¨)
    - [1. AlwaysOn](#1-alwayson)
    - [2. AlwaysOff](#2-alwaysoff)
    - [3. TraceIDRatioBased](#3-traceidratiobased)
    - [4. ParentBased](#4-parentbased)
  - [é‡‡æ ·å†³ç­–](#é‡‡æ ·å†³ç­–)
    - [1. å†³ç­–ç±»å‹](#1-å†³ç­–ç±»å‹)
    - [2. å†³ç­–æµç¨‹](#2-å†³ç­–æµç¨‹)
  - [Go 1.25.1 å®ç°](#go-1251-å®ç°)
    - [1. è‡ªå®šä¹‰é‡‡æ ·å™¨](#1-è‡ªå®šä¹‰é‡‡æ ·å™¨)
    - [2. ç»„åˆé‡‡æ ·å™¨](#2-ç»„åˆé‡‡æ ·å™¨)
    - [3. åŠ¨æ€é‡‡æ ·å™¨](#3-åŠ¨æ€é‡‡æ ·å™¨)
  - [é«˜çº§é‡‡æ ·ç­–ç•¥](#é«˜çº§é‡‡æ ·ç­–ç•¥)
    - [1. åŸºäºå±æ€§é‡‡æ ·](#1-åŸºäºå±æ€§é‡‡æ ·)
    - [2. åŸºäºé€Ÿç‡é™åˆ¶](#2-åŸºäºé€Ÿç‡é™åˆ¶)
    - [3. åŸºäºé”™è¯¯é‡‡æ ·](#3-åŸºäºé”™è¯¯é‡‡æ ·)
  - [é‡‡æ ·æ€§èƒ½](#é‡‡æ ·æ€§èƒ½)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)
  - [å‚è€ƒèµ„æº](#å‚è€ƒèµ„æº)

---

## æ¦‚è¿°

### ä»€ä¹ˆæ˜¯é‡‡æ ·

**é‡‡æ · (Sampling)** æ˜¯å†³å®šæ˜¯å¦è®°å½•å’Œå¯¼å‡º Span çš„è¿‡ç¨‹ã€‚é‡‡æ ·å™¨åœ¨ Span åˆ›å»ºæ—¶åšå‡ºå†³ç­–ã€‚

```text
Request 1 â†’ Span â†’ Sampler â†’ [Drop] âŒ
Request 2 â†’ Span â†’ Sampler â†’ [Record] âœ…
Request 3 â†’ Span â†’ Sampler â†’ [Drop] âŒ
Request 4 â†’ Span â†’ Sampler â†’ [Record] âœ…
```

### ä¸ºä»€ä¹ˆéœ€è¦é‡‡æ ·

```text
é—®é¢˜:
âŒ 100% è¿½è¸ªæˆæœ¬é«˜æ˜‚
âŒ å­˜å‚¨å’Œç½‘ç»œå‹åŠ›å¤§
âŒ åç«¯å¤„ç†èƒ½åŠ›æœ‰é™

é‡‡æ ·è§£å†³æ–¹æ¡ˆ:
âœ… é™ä½æˆæœ¬ï¼ˆ10% é‡‡æ · = 10% æˆæœ¬ï¼‰
âœ… å‡å°‘ç½‘ç»œæµé‡
âœ… ä¿æŒç³»ç»Ÿæ€§èƒ½
âœ… è·å–æœ‰ä»£è¡¨æ€§çš„æ•°æ®

å…¸å‹é‡‡æ ·ç‡:
- å¼€å‘ç¯å¢ƒ: 100% (å®Œæ•´è¿½è¸ª)
- æµ‹è¯•ç¯å¢ƒ: 50-100%
- ç”Ÿäº§ç¯å¢ƒ: 1-10% (è§†æµé‡è€Œå®š)
```

---

## å†…ç½®é‡‡æ ·å™¨

### 1. AlwaysOn

é‡‡æ ·æ‰€æœ‰ Spanï¼š

```go
import "go.opentelemetry.io/otel/sdk/trace"

// é‡‡æ · 100% çš„ Span
sampler := trace.AlwaysSample()

tp := trace.NewTracerProvider(
    trace.WithSampler(sampler),
)
```

**ä½¿ç”¨åœºæ™¯**:

- âœ… å¼€å‘ç¯å¢ƒ
- âœ… è°ƒè¯•é—®é¢˜
- âœ… ä½æµé‡æœåŠ¡
- âŒ é«˜æµé‡ç”Ÿäº§ç¯å¢ƒ

### 2. AlwaysOff

ä¸é‡‡æ ·ä»»ä½• Spanï¼š

```go
// ä¸é‡‡æ ·ä»»ä½• Span (0%)
sampler := trace.NeverSample()

tp := trace.NewTracerProvider(
    trace.WithSampler(sampler),
)
```

**ä½¿ç”¨åœºæ™¯**:

- âœ… ä¸´æ—¶ç¦ç”¨è¿½è¸ª
- âœ… ç‰¹å®šæœåŠ¡ä¸éœ€è¦è¿½è¸ª
- âŒ ä¸€èˆ¬ç”Ÿäº§ç¯å¢ƒ

### 3. TraceIDRatioBased

åŸºäº TraceID çš„æ¯”ä¾‹é‡‡æ ·ï¼š

```go
// é‡‡æ · 10% çš„ Trace
sampler := trace.TraceIDRatioBased(0.1)

// é‡‡æ · 1% çš„ Trace
sampler := trace.TraceIDRatioBased(0.01)

// é‡‡æ · 50% çš„ Trace
sampler := trace.TraceIDRatioBased(0.5)

tp := trace.NewTracerProvider(
    trace.WithSampler(sampler),
)
```

**å·¥ä½œåŸç†**:

```text
1. è·å– TraceID çš„å‰ 8 å­—èŠ‚
2. è½¬æ¢ä¸º uint64
3. è®¡ç®—: value / MAX_UINT64
4. å¦‚æœç»“æœ < samplingRateï¼Œåˆ™é‡‡æ ·

ä¼˜ç‚¹:
âœ… åŒä¸€ Trace çš„æ‰€æœ‰ Span å†³ç­–ä¸€è‡´
âœ… åˆ†å¸ƒå‡åŒ€
âœ… æ— çŠ¶æ€ï¼ˆå¯æ¨ªå‘æ‰©å±•ï¼‰
```

**ä½¿ç”¨åœºæ™¯**:

- âœ… ç”Ÿäº§ç¯å¢ƒé¦–é€‰
- âœ… å¾®æœåŠ¡æ¶æ„
- âœ… é«˜æµé‡åœºæ™¯

### 4. ParentBased

åŸºäºçˆ¶ Span çš„é‡‡æ ·å†³ç­–ï¼š

```go
// æ ¹é‡‡æ ·å™¨ï¼šé‡‡æ · 10%
rootSampler := trace.TraceIDRatioBased(0.1)

// ParentBased: éµå¾ªçˆ¶ Span çš„å†³ç­–
sampler := trace.ParentBased(
    rootSampler,
    trace.WithRemoteParentSampled(trace.AlwaysSample()),
    trace.WithRemoteParentNotSampled(trace.NeverSample()),
    trace.WithLocalParentSampled(trace.AlwaysSample()),
    trace.WithLocalParentNotSampled(trace.NeverSample()),
)

tp := trace.NewTracerProvider(
    trace.WithSampler(sampler),
)
```

**å†³ç­–é€»è¾‘**:

```text
å¦‚æœæ²¡æœ‰çˆ¶ Span (æ ¹ Span):
    ä½¿ç”¨ rootSampler å†³ç­–

å¦‚æœæœ‰è¿œç¨‹çˆ¶ Span (è·¨æœåŠ¡):
    å¦‚æœçˆ¶ Span è¢«é‡‡æ · â†’ ä½¿ç”¨ RemoteParentSampled
    å¦‚æœçˆ¶ Span æœªé‡‡æ · â†’ ä½¿ç”¨ RemoteParentNotSampled

å¦‚æœæœ‰æœ¬åœ°çˆ¶ Span (åŒæœåŠ¡):
    å¦‚æœçˆ¶ Span è¢«é‡‡æ · â†’ ä½¿ç”¨ LocalParentSampled
    å¦‚æœçˆ¶ Span æœªé‡‡æ · â†’ ä½¿ç”¨ LocalParentNotSampled
```

**ä½¿ç”¨åœºæ™¯**:

- âœ… å¾®æœåŠ¡æ¶æ„ï¼ˆæ¨èï¼‰
- âœ… ç¡®ä¿ Trace å®Œæ•´æ€§
- âœ… ç”Ÿäº§ç¯å¢ƒé»˜è®¤é€‰æ‹©

---

## é‡‡æ ·å†³ç­–

### 1. å†³ç­–ç±»å‹

```go
import "go.opentelemetry.io/otel/sdk/trace"

// å†³ç­–ç±»å‹
const (
    // Drop: ä¸è®°å½•ï¼Œä¸å¯¼å‡º
    Drop trace.SamplingDecision = 0
    
    // RecordOnly: è®°å½•ä½†ä¸å¯¼å‡º
    RecordOnly trace.SamplingDecision = 1
    
    // RecordAndSample: è®°å½•å¹¶å¯¼å‡º
    RecordAndSample trace.SamplingDecision = 2
)
```

### 2. å†³ç­–æµç¨‹

```text
1. Span åˆ›å»ºæ—¶è°ƒç”¨ Sampler.ShouldSample()
2. Sampler è¿”å› SamplingDecision
3. æ ¹æ®å†³ç­–å¤„ç† Span:
   - Drop: ç«‹å³ä¸¢å¼ƒ
   - RecordOnly: è®°å½•åˆ°å†…å­˜ä½†ä¸å¯¼å‡º
   - RecordAndSample: è®°å½•å¹¶å¯¼å‡ºåˆ°åç«¯
```

---

## Go 1.25.1 å®ç°

### 1. è‡ªå®šä¹‰é‡‡æ ·å™¨

```go
package sampling

import (
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/sdk/trace"
    oteltrace "go.opentelemetry.io/otel/trace"
)

// CustomSampler è‡ªå®šä¹‰é‡‡æ ·å™¨
type CustomSampler struct {
    rate float64
}

// NewCustomSampler åˆ›å»ºè‡ªå®šä¹‰é‡‡æ ·å™¨
func NewCustomSampler(rate float64) trace.Sampler {
    return &CustomSampler{rate: rate}
}

// ShouldSample å®ç°é‡‡æ ·å†³ç­–
func (s *CustomSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    // è‡ªå®šä¹‰é‡‡æ ·é€»è¾‘
    decision := trace.Drop
    
    // ç¤ºä¾‹ï¼šåŸºäº TraceID é‡‡æ ·
    tid := p.TraceID
    if shouldSampleTraceID(tid, s.rate) {
        decision = trace.RecordAndSample
    }
    
    return trace.SamplingResult{
        Decision:   decision,
        Attributes: []attribute.KeyValue{},
        Tracestate: oteltrace.TraceState{},
    }
}

// Description è¿”å›é‡‡æ ·å™¨æè¿°
func (s *CustomSampler) Description() string {
    return fmt.Sprintf("CustomSampler{rate=%f}", s.rate)
}

func shouldSampleTraceID(tid oteltrace.TraceID, rate float64) bool {
    // å®ç°é‡‡æ ·é€»è¾‘
    upper := uint64(rate * float64(^uint64(0)))
    
    // ä½¿ç”¨ TraceID çš„å‰ 8 å­—èŠ‚
    value := binary.BigEndian.Uint64(tid[0:8])
    
    return value < upper
}
```

### 2. ç»„åˆé‡‡æ ·å™¨

```go
package sampling

// CompositeSampler ç»„åˆå¤šä¸ªé‡‡æ ·å™¨
type CompositeSampler struct {
    samplers []trace.Sampler
}

// NewCompositeSampler åˆ›å»ºç»„åˆé‡‡æ ·å™¨
func NewCompositeSampler(samplers ...trace.Sampler) trace.Sampler {
    return &CompositeSampler{samplers: samplers}
}

// ShouldSample ä¾æ¬¡è°ƒç”¨æ‰€æœ‰é‡‡æ ·å™¨
func (s *CompositeSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    for _, sampler := range s.samplers {
        result := sampler.ShouldSample(p)
        
        // å¦‚æœä»»ä¸€é‡‡æ ·å™¨å†³å®šé‡‡æ ·ï¼Œåˆ™é‡‡æ ·
        if result.Decision == trace.RecordAndSample {
            return result
        }
    }
    
    // æ‰€æœ‰é‡‡æ ·å™¨éƒ½å†³å®šä¸é‡‡æ ·
    return trace.SamplingResult{
        Decision: trace.Drop,
    }
}

func (s *CompositeSampler) Description() string {
    return "CompositeSampler"
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    sampler := NewCompositeSampler(
        trace.TraceIDRatioBased(0.1),  // 10% åŸºç¡€é‡‡æ ·
        NewErrorSampler(),              // æ€»æ˜¯é‡‡æ ·é”™è¯¯
    )
    
    tp := trace.NewTracerProvider(
        trace.WithSampler(sampler),
    )
}
```

### 3. åŠ¨æ€é‡‡æ ·å™¨

```go
package sampling

import (
    "sync/atomic"
)

// DynamicSampler æ”¯æŒè¿è¡Œæ—¶è°ƒæ•´é‡‡æ ·ç‡
type DynamicSampler struct {
    rate atomic.Value // float64
}

// NewDynamicSampler åˆ›å»ºåŠ¨æ€é‡‡æ ·å™¨
func NewDynamicSampler(initialRate float64) *DynamicSampler {
    s := &DynamicSampler{}
    s.rate.Store(initialRate)
    return s
}

// UpdateRate æ›´æ–°é‡‡æ ·ç‡
func (s *DynamicSampler) UpdateRate(rate float64) {
    if rate < 0 {
        rate = 0
    }
    if rate > 1 {
        rate = 1
    }
    s.rate.Store(rate)
}

// GetRate è·å–å½“å‰é‡‡æ ·ç‡
func (s *DynamicSampler) GetRate() float64 {
    return s.rate.Load().(float64)
}

// ShouldSample å®ç°é‡‡æ ·å†³ç­–
func (s *DynamicSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    rate := s.GetRate()
    
    decision := trace.Drop
    if shouldSampleTraceID(p.TraceID, rate) {
        decision = trace.RecordAndSample
    }
    
    return trace.SamplingResult{
        Decision: decision,
    }
}

func (s *DynamicSampler) Description() string {
    return fmt.Sprintf("DynamicSampler{rate=%f}", s.GetRate())
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šæ ¹æ®è´Ÿè½½åŠ¨æ€è°ƒæ•´
func adjustSamplingRate(sampler *DynamicSampler) {
    ticker := time.NewTicker(1 * time.Minute)
    defer ticker.Stop()
    
    for range ticker.C {
        load := getCurrentLoad()
        
        var newRate float64
        switch {
        case load > 0.9:
            newRate = 0.01 // é«˜è´Ÿè½½ï¼š1% é‡‡æ ·
        case load > 0.7:
            newRate = 0.05 // ä¸­è´Ÿè½½ï¼š5% é‡‡æ ·
        default:
            newRate = 0.1  // ä½è´Ÿè½½ï¼š10% é‡‡æ ·
        }
        
        sampler.UpdateRate(newRate)
        log.Printf("Adjusted sampling rate to %.2f%%", newRate*100)
    }
}
```

---

## é«˜çº§é‡‡æ ·ç­–ç•¥

### 1. åŸºäºå±æ€§é‡‡æ ·

```go
package sampling

// AttributeBasedSampler åŸºäº Span å±æ€§é‡‡æ ·
type AttributeBasedSampler struct {
    baseRate    float64
    rules       []SamplingRule
}

type SamplingRule struct {
    AttributeKey   string
    AttributeValue string
    Rate           float64
}

func NewAttributeBasedSampler(baseRate float64, rules []SamplingRule) trace.Sampler {
    return &AttributeBasedSampler{
        baseRate: baseRate,
        rules:    rules,
    }
}

func (s *AttributeBasedSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    // æ£€æŸ¥è§„åˆ™
    for _, rule := range s.rules {
        for _, attr := range p.Attributes {
            if string(attr.Key) == rule.AttributeKey &&
               attr.Value.AsString() == rule.AttributeValue {
                // åŒ¹é…è§„åˆ™ï¼Œä½¿ç”¨è§„åˆ™çš„é‡‡æ ·ç‡
                if shouldSampleTraceID(p.TraceID, rule.Rate) {
                    return trace.SamplingResult{
                        Decision: trace.RecordAndSample,
                    }
                }
            }
        }
    }
    
    // ä½¿ç”¨åŸºç¡€é‡‡æ ·ç‡
    if shouldSampleTraceID(p.TraceID, s.baseRate) {
        return trace.SamplingResult{
            Decision: trace.RecordAndSample,
        }
    }
    
    return trace.SamplingResult{
        Decision: trace.Drop,
    }
}

func (s *AttributeBasedSampler) Description() string {
    return "AttributeBasedSampler"
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    sampler := NewAttributeBasedSampler(0.1, []SamplingRule{
        {
            AttributeKey:   "http.route",
            AttributeValue: "/api/critical",
            Rate:           1.0, // å…³é”® API 100% é‡‡æ ·
        },
        {
            AttributeKey:   "user.tier",
            AttributeValue: "premium",
            Rate:           0.5, // VIP ç”¨æˆ· 50% é‡‡æ ·
        },
    })
    
    tp := trace.NewTracerProvider(
        trace.WithSampler(sampler),
    )
}
```

### 2. åŸºäºé€Ÿç‡é™åˆ¶

```go
package sampling

import (
    "golang.org/x/time/rate"
)

// RateLimitSampler é€Ÿç‡é™åˆ¶é‡‡æ ·å™¨
type RateLimitSampler struct {
    limiter *rate.Limiter
}

// NewRateLimitSampler åˆ›å»ºé€Ÿç‡é™åˆ¶é‡‡æ ·å™¨
// tracesPerç§’: æ¯ç§’å…è®¸çš„ Trace æ•°é‡
func NewRateLimitSampler(tracesPerSecond int) trace.Sampler {
    return &RateLimitSampler{
        limiter: rate.NewLimiter(rate.Limit(tracesPerSecond), tracesPerSecond),
    }
}

func (s *RateLimitSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é€Ÿç‡é™åˆ¶
    if s.limiter.Allow() {
        return trace.SamplingResult{
            Decision: trace.RecordAndSample,
        }
    }
    
    return trace.SamplingResult{
        Decision: trace.Drop,
    }
}

func (s *RateLimitSampler) Description() string {
    return "RateLimitSampler"
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    // æ¯ç§’æœ€å¤š 100 ä¸ª Trace
    sampler := NewRateLimitSampler(100)
    
    tp := trace.NewTracerProvider(
        trace.WithSampler(sampler),
    )
}
```

### 3. åŸºäºé”™è¯¯é‡‡æ ·

```go
package sampling

// ErrorSampler æ€»æ˜¯é‡‡æ ·é”™è¯¯ Span
type ErrorSampler struct{}

func NewErrorSampler() trace.Sampler {
    return &ErrorSampler{}
}

func (s *ErrorSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    // æ£€æŸ¥æ˜¯å¦æœ‰é”™è¯¯ç›¸å…³å±æ€§
    for _, attr := range p.Attributes {
        if string(attr.Key) == "error" && attr.Value.AsBool() {
            // æœ‰é”™è¯¯ï¼Œæ€»æ˜¯é‡‡æ ·
            return trace.SamplingResult{
                Decision: trace.RecordAndSample,
            }
        }
    }
    
    // æ— é”™è¯¯ï¼Œä¸é‡‡æ ·
    return trace.SamplingResult{
        Decision: trace.Drop,
    }
}

func (s *ErrorSampler) Description() string {
    return "ErrorSampler"
}

// ç»„åˆä½¿ç”¨ï¼šåŸºç¡€é‡‡æ · + é”™è¯¯é‡‡æ ·
func main() {
    baseSampler := trace.TraceIDRatioBased(0.1)
    errorSampler := NewErrorSampler()
    
    sampler := NewCompositeSampler(baseSampler, errorSampler)
    
    tp := trace.NewTracerProvider(
        trace.WithSampler(sampler),
    )
}
```

---

## é‡‡æ ·æ€§èƒ½

```go
// 1. é‡‡æ ·å™¨åº”è¯¥å¿«é€Ÿ
// âœ… å¥½ï¼šç®€å•åˆ¤æ–­
func (s *SimpleSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    return trace.SamplingResult{
        Decision: trace.RecordAndSample,
    }
}

// âŒ å·®ï¼šå¤æ‚è®¡ç®—æˆ– I/O
func (s *SlowSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    // æ•°æ®åº“æŸ¥è¯¢ - å¤ªæ…¢ï¼
    user := db.GetUser(p.Attributes["user.id"])
    if user.IsPremium {
        return trace.SamplingResult{Decision: trace.RecordAndSample}
    }
    return trace.SamplingResult{Decision: trace.Drop}
}

// 2. é¿å…é”ç«äº‰
// âœ… å¥½ï¼šä½¿ç”¨ atomic
type DynamicSampler struct {
    rate atomic.Value
}

// âŒ å·®ï¼šä½¿ç”¨ mutex
type SlowDynamicSampler struct {
    mu   sync.Mutex
    rate float64
}

// 3. é¢„è®¡ç®—
var samplingThreshold = uint64(0.1 * float64(^uint64(0)))

func shouldSample(tid oteltrace.TraceID) bool {
    value := binary.BigEndian.Uint64(tid[0:8])
    return value < samplingThreshold // å¿«é€Ÿæ¯”è¾ƒ
}
```

---

## æœ€ä½³å®è·µ

```go
// âœ… æ­£ç¡®ï¼šç”Ÿäº§ç¯å¢ƒä½¿ç”¨ ParentBased
sampler := trace.ParentBased(
    trace.TraceIDRatioBased(0.1),
)

// âœ… æ­£ç¡®ï¼šæ ¹æ®ç¯å¢ƒè°ƒæ•´é‡‡æ ·ç‡
var samplingRate float64
switch env {
case "production":
    samplingRate = 0.1  // 10%
case "staging":
    samplingRate = 0.5  // 50%
case "development":
    samplingRate = 1.0  // 100%
}

sampler := trace.TraceIDRatioBased(samplingRate)

// âœ… æ­£ç¡®ï¼šç»„åˆç­–ç•¥
sampler := NewCompositeSampler(
    trace.TraceIDRatioBased(0.1),  // åŸºç¡€é‡‡æ ·
    NewErrorSampler(),              // é”™è¯¯é‡‡æ ·
    NewCriticalPathSampler(),       // å…³é”®è·¯å¾„é‡‡æ ·
)

// âŒ é”™è¯¯ï¼šä¸åŒæœåŠ¡ä½¿ç”¨ä¸åŒé‡‡æ ·ç‡ï¼ˆç ´å Trace å®Œæ•´æ€§ï¼‰
// Service A: 10% é‡‡æ ·
// Service B: 50% é‡‡æ ·
// ç»“æœï¼šTrace ä¸å®Œæ•´

// âœ… æ­£ç¡®ï¼šæ‰€æœ‰æœåŠ¡ä½¿ç”¨ç›¸åŒçš„æ ¹é‡‡æ ·é€»è¾‘
sampler := trace.ParentBased(
    trace.TraceIDRatioBased(0.1), // æ‰€æœ‰æœåŠ¡ä½¿ç”¨ç›¸åŒæ¯”ä¾‹
)
```

---

## å¸¸è§é—®é¢˜

**Q1: å¦‚ä½•é€‰æ‹©é‡‡æ ·ç‡ï¼Ÿ**

```text
è€ƒè™‘å› ç´ :
1. æµé‡å¤§å°
   - < 100 RPS: 100% é‡‡æ ·
   - 100-1000 RPS: 10-50% é‡‡æ ·
   - > 1000 RPS: 1-10% é‡‡æ ·

2. æˆæœ¬é¢„ç®—
   - é‡‡æ ·ç‡ = é¢„ç®— / (æµé‡ Ã— æˆæœ¬per trace)

3. é—®é¢˜æ£€æµ‹éœ€æ±‚
   - éœ€è¦å¿«é€Ÿå‘ç°é—®é¢˜ï¼šæé«˜é‡‡æ ·ç‡
   - åªéœ€ç»Ÿè®¡åˆ†æï¼šé™ä½é‡‡æ ·ç‡

æ¨è:
- ä» 10% å¼€å§‹
- æ ¹æ®æˆæœ¬å’Œéœ€æ±‚è°ƒæ•´
- å…³é”®è·¯å¾„å¯ä»¥æé«˜é‡‡æ ·ç‡
```

**Q2: ParentBased å’Œ TraceIDRatioBased æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ**

```text
TraceIDRatioBased:
- æ¯ä¸ªæœåŠ¡ç‹¬ç«‹å†³ç­–
- å¯èƒ½å¯¼è‡´ Trace ä¸å®Œæ•´
- é€‚åˆå•ä½“åº”ç”¨

ParentBased:
- éµå¾ªçˆ¶ Span å†³ç­–
- ç¡®ä¿ Trace å®Œæ•´æ€§
- é€‚åˆå¾®æœåŠ¡æ¶æ„ï¼ˆæ¨èï¼‰

ç¤ºä¾‹:
TraceIDRatioBased (10%):
  Service A (é‡‡æ ·) â†’ Service B (å¯èƒ½ä¸é‡‡æ ·) âŒ Trace ä¸å®Œæ•´

ParentBased:
  Service A (é‡‡æ ·) â†’ Service B (ç»§æ‰¿ï¼Œé‡‡æ ·) âœ… Trace å®Œæ•´
```

---

## å‚è€ƒèµ„æº

- [OpenTelemetry Sampling](https://opentelemetry.io/docs/concepts/sampling/)
- [Go SDK Sampler](https://pkg.go.dev/go.opentelemetry.io/otel/sdk/trace#Sampler)
- [01_Provideré…ç½®.md](./01_Provideré…ç½®.md)
- [04_å¤„ç†å™¨.md](./04_å¤„ç†å™¨.md)

---

**ğŸ‰ æ­å–œï¼ä½ å·²ç»æŒæ¡äº†é‡‡æ ·å™¨çš„å®Œæ•´çŸ¥è¯†ï¼**

ç°åœ¨ä½ å¯ä»¥ï¼š

- âœ… ä½¿ç”¨å†…ç½®é‡‡æ ·å™¨
- âœ… å®ç°è‡ªå®šä¹‰é‡‡æ ·å™¨
- âœ… ç»„åˆå¤šç§é‡‡æ ·ç­–ç•¥
- âœ… æ ¹æ®ç¯å¢ƒå’Œéœ€æ±‚é€‰æ‹©é‡‡æ ·ç‡
- âœ… ä¼˜åŒ–é‡‡æ ·æ€§èƒ½
