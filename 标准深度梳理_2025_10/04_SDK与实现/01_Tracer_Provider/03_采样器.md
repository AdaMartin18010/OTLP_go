# 采样器 (Sampler)

## 📋 目录

- [采样器 (Sampler)](#采样器-sampler)
  - [📋 目录](#-目录)
  - [概述](#概述)
    - [什么是采样](#什么是采样)
    - [为什么需要采样](#为什么需要采样)
  - [内置采样器](#内置采样器)
    - [1. AlwaysOn](#1-alwayson)
    - [2. AlwaysOff](#2-alwaysoff)
    - [3. TraceIDRatioBased](#3-traceidratiobased)
    - [4. ParentBased](#4-parentbased)
  - [采样决策](#采样决策)
    - [1. 决策类型](#1-决策类型)
    - [2. 决策流程](#2-决策流程)
  - [Go 1.25.1 实现](#go-1251-实现)
    - [1. 自定义采样器](#1-自定义采样器)
    - [2. 组合采样器](#2-组合采样器)
    - [3. 动态采样器](#3-动态采样器)
  - [高级采样策略](#高级采样策略)
    - [1. 基于属性采样](#1-基于属性采样)
    - [2. 基于速率限制](#2-基于速率限制)
    - [3. 基于错误采样](#3-基于错误采样)
  - [采样性能](#采样性能)
  - [最佳实践](#最佳实践)
  - [常见问题](#常见问题)
  - [参考资源](#参考资源)

---

## 概述

### 什么是采样

**采样 (Sampling)** 是决定是否记录和导出 Span 的过程。采样器在 Span 创建时做出决策。

```text
Request 1 → Span → Sampler → [Drop] ❌
Request 2 → Span → Sampler → [Record] ✅
Request 3 → Span → Sampler → [Drop] ❌
Request 4 → Span → Sampler → [Record] ✅
```

### 为什么需要采样

```text
问题:
❌ 100% 追踪成本高昂
❌ 存储和网络压力大
❌ 后端处理能力有限

采样解决方案:
✅ 降低成本（10% 采样 = 10% 成本）
✅ 减少网络流量
✅ 保持系统性能
✅ 获取有代表性的数据

典型采样率:
- 开发环境: 100% (完整追踪)
- 测试环境: 50-100%
- 生产环境: 1-10% (视流量而定)
```

---

## 内置采样器

### 1. AlwaysOn

采样所有 Span：

```go
import "go.opentelemetry.io/otel/sdk/trace"

// 采样 100% 的 Span
sampler := trace.AlwaysSample()

tp := trace.NewTracerProvider(
    trace.WithSampler(sampler),
)
```

**使用场景**:

- ✅ 开发环境
- ✅ 调试问题
- ✅ 低流量服务
- ❌ 高流量生产环境

### 2. AlwaysOff

不采样任何 Span：

```go
// 不采样任何 Span (0%)
sampler := trace.NeverSample()

tp := trace.NewTracerProvider(
    trace.WithSampler(sampler),
)
```

**使用场景**:

- ✅ 临时禁用追踪
- ✅ 特定服务不需要追踪
- ❌ 一般生产环境

### 3. TraceIDRatioBased

基于 TraceID 的比例采样：

```go
// 采样 10% 的 Trace
sampler := trace.TraceIDRatioBased(0.1)

// 采样 1% 的 Trace
sampler := trace.TraceIDRatioBased(0.01)

// 采样 50% 的 Trace
sampler := trace.TraceIDRatioBased(0.5)

tp := trace.NewTracerProvider(
    trace.WithSampler(sampler),
)
```

**工作原理**:

```text
1. 获取 TraceID 的前 8 字节
2. 转换为 uint64
3. 计算: value / MAX_UINT64
4. 如果结果 < samplingRate，则采样

优点:
✅ 同一 Trace 的所有 Span 决策一致
✅ 分布均匀
✅ 无状态（可横向扩展）
```

**使用场景**:

- ✅ 生产环境首选
- ✅ 微服务架构
- ✅ 高流量场景

### 4. ParentBased

基于父 Span 的采样决策：

```go
// 根采样器：采样 10%
rootSampler := trace.TraceIDRatioBased(0.1)

// ParentBased: 遵循父 Span 的决策
sampler := trace.ParentBased(
    rootSampler,
    trace.WithRemoteParentSampled(trace.AlwaysSample()),
    trace.WithRemoteParentNotSampled(trace.NeverSample()),
    trace.WithLocalParentSampled(trace.AlwaysSample()),
    trace.WithLocalParentNotSampled(trace.NeverSample()),
)

tp := trace.NewTracerProvider(
    trace.WithSampler(sampler),
)
```

**决策逻辑**:

```text
如果没有父 Span (根 Span):
    使用 rootSampler 决策

如果有远程父 Span (跨服务):
    如果父 Span 被采样 → 使用 RemoteParentSampled
    如果父 Span 未采样 → 使用 RemoteParentNotSampled

如果有本地父 Span (同服务):
    如果父 Span 被采样 → 使用 LocalParentSampled
    如果父 Span 未采样 → 使用 LocalParentNotSampled
```

**使用场景**:

- ✅ 微服务架构（推荐）
- ✅ 确保 Trace 完整性
- ✅ 生产环境默认选择

---

## 采样决策

### 1. 决策类型

```go
import "go.opentelemetry.io/otel/sdk/trace"

// 决策类型
const (
    // Drop: 不记录，不导出
    Drop trace.SamplingDecision = 0
    
    // RecordOnly: 记录但不导出
    RecordOnly trace.SamplingDecision = 1
    
    // RecordAndSample: 记录并导出
    RecordAndSample trace.SamplingDecision = 2
)
```

### 2. 决策流程

```text
1. Span 创建时调用 Sampler.ShouldSample()
2. Sampler 返回 SamplingDecision
3. 根据决策处理 Span:
   - Drop: 立即丢弃
   - RecordOnly: 记录到内存但不导出
   - RecordAndSample: 记录并导出到后端
```

---

## Go 1.25.1 实现

### 1. 自定义采样器

```go
package sampling

import (
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/sdk/trace"
    oteltrace "go.opentelemetry.io/otel/trace"
)

// CustomSampler 自定义采样器
type CustomSampler struct {
    rate float64
}

// NewCustomSampler 创建自定义采样器
func NewCustomSampler(rate float64) trace.Sampler {
    return &CustomSampler{rate: rate}
}

// ShouldSample 实现采样决策
func (s *CustomSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    // 自定义采样逻辑
    decision := trace.Drop
    
    // 示例：基于 TraceID 采样
    tid := p.TraceID
    if shouldSampleTraceID(tid, s.rate) {
        decision = trace.RecordAndSample
    }
    
    return trace.SamplingResult{
        Decision:   decision,
        Attributes: []attribute.KeyValue{},
        Tracestate: oteltrace.TraceState{},
    }
}

// Description 返回采样器描述
func (s *CustomSampler) Description() string {
    return fmt.Sprintf("CustomSampler{rate=%f}", s.rate)
}

func shouldSampleTraceID(tid oteltrace.TraceID, rate float64) bool {
    // 实现采样逻辑
    upper := uint64(rate * float64(^uint64(0)))
    
    // 使用 TraceID 的前 8 字节
    value := binary.BigEndian.Uint64(tid[0:8])
    
    return value < upper
}
```

### 2. 组合采样器

```go
package sampling

// CompositeSampler 组合多个采样器
type CompositeSampler struct {
    samplers []trace.Sampler
}

// NewCompositeSampler 创建组合采样器
func NewCompositeSampler(samplers ...trace.Sampler) trace.Sampler {
    return &CompositeSampler{samplers: samplers}
}

// ShouldSample 依次调用所有采样器
func (s *CompositeSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    for _, sampler := range s.samplers {
        result := sampler.ShouldSample(p)
        
        // 如果任一采样器决定采样，则采样
        if result.Decision == trace.RecordAndSample {
            return result
        }
    }
    
    // 所有采样器都决定不采样
    return trace.SamplingResult{
        Decision: trace.Drop,
    }
}

func (s *CompositeSampler) Description() string {
    return "CompositeSampler"
}

// 使用示例
func main() {
    sampler := NewCompositeSampler(
        trace.TraceIDRatioBased(0.1),  // 10% 基础采样
        NewErrorSampler(),              // 总是采样错误
    )
    
    tp := trace.NewTracerProvider(
        trace.WithSampler(sampler),
    )
}
```

### 3. 动态采样器

```go
package sampling

import (
    "sync/atomic"
)

// DynamicSampler 支持运行时调整采样率
type DynamicSampler struct {
    rate atomic.Value // float64
}

// NewDynamicSampler 创建动态采样器
func NewDynamicSampler(initialRate float64) *DynamicSampler {
    s := &DynamicSampler{}
    s.rate.Store(initialRate)
    return s
}

// UpdateRate 更新采样率
func (s *DynamicSampler) UpdateRate(rate float64) {
    if rate < 0 {
        rate = 0
    }
    if rate > 1 {
        rate = 1
    }
    s.rate.Store(rate)
}

// GetRate 获取当前采样率
func (s *DynamicSampler) GetRate() float64 {
    return s.rate.Load().(float64)
}

// ShouldSample 实现采样决策
func (s *DynamicSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    rate := s.GetRate()
    
    decision := trace.Drop
    if shouldSampleTraceID(p.TraceID, rate) {
        decision = trace.RecordAndSample
    }
    
    return trace.SamplingResult{
        Decision: decision,
    }
}

func (s *DynamicSampler) Description() string {
    return fmt.Sprintf("DynamicSampler{rate=%f}", s.GetRate())
}

// 使用示例：根据负载动态调整
func adjustSamplingRate(sampler *DynamicSampler) {
    ticker := time.NewTicker(1 * time.Minute)
    defer ticker.Stop()
    
    for range ticker.C {
        load := getCurrentLoad()
        
        var newRate float64
        switch {
        case load > 0.9:
            newRate = 0.01 // 高负载：1% 采样
        case load > 0.7:
            newRate = 0.05 // 中负载：5% 采样
        default:
            newRate = 0.1  // 低负载：10% 采样
        }
        
        sampler.UpdateRate(newRate)
        log.Printf("Adjusted sampling rate to %.2f%%", newRate*100)
    }
}
```

---

## 高级采样策略

### 1. 基于属性采样

```go
package sampling

// AttributeBasedSampler 基于 Span 属性采样
type AttributeBasedSampler struct {
    baseRate    float64
    rules       []SamplingRule
}

type SamplingRule struct {
    AttributeKey   string
    AttributeValue string
    Rate           float64
}

func NewAttributeBasedSampler(baseRate float64, rules []SamplingRule) trace.Sampler {
    return &AttributeBasedSampler{
        baseRate: baseRate,
        rules:    rules,
    }
}

func (s *AttributeBasedSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    // 检查规则
    for _, rule := range s.rules {
        for _, attr := range p.Attributes {
            if string(attr.Key) == rule.AttributeKey &&
               attr.Value.AsString() == rule.AttributeValue {
                // 匹配规则，使用规则的采样率
                if shouldSampleTraceID(p.TraceID, rule.Rate) {
                    return trace.SamplingResult{
                        Decision: trace.RecordAndSample,
                    }
                }
            }
        }
    }
    
    // 使用基础采样率
    if shouldSampleTraceID(p.TraceID, s.baseRate) {
        return trace.SamplingResult{
            Decision: trace.RecordAndSample,
        }
    }
    
    return trace.SamplingResult{
        Decision: trace.Drop,
    }
}

func (s *AttributeBasedSampler) Description() string {
    return "AttributeBasedSampler"
}

// 使用示例
func main() {
    sampler := NewAttributeBasedSampler(0.1, []SamplingRule{
        {
            AttributeKey:   "http.route",
            AttributeValue: "/api/critical",
            Rate:           1.0, // 关键 API 100% 采样
        },
        {
            AttributeKey:   "user.tier",
            AttributeValue: "premium",
            Rate:           0.5, // VIP 用户 50% 采样
        },
    })
    
    tp := trace.NewTracerProvider(
        trace.WithSampler(sampler),
    )
}
```

### 2. 基于速率限制

```go
package sampling

import (
    "golang.org/x/time/rate"
)

// RateLimitSampler 速率限制采样器
type RateLimitSampler struct {
    limiter *rate.Limiter
}

// NewRateLimitSampler 创建速率限制采样器
// tracesPer秒: 每秒允许的 Trace 数量
func NewRateLimitSampler(tracesPerSecond int) trace.Sampler {
    return &RateLimitSampler{
        limiter: rate.NewLimiter(rate.Limit(tracesPerSecond), tracesPerSecond),
    }
}

func (s *RateLimitSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    // 检查是否超过速率限制
    if s.limiter.Allow() {
        return trace.SamplingResult{
            Decision: trace.RecordAndSample,
        }
    }
    
    return trace.SamplingResult{
        Decision: trace.Drop,
    }
}

func (s *RateLimitSampler) Description() string {
    return "RateLimitSampler"
}

// 使用示例
func main() {
    // 每秒最多 100 个 Trace
    sampler := NewRateLimitSampler(100)
    
    tp := trace.NewTracerProvider(
        trace.WithSampler(sampler),
    )
}
```

### 3. 基于错误采样

```go
package sampling

// ErrorSampler 总是采样错误 Span
type ErrorSampler struct{}

func NewErrorSampler() trace.Sampler {
    return &ErrorSampler{}
}

func (s *ErrorSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    // 检查是否有错误相关属性
    for _, attr := range p.Attributes {
        if string(attr.Key) == "error" && attr.Value.AsBool() {
            // 有错误，总是采样
            return trace.SamplingResult{
                Decision: trace.RecordAndSample,
            }
        }
    }
    
    // 无错误，不采样
    return trace.SamplingResult{
        Decision: trace.Drop,
    }
}

func (s *ErrorSampler) Description() string {
    return "ErrorSampler"
}

// 组合使用：基础采样 + 错误采样
func main() {
    baseSampler := trace.TraceIDRatioBased(0.1)
    errorSampler := NewErrorSampler()
    
    sampler := NewCompositeSampler(baseSampler, errorSampler)
    
    tp := trace.NewTracerProvider(
        trace.WithSampler(sampler),
    )
}
```

---

## 采样性能

```go
// 1. 采样器应该快速
// ✅ 好：简单判断
func (s *SimpleSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    return trace.SamplingResult{
        Decision: trace.RecordAndSample,
    }
}

// ❌ 差：复杂计算或 I/O
func (s *SlowSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    // 数据库查询 - 太慢！
    user := db.GetUser(p.Attributes["user.id"])
    if user.IsPremium {
        return trace.SamplingResult{Decision: trace.RecordAndSample}
    }
    return trace.SamplingResult{Decision: trace.Drop}
}

// 2. 避免锁竞争
// ✅ 好：使用 atomic
type DynamicSampler struct {
    rate atomic.Value
}

// ❌ 差：使用 mutex
type SlowDynamicSampler struct {
    mu   sync.Mutex
    rate float64
}

// 3. 预计算
var samplingThreshold = uint64(0.1 * float64(^uint64(0)))

func shouldSample(tid oteltrace.TraceID) bool {
    value := binary.BigEndian.Uint64(tid[0:8])
    return value < samplingThreshold // 快速比较
}
```

---

## 最佳实践

```go
// ✅ 正确：生产环境使用 ParentBased
sampler := trace.ParentBased(
    trace.TraceIDRatioBased(0.1),
)

// ✅ 正确：根据环境调整采样率
var samplingRate float64
switch env {
case "production":
    samplingRate = 0.1  // 10%
case "staging":
    samplingRate = 0.5  // 50%
case "development":
    samplingRate = 1.0  // 100%
}

sampler := trace.TraceIDRatioBased(samplingRate)

// ✅ 正确：组合策略
sampler := NewCompositeSampler(
    trace.TraceIDRatioBased(0.1),  // 基础采样
    NewErrorSampler(),              // 错误采样
    NewCriticalPathSampler(),       // 关键路径采样
)

// ❌ 错误：不同服务使用不同采样率（破坏 Trace 完整性）
// Service A: 10% 采样
// Service B: 50% 采样
// 结果：Trace 不完整

// ✅ 正确：所有服务使用相同的根采样逻辑
sampler := trace.ParentBased(
    trace.TraceIDRatioBased(0.1), // 所有服务使用相同比例
)
```

---

## 常见问题

**Q1: 如何选择采样率？**

```text
考虑因素:
1. 流量大小
   - < 100 RPS: 100% 采样
   - 100-1000 RPS: 10-50% 采样
   - > 1000 RPS: 1-10% 采样

2. 成本预算
   - 采样率 = 预算 / (流量 × 成本per trace)

3. 问题检测需求
   - 需要快速发现问题：提高采样率
   - 只需统计分析：降低采样率

推荐:
- 从 10% 开始
- 根据成本和需求调整
- 关键路径可以提高采样率
```

**Q2: ParentBased 和 TraceIDRatioBased 有什么区别？**

```text
TraceIDRatioBased:
- 每个服务独立决策
- 可能导致 Trace 不完整
- 适合单体应用

ParentBased:
- 遵循父 Span 决策
- 确保 Trace 完整性
- 适合微服务架构（推荐）

示例:
TraceIDRatioBased (10%):
  Service A (采样) → Service B (可能不采样) ❌ Trace 不完整

ParentBased:
  Service A (采样) → Service B (继承，采样) ✅ Trace 完整
```

---

## 参考资源

- [OpenTelemetry Sampling](https://opentelemetry.io/docs/concepts/sampling/)
- [Go SDK Sampler](https://pkg.go.dev/go.opentelemetry.io/otel/sdk/trace#Sampler)
- [01_Provider配置.md](./01_Provider配置.md)
- [04_处理器.md](./04_处理器.md)

---

**🎉 恭喜！你已经掌握了采样器的完整知识！**

现在你可以：

- ✅ 使用内置采样器
- ✅ 实现自定义采样器
- ✅ 组合多种采样策略
- ✅ 根据环境和需求选择采样率
- ✅ 优化采样性能
