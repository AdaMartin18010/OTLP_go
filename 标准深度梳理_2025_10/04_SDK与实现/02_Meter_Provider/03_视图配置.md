# 视图配置 (View)

## 📋 目录

- [视图配置 (View)](#视图配置-view)
  - [📋 目录](#-目录)
  - [概述](#概述)
    - [什么是 View](#什么是-view)
    - [View 的作用](#view-的作用)
  - [基本配置](#基本配置)
    - [1. 创建 View](#1-创建-view)
    - [2. 注册 View](#2-注册-view)
    - [3. 多个 View](#3-多个-view)
  - [选择器 (Selector)](#选择器-selector)
    - [1. 按名称选择](#1-按名称选择)
    - [2. 按通配符选择](#2-按通配符选择)
    - [3. 按类型选择](#3-按类型选择)
  - [聚合配置](#聚合配置)
    - [1. 更改聚合类型](#1-更改聚合类型)
    - [2. Histogram 桶配置](#2-histogram-桶配置)
    - [3. 禁用指标](#3-禁用指标)
  - [属性过滤](#属性过滤)
    - [1. 保留特定属性](#1-保留特定属性)
    - [2. 删除属性](#2-删除属性)
    - [3. 属性重命名](#3-属性重命名)
  - [Go 1.25.1 实现](#go-1251-实现)
    - [1. 动态 View](#1-动态-view)
    - [2. View 构建器](#2-view-构建器)
    - [3. View 链](#3-view-链)
  - [高级模式](#高级模式)
    - [1. 降低基数](#1-降低基数)
    - [2. 性能优化](#2-性能优化)
    - [3. 成本控制](#3-成本控制)
  - [最佳实践](#最佳实践)
  - [常见问题](#常见问题)
  - [参考资源](#参考资源)

---

## 概述

### 什么是 View

**View** 是 OpenTelemetry Metrics 的配置机制，用于自定义指标的行为，而无需修改代码。

```text
Instrument (原始)
    ↓
View (转换/过滤)
    ↓
Metric (最终导出)
```

### View 的作用

```text
View 可以:
1. 更改指标名称
2. 更改指标描述
3. 更改聚合方式
4. 过滤/保留属性
5. 配置 Histogram 桶
6. 禁用特定指标
```

---

## 基本配置

### 1. 创建 View

```go
import (
    "go.opentelemetry.io/otel/sdk/metric"
)

// 创建 View
view := metric.NewView(
    // Selector: 选择要应用的 Instrument
    metric.Instrument{
        Name: "http.server.duration",
    },
    // Stream: 配置输出
    metric.Stream{
        Name:        "http.server.request.duration", // 重命名
        Description: "HTTP request duration in milliseconds",
        Unit:        "ms",
    },
)
```

### 2. 注册 View

```go
// 在创建 MeterProvider 时注册 View
mp := metric.NewMeterProvider(
    metric.WithReader(reader),
    metric.WithView(view), // 注册 View
)
```

### 3. 多个 View

```go
// 注册多个 View
mp := metric.NewMeterProvider(
    metric.WithReader(reader),
    metric.WithView(view1),
    metric.WithView(view2),
    metric.WithView(view3),
)
```

---

## 选择器 (Selector)

### 1. 按名称选择

```go
// 精确匹配
view := metric.NewView(
    metric.Instrument{
        Name: "http.server.duration",
    },
    metric.Stream{
        Name: "http.request.duration",
    },
)

// 匹配多个 Instrument (使用通配符)
view := metric.NewView(
    metric.Instrument{
        Name: "http.*", // 匹配所有以 http. 开头的指标
    },
    metric.Stream{
        // 配置
    },
)
```

### 2. 按通配符选择

```go
// 匹配所有指标
view := metric.NewView(
    metric.Instrument{
        Name: "*",
    },
    metric.Stream{
        // 应用于所有指标
    },
)

// 匹配前缀
view := metric.NewView(
    metric.Instrument{
        Name: "database.*",
    },
    metric.Stream{
        // 应用于所有 database.* 指标
    },
)
```

### 3. 按类型选择

```go
// 选择特定类型的 Instrument
view := metric.NewView(
    metric.Instrument{
        Kind: metric.InstrumentKindHistogram,
    },
    metric.Stream{
        // 应用于所有 Histogram
    },
)

// 选择特定 Scope
view := metric.NewView(
    metric.Instrument{
        Scope: instrumentation.Scope{
            Name: "myapp/api",
        },
    },
    metric.Stream{
        // 应用于特定 Scope 的指标
    },
)
```

---

## 聚合配置

### 1. 更改聚合类型

```go
import (
    "go.opentelemetry.io/otel/sdk/metric"
)

// Counter → Sum
view := metric.NewView(
    metric.Instrument{Name: "requests"},
    metric.Stream{
        Aggregation: metric.AggregationSum{},
    },
)

// Histogram → LastValue (转换为 Gauge)
view := metric.NewView(
    metric.Instrument{Name: "memory.used"},
    metric.Stream{
        Aggregation: metric.AggregationLastValue{},
    },
)

// Histogram → ExplicitBucketHistogram
view := metric.NewView(
    metric.Instrument{Name: "http.server.duration"},
    metric.Stream{
        Aggregation: metric.AggregationExplicitBucketHistogram{
            Boundaries: []float64{0, 5, 10, 25, 50, 75, 100, 250, 500, 1000},
        },
    },
)
```

### 2. Histogram 桶配置

```go
// 自定义 Histogram 桶
view := metric.NewView(
    metric.Instrument{Name: "http.server.duration"},
    metric.Stream{
        Aggregation: metric.AggregationExplicitBucketHistogram{
            Boundaries: []float64{
                10, 50, 100,    // 快速响应: 10-100ms
                500, 1000,      // 正常响应: 500ms-1s
                5000, 10000,    // 慢响应: 5-10s
            },
        },
    },
)

// 推荐的桶（不同场景）
var (
    // HTTP 延迟 (毫秒)
    HTTPLatencyBoundaries = []float64{0, 5, 10, 25, 50, 75, 100, 250, 500, 1000, 2500, 5000, 10000}
    
    // 数据库查询延迟 (毫秒)
    DBQueryBoundaries = []float64{0, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000}
    
    // 请求大小 (字节)
    SizeBoundaries = []float64{0, 1024, 10240, 102400, 1048576, 10485760} // 0, 1KB, 10KB, 100KB, 1MB, 10MB
)
```

### 3. 禁用指标

```go
// 禁用特定指标
view := metric.NewView(
    metric.Instrument{Name: "debug.metric"},
    metric.Stream{
        Aggregation: metric.AggregationDrop{}, // 丢弃指标
    },
)

// 禁用所有以 debug. 开头的指标
view := metric.NewView(
    metric.Instrument{Name: "debug.*"},
    metric.Stream{
        Aggregation: metric.AggregationDrop{},
    },
)
```

---

## 属性过滤

### 1. 保留特定属性

```go
// 只保留指定属性
view := metric.NewView(
    metric.Instrument{Name: "http.server.duration"},
    metric.Stream{
        AttributeFilter: func(kv attribute.KeyValue) bool {
            // 只保留 method, route, status_code
            key := string(kv.Key)
            return key == "http.method" || 
                   key == "http.route" || 
                   key == "http.status_code"
        },
    },
)
```

### 2. 删除属性

```go
// 删除高基数属性
view := metric.NewView(
    metric.Instrument{Name: "http.server.duration"},
    metric.Stream{
        AttributeFilter: func(kv attribute.KeyValue) bool {
            // 删除 user_id (高基数)
            return string(kv.Key) != "user.id"
        },
    },
)

// 删除敏感信息
view := metric.NewView(
    metric.Instrument{Name: "*"},
    metric.Stream{
        AttributeFilter: func(kv attribute.KeyValue) bool {
            key := string(kv.Key)
            // 删除所有包含 "password", "token" 的属性
            return !strings.Contains(key, "password") && 
                   !strings.Contains(key, "token")
        },
    },
)
```

### 3. 属性重命名

```go
// 注意：OpenTelemetry 不直接支持属性重命名
// 需要在应用层面处理，或使用 Collector Processor

// 方案：通过自定义 Exporter 实现
type RenamingExporter struct {
    next metric.Exporter
}

func (e *RenamingExporter) Export(ctx context.Context, rm *metricdata.ResourceMetrics) error {
    // 遍历并重命名属性
    for _, sm := range rm.ScopeMetrics {
        for _, m := range sm.Metrics {
            for _, dp := range m.Data.(metricdata.Histogram).DataPoints {
                newAttrs := []attribute.KeyValue{}
                for _, attr := range dp.Attributes.ToSlice() {
                    if string(attr.Key) == "old_name" {
                        newAttrs = append(newAttrs, attribute.String("new_name", attr.Value.AsString()))
                    } else {
                        newAttrs = append(newAttrs, attr)
                    }
                }
                dp.Attributes = attribute.NewSet(newAttrs...)
            }
        }
    }
    return e.next.Export(ctx, rm)
}
```

---

## Go 1.25.1 实现

### 1. 动态 View

```go
package metrics

import (
    "sync"
)

// DynamicViewManager 动态 View 管理器
type DynamicViewManager struct {
    mu    sync.RWMutex
    views []metric.View
}

func NewDynamicViewManager() *DynamicViewManager {
    return &DynamicViewManager{
        views: make([]metric.View, 0),
    }
}

// AddView 添加 View
func (m *DynamicViewManager) AddView(view metric.View) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.views = append(m.views, view)
}

// GetViews 获取所有 View
func (m *DynamicViewManager) GetViews() []metric.View {
    m.mu.RLock()
    defer m.mu.RUnlock()
    return append([]metric.View{}, m.views...)
}

// 使用示例
func main() {
    manager := NewDynamicViewManager()
    
    // 动态添加 View
    manager.AddView(metric.NewView(...))
    
    // 创建 MeterProvider
    mp := metric.NewMeterProvider(
        metric.WithReader(reader),
        metric.WithView(manager.GetViews()...),
    )
}
```

### 2. View 构建器

```go
package metrics

// ViewBuilder View 构建器
type ViewBuilder struct {
    instrumentName string
    instrumentKind metric.InstrumentKind
    streamName     string
    description    string
    unit           string
    aggregation    metric.Aggregation
    attrFilter     attribute.Filter
}

func NewViewBuilder() *ViewBuilder {
    return &ViewBuilder{}
}

func (b *ViewBuilder) ForInstrument(name string) *ViewBuilder {
    b.instrumentName = name
    return b
}

func (b *ViewBuilder) WithName(name string) *ViewBuilder {
    b.streamName = name
    return b
}

func (b *ViewBuilder) WithDescription(desc string) *ViewBuilder {
    b.description = desc
    return b
}

func (b *ViewBuilder) WithUnit(unit string) *ViewBuilder {
    b.unit = unit
    return b
}

func (b *ViewBuilder) WithAggregation(agg metric.Aggregation) *ViewBuilder {
    b.aggregation = agg
    return b
}

func (b *ViewBuilder) WithAttributeFilter(filter attribute.Filter) *ViewBuilder {
    b.attrFilter = filter
    return b
}

func (b *ViewBuilder) Build() metric.View {
    return metric.NewView(
        metric.Instrument{
            Name: b.instrumentName,
            Kind: b.instrumentKind,
        },
        metric.Stream{
            Name:            b.streamName,
            Description:     b.description,
            Unit:            b.unit,
            Aggregation:     b.aggregation,
            AttributeFilter: b.attrFilter,
        },
    )
}

// 使用示例
view := NewViewBuilder().
    ForInstrument("http.server.duration").
    WithName("http.request.duration").
    WithDescription("HTTP request duration").
    WithUnit("ms").
    WithAggregation(metric.AggregationExplicitBucketHistogram{
        Boundaries: []float64{0, 5, 10, 25, 50, 100, 250, 500, 1000},
    }).
    WithAttributeFilter(func(kv attribute.KeyValue) bool {
        key := string(kv.Key)
        return key == "http.method" || key == "http.route"
    }).
    Build()
```

### 3. View 链

```go
package metrics

// ViewChain View 链
type ViewChain struct {
    views []metric.View
}

func NewViewChain() *ViewChain {
    return &ViewChain{
        views: make([]metric.View, 0),
    }
}

func (c *ViewChain) Add(view metric.View) *ViewChain {
    c.views = append(c.views, view)
    return c
}

func (c *ViewChain) AddHTTPViews() *ViewChain {
    // HTTP 相关 View
    c.Add(metric.NewView(
        metric.Instrument{Name: "http.server.duration"},
        metric.Stream{
            Aggregation: metric.AggregationExplicitBucketHistogram{
                Boundaries: HTTPLatencyBoundaries,
            },
        },
    ))
    return c
}

func (c *ViewChain) AddDBViews() *ViewChain {
    // 数据库相关 View
    c.Add(metric.NewView(
        metric.Instrument{Name: "db.query.duration"},
        metric.Stream{
            Aggregation: metric.AggregationExplicitBucketHistogram{
                Boundaries: DBQueryBoundaries,
            },
        },
    ))
    return c
}

func (c *ViewChain) RemoveHighCardinalityAttributes() *ViewChain {
    c.Add(metric.NewView(
        metric.Instrument{Name: "*"},
        metric.Stream{
            AttributeFilter: func(kv attribute.KeyValue) bool {
                key := string(kv.Key)
                // 删除常见的高基数属性
                return key != "user.id" && 
                       key != "trace.id" && 
                       key != "span.id"
            },
        },
    ))
    return c
}

func (c *ViewChain) Build() []metric.View {
    return c.views
}

// 使用示例
views := NewViewChain().
    AddHTTPViews().
    AddDBViews().
    RemoveHighCardinalityAttributes().
    Build()

mp := metric.NewMeterProvider(
    metric.WithReader(reader),
    metric.WithView(views...),
)
```

---

## 高级模式

### 1. 降低基数

```go
// 问题：URL 路径导致高基数
// 原始: /users/123, /users/456, /users/789...

// 方案 1: 过滤 URL 参数
view := metric.NewView(
    metric.Instrument{Name: "http.server.duration"},
    metric.Stream{
        AttributeFilter: func(kv attribute.KeyValue) bool {
            // 保留 route (模板)，删除 target (实际路径)
            return string(kv.Key) != "http.target"
        },
    },
)

// 方案 2: 在应用层规范化
func recordHTTPMetric(ctx context.Context, path string) {
    // 规范化路径: /users/123 → /users/:id
    normalizedPath := normalizePath(path)
    
    histogram.Record(ctx, duration, metric.WithAttributes(
        attribute.String("http.route", normalizedPath),
    ))
}

// 方案 3: 状态码分组
view := metric.NewView(
    metric.Instrument{Name: "http.server.duration"},
    metric.Stream{
        AttributeFilter: func(kv attribute.KeyValue) bool {
            if string(kv.Key) == "http.status_code" {
                // 保留状态码类别 (2xx, 3xx, 4xx, 5xx)
                code := kv.Value.AsInt64()
                return code >= 200 && code < 600
            }
            return true
        },
    },
)
```

### 2. 性能优化

```go
// 减少导出的指标数量
view := metric.NewView(
    metric.Instrument{Name: "debug.*"},
    metric.Stream{
        Aggregation: metric.AggregationDrop{}, // 生产环境禁用调试指标
    },
)

// 简化 Histogram 桶
view := metric.NewView(
    metric.Instrument{Kind: metric.InstrumentKindHistogram},
    metric.Stream{
        Aggregation: metric.AggregationExplicitBucketHistogram{
            Boundaries: []float64{10, 100, 1000}, // 只用 3 个桶
        },
    },
)

// 减少属性数量
view := metric.NewView(
    metric.Instrument{Name: "*"},
    metric.Stream{
        AttributeFilter: func(kv attribute.KeyValue) bool {
            // 只保留核心属性
            key := string(kv.Key)
            coreAttrs := []string{"service.name", "http.method", "http.status_code"}
            for _, core := range coreAttrs {
                if key == core {
                    return true
                }
            }
            return false
        },
    },
)
```

### 3. 成本控制

```go
// 环境相关配置
func getViewsForEnvironment(env string) []metric.View {
    switch env {
    case "production":
        return []metric.View{
            // 生产环境：保留核心指标，删除调试指标
            metric.NewView(
                metric.Instrument{Name: "debug.*"},
                metric.Stream{Aggregation: metric.AggregationDrop{}},
            ),
            // 简化 Histogram
            metric.NewView(
                metric.Instrument{Kind: metric.InstrumentKindHistogram},
                metric.Stream{
                    Aggregation: metric.AggregationExplicitBucketHistogram{
                        Boundaries: []float64{10, 100, 1000},
                    },
                },
            ),
        }
    case "development":
        return []metric.View{
            // 开发环境：保留所有指标，详细 Histogram
            metric.NewView(
                metric.Instrument{Kind: metric.InstrumentKindHistogram},
                metric.Stream{
                    Aggregation: metric.AggregationExplicitBucketHistogram{
                        Boundaries: []float64{1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000},
                    },
                },
            ),
        }
    default:
        return []metric.View{}
    }
}
```

---

## 最佳实践

```go
// ✅ 正确: 配置合理的 Histogram 桶
view := metric.NewView(
    metric.Instrument{Name: "http.server.duration"},
    metric.Stream{
        Aggregation: metric.AggregationExplicitBucketHistogram{
            Boundaries: []float64{0, 5, 10, 25, 50, 75, 100, 250, 500, 1000},
        },
    },
)

// ❌ 错误: 桶太多或太少
view := metric.NewView(
    metric.Instrument{Name: "http.server.duration"},
    metric.Stream{
        Aggregation: metric.AggregationExplicitBucketHistogram{
            Boundaries: []float64{100}, // 太少
        },
    },
)

// ✅ 正确: 过滤高基数属性
view := metric.NewView(
    metric.Instrument{Name: "*"},
    metric.Stream{
        AttributeFilter: func(kv attribute.KeyValue) bool {
            key := string(kv.Key)
            return key != "user.id" && key != "session.id"
        },
    },
)

// ✅ 正确: 禁用不需要的指标
view := metric.NewView(
    metric.Instrument{Name: "internal.*"},
    metric.Stream{
        Aggregation: metric.AggregationDrop{},
    },
)

// ✅ 正确: 为不同环境使用不同配置
views := getViewsForEnvironment(os.Getenv("ENV"))
```

---

## 常见问题

**Q1: 何时使用 View？**

```text
应该使用 View:
✅ 需要更改指标名称/描述
✅ 需要自定义 Histogram 桶
✅ 需要降低基数
✅ 需要禁用某些指标
✅ 需要过滤属性

不需要 View:
❌ 默认配置已满足需求
❌ 可以在应用代码中解决
```

**Q2: View 的执行顺序？**

```text
View 按注册顺序执行:
mp := metric.NewMeterProvider(
    metric.WithView(view1), // 第一个
    metric.WithView(view2), // 第二个
    metric.WithView(view3), // 第三个
)

注意:
- 第一个匹配的 View 生效
- 后续 View 不会再处理已匹配的 Instrument
```

**Q3: 如何调试 View 配置？**

```go
// 使用 stdout exporter 查看最终指标
exporter, _ := stdoutmetric.New(
    stdoutmetric.WithPrettyPrint(),
)

mp := metric.NewMeterProvider(
    metric.WithReader(metric.NewPeriodicReader(exporter)),
    metric.WithView(yourView),
)

// 运行应用，查看输出的指标名称、属性等
```

---

## 参考资源

- [OpenTelemetry View](https://opentelemetry.io/docs/specs/otel/metrics/sdk/#view)
- [Go SDK View](https://pkg.go.dev/go.opentelemetry.io/otel/sdk/metric#View)
- [02_Meter创建.md](./02_Meter创建.md)
- [04_聚合器.md](./04_聚合器.md)

---

**🎉 恭喜！你已经掌握了 View 配置的完整知识！**

现在你可以：

- ✅ 创建和注册 View
- ✅ 使用选择器匹配 Instrument
- ✅ 配置聚合类型和 Histogram 桶
- ✅ 过滤和转换属性
- ✅ 降低基数和控制成本
