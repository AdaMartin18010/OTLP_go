# 聚合器 (Aggregation)

## 📋 目录

- [聚合器 (Aggregation)](#聚合器-aggregation)
  - [📋 目录](#-目录)
  - [概述](#概述)
    - [什么是聚合](#什么是聚合)
    - [聚合流程](#聚合流程)
  - [内置聚合器](#内置聚合器)
    - [1. Sum](#1-sum)
    - [2. LastValue](#2-lastvalue)
    - [3. ExplicitBucketHistogram](#3-explicitbuckethistogram)
    - [4. ExponentialHistogram](#4-exponentialhistogram)
    - [5. Drop](#5-drop)
  - [时间性 (Temporality)](#时间性-temporality)
    - [1. Cumulative](#1-cumulative)
    - [2. Delta](#2-delta)
    - [3. 选择指南](#3-选择指南)
  - [Go 1.25.1 实现](#go-1251-实现)
    - [1. 自定义聚合器](#1-自定义聚合器)
    - [2. 聚合器配置](#2-聚合器配置)
    - [3. 条件聚合](#3-条件聚合)
  - [性能优化](#性能优化)
  - [最佳实践](#最佳实践)
  - [常见问题](#常见问题)
  - [参考资源](#参考资源)

---

## 概述

### 什么是聚合

**聚合 (Aggregation)** 是将多个测量值合并为单个指标数据点的过程。

```text
Measurements (原始数据):
  100ms, 150ms, 200ms, 120ms, 180ms...
    ↓ (聚合)
Metric (聚合后):
  Count: 5
  Sum: 750ms
  Min: 100ms
  Max: 200ms
  Histogram: [0-100: 0, 100-200: 4, 200-300: 1]
```

### 聚合流程

```text
1. Instrument 记录测量值
2. Aggregation 聚合测量值
3. Reader 周期性收集聚合结果
4. Exporter 导出到后端
```

---

## 内置聚合器

### 1. Sum

累加所有测量值：

```go
import "go.opentelemetry.io/otel/sdk/metric"

// 配置 Sum 聚合
view := metric.NewView(
    metric.Instrument{Name: "requests.count"},
    metric.Stream{
        Aggregation: metric.AggregationSum{},
    },
)
```

**特点**:

```text
用途: Counter
计算: Sum = Σ(measurements)

示例:
  Measurements: 1, 1, 1, 1, 1
  Result: Sum = 5

适用场景:
✅ 计数器 (请求数、错误数)
✅ 累计值 (字节传输量)
```

### 2. LastValue

保留最后一个测量值：

```go
// 配置 LastValue 聚合
view := metric.NewView(
    metric.Instrument{Name: "memory.used"},
    metric.Stream{
        Aggregation: metric.AggregationLastValue{},
    },
)
```

**特点**:

```text
用途: Gauge
计算: Value = Last(measurements)

示例:
  Measurements: 100, 150, 200, 180, 220
  Result: LastValue = 220

适用场景:
✅ 当前值 (内存使用、CPU 使用率)
✅ 瞬时值 (温度、队列长度)
```

### 3. ExplicitBucketHistogram

将测量值分配到预定义的桶中：

```go
// 配置 Histogram 聚合
view := metric.NewView(
    metric.Instrument{Name: "http.server.duration"},
    metric.Stream{
        Aggregation: metric.AggregationExplicitBucketHistogram{
            Boundaries: []float64{0, 5, 10, 25, 50, 75, 100, 250, 500, 1000},
        },
    },
)
```

**特点**:

```text
用途: Histogram
计算: 将值分配到桶

示例 (桶: [0, 10, 100, 1000]):
  Measurements: 5, 15, 50, 150, 500
  Result:
    [0-10):    1 (5)
    [10-100):  2 (15, 50)
    [100-1000): 2 (150, 500)

适用场景:
✅ 分布分析 (延迟、请求大小)
✅ 百分位计算 (P50, P95, P99)
```

**桶边界配置**:

```go
// HTTP 延迟 (毫秒)
Boundaries: []float64{0, 5, 10, 25, 50, 75, 100, 250, 500, 1000, 2500, 5000, 10000}

// 数据库查询 (毫秒)
Boundaries: []float64{0, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000}

// 请求大小 (字节)
Boundaries: []float64{0, 1024, 10240, 102400, 1048576, 10485760}
// 0, 1KB, 10KB, 100KB, 1MB, 10MB

// 推荐: 使用对数刻度
Boundaries: []float64{1, 2, 5, 10, 20, 50, 100, 200, 500, 1000}
```

### 4. ExponentialHistogram

使用指数级桶边界：

```go
// 配置 ExponentialHistogram
view := metric.NewView(
    metric.Instrument{Name: "http.server.duration"},
    metric.Stream{
        Aggregation: metric.AggregationBase2ExponentialHistogram{
            MaxSize:  160, // 最大桶数
            MaxScale: 20,  // 最大精度
        },
    },
)
```

**特点**:

```text
用途: Histogram (自适应桶)
计算: 桶边界自动调整

优点:
✅ 无需预定义桶边界
✅ 自动适应数据分布
✅ 更高的精度

缺点:
❌ 更复杂
❌ 某些后端不支持

适用场景:
✅ 不确定数据分布
✅ 需要高精度
```

### 5. Drop

丢弃所有测量值：

```go
// 禁用指标
view := metric.NewView(
    metric.Instrument{Name: "debug.metric"},
    metric.Stream{
        Aggregation: metric.AggregationDrop{},
    },
)
```

**特点**:

```text
用途: 禁用指标
计算: 丢弃所有数据

适用场景:
✅ 生产环境禁用调试指标
✅ 临时禁用某些指标
```

---

## 时间性 (Temporality)

### 1. Cumulative

累积模式（从开始累计）：

```text
时间: 0s    10s   20s   30s
值:   0     100   250   400

导出:
  t=10s: 100  (0到10s的累计)
  t=20s: 250  (0到20s的累计)
  t=30s: 400  (0到30s的累计)

特点:
✅ 简单易理解
✅ 后端可以计算任意时间段的变化
❌ 需要更多存储空间
```

### 2. Delta

增量模式（每个周期的变化）：

```text
时间: 0s    10s   20s   30s
值:   0     100   250   400

导出:
  t=10s: 100  (0到10s的增量)
  t=20s: 150  (10到20s的增量)
  t=30s: 150  (20到30s的增量)

特点:
✅ 节省存储空间
✅ 网络传输更少
❌ 无法重新计算历史数据
```

### 3. 选择指南

```go
// 配置 Temporality
reader := metric.NewPeriodicReader(
    exporter,
    metric.WithTemporalitySelector(func(ik metric.InstrumentKind) metricdata.Temporality {
        switch ik {
        case metric.InstrumentKindCounter,
             metric.InstrumentKindUpDownCounter,
             metric.InstrumentKindHistogram:
            return metricdata.CumulativeTemporality // Cumulative
        case metric.InstrumentKindObservableCounter,
             metric.InstrumentKindObservableUpDownCounter,
             metric.InstrumentKindObservableGauge:
            return metricdata.CumulativeTemporality // Cumulative
        default:
            return metricdata.CumulativeTemporality
        }
    }),
)
```

**选择建议**:

```text
Cumulative:
✅ Prometheus
✅ 长期存储
✅ 需要灵活查询

Delta:
✅ 节省网络带宽
✅ 实时监控
✅ StatsD 风格

推荐:
- 默认使用 Cumulative
- 特殊需求使用 Delta
```

---

## Go 1.25.1 实现

### 1. 自定义聚合器

```go
package aggregation

import (
    "go.opentelemetry.io/otel/sdk/metric"
    "go.opentelemetry.io/otel/sdk/metric/metricdata"
)

// CustomAggregation 自定义聚合器接口
type CustomAggregation interface {
    // Aggregate 聚合测量值
    Aggregate(value float64)
    
    // Snapshot 获取聚合结果
    Snapshot() metricdata.DataPoint
    
    // Reset 重置聚合器
    Reset()
}

// MinMaxAggregation 最小最大值聚合
type MinMaxAggregation struct {
    min   float64
    max   float64
    count int64
}

func NewMinMaxAggregation() *MinMaxAggregation {
    return &MinMaxAggregation{
        min: math.MaxFloat64,
        max: -math.MaxFloat64,
    }
}

func (a *MinMaxAggregation) Aggregate(value float64) {
    a.count++
    if value < a.min {
        a.min = value
    }
    if value > a.max {
        a.max = value
    }
}

func (a *MinMaxAggregation) Snapshot() (min, max float64, count int64) {
    return a.min, a.max, a.count
}

func (a *MinMaxAggregation) Reset() {
    a.min = math.MaxFloat64
    a.max = -math.MaxFloat64
    a.count = 0
}

// 使用示例
type MinMaxInstrument struct {
    agg *MinMaxAggregation
}

func (i *MinMaxInstrument) Record(ctx context.Context, value float64, attrs ...attribute.KeyValue) {
    i.agg.Aggregate(value)
}
```

### 2. 聚合器配置

```go
package aggregation

// AggregationConfig 聚合器配置
type AggregationConfig struct {
    Type       AggregationType
    Boundaries []float64 // for Histogram
    MaxSize    int       // for ExponentialHistogram
    MaxScale   int       // for ExponentialHistogram
}

type AggregationType int

const (
    AggregationTypeSum AggregationType = iota
    AggregationTypeLastValue
    AggregationTypeHistogram
    AggregationTypeExponentialHistogram
    AggregationTypeDrop
)

// NewAggregation 创建聚合器
func NewAggregation(cfg AggregationConfig) metric.Aggregation {
    switch cfg.Type {
    case AggregationTypeSum:
        return metric.AggregationSum{}
    case AggregationTypeLastValue:
        return metric.AggregationLastValue{}
    case AggregationTypeHistogram:
        return metric.AggregationExplicitBucketHistogram{
            Boundaries: cfg.Boundaries,
        }
    case AggregationTypeExponentialHistogram:
        return metric.AggregationBase2ExponentialHistogram{
            MaxSize:  cfg.MaxSize,
            MaxScale: cfg.MaxScale,
        }
    case AggregationTypeDrop:
        return metric.AggregationDrop{}
    default:
        return metric.AggregationDefault{}
    }
}

// 使用示例
func createHTTPViews() []metric.View {
    return []metric.View{
        metric.NewView(
            metric.Instrument{Name: "http.server.duration"},
            metric.Stream{
                Aggregation: NewAggregation(AggregationConfig{
                    Type:       AggregationTypeHistogram,
                    Boundaries: []float64{0, 5, 10, 25, 50, 100, 250, 500, 1000},
                }),
            },
        ),
    }
}
```

### 3. 条件聚合

```go
package aggregation

// ConditionalAggregation 条件聚合
func ConditionalAggregation(instrumentName string) metric.Aggregation {
    switch {
    case strings.HasSuffix(instrumentName, ".duration"):
        // 延迟类指标使用 Histogram
        return metric.AggregationExplicitBucketHistogram{
            Boundaries: []float64{0, 5, 10, 25, 50, 100, 250, 500, 1000},
        }
    case strings.HasSuffix(instrumentName, ".size"):
        // 大小类指标使用 Histogram (字节)
        return metric.AggregationExplicitBucketHistogram{
            Boundaries: []float64{0, 1024, 10240, 102400, 1048576, 10485760},
        }
    case strings.HasSuffix(instrumentName, ".count"):
        // 计数类指标使用 Sum
        return metric.AggregationSum{}
    case strings.HasSuffix(instrumentName, ".current"):
        // 当前值类指标使用 LastValue
        return metric.AggregationLastValue{}
    default:
        return metric.AggregationDefault{}
    }
}

// 使用示例
view := metric.NewView(
    metric.Instrument{Name: "*"},
    metric.Stream{
        Aggregation: ConditionalAggregation("http.server.duration"),
    },
)
```

---

## 性能优化

```go
// 1. 减少 Histogram 桶数量
// ❌ 太多桶
Boundaries: []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ..., 100} // 100个桶！

// ✅ 合理数量
Boundaries: []float64{1, 10, 100, 1000} // 4个桶

// 2. 使用 Drop 禁用不需要的指标
view := metric.NewView(
    metric.Instrument{Name: "debug.*"},
    metric.Stream{
        Aggregation: metric.AggregationDrop{},
    },
)

// 3. 选择合适的聚合类型
// 对于简单计数，使用 Sum（最快）
view := metric.NewView(
    metric.Instrument{Name: "requests.count"},
    metric.Stream{
        Aggregation: metric.AggregationSum{}, // 快
    },
)

// 4. 避免过度精细的桶
// ❌ 过度精细
Boundaries: []float64{0, 1, 2, 3, 4, 5, ..., 1000} // 太多！

// ✅ 合理精度
Boundaries: []float64{0, 10, 50, 100, 500, 1000} // 够用

// 5. 根据环境调整
func getAggregation(env string) metric.Aggregation {
    if env == "production" {
        // 生产环境：简单桶
        return metric.AggregationExplicitBucketHistogram{
            Boundaries: []float64{10, 100, 1000},
        }
    }
    // 开发环境：详细桶
    return metric.AggregationExplicitBucketHistogram{
        Boundaries: []float64{1, 5, 10, 25, 50, 100, 250, 500, 1000, 2500, 5000},
    }
}
```

---

## 最佳实践

```go
// ✅ 正确: 为延迟使用 Histogram
view := metric.NewView(
    metric.Instrument{Name: "http.server.duration"},
    metric.Stream{
        Aggregation: metric.AggregationExplicitBucketHistogram{
            Boundaries: []float64{0, 5, 10, 25, 50, 100, 250, 500, 1000},
        },
    },
)

// ✅ 正确: 为计数器使用 Sum
view := metric.NewView(
    metric.Instrument{Name: "requests.count"},
    metric.Stream{
        Aggregation: metric.AggregationSum{},
    },
)

// ✅ 正确: 为当前值使用 LastValue
view := metric.NewView(
    metric.Instrument{Name: "memory.used"},
    metric.Stream{
        Aggregation: metric.AggregationLastValue{},
    },
)

// ✅ 正确: 使用对数刻度的桶
Boundaries: []float64{1, 2, 5, 10, 20, 50, 100, 200, 500, 1000}

// ❌ 错误: 使用线性刻度（对大范围不友好）
Boundaries: []float64{10, 20, 30, 40, 50, ..., 1000}

// ✅ 正确: 桶边界要覆盖预期范围
// HTTP 延迟通常在 0-1000ms，所以:
Boundaries: []float64{0, 5, 10, 25, 50, 100, 250, 500, 1000}

// ❌ 错误: 桶边界范围不合理
Boundaries: []float64{0, 1, 2, 3, 4, 5} // 太小！大部分值会超出

// ✅ 正确: 禁用调试指标
view := metric.NewView(
    metric.Instrument{Name: "debug.*"},
    metric.Stream{
        Aggregation: metric.AggregationDrop{},
    },
)
```

---

## 常见问题

**Q1: 如何选择聚合类型？**

```text
Sum:
✅ Counter
✅ 累计值 (总请求数、总字节数)

LastValue:
✅ Gauge
✅ 当前值 (内存使用、CPU使用率、队列长度)

Histogram:
✅ 分布分析
✅ 延迟、大小、持续时间

ExponentialHistogram:
✅ 不确定数据分布
✅ 需要高精度

Drop:
✅ 禁用指标
```

**Q2: Histogram 桶如何配置？**

```text
原则:
1. 覆盖预期范围
   - HTTP: 0-10,000ms
   - DB: 0-1,000ms

2. 使用对数刻度
   - 1, 2, 5, 10, 20, 50, 100...
   - 而不是 10, 20, 30, 40...

3. 合理的桶数量
   - 推荐: 5-15个桶
   - 太少: 精度低
   - 太多: 性能差

4. 根据需求调整
   - SLA 是 100ms? 在 100ms 附近增加桶
   - 99% 请求 < 500ms? 在 500ms 前多设桶
```

**Q3: Cumulative vs Delta？**

```text
Cumulative (推荐):
✅ 优点:
  - 简单易理解
  - 后端可以灵活查询
  - Prometheus 标准
  
❌ 缺点:
  - 需要更多存储

Delta:
✅ 优点:
  - 节省存储和带宽
  - 实时监控
  
❌ 缺点:
  - 无法重算历史
  - 需要后端支持

推荐:
- 默认: Cumulative
- 特殊需求: Delta
```

**Q4: 如何验证聚合配置？**

```go
// 使用 stdout exporter 查看
exporter, _ := stdoutmetric.New(
    stdoutmetric.WithPrettyPrint(),
)

mp := metric.NewMeterProvider(
    metric.WithReader(metric.NewPeriodicReader(exporter)),
    metric.WithView(yourView),
)

// 记录一些数据
meter := mp.Meter("test")
histogram, _ := meter.Float64Histogram("test.duration")
histogram.Record(context.Background(), 50)
histogram.Record(context.Background(), 150)
histogram.Record(context.Background(), 500)

// 等待导出，查看输出
time.Sleep(2 * time.Second)

// 检查:
// 1. 桶分布是否合理
// 2. 是否有数据落在正确的桶中
// 3. Sum, Count 是否正确
```

---

## 参考资源

- [OpenTelemetry Aggregation](https://opentelemetry.io/docs/specs/otel/metrics/sdk/#aggregation)
- [Go SDK Aggregation](https://pkg.go.dev/go.opentelemetry.io/otel/sdk/metric#Aggregation)
- [03_视图配置.md](./03_视图配置.md)
- [05_导出器.md](./05_导出器.md)

---

**🎉 恭喜！你已经掌握了聚合器的完整知识！**

现在你可以：

- ✅ 理解各种聚合类型
- ✅ 配置 Histogram 桶
- ✅ 选择合适的 Temporality
- ✅ 实现自定义聚合器
- ✅ 优化聚合性能
