# MetricExporter 导出器

## 📋 目录

- [MetricExporter 导出器](#metricexporter-导出器)
  - [📋 目录](#-目录)
  - [概述](#概述)
    - [什么是 MetricExporter](#什么是-metricexporter)
    - [导出流程](#导出流程)
  - [内置导出器](#内置导出器)
    - [1. OTLP Exporter](#1-otlp-exporter)
    - [2. Prometheus Exporter](#2-prometheus-exporter)
    - [3. Stdout Exporter](#3-stdout-exporter)
  - [OTLP 配置](#otlp-配置)
    - [1. gRPC 导出器](#1-grpc-导出器)
    - [2. HTTP 导出器](#2-http-导出器)
    - [3. 认证配置](#3-认证配置)
  - [Prometheus 集成](#prometheus-集成)
    - [1. Push 模式](#1-push-模式)
    - [2. Pull 模式](#2-pull-模式)
    - [3. Remote Write](#3-remote-write)
  - [Go 1.25.1 实现](#go-1251-实现)
    - [1. 自定义导出器](#1-自定义导出器)
    - [2. 多导出器](#2-多导出器)
    - [3. 导出器装饰器](#3-导出器装饰器)
  - [错误处理](#错误处理)
  - [性能优化](#性能优化)
  - [最佳实践](#最佳实践)
  - [常见问题](#常见问题)
  - [参考资源](#参考资源)

---

## 概述

### 什么是 MetricExporter

**MetricExporter** 负责将聚合后的指标数据发送到后端系统（如 Prometheus、OpenTelemetry Collector）。

```text
Reader
    ↓
MetricExporter.Export()
    ↓ (gRPC/HTTP/Pull)
Backend
  - Prometheus
  - OTLP Collector
  - Custom Backend
```

### 导出流程

```text
1. Reader 周期性收集指标
2. 调用 Exporter.Export(metrics)
3. Exporter 序列化并发送
4. 后端接收和存储
```

---

## 内置导出器

### 1. OTLP Exporter

OpenTelemetry Protocol 导出器（推荐）：

```go
import (
    "context"
    "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
    "go.opentelemetry.io/otel/sdk/metric"
)

func main() {
    // 创建 OTLP gRPC 导出器
    exporter, err := otlpmetricgrpc.New(
        context.Background(),
        otlpmetricgrpc.WithEndpoint("localhost:4317"),
        otlpmetricgrpc.WithInsecure(),
    )
    if err != nil {
        log.Fatal(err)
    }
    
    // 创建 Reader
    reader := metric.NewPeriodicReader(exporter)
    
    // 配置 MeterProvider
    mp := metric.NewMeterProvider(
        metric.WithReader(reader),
    )
    defer mp.Shutdown(context.Background())
}
```

### 2. Prometheus Exporter

Prometheus Pull 模式导出器：

```go
import (
    "net/http"
    "go.opentelemetry.io/otel/exporters/prometheus"
    "go.opentelemetry.io/otel/sdk/metric"
)

func main() {
    // 创建 Prometheus 导出器
    exporter, err := prometheus.New()
    if err != nil {
        log.Fatal(err)
    }
    
    // 配置 MeterProvider
    mp := metric.NewMeterProvider(
        metric.WithReader(exporter),
    )
    
    // 启动 HTTP 服务器暴露指标
    http.Handle("/metrics", promhttp.Handler())
    go http.ListenAndServe(":9090", nil)
    
    defer mp.Shutdown(context.Background())
}
```

### 3. Stdout Exporter

标准输出导出器（调试）：

```go
import (
    "go.opentelemetry.io/otel/exporters/stdout/stdoutmetric"
)

func main() {
    // 创建 Stdout 导出器
    exporter, err := stdoutmetric.New(
        stdoutmetric.WithPrettyPrint(),
    )
    if err != nil {
        log.Fatal(err)
    }
    
    reader := metric.NewPeriodicReader(exporter)
    
    mp := metric.NewMeterProvider(
        metric.WithReader(reader),
    )
    defer mp.Shutdown(context.Background())
}
```

---

## OTLP 配置

### 1. gRPC 导出器

```go
import (
    "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
    "google.golang.org/grpc/credentials"
)

func NewOTLPgRPCExporter() (metric.Exporter, error) {
    return otlpmetricgrpc.New(
        context.Background(),
        
        // 端点配置
        otlpmetricgrpc.WithEndpoint("collector.example.com:4317"),
        
        // TLS 配置
        otlpmetricgrpc.WithTLSCredentials(
            credentials.NewClientTLSFromCert(certPool, ""),
        ),
        
        // 或不使用 TLS
        // otlpmetricgrpc.WithInsecure(),
        
        // 重试配置
        otlpmetricgrpc.WithRetry(otlpmetricgrpc.RetryConfig{
            Enabled:         true,
            InitialInterval: 5 * time.Second,
            MaxInterval:     30 * time.Second,
            MaxElapsedTime:  time.Minute,
        }),
        
        // 超时配置
        otlpmetricgrpc.WithTimeout(30*time.Second),
        
        // 压缩
        otlpmetricgrpc.WithCompressor("gzip"),
        
        // HTTP 头
        otlpmetricgrpc.WithHeaders(map[string]string{
            "api-key": "your-api-key",
        }),
        
        // Temporality 配置
        otlpmetricgrpc.WithTemporalitySelector(func(ik metric.InstrumentKind) metricdata.Temporality {
            return metricdata.CumulativeTemporality
        }),
    )
}
```

### 2. HTTP 导出器

```go
import (
    "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetrichttp"
)

func NewOTLPHTTPExporter() (metric.Exporter, error) {
    return otlpmetrichttp.New(
        context.Background(),
        
        // 端点配置
        otlpmetrichttp.WithEndpoint("collector.example.com:4318"),
        
        // URL 路径
        otlpmetrichttp.WithURLPath("/v1/metrics"),
        
        // TLS 配置
        otlpmetrichttp.WithTLSClientConfig(&tls.Config{
            InsecureSkipVerify: false,
        }),
        
        // 或不使用 TLS
        // otlpmetrichttp.WithInsecure(),
        
        // 重试配置
        otlpmetrichttp.WithRetry(otlpmetrichttp.RetryConfig{
            Enabled:         true,
            InitialInterval: 5 * time.Second,
            MaxInterval:     30 * time.Second,
            MaxElapsedTime:  time.Minute,
        }),
        
        // 超时
        otlpmetrichttp.WithTimeout(30*time.Second),
        
        // 压缩
        otlpmetrichttp.WithCompression(otlpmetrichttp.GzipCompression),
        
        // HTTP 头
        otlpmetrichttp.WithHeaders(map[string]string{
            "api-key": "your-api-key",
        }),
    )
}
```

### 3. 认证配置

```go
// 1. API Key 认证
exporter, _ := otlpmetricgrpc.New(
    context.Background(),
    otlpmetricgrpc.WithEndpoint("collector.example.com:4317"),
    otlpmetricgrpc.WithHeaders(map[string]string{
        "authorization": "Bearer YOUR_API_KEY",
    }),
)

// 2. mTLS 认证
cert, _ := tls.LoadX509KeyPair("client.crt", "client.key")
caCert, _ := os.ReadFile("ca.crt")
caCertPool := x509.NewCertPool()
caCertPool.AppendCertsFromPEM(caCert)

tlsConfig := &tls.Config{
    Certificates: []tls.Certificate{cert},
    RootCAs:      caCertPool,
}

exporter, _ := otlpmetricgrpc.New(
    context.Background(),
    otlpmetricgrpc.WithEndpoint("collector.example.com:4317"),
    otlpmetricgrpc.WithTLSCredentials(
        credentials.NewTLS(tlsConfig),
    ),
)

// 3. 自定义认证
type customAuthInterceptor struct{}

func (i *customAuthInterceptor) UnaryClientInterceptor(...) {
    // 自定义认证逻辑
}

exporter, _ := otlpmetricgrpc.New(
    context.Background(),
    otlpmetricgrpc.WithDialOption(
        grpc.WithUnaryInterceptor(interceptor),
    ),
)
```

---

## Prometheus 集成

### 1. Push 模式

使用 Pushgateway：

```go
import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/push"
)

func pushToPrometheus() error {
    // 创建 Pusher
    pusher := push.New("http://pushgateway:9091", "my-job").
        Grouping("instance", "my-instance")
    
    // 添加指标
    pusher.Collector(yourCollector)
    
    // 推送
    if err := pusher.Push(); err != nil {
        return fmt.Errorf("failed to push metrics: %w", err)
    }
    
    return nil
}

// 周期性推送
func startPushMetrics() {
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        if err := pushToPrometheus(); err != nil {
            log.Printf("Failed to push metrics: %v", err)
        }
    }
}
```

### 2. Pull 模式

暴露 /metrics 端点：

```go
import (
    "net/http"
    "go.opentelemetry.io/otel/exporters/prometheus"
    "github.com/prometheus/client_golang/prometheus/promhttp"
)

func main() {
    // 创建 Prometheus 导出器
    exporter, err := prometheus.New()
    if err != nil {
        log.Fatal(err)
    }
    
    // 配置 MeterProvider
    mp := metric.NewMeterProvider(
        metric.WithReader(exporter),
    )
    
    // 暴露 /metrics 端点
    http.Handle("/metrics", promhttp.Handler())
    
    // 启动 HTTP 服务器
    log.Println("Serving metrics on :9090/metrics")
    if err := http.ListenAndServe(":9090", nil); err != nil {
        log.Fatal(err)
    }
}
```

### 3. Remote Write

直接写入 Prometheus：

```go
import (
    "github.com/prometheus/prometheus/prompb"
    "github.com/golang/snappy"
    "bytes"
    "net/http"
)

func remoteWrite(samples []prompb.TimeSeries) error {
    // 创建 WriteRequest
    req := &prompb.WriteRequest{
        Timeseries: samples,
    }
    
    // 序列化
    data, err := proto.Marshal(req)
    if err != nil {
        return err
    }
    
    // 压缩
    compressed := snappy.Encode(nil, data)
    
    // 发送
    httpReq, _ := http.NewRequest(
        "POST",
        "http://prometheus:9090/api/v1/write",
        bytes.NewReader(compressed),
    )
    httpReq.Header.Set("Content-Encoding", "snappy")
    httpReq.Header.Set("Content-Type", "application/x-protobuf")
    
    resp, err := http.DefaultClient.Do(httpReq)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("unexpected status: %d", resp.StatusCode)
    }
    
    return nil
}
```

---

## Go 1.25.1 实现

### 1. 自定义导出器

```go
package exporter

import (
    "context"
    "go.opentelemetry.io/otel/sdk/metric"
    "go.opentelemetry.io/otel/sdk/metric/metricdata"
)

// CustomExporter 自定义导出器
type CustomExporter struct {
    endpoint string
    client   *http.Client
}

// NewCustomExporter 创建自定义导出器
func NewCustomExporter(endpoint string) metric.Exporter {
    return &CustomExporter{
        endpoint: endpoint,
        client:   &http.Client{Timeout: 30 * time.Second},
    }
}

// Export 导出指标
func (e *CustomExporter) Export(ctx context.Context, rm *metricdata.ResourceMetrics) error {
    // 1. 序列化指标
    data, err := e.serializeMetrics(rm)
    if err != nil {
        return fmt.Errorf("failed to serialize metrics: %w", err)
    }
    
    // 2. 发送到后端
    req, err := http.NewRequestWithContext(ctx, "POST", e.endpoint, bytes.NewReader(data))
    if err != nil {
        return err
    }
    
    req.Header.Set("Content-Type", "application/json")
    
    resp, err := e.client.Do(req)
    if err != nil {
        return fmt.Errorf("failed to send metrics: %w", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
    }
    
    return nil
}

// Temporality 返回 Temporality 配置
func (e *CustomExporter) Temporality(ik metric.InstrumentKind) metricdata.Temporality {
    return metricdata.CumulativeTemporality
}

// Aggregation 返回聚合配置
func (e *CustomExporter) Aggregation(ik metric.InstrumentKind) metric.Aggregation {
    return metric.AggregationDefault{}
}

// ForceFlush 强制刷新
func (e *CustomExporter) ForceFlush(ctx context.Context) error {
    return nil
}

// Shutdown 关闭导出器
func (e *CustomExporter) Shutdown(ctx context.Context) error {
    e.client.CloseIdleConnections()
    return nil
}

func (e *CustomExporter) serializeMetrics(rm *metricdata.ResourceMetrics) ([]byte, error) {
    // 实现序列化逻辑
    type metricData struct {
        Name        string            `json:"name"`
        Description string            `json:"description"`
        Unit        string            `json:"unit"`
        DataPoints  []dataPoint       `json:"data_points"`
    }
    
    type dataPoint struct {
        Attributes map[string]string `json:"attributes"`
        Value      interface{}       `json:"value"`
        Timestamp  int64             `json:"timestamp"`
    }
    
    metrics := make([]metricData, 0)
    
    for _, sm := range rm.ScopeMetrics {
        for _, m := range sm.Metrics {
            md := metricData{
                Name:        m.Name,
                Description: m.Description,
                Unit:        m.Unit,
                DataPoints:  []dataPoint{},
            }
            
            // 根据类型处理数据点
            switch data := m.Data.(type) {
            case metricdata.Sum[int64]:
                for _, dp := range data.DataPoints {
                    md.DataPoints = append(md.DataPoints, dataPoint{
                        Attributes: attributesToMap(dp.Attributes),
                        Value:      dp.Value,
                        Timestamp:  dp.Time.Unix(),
                    })
                }
            case metricdata.Histogram[float64]:
                // 处理 Histogram
            // ... 其他类型
            }
            
            metrics = append(metrics, md)
        }
    }
    
    return json.Marshal(metrics)
}

func attributesToMap(attrs attribute.Set) map[string]string {
    m := make(map[string]string)
    for _, attr := range attrs.ToSlice() {
        m[string(attr.Key)] = attr.Value.AsString()
    }
    return m
}
```

### 2. 多导出器

```go
package exporter

// MultiExporter 多导出器
type MultiExporter struct {
    exporters []metric.Exporter
}

// NewMultiExporter 创建多导出器
func NewMultiExporter(exporters ...metric.Exporter) metric.Exporter {
    return &MultiExporter{
        exporters: exporters,
    }
}

// Export 导出到所有导出器
func (e *MultiExporter) Export(ctx context.Context, rm *metricdata.ResourceMetrics) error {
    var errs []error
    
    for _, exporter := range e.exporters {
        if err := exporter.Export(ctx, rm); err != nil {
            errs = append(errs, err)
        }
    }
    
    if len(errs) > 0 {
        return fmt.Errorf("multiple export errors: %v", errs)
    }
    
    return nil
}

// Temporality 返回第一个导出器的配置
func (e *MultiExporter) Temporality(ik metric.InstrumentKind) metricdata.Temporality {
    if len(e.exporters) > 0 {
        return e.exporters[0].Temporality(ik)
    }
    return metricdata.CumulativeTemporality
}

// Aggregation 返回第一个导出器的配置
func (e *MultiExporter) Aggregation(ik metric.InstrumentKind) metric.Aggregation {
    if len(e.exporters) > 0 {
        return e.exporters[0].Aggregation(ik)
    }
    return metric.AggregationDefault{}
}

// ForceFlush 刷新所有导出器
func (e *MultiExporter) ForceFlush(ctx context.Context) error {
    for _, exporter := range e.exporters {
        if err := exporter.ForceFlush(ctx); err != nil {
            return err
        }
    }
    return nil
}

// Shutdown 关闭所有导出器
func (e *MultiExporter) Shutdown(ctx context.Context) error {
    var errs []error
    
    for _, exporter := range e.exporters {
        if err := exporter.Shutdown(ctx); err != nil {
            errs = append(errs, err)
        }
    }
    
    if len(errs) > 0 {
        return fmt.Errorf("multiple shutdown errors: %v", errs)
    }
    
    return nil
}

// 使用示例
func main() {
    // 导出器 1: OTLP
    otlpExporter, _ := otlpmetricgrpc.New(context.Background())
    
    // 导出器 2: Prometheus
    promExporter, _ := prometheus.New()
    
    // 组合导出器
    multiExporter := NewMultiExporter(otlpExporter, promExporter)
    
    mp := metric.NewMeterProvider(
        metric.WithReader(metric.NewPeriodicReader(multiExporter)),
    )
}
```

### 3. 导出器装饰器

```go
package exporter

// LoggingExporter 日志装饰器
type LoggingExporter struct {
    next metric.Exporter
}

func NewLoggingExporter(next metric.Exporter) metric.Exporter {
    return &LoggingExporter{next: next}
}

func (e *LoggingExporter) Export(ctx context.Context, rm *metricdata.ResourceMetrics) error {
    // 统计指标数量
    var metricCount int
    for _, sm := range rm.ScopeMetrics {
        metricCount += len(sm.Metrics)
    }
    
    log.Printf("Exporting %d metrics", metricCount)
    
    start := time.Now()
    err := e.next.Export(ctx, rm)
    duration := time.Since(start)
    
    if err != nil {
        log.Printf("Export failed: %v (duration: %v)", err, duration)
    } else {
        log.Printf("Export successful (duration: %v)", duration)
    }
    
    return err
}

func (e *LoggingExporter) Temporality(ik metric.InstrumentKind) metricdata.Temporality {
    return e.next.Temporality(ik)
}

func (e *LoggingExporter) Aggregation(ik metric.InstrumentKind) metric.Aggregation {
    return e.next.Aggregation(ik)
}

func (e *LoggingExporter) ForceFlush(ctx context.Context) error {
    return e.next.ForceFlush(ctx)
}

func (e *LoggingExporter) Shutdown(ctx context.Context) error {
    return e.next.Shutdown(ctx)
}
```

---

## 错误处理

```go
// 1. 重试导出器
type RetryExporter struct {
    next       metric.Exporter
    maxRetries int
}

func (e *RetryExporter) Export(ctx context.Context, rm *metricdata.ResourceMetrics) error {
    var lastErr error
    
    for i := 0; i <= e.maxRetries; i++ {
        err := e.next.Export(ctx, rm)
        if err == nil {
            return nil
        }
        
        lastErr = err
        
        if i < e.maxRetries {
            backoff := time.Duration(1<<uint(i)) * time.Second
            log.Printf("Export failed, retrying in %v: %v", backoff, err)
            time.Sleep(backoff)
        }
    }
    
    return fmt.Errorf("export failed after %d retries: %w", e.maxRetries, lastErr)
}

// 2. 故障转移导出器
type FallbackExporter struct {
    primary  metric.Exporter
    fallback metric.Exporter
}

func (e *FallbackExporter) Export(ctx context.Context, rm *metricdata.ResourceMetrics) error {
    err := e.primary.Export(ctx, rm)
    if err == nil {
        return nil
    }
    
    log.Printf("Primary exporter failed: %v, using fallback", err)
    return e.fallback.Export(ctx, rm)
}
```

---

## 性能优化

```go
// 1. 使用连接池
exporter, _ := otlpmetricgrpc.New(
    context.Background(),
    otlpmetricgrpc.WithDialOption(
        grpc.WithDefaultServiceConfig(`{"loadBalancingPolicy":"round_robin"}`),
    ),
)

// 2. 启用压缩
exporter, _ := otlpmetricgrpc.New(
    context.Background(),
    otlpmetricgrpc.WithCompressor("gzip"),
)

// 3. 配置超时
exporter, _ := otlpmetricgrpc.New(
    context.Background(),
    otlpmetricgrpc.WithTimeout(30*time.Second),
)

// 4. 批处理配置（在 Reader 级别）
reader := metric.NewPeriodicReader(
    exporter,
    metric.WithInterval(30*time.Second), // 较长间隔 = 更大批次
)

// 5. 重用导出器
var globalExporter metric.Exporter

func init() {
    var err error
    globalExporter, err = otlpmetricgrpc.New(context.Background())
    if err != nil {
        log.Fatal(err)
    }
}
```

---

## 最佳实践

```go
// ✅ 正确: 生产环境使用 OTLP
exporter, _ := otlpmetricgrpc.New(
    context.Background(),
    otlpmetricgrpc.WithEndpoint("collector:4317"),
    otlpmetricgrpc.WithTLSCredentials(...),
)

// ✅ 正确: 配置重试
exporter, _ := otlpmetricgrpc.New(
    context.Background(),
    otlpmetricgrpc.WithRetry(otlpmetricgrpc.RetryConfig{
        Enabled:         true,
        InitialInterval: 5 * time.Second,
    }),
)

// ✅ 正确: 正确关闭
defer func() {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    if err := mp.Shutdown(ctx); err != nil {
        log.Printf("Error shutting down: %v", err)
    }
}()

// ✅ 正确: 使用环境变量配置
endpoint := os.Getenv("OTEL_EXPORTER_OTLP_ENDPOINT")
if endpoint == "" {
    endpoint = "localhost:4317"
}

exporter, _ := otlpmetricgrpc.New(
    context.Background(),
    otlpmetricgrpc.WithEndpoint(endpoint),
)
```

---

## 常见问题

**Q1: OTLP vs Prometheus？**

```text
OTLP (推荐):
✅ 优点:
  - 标准协议
  - Push 模式（主动导出）
  - gRPC/HTTP 双支持
  - 支持所有 OpenTelemetry 信号

❌ 缺点:
  - 需要 Collector

Prometheus:
✅ 优点:
  - 成熟生态
  - Pull 模式（服务发现）
  - 强大的查询语言

❌ 缺点:
  - 仅支持 Metrics
  - 需要暴露端点

推荐:
- 新项目: OTLP
- 已有 Prometheus: 两者并用
```

**Q2: gRPC vs HTTP？**

```text
参考 Tracer 的 SpanExporter 文档
```

---

## 参考资源

- [OpenTelemetry Metric Exporters](https://opentelemetry.io/docs/specs/otel/metrics/sdk/#metricexporter)
- [Go SDK Metric Exporter](https://pkg.go.dev/go.opentelemetry.io/otel/sdk/metric#Exporter)
- [01_Provider配置.md](./01_Provider配置.md)
- [04_聚合器.md](./04_聚合器.md)

---

**🎉 恭喜！你已经掌握了 MetricExporter 的完整知识！**

**🎊🎊🎊 Phase 4.2: Meter Provider 全部完成！🎊🎊🎊**-

现在你可以：

- ✅ 使用各种内置导出器
- ✅ 配置 OTLP gRPC/HTTP
- ✅ 集成 Prometheus (Push/Pull)
- ✅ 实现自定义导出器
- ✅ 处理错误和优化性能
