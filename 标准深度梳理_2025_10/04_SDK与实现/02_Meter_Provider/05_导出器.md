# MetricExporter å¯¼å‡ºå™¨

## ğŸ“‹ ç›®å½•

- [MetricExporter å¯¼å‡ºå™¨](#metricexporter-å¯¼å‡ºå™¨)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [ä»€ä¹ˆæ˜¯ MetricExporter](#ä»€ä¹ˆæ˜¯-metricexporter)
    - [å¯¼å‡ºæµç¨‹](#å¯¼å‡ºæµç¨‹)
  - [å†…ç½®å¯¼å‡ºå™¨](#å†…ç½®å¯¼å‡ºå™¨)
    - [1. OTLP Exporter](#1-otlp-exporter)
    - [2. Prometheus Exporter](#2-prometheus-exporter)
    - [3. Stdout Exporter](#3-stdout-exporter)
  - [OTLP é…ç½®](#otlp-é…ç½®)
    - [1. gRPC å¯¼å‡ºå™¨](#1-grpc-å¯¼å‡ºå™¨)
    - [2. HTTP å¯¼å‡ºå™¨](#2-http-å¯¼å‡ºå™¨)
    - [3. è®¤è¯é…ç½®](#3-è®¤è¯é…ç½®)
  - [Prometheus é›†æˆ](#prometheus-é›†æˆ)
    - [1. Push æ¨¡å¼](#1-push-æ¨¡å¼)
    - [2. Pull æ¨¡å¼](#2-pull-æ¨¡å¼)
    - [3. Remote Write](#3-remote-write)
  - [Go 1.25.1 å®ç°](#go-1251-å®ç°)
    - [1. è‡ªå®šä¹‰å¯¼å‡ºå™¨](#1-è‡ªå®šä¹‰å¯¼å‡ºå™¨)
    - [2. å¤šå¯¼å‡ºå™¨](#2-å¤šå¯¼å‡ºå™¨)
    - [3. å¯¼å‡ºå™¨è£…é¥°å™¨](#3-å¯¼å‡ºå™¨è£…é¥°å™¨)
  - [é”™è¯¯å¤„ç†](#é”™è¯¯å¤„ç†)
  - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)
  - [å‚è€ƒèµ„æº](#å‚è€ƒèµ„æº)

---

## æ¦‚è¿°

### ä»€ä¹ˆæ˜¯ MetricExporter

**MetricExporter** è´Ÿè´£å°†èšåˆåçš„æŒ‡æ ‡æ•°æ®å‘é€åˆ°åç«¯ç³»ç»Ÿï¼ˆå¦‚ Prometheusã€OpenTelemetry Collectorï¼‰ã€‚

```text
Reader
    â†“
MetricExporter.Export()
    â†“ (gRPC/HTTP/Pull)
Backend
  - Prometheus
  - OTLP Collector
  - Custom Backend
```

### å¯¼å‡ºæµç¨‹

```text
1. Reader å‘¨æœŸæ€§æ”¶é›†æŒ‡æ ‡
2. è°ƒç”¨ Exporter.Export(metrics)
3. Exporter åºåˆ—åŒ–å¹¶å‘é€
4. åç«¯æ¥æ”¶å’Œå­˜å‚¨
```

---

## å†…ç½®å¯¼å‡ºå™¨

### 1. OTLP Exporter

OpenTelemetry Protocol å¯¼å‡ºå™¨ï¼ˆæ¨èï¼‰ï¼š

```go
import (
    "context"
    "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
    "go.opentelemetry.io/otel/sdk/metric"
)

func main() {
    // åˆ›å»º OTLP gRPC å¯¼å‡ºå™¨
    exporter, err := otlpmetricgrpc.New(
        context.Background(),
        otlpmetricgrpc.WithEndpoint("localhost:4317"),
        otlpmetricgrpc.WithInsecure(),
    )
    if err != nil {
        log.Fatal(err)
    }
    
    // åˆ›å»º Reader
    reader := metric.NewPeriodicReader(exporter)
    
    // é…ç½® MeterProvider
    mp := metric.NewMeterProvider(
        metric.WithReader(reader),
    )
    defer mp.Shutdown(context.Background())
}
```

### 2. Prometheus Exporter

Prometheus Pull æ¨¡å¼å¯¼å‡ºå™¨ï¼š

```go
import (
    "net/http"
    "go.opentelemetry.io/otel/exporters/prometheus"
    "go.opentelemetry.io/otel/sdk/metric"
)

func main() {
    // åˆ›å»º Prometheus å¯¼å‡ºå™¨
    exporter, err := prometheus.New()
    if err != nil {
        log.Fatal(err)
    }
    
    // é…ç½® MeterProvider
    mp := metric.NewMeterProvider(
        metric.WithReader(exporter),
    )
    
    // å¯åŠ¨ HTTP æœåŠ¡å™¨æš´éœ²æŒ‡æ ‡
    http.Handle("/metrics", promhttp.Handler())
    go http.ListenAndServe(":9090", nil)
    
    defer mp.Shutdown(context.Background())
}
```

### 3. Stdout Exporter

æ ‡å‡†è¾“å‡ºå¯¼å‡ºå™¨ï¼ˆè°ƒè¯•ï¼‰ï¼š

```go
import (
    "go.opentelemetry.io/otel/exporters/stdout/stdoutmetric"
)

func main() {
    // åˆ›å»º Stdout å¯¼å‡ºå™¨
    exporter, err := stdoutmetric.New(
        stdoutmetric.WithPrettyPrint(),
    )
    if err != nil {
        log.Fatal(err)
    }
    
    reader := metric.NewPeriodicReader(exporter)
    
    mp := metric.NewMeterProvider(
        metric.WithReader(reader),
    )
    defer mp.Shutdown(context.Background())
}
```

---

## OTLP é…ç½®

### 1. gRPC å¯¼å‡ºå™¨

```go
import (
    "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
    "google.golang.org/grpc/credentials"
)

func NewOTLPgRPCExporter() (metric.Exporter, error) {
    return otlpmetricgrpc.New(
        context.Background(),
        
        // ç«¯ç‚¹é…ç½®
        otlpmetricgrpc.WithEndpoint("collector.example.com:4317"),
        
        // TLS é…ç½®
        otlpmetricgrpc.WithTLSCredentials(
            credentials.NewClientTLSFromCert(certPool, ""),
        ),
        
        // æˆ–ä¸ä½¿ç”¨ TLS
        // otlpmetricgrpc.WithInsecure(),
        
        // é‡è¯•é…ç½®
        otlpmetricgrpc.WithRetry(otlpmetricgrpc.RetryConfig{
            Enabled:         true,
            InitialInterval: 5 * time.Second,
            MaxInterval:     30 * time.Second,
            MaxElapsedTime:  time.Minute,
        }),
        
        // è¶…æ—¶é…ç½®
        otlpmetricgrpc.WithTimeout(30*time.Second),
        
        // å‹ç¼©
        otlpmetricgrpc.WithCompressor("gzip"),
        
        // HTTP å¤´
        otlpmetricgrpc.WithHeaders(map[string]string{
            "api-key": "your-api-key",
        }),
        
        // Temporality é…ç½®
        otlpmetricgrpc.WithTemporalitySelector(func(ik metric.InstrumentKind) metricdata.Temporality {
            return metricdata.CumulativeTemporality
        }),
    )
}
```

### 2. HTTP å¯¼å‡ºå™¨

```go
import (
    "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetrichttp"
)

func NewOTLPHTTPExporter() (metric.Exporter, error) {
    return otlpmetrichttp.New(
        context.Background(),
        
        // ç«¯ç‚¹é…ç½®
        otlpmetrichttp.WithEndpoint("collector.example.com:4318"),
        
        // URL è·¯å¾„
        otlpmetrichttp.WithURLPath("/v1/metrics"),
        
        // TLS é…ç½®
        otlpmetrichttp.WithTLSClientConfig(&tls.Config{
            InsecureSkipVerify: false,
        }),
        
        // æˆ–ä¸ä½¿ç”¨ TLS
        // otlpmetrichttp.WithInsecure(),
        
        // é‡è¯•é…ç½®
        otlpmetrichttp.WithRetry(otlpmetrichttp.RetryConfig{
            Enabled:         true,
            InitialInterval: 5 * time.Second,
            MaxInterval:     30 * time.Second,
            MaxElapsedTime:  time.Minute,
        }),
        
        // è¶…æ—¶
        otlpmetrichttp.WithTimeout(30*time.Second),
        
        // å‹ç¼©
        otlpmetrichttp.WithCompression(otlpmetrichttp.GzipCompression),
        
        // HTTP å¤´
        otlpmetrichttp.WithHeaders(map[string]string{
            "api-key": "your-api-key",
        }),
    )
}
```

### 3. è®¤è¯é…ç½®

```go
// 1. API Key è®¤è¯
exporter, _ := otlpmetricgrpc.New(
    context.Background(),
    otlpmetricgrpc.WithEndpoint("collector.example.com:4317"),
    otlpmetricgrpc.WithHeaders(map[string]string{
        "authorization": "Bearer YOUR_API_KEY",
    }),
)

// 2. mTLS è®¤è¯
cert, _ := tls.LoadX509KeyPair("client.crt", "client.key")
caCert, _ := os.ReadFile("ca.crt")
caCertPool := x509.NewCertPool()
caCertPool.AppendCertsFromPEM(caCert)

tlsConfig := &tls.Config{
    Certificates: []tls.Certificate{cert},
    RootCAs:      caCertPool,
}

exporter, _ := otlpmetricgrpc.New(
    context.Background(),
    otlpmetricgrpc.WithEndpoint("collector.example.com:4317"),
    otlpmetricgrpc.WithTLSCredentials(
        credentials.NewTLS(tlsConfig),
    ),
)

// 3. è‡ªå®šä¹‰è®¤è¯
type customAuthInterceptor struct{}

func (i *customAuthInterceptor) UnaryClientInterceptor(...) {
    // è‡ªå®šä¹‰è®¤è¯é€»è¾‘
}

exporter, _ := otlpmetricgrpc.New(
    context.Background(),
    otlpmetricgrpc.WithDialOption(
        grpc.WithUnaryInterceptor(interceptor),
    ),
)
```

---

## Prometheus é›†æˆ

### 1. Push æ¨¡å¼

ä½¿ç”¨ Pushgatewayï¼š

```go
import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/push"
)

func pushToPrometheus() error {
    // åˆ›å»º Pusher
    pusher := push.New("http://pushgateway:9091", "my-job").
        Grouping("instance", "my-instance")
    
    // æ·»åŠ æŒ‡æ ‡
    pusher.Collector(yourCollector)
    
    // æ¨é€
    if err := pusher.Push(); err != nil {
        return fmt.Errorf("failed to push metrics: %w", err)
    }
    
    return nil
}

// å‘¨æœŸæ€§æ¨é€
func startPushMetrics() {
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        if err := pushToPrometheus(); err != nil {
            log.Printf("Failed to push metrics: %v", err)
        }
    }
}
```

### 2. Pull æ¨¡å¼

æš´éœ² /metrics ç«¯ç‚¹ï¼š

```go
import (
    "net/http"
    "go.opentelemetry.io/otel/exporters/prometheus"
    "github.com/prometheus/client_golang/prometheus/promhttp"
)

func main() {
    // åˆ›å»º Prometheus å¯¼å‡ºå™¨
    exporter, err := prometheus.New()
    if err != nil {
        log.Fatal(err)
    }
    
    // é…ç½® MeterProvider
    mp := metric.NewMeterProvider(
        metric.WithReader(exporter),
    )
    
    // æš´éœ² /metrics ç«¯ç‚¹
    http.Handle("/metrics", promhttp.Handler())
    
    // å¯åŠ¨ HTTP æœåŠ¡å™¨
    log.Println("Serving metrics on :9090/metrics")
    if err := http.ListenAndServe(":9090", nil); err != nil {
        log.Fatal(err)
    }
}
```

### 3. Remote Write

ç›´æ¥å†™å…¥ Prometheusï¼š

```go
import (
    "github.com/prometheus/prometheus/prompb"
    "github.com/golang/snappy"
    "bytes"
    "net/http"
)

func remoteWrite(samples []prompb.TimeSeries) error {
    // åˆ›å»º WriteRequest
    req := &prompb.WriteRequest{
        Timeseries: samples,
    }
    
    // åºåˆ—åŒ–
    data, err := proto.Marshal(req)
    if err != nil {
        return err
    }
    
    // å‹ç¼©
    compressed := snappy.Encode(nil, data)
    
    // å‘é€
    httpReq, _ := http.NewRequest(
        "POST",
        "http://prometheus:9090/api/v1/write",
        bytes.NewReader(compressed),
    )
    httpReq.Header.Set("Content-Encoding", "snappy")
    httpReq.Header.Set("Content-Type", "application/x-protobuf")
    
    resp, err := http.DefaultClient.Do(httpReq)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("unexpected status: %d", resp.StatusCode)
    }
    
    return nil
}
```

---

## Go 1.25.1 å®ç°

### 1. è‡ªå®šä¹‰å¯¼å‡ºå™¨

```go
package exporter

import (
    "context"
    "go.opentelemetry.io/otel/sdk/metric"
    "go.opentelemetry.io/otel/sdk/metric/metricdata"
)

// CustomExporter è‡ªå®šä¹‰å¯¼å‡ºå™¨
type CustomExporter struct {
    endpoint string
    client   *http.Client
}

// NewCustomExporter åˆ›å»ºè‡ªå®šä¹‰å¯¼å‡ºå™¨
func NewCustomExporter(endpoint string) metric.Exporter {
    return &CustomExporter{
        endpoint: endpoint,
        client:   &http.Client{Timeout: 30 * time.Second},
    }
}

// Export å¯¼å‡ºæŒ‡æ ‡
func (e *CustomExporter) Export(ctx context.Context, rm *metricdata.ResourceMetrics) error {
    // 1. åºåˆ—åŒ–æŒ‡æ ‡
    data, err := e.serializeMetrics(rm)
    if err != nil {
        return fmt.Errorf("failed to serialize metrics: %w", err)
    }
    
    // 2. å‘é€åˆ°åç«¯
    req, err := http.NewRequestWithContext(ctx, "POST", e.endpoint, bytes.NewReader(data))
    if err != nil {
        return err
    }
    
    req.Header.Set("Content-Type", "application/json")
    
    resp, err := e.client.Do(req)
    if err != nil {
        return fmt.Errorf("failed to send metrics: %w", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
    }
    
    return nil
}

// Temporality è¿”å› Temporality é…ç½®
func (e *CustomExporter) Temporality(ik metric.InstrumentKind) metricdata.Temporality {
    return metricdata.CumulativeTemporality
}

// Aggregation è¿”å›èšåˆé…ç½®
func (e *CustomExporter) Aggregation(ik metric.InstrumentKind) metric.Aggregation {
    return metric.AggregationDefault{}
}

// ForceFlush å¼ºåˆ¶åˆ·æ–°
func (e *CustomExporter) ForceFlush(ctx context.Context) error {
    return nil
}

// Shutdown å…³é—­å¯¼å‡ºå™¨
func (e *CustomExporter) Shutdown(ctx context.Context) error {
    e.client.CloseIdleConnections()
    return nil
}

func (e *CustomExporter) serializeMetrics(rm *metricdata.ResourceMetrics) ([]byte, error) {
    // å®ç°åºåˆ—åŒ–é€»è¾‘
    type metricData struct {
        Name        string            `json:"name"`
        Description string            `json:"description"`
        Unit        string            `json:"unit"`
        DataPoints  []dataPoint       `json:"data_points"`
    }
    
    type dataPoint struct {
        Attributes map[string]string `json:"attributes"`
        Value      interface{}       `json:"value"`
        Timestamp  int64             `json:"timestamp"`
    }
    
    metrics := make([]metricData, 0)
    
    for _, sm := range rm.ScopeMetrics {
        for _, m := range sm.Metrics {
            md := metricData{
                Name:        m.Name,
                Description: m.Description,
                Unit:        m.Unit,
                DataPoints:  []dataPoint{},
            }
            
            // æ ¹æ®ç±»å‹å¤„ç†æ•°æ®ç‚¹
            switch data := m.Data.(type) {
            case metricdata.Sum[int64]:
                for _, dp := range data.DataPoints {
                    md.DataPoints = append(md.DataPoints, dataPoint{
                        Attributes: attributesToMap(dp.Attributes),
                        Value:      dp.Value,
                        Timestamp:  dp.Time.Unix(),
                    })
                }
            case metricdata.Histogram[float64]:
                // å¤„ç† Histogram
            // ... å…¶ä»–ç±»å‹
            }
            
            metrics = append(metrics, md)
        }
    }
    
    return json.Marshal(metrics)
}

func attributesToMap(attrs attribute.Set) map[string]string {
    m := make(map[string]string)
    for _, attr := range attrs.ToSlice() {
        m[string(attr.Key)] = attr.Value.AsString()
    }
    return m
}
```

### 2. å¤šå¯¼å‡ºå™¨

```go
package exporter

// MultiExporter å¤šå¯¼å‡ºå™¨
type MultiExporter struct {
    exporters []metric.Exporter
}

// NewMultiExporter åˆ›å»ºå¤šå¯¼å‡ºå™¨
func NewMultiExporter(exporters ...metric.Exporter) metric.Exporter {
    return &MultiExporter{
        exporters: exporters,
    }
}

// Export å¯¼å‡ºåˆ°æ‰€æœ‰å¯¼å‡ºå™¨
func (e *MultiExporter) Export(ctx context.Context, rm *metricdata.ResourceMetrics) error {
    var errs []error
    
    for _, exporter := range e.exporters {
        if err := exporter.Export(ctx, rm); err != nil {
            errs = append(errs, err)
        }
    }
    
    if len(errs) > 0 {
        return fmt.Errorf("multiple export errors: %v", errs)
    }
    
    return nil
}

// Temporality è¿”å›ç¬¬ä¸€ä¸ªå¯¼å‡ºå™¨çš„é…ç½®
func (e *MultiExporter) Temporality(ik metric.InstrumentKind) metricdata.Temporality {
    if len(e.exporters) > 0 {
        return e.exporters[0].Temporality(ik)
    }
    return metricdata.CumulativeTemporality
}

// Aggregation è¿”å›ç¬¬ä¸€ä¸ªå¯¼å‡ºå™¨çš„é…ç½®
func (e *MultiExporter) Aggregation(ik metric.InstrumentKind) metric.Aggregation {
    if len(e.exporters) > 0 {
        return e.exporters[0].Aggregation(ik)
    }
    return metric.AggregationDefault{}
}

// ForceFlush åˆ·æ–°æ‰€æœ‰å¯¼å‡ºå™¨
func (e *MultiExporter) ForceFlush(ctx context.Context) error {
    for _, exporter := range e.exporters {
        if err := exporter.ForceFlush(ctx); err != nil {
            return err
        }
    }
    return nil
}

// Shutdown å…³é—­æ‰€æœ‰å¯¼å‡ºå™¨
func (e *MultiExporter) Shutdown(ctx context.Context) error {
    var errs []error
    
    for _, exporter := range e.exporters {
        if err := exporter.Shutdown(ctx); err != nil {
            errs = append(errs, err)
        }
    }
    
    if len(errs) > 0 {
        return fmt.Errorf("multiple shutdown errors: %v", errs)
    }
    
    return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    // å¯¼å‡ºå™¨ 1: OTLP
    otlpExporter, _ := otlpmetricgrpc.New(context.Background())
    
    // å¯¼å‡ºå™¨ 2: Prometheus
    promExporter, _ := prometheus.New()
    
    // ç»„åˆå¯¼å‡ºå™¨
    multiExporter := NewMultiExporter(otlpExporter, promExporter)
    
    mp := metric.NewMeterProvider(
        metric.WithReader(metric.NewPeriodicReader(multiExporter)),
    )
}
```

### 3. å¯¼å‡ºå™¨è£…é¥°å™¨

```go
package exporter

// LoggingExporter æ—¥å¿—è£…é¥°å™¨
type LoggingExporter struct {
    next metric.Exporter
}

func NewLoggingExporter(next metric.Exporter) metric.Exporter {
    return &LoggingExporter{next: next}
}

func (e *LoggingExporter) Export(ctx context.Context, rm *metricdata.ResourceMetrics) error {
    // ç»Ÿè®¡æŒ‡æ ‡æ•°é‡
    var metricCount int
    for _, sm := range rm.ScopeMetrics {
        metricCount += len(sm.Metrics)
    }
    
    log.Printf("Exporting %d metrics", metricCount)
    
    start := time.Now()
    err := e.next.Export(ctx, rm)
    duration := time.Since(start)
    
    if err != nil {
        log.Printf("Export failed: %v (duration: %v)", err, duration)
    } else {
        log.Printf("Export successful (duration: %v)", duration)
    }
    
    return err
}

func (e *LoggingExporter) Temporality(ik metric.InstrumentKind) metricdata.Temporality {
    return e.next.Temporality(ik)
}

func (e *LoggingExporter) Aggregation(ik metric.InstrumentKind) metric.Aggregation {
    return e.next.Aggregation(ik)
}

func (e *LoggingExporter) ForceFlush(ctx context.Context) error {
    return e.next.ForceFlush(ctx)
}

func (e *LoggingExporter) Shutdown(ctx context.Context) error {
    return e.next.Shutdown(ctx)
}
```

---

## é”™è¯¯å¤„ç†

```go
// 1. é‡è¯•å¯¼å‡ºå™¨
type RetryExporter struct {
    next       metric.Exporter
    maxRetries int
}

func (e *RetryExporter) Export(ctx context.Context, rm *metricdata.ResourceMetrics) error {
    var lastErr error
    
    for i := 0; i <= e.maxRetries; i++ {
        err := e.next.Export(ctx, rm)
        if err == nil {
            return nil
        }
        
        lastErr = err
        
        if i < e.maxRetries {
            backoff := time.Duration(1<<uint(i)) * time.Second
            log.Printf("Export failed, retrying in %v: %v", backoff, err)
            time.Sleep(backoff)
        }
    }
    
    return fmt.Errorf("export failed after %d retries: %w", e.maxRetries, lastErr)
}

// 2. æ•…éšœè½¬ç§»å¯¼å‡ºå™¨
type FallbackExporter struct {
    primary  metric.Exporter
    fallback metric.Exporter
}

func (e *FallbackExporter) Export(ctx context.Context, rm *metricdata.ResourceMetrics) error {
    err := e.primary.Export(ctx, rm)
    if err == nil {
        return nil
    }
    
    log.Printf("Primary exporter failed: %v, using fallback", err)
    return e.fallback.Export(ctx, rm)
}
```

---

## æ€§èƒ½ä¼˜åŒ–

```go
// 1. ä½¿ç”¨è¿æ¥æ± 
exporter, _ := otlpmetricgrpc.New(
    context.Background(),
    otlpmetricgrpc.WithDialOption(
        grpc.WithDefaultServiceConfig(`{"loadBalancingPolicy":"round_robin"}`),
    ),
)

// 2. å¯ç”¨å‹ç¼©
exporter, _ := otlpmetricgrpc.New(
    context.Background(),
    otlpmetricgrpc.WithCompressor("gzip"),
)

// 3. é…ç½®è¶…æ—¶
exporter, _ := otlpmetricgrpc.New(
    context.Background(),
    otlpmetricgrpc.WithTimeout(30*time.Second),
)

// 4. æ‰¹å¤„ç†é…ç½®ï¼ˆåœ¨ Reader çº§åˆ«ï¼‰
reader := metric.NewPeriodicReader(
    exporter,
    metric.WithInterval(30*time.Second), // è¾ƒé•¿é—´éš” = æ›´å¤§æ‰¹æ¬¡
)

// 5. é‡ç”¨å¯¼å‡ºå™¨
var globalExporter metric.Exporter

func init() {
    var err error
    globalExporter, err = otlpmetricgrpc.New(context.Background())
    if err != nil {
        log.Fatal(err)
    }
}
```

---

## æœ€ä½³å®è·µ

```go
// âœ… æ­£ç¡®: ç”Ÿäº§ç¯å¢ƒä½¿ç”¨ OTLP
exporter, _ := otlpmetricgrpc.New(
    context.Background(),
    otlpmetricgrpc.WithEndpoint("collector:4317"),
    otlpmetricgrpc.WithTLSCredentials(...),
)

// âœ… æ­£ç¡®: é…ç½®é‡è¯•
exporter, _ := otlpmetricgrpc.New(
    context.Background(),
    otlpmetricgrpc.WithRetry(otlpmetricgrpc.RetryConfig{
        Enabled:         true,
        InitialInterval: 5 * time.Second,
    }),
)

// âœ… æ­£ç¡®: æ­£ç¡®å…³é—­
defer func() {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    if err := mp.Shutdown(ctx); err != nil {
        log.Printf("Error shutting down: %v", err)
    }
}()

// âœ… æ­£ç¡®: ä½¿ç”¨ç¯å¢ƒå˜é‡é…ç½®
endpoint := os.Getenv("OTEL_EXPORTER_OTLP_ENDPOINT")
if endpoint == "" {
    endpoint = "localhost:4317"
}

exporter, _ := otlpmetricgrpc.New(
    context.Background(),
    otlpmetricgrpc.WithEndpoint(endpoint),
)
```

---

## å¸¸è§é—®é¢˜

**Q1: OTLP vs Prometheusï¼Ÿ**

```text
OTLP (æ¨è):
âœ… ä¼˜ç‚¹:
  - æ ‡å‡†åè®®
  - Push æ¨¡å¼ï¼ˆä¸»åŠ¨å¯¼å‡ºï¼‰
  - gRPC/HTTP åŒæ”¯æŒ
  - æ”¯æŒæ‰€æœ‰ OpenTelemetry ä¿¡å·

âŒ ç¼ºç‚¹:
  - éœ€è¦ Collector

Prometheus:
âœ… ä¼˜ç‚¹:
  - æˆç†Ÿç”Ÿæ€
  - Pull æ¨¡å¼ï¼ˆæœåŠ¡å‘ç°ï¼‰
  - å¼ºå¤§çš„æŸ¥è¯¢è¯­è¨€

âŒ ç¼ºç‚¹:
  - ä»…æ”¯æŒ Metrics
  - éœ€è¦æš´éœ²ç«¯ç‚¹

æ¨è:
- æ–°é¡¹ç›®: OTLP
- å·²æœ‰ Prometheus: ä¸¤è€…å¹¶ç”¨
```

**Q2: gRPC vs HTTPï¼Ÿ**

```text
å‚è€ƒ Tracer çš„ SpanExporter æ–‡æ¡£
```

---

## å‚è€ƒèµ„æº

- [OpenTelemetry Metric Exporters](https://opentelemetry.io/docs/specs/otel/metrics/sdk/#metricexporter)
- [Go SDK Metric Exporter](https://pkg.go.dev/go.opentelemetry.io/otel/sdk/metric#Exporter)
- [01_Provideré…ç½®.md](./01_Provideré…ç½®.md)
- [04_èšåˆå™¨.md](./04_èšåˆå™¨.md)

---

**ğŸ‰ æ­å–œï¼ä½ å·²ç»æŒæ¡äº† MetricExporter çš„å®Œæ•´çŸ¥è¯†ï¼**

**ğŸŠğŸŠğŸŠ Phase 4.2: Meter Provider å…¨éƒ¨å®Œæˆï¼ğŸŠğŸŠğŸŠ**-

ç°åœ¨ä½ å¯ä»¥ï¼š

- âœ… ä½¿ç”¨å„ç§å†…ç½®å¯¼å‡ºå™¨
- âœ… é…ç½® OTLP gRPC/HTTP
- âœ… é›†æˆ Prometheus (Push/Pull)
- âœ… å®ç°è‡ªå®šä¹‰å¯¼å‡ºå™¨
- âœ… å¤„ç†é”™è¯¯å’Œä¼˜åŒ–æ€§èƒ½
