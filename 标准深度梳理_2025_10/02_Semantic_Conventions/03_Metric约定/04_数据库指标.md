# 数据库指标（Database Metrics）

## 目录

- [数据库指标（Database Metrics）](#数据库指标database-metrics)
  - [目录](#目录)
  - [1. 概述](#1-概述)
  - [2. 连接池指标](#2-连接池指标)
  - [3. 查询性能指标](#3-查询性能指标)
  - [4. 事务指标](#4-事务指标)
  - [5. Go 实现](#5-go-实现)
    - [5.1 database/sql 集成](#51-databasesql-集成)
    - [5.2 GORM 集成](#52-gorm-集成)
    - [5.3 sqlx 集成](#53-sqlx-集成)
  - [6. 完整示例](#6-完整示例)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 连接池配置](#71-连接池配置)
    - [7.2 慢查询检测](#72-慢查询检测)
    - [7.3 告警配置](#73-告警配置)
  - [8. 常见问题](#8-常见问题)
  - [总结](#总结)

---

## 1. 概述

数据库指标遵循 [OpenTelemetry Database Metrics Semantic Conventions](https://opentelemetry.io/docs/specs/semconv/database/database-metrics/)。

**核心指标**：
- 🔗 **连接池**：连接数、等待时间
- ⏱️ **查询性能**：执行时间、吞吐量
- 📊 **事务统计**：提交/回滚率
- 🚨 **错误监控**：超时、死锁

---

## 2. 连接池指标

**指标名称**：`db.client.connections.usage`

**描述**：数据库连接池使用情况

**单位**：`{connection}`

**指标类型**：UpDownCounter

**必需属性**：
- `db.client.connections.state`：连接状态
  - `idle`：空闲连接
  - `used`：使用中的连接
- `db.client.connections.pool.name`：连接池名称（可选）

**指标名称**：`db.client.connections.idle.max`

**描述**：最大空闲连接数

**单位**：`{connection}`

**指标类型**：UpDownCounter

**指标名称**：`db.client.connections.idle.min`

**描述**：最小空闲连接数

**单位**：`{connection}`

**指标类型**：UpDownCounter

**指标名称**：`db.client.connections.max`

**描述**：最大连接数

**单位**：`{connection}`

**指标类型**：UpDownCounter

**指标名称**：`db.client.connections.pending_requests`

**描述**：等待连接的请求数

**单位**：`{request}`

**指标类型**：UpDownCounter

**指标名称**：`db.client.connections.timeouts`

**描述**：连接超时次数

**单位**：`{timeout}`

**指标类型**：Counter

**指标名称**：`db.client.connections.create_time`

**描述**：创建连接耗时

**单位**：`s`

**指标类型**：Histogram

**指标名称**：`db.client.connections.wait_time`

**描述**：等待连接耗时

**单位**：`s`

**指标类型**：Histogram

**指标名称**：`db.client.connections.use_time`

**描述**：连接使用时长

**单位**：`s`

**指标类型**：Histogram

---

## 3. 查询性能指标

**指标名称**：`db.client.operations.duration`

**描述**：数据库操作执行时间

**单位**：`s`

**指标类型**：Histogram

**必需属性**：
- `db.system`：数据库类型（如 `postgresql`, `mysql`, `redis`）
- `db.operation`：操作类型（如 `SELECT`, `INSERT`, `UPDATE`, `DELETE`）

**可选属性**：
- `db.name`：数据库名称
- `db.sql.table`：表名
- `db.user`：数据库用户
- `server.address`：数据库服务器地址
- `server.port`：数据库服务器端口

**指标名称**：`db.client.operations.count`

**描述**：数据库操作次数

**单位**：`{operation}`

**指标类型**：Counter

**必需属性**：同上

**指标名称**：`db.client.rows_affected`

**描述**：受影响的行数

**单位**：`{row}`

**指标类型**：Histogram

---

## 4. 事务指标

**指标名称**：`db.client.transaction.duration`

**描述**：事务执行时间

**单位**：`s`

**指标类型**：Histogram

**必需属性**：
- `db.transaction.status`：事务状态
  - `commit`：提交
  - `rollback`：回滚

**指标名称**：`db.client.transaction.count`

**描述**：事务计数

**单位**：`{transaction}`

**指标类型**：Counter

**必需属性**：同上

---

## 5. Go 实现

### 5.1 database/sql 集成

```go
package dbmetrics

import (
    "context"
    "database/sql"
    "fmt"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// DBMetrics 数据库指标
type DBMetrics struct {
    meter                metric.Meter
    connUsage            metric.Int64ObservableUpDownCounter
    connMax              metric.Int64ObservableUpDownCounter
    connIdleMax          metric.Int64ObservableUpDownCounter
    connIdleMin          metric.Int64ObservableUpDownCounter
    connWaitCount        metric.Int64ObservableCounter
    connWaitDuration     metric.Float64ObservableCounter
    connCreateTime       metric.Float64Histogram
    connWaitTime         metric.Float64Histogram
    connUseTime          metric.Float64Histogram
    operationDuration    metric.Float64Histogram
    operationCount       metric.Int64Counter
    rowsAffected         metric.Int64Histogram
    transactionDuration  metric.Float64Histogram
    transactionCount     metric.Int64Counter
    
    db *sql.DB
}

// NewDBMetrics 创建数据库指标收集器
func NewDBMetrics(db *sql.DB, dbSystem string) (*DBMetrics, error) {
    meter := otel.Meter("db.client")
    
    dm := &DBMetrics{
        meter: meter,
        db:    db,
    }
    
    var err error
    
    // 连接池指标
    dm.connUsage, err = meter.Int64ObservableUpDownCounter(
        "db.client.connections.usage",
        metric.WithDescription("Database connections usage"),
        metric.WithUnit("{connection}"),
    )
    if err != nil {
        return nil, err
    }
    
    dm.connMax, err = meter.Int64ObservableUpDownCounter(
        "db.client.connections.max",
        metric.WithDescription("Maximum database connections"),
        metric.WithUnit("{connection}"),
    )
    if err != nil {
        return nil, err
    }
    
    dm.connIdleMax, err = meter.Int64ObservableUpDownCounter(
        "db.client.connections.idle.max",
        metric.WithDescription("Maximum idle connections"),
        metric.WithUnit("{connection}"),
    )
    if err != nil {
        return nil, err
    }
    
    dm.connWaitCount, err = meter.Int64ObservableCounter(
        "db.client.connections.wait_count",
        metric.WithDescription("Connection wait count"),
        metric.WithUnit("{wait}"),
    )
    if err != nil {
        return nil, err
    }
    
    dm.connWaitDuration, err = meter.Float64ObservableCounter(
        "db.client.connections.wait_duration",
        metric.WithDescription("Connection wait duration"),
        metric.WithUnit("s"),
    )
    if err != nil {
        return nil, err
    }
    
    // 查询性能指标
    dm.operationDuration, err = meter.Float64Histogram(
        "db.client.operations.duration",
        metric.WithDescription("Database operation duration"),
        metric.WithUnit("s"),
        metric.WithExplicitBucketBoundaries(
            0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0,
        ),
    )
    if err != nil {
        return nil, err
    }
    
    dm.operationCount, err = meter.Int64Counter(
        "db.client.operations.count",
        metric.WithDescription("Database operation count"),
        metric.WithUnit("{operation}"),
    )
    if err != nil {
        return nil, err
    }
    
    dm.rowsAffected, err = meter.Int64Histogram(
        "db.client.rows_affected",
        metric.WithDescription("Rows affected by operation"),
        metric.WithUnit("{row}"),
    )
    if err != nil {
        return nil, err
    }
    
    // 事务指标
    dm.transactionDuration, err = meter.Float64Histogram(
        "db.client.transaction.duration",
        metric.WithDescription("Transaction duration"),
        metric.WithUnit("s"),
    )
    if err != nil {
        return nil, err
    }
    
    dm.transactionCount, err = meter.Int64Counter(
        "db.client.transaction.count",
        metric.WithDescription("Transaction count"),
        metric.WithUnit("{transaction}"),
    )
    if err != nil {
        return nil, err
    }
    
    // 注册连接池指标回调
    if _, err := meter.RegisterCallback(dm.observeConnectionPool,
        dm.connUsage, dm.connMax, dm.connIdleMax, dm.connWaitCount, dm.connWaitDuration,
    ); err != nil {
        return nil, err
    }
    
    return dm, nil
}

// observeConnectionPool 观察连接池指标
func (dm *DBMetrics) observeConnectionPool(ctx context.Context, observer metric.Observer) error {
    stats := dm.db.Stats()
    
    // 连接使用情况
    observer.ObserveInt64(dm.connUsage, int64(stats.InUse),
        metric.WithAttributes(attribute.String("db.client.connections.state", "used")))
    observer.ObserveInt64(dm.connUsage, int64(stats.Idle),
        metric.WithAttributes(attribute.String("db.client.connections.state", "idle")))
    
    // 最大连接数
    observer.ObserveInt64(dm.connMax, int64(stats.MaxOpenConnections))
    
    // 最大空闲连接数
    observer.ObserveInt64(dm.connIdleMax, int64(stats.MaxIdleClosed))
    
    // 等待计数和时长
    observer.ObserveInt64(dm.connWaitCount, stats.WaitCount)
    observer.ObserveFloat64(dm.connWaitDuration, stats.WaitDuration.Seconds())
    
    return nil
}

// WrapQuery 包装查询以记录指标
func (dm *DBMetrics) WrapQuery(
    ctx context.Context,
    operation string,
    table string,
    fn func(context.Context) (sql.Result, error),
) (sql.Result, error) {
    start := time.Now()
    
    result, err := fn(ctx)
    
    duration := time.Since(start).Seconds()
    
    attrs := []attribute.KeyValue{
        attribute.String("db.operation", operation),
        attribute.String("db.sql.table", table),
    }
    
    // 记录执行时间
    dm.operationDuration.Record(ctx, duration, metric.WithAttributes(attrs...))
    
    // 记录操作次数
    dm.operationCount.Add(ctx, 1, metric.WithAttributes(attrs...))
    
    // 记录受影响的行数
    if result != nil && err == nil {
        if rowsAffected, err := result.RowsAffected(); err == nil {
            dm.rowsAffected.Record(ctx, rowsAffected, metric.WithAttributes(attrs...))
        }
    }
    
    return result, err
}

// WrapTransaction 包装事务以记录指标
func (dm *DBMetrics) WrapTransaction(
    ctx context.Context,
    fn func(context.Context, *sql.Tx) error,
) error {
    start := time.Now()
    
    tx, err := dm.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    
    status := "commit"
    err = fn(ctx, tx)
    
    if err != nil {
        tx.Rollback()
        status = "rollback"
    } else {
        err = tx.Commit()
    }
    
    duration := time.Since(start).Seconds()
    attrs := []attribute.KeyValue{
        attribute.String("db.transaction.status", status),
    }
    
    dm.transactionDuration.Record(ctx, duration, metric.WithAttributes(attrs...))
    dm.transactionCount.Add(ctx, 1, metric.WithAttributes(attrs...))
    
    return err
}
```

### 5.2 GORM 集成

```go
package gormmetrics

import (
    "context"
    "time"

    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
    "gorm.io/gorm"
)

// GORMMetrics GORM 指标插件
type GORMMetrics struct {
    metrics *DBMetrics
}

// NewGORMMetrics 创建 GORM 指标插件
func NewGORMMetrics(metrics *DBMetrics) *GORMMetrics {
    return &GORMMetrics{metrics: metrics}
}

// Name 插件名称
func (gm *GORMMetrics) Name() string {
    return "otel:metrics"
}

// Initialize 初始化插件
func (gm *GORMMetrics) Initialize(db *gorm.DB) error {
    // 注册回调
    db.Callback().Create().Before("gorm:create").Register("otel:metrics:before", gm.before)
    db.Callback().Create().After("gorm:create").Register("otel:metrics:after", gm.after)
    
    db.Callback().Query().Before("gorm:query").Register("otel:metrics:before", gm.before)
    db.Callback().Query().After("gorm:query").Register("otel:metrics:after", gm.after)
    
    db.Callback().Update().Before("gorm:update").Register("otel:metrics:before", gm.before)
    db.Callback().Update().After("gorm:update").Register("otel:metrics:after", gm.after)
    
    db.Callback().Delete().Before("gorm:delete").Register("otel:metrics:before", gm.before)
    db.Callback().Delete().After("gorm:delete").Register("otel:metrics:after", gm.after)
    
    return nil
}

func (gm *GORMMetrics) before(db *gorm.DB) {
    db.InstanceSet("otel:metrics:start_time", time.Now())
}

func (gm *GORMMetrics) after(db *gorm.DB) {
    start, ok := db.InstanceGet("otel:metrics:start_time")
    if !ok {
        return
    }
    
    duration := time.Since(start.(time.Now)).Seconds()
    
    operation := "unknown"
    switch {
    case db.Statement.Schema != nil:
        switch db.Statement.ReflectValue.Kind() {
        case reflect.Slice, reflect.Array:
            operation = "SELECT"
        default:
            if db.Statement.Changed() {
                operation = "UPDATE"
            } else {
                operation = "SELECT"
            }
        }
    }
    
    attrs := []attribute.KeyValue{
        attribute.String("db.operation", operation),
        attribute.String("db.sql.table", db.Statement.Table),
    }
    
    gm.metrics.operationDuration.Record(db.Statement.Context, duration,
        metric.WithAttributes(attrs...))
    gm.metrics.operationCount.Add(db.Statement.Context, 1,
        metric.WithAttributes(attrs...))
    
    if db.RowsAffected > 0 {
        gm.metrics.rowsAffected.Record(db.Statement.Context, db.RowsAffected,
            metric.WithAttributes(attrs...))
    }
}
```

### 5.3 sqlx 集成

```go
package sqlxmetrics

import (
    "context"
    "database/sql"
    "time"

    "github.com/jmoiron/sqlx"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// DB 包装 sqlx.DB
type DB struct {
    *sqlx.DB
    metrics *DBMetrics
}

// WrapDB 包装 sqlx.DB
func WrapDB(db *sqlx.DB, metrics *DBMetrics) *DB {
    return &DB{DB: db, metrics: metrics}
}

// QueryContext 包装 QueryContext
func (db *DB) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
    start := time.Now()
    rows, err := db.DB.QueryContext(ctx, query, args...)
    
    db.recordQuery(ctx, "SELECT", time.Since(start))
    return rows, err
}

// ExecContext 包装 ExecContext
func (db *DB) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
    start := time.Now()
    result, err := db.DB.ExecContext(ctx, query, args...)
    
    duration := time.Since(start)
    operation := "EXEC"
    
    db.recordExec(ctx, operation, duration, result)
    return result, err
}

func (db *DB) recordQuery(ctx context.Context, operation string, duration time.Duration) {
    attrs := []attribute.KeyValue{
        attribute.String("db.operation", operation),
    }
    
    db.metrics.operationDuration.Record(ctx, duration.Seconds(),
        metric.WithAttributes(attrs...))
    db.metrics.operationCount.Add(ctx, 1,
        metric.WithAttributes(attrs...))
}

func (db *DB) recordExec(ctx context.Context, operation string, duration time.Duration, result sql.Result) {
    attrs := []attribute.KeyValue{
        attribute.String("db.operation", operation),
    }
    
    db.metrics.operationDuration.Record(ctx, duration.Seconds(),
        metric.WithAttributes(attrs...))
    db.metrics.operationCount.Add(ctx, 1,
        metric.WithAttributes(attrs...))
    
    if result != nil {
        if rowsAffected, err := result.RowsAffected(); err == nil {
            db.metrics.rowsAffected.Record(ctx, rowsAffected,
                metric.WithAttributes(attrs...))
        }
    }
}
```

---

## 6. 完整示例

```go
package main

import (
    "context"
    "database/sql"
    "log"
    "time"

    _ "github.com/lib/pq"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
    "go.opentelemetry.io/otel/sdk/metric"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
)

func main() {
    ctx := context.Background()
    
    // 初始化 OpenTelemetry
    res, _ := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName("db-service"),
        ),
    )
    
    exporter, _ := otlpmetricgrpc.New(ctx,
        otlpmetricgrpc.WithInsecure(),
        otlpmetricgrpc.WithEndpoint("localhost:4317"),
    )
    
    provider := metric.NewMeterProvider(
        metric.WithResource(res),
        metric.WithReader(metric.NewPeriodicReader(exporter,
            metric.WithInterval(10*time.Second),
        )),
    )
    defer provider.Shutdown(ctx)
    otel.SetMeterProvider(provider)
    
    // 连接数据库
    db, err := sql.Open("postgres", "postgresql://user:pass@localhost/mydb?sslmode=disable")
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // 配置连接池
    db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(5)
    db.SetConnMaxLifetime(5 * time.Minute)
    
    // 创建指标
    metrics, _ := NewDBMetrics(db, "postgresql")
    
    // 执行查询
    _, err = metrics.WrapQuery(ctx, "SELECT", "users", func(ctx context.Context) (sql.Result, error) {
        return db.ExecContext(ctx, "SELECT * FROM users LIMIT 10")
    })
    if err != nil {
        log.Fatal(err)
    }
    
    // 执行事务
    err = metrics.WrapTransaction(ctx, func(ctx context.Context, tx *sql.Tx) error {
        _, err := tx.ExecContext(ctx, "INSERT INTO users (name) VALUES ($1)", "Alice")
        return err
    })
    if err != nil {
        log.Fatal(err)
    }
    
    log.Println("数据库操作完成")
    time.Sleep(15 * time.Second) // 等待指标导出
}
```

---

## 7. 最佳实践

### 7.1 连接池配置

```go
// 推荐配置
db.SetMaxOpenConns(25)              // 最大连接数
db.SetMaxIdleConns(5)               // 最大空闲连接
db.SetConnMaxLifetime(5 * time.Minute)  // 连接最大生命周期
db.SetConnMaxIdleTime(10 * time.Minute) // 空闲连接最大生命周期
```

### 7.2 慢查询检测

```go
const slowQueryThreshold = 1 * time.Second

func (dm *DBMetrics) detectSlowQuery(ctx context.Context, query string, duration time.Duration) {
    if duration > slowQueryThreshold {
        log.Printf("慢查询检测: %s (耗时 %v)", query, duration)
        // 发送告警...
    }
}
```

### 7.3 告警配置

```yaml
groups:
  - name: database_alerts
    rules:
      - alert: HighDBConnectionUsage
        expr: db_client_connections_usage{state="used"} / db_client_connections_max > 0.8
        for: 5m
        labels:
          severity: warning
      
      - alert: SlowDatabaseQuery
        expr: histogram_quantile(0.99, rate(db_client_operations_duration_bucket[5m])) > 1
        for: 5m
        labels:
          severity: warning
```

---

## 8. 常见问题

**Q1: 如何监控慢查询？**

A: 使用 `db.client.operations.duration` 的 P99 指标，或在查询包装器中添加慢查询日志。

**Q2: 连接池配置建议？**

A: `MaxOpenConns` = CPU 核心数 × 2 +  有效磁盘数，`MaxIdleConns` = `MaxOpenConns` / 5。

**Q3: 如何处理连接泄漏？**

A: 监控 `db.client.connections.usage{state="used"}` 的持续增长，结合 `pprof` 分析 goroutine 泄漏。

---

## 总结

本文档详细介绍了 OpenTelemetry 数据库指标的语义约定和 Go 1.25.1 实现方案，涵盖：

✅ **连接池指标**：连接数、等待时间  
✅ **查询性能**：执行时间、受影响行数  
✅ **事务指标**：提交/回滚统计  
✅ **Go 集成**：database/sql、GORM、sqlx  
✅ **最佳实践**：连接池配置、慢查询检测、告警  

**下一步**：
- 📖 阅读《自定义指标》学习业务指标
- 🔗 参考 [OpenTelemetry Database Metrics](https://opentelemetry.io/docs/specs/semconv/database/database-metrics/)

