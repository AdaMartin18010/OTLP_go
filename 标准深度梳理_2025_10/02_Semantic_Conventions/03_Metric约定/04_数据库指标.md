# æ•°æ®åº“æŒ‡æ ‡ï¼ˆDatabase Metricsï¼‰

## ç›®å½•

- [æ•°æ®åº“æŒ‡æ ‡ï¼ˆDatabase Metricsï¼‰](#æ•°æ®åº“æŒ‡æ ‡database-metrics)
  - [ç›®å½•](#ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. è¿æ¥æ± æŒ‡æ ‡](#2-è¿æ¥æ± æŒ‡æ ‡)
  - [3. æŸ¥è¯¢æ€§èƒ½æŒ‡æ ‡](#3-æŸ¥è¯¢æ€§èƒ½æŒ‡æ ‡)
  - [4. äº‹åŠ¡æŒ‡æ ‡](#4-äº‹åŠ¡æŒ‡æ ‡)
  - [5. Go å®ç°](#5-go-å®ç°)
    - [5.1 database/sql é›†æˆ](#51-databasesql-é›†æˆ)
    - [5.2 GORM é›†æˆ](#52-gorm-é›†æˆ)
    - [5.3 sqlx é›†æˆ](#53-sqlx-é›†æˆ)
  - [6. å®Œæ•´ç¤ºä¾‹](#6-å®Œæ•´ç¤ºä¾‹)
  - [7. æœ€ä½³å®è·µ](#7-æœ€ä½³å®è·µ)
    - [7.1 è¿æ¥æ± é…ç½®](#71-è¿æ¥æ± é…ç½®)
    - [7.2 æ…¢æŸ¥è¯¢æ£€æµ‹](#72-æ…¢æŸ¥è¯¢æ£€æµ‹)
    - [7.3 å‘Šè­¦é…ç½®](#73-å‘Šè­¦é…ç½®)
  - [8. å¸¸è§é—®é¢˜](#8-å¸¸è§é—®é¢˜)
  - [æ€»ç»“](#æ€»ç»“)

---

## 1. æ¦‚è¿°

æ•°æ®åº“æŒ‡æ ‡éµå¾ª [OpenTelemetry Database Metrics Semantic Conventions](https://opentelemetry.io/docs/specs/semconv/database/database-metrics/)ã€‚

**æ ¸å¿ƒæŒ‡æ ‡**ï¼š
- ğŸ”— **è¿æ¥æ± **ï¼šè¿æ¥æ•°ã€ç­‰å¾…æ—¶é—´
- â±ï¸ **æŸ¥è¯¢æ€§èƒ½**ï¼šæ‰§è¡Œæ—¶é—´ã€ååé‡
- ğŸ“Š **äº‹åŠ¡ç»Ÿè®¡**ï¼šæäº¤/å›æ»šç‡
- ğŸš¨ **é”™è¯¯ç›‘æ§**ï¼šè¶…æ—¶ã€æ­»é”

---

## 2. è¿æ¥æ± æŒ‡æ ‡

**æŒ‡æ ‡åç§°**ï¼š`db.client.connections.usage`

**æè¿°**ï¼šæ•°æ®åº“è¿æ¥æ± ä½¿ç”¨æƒ…å†µ

**å•ä½**ï¼š`{connection}`

**æŒ‡æ ‡ç±»å‹**ï¼šUpDownCounter

**å¿…éœ€å±æ€§**ï¼š
- `db.client.connections.state`ï¼šè¿æ¥çŠ¶æ€
  - `idle`ï¼šç©ºé—²è¿æ¥
  - `used`ï¼šä½¿ç”¨ä¸­çš„è¿æ¥
- `db.client.connections.pool.name`ï¼šè¿æ¥æ± åç§°ï¼ˆå¯é€‰ï¼‰

**æŒ‡æ ‡åç§°**ï¼š`db.client.connections.idle.max`

**æè¿°**ï¼šæœ€å¤§ç©ºé—²è¿æ¥æ•°

**å•ä½**ï¼š`{connection}`

**æŒ‡æ ‡ç±»å‹**ï¼šUpDownCounter

**æŒ‡æ ‡åç§°**ï¼š`db.client.connections.idle.min`

**æè¿°**ï¼šæœ€å°ç©ºé—²è¿æ¥æ•°

**å•ä½**ï¼š`{connection}`

**æŒ‡æ ‡ç±»å‹**ï¼šUpDownCounter

**æŒ‡æ ‡åç§°**ï¼š`db.client.connections.max`

**æè¿°**ï¼šæœ€å¤§è¿æ¥æ•°

**å•ä½**ï¼š`{connection}`

**æŒ‡æ ‡ç±»å‹**ï¼šUpDownCounter

**æŒ‡æ ‡åç§°**ï¼š`db.client.connections.pending_requests`

**æè¿°**ï¼šç­‰å¾…è¿æ¥çš„è¯·æ±‚æ•°

**å•ä½**ï¼š`{request}`

**æŒ‡æ ‡ç±»å‹**ï¼šUpDownCounter

**æŒ‡æ ‡åç§°**ï¼š`db.client.connections.timeouts`

**æè¿°**ï¼šè¿æ¥è¶…æ—¶æ¬¡æ•°

**å•ä½**ï¼š`{timeout}`

**æŒ‡æ ‡ç±»å‹**ï¼šCounter

**æŒ‡æ ‡åç§°**ï¼š`db.client.connections.create_time`

**æè¿°**ï¼šåˆ›å»ºè¿æ¥è€—æ—¶

**å•ä½**ï¼š`s`

**æŒ‡æ ‡ç±»å‹**ï¼šHistogram

**æŒ‡æ ‡åç§°**ï¼š`db.client.connections.wait_time`

**æè¿°**ï¼šç­‰å¾…è¿æ¥è€—æ—¶

**å•ä½**ï¼š`s`

**æŒ‡æ ‡ç±»å‹**ï¼šHistogram

**æŒ‡æ ‡åç§°**ï¼š`db.client.connections.use_time`

**æè¿°**ï¼šè¿æ¥ä½¿ç”¨æ—¶é•¿

**å•ä½**ï¼š`s`

**æŒ‡æ ‡ç±»å‹**ï¼šHistogram

---

## 3. æŸ¥è¯¢æ€§èƒ½æŒ‡æ ‡

**æŒ‡æ ‡åç§°**ï¼š`db.client.operations.duration`

**æè¿°**ï¼šæ•°æ®åº“æ“ä½œæ‰§è¡Œæ—¶é—´

**å•ä½**ï¼š`s`

**æŒ‡æ ‡ç±»å‹**ï¼šHistogram

**å¿…éœ€å±æ€§**ï¼š
- `db.system`ï¼šæ•°æ®åº“ç±»å‹ï¼ˆå¦‚ `postgresql`, `mysql`, `redis`ï¼‰
- `db.operation`ï¼šæ“ä½œç±»å‹ï¼ˆå¦‚ `SELECT`, `INSERT`, `UPDATE`, `DELETE`ï¼‰

**å¯é€‰å±æ€§**ï¼š
- `db.name`ï¼šæ•°æ®åº“åç§°
- `db.sql.table`ï¼šè¡¨å
- `db.user`ï¼šæ•°æ®åº“ç”¨æˆ·
- `server.address`ï¼šæ•°æ®åº“æœåŠ¡å™¨åœ°å€
- `server.port`ï¼šæ•°æ®åº“æœåŠ¡å™¨ç«¯å£

**æŒ‡æ ‡åç§°**ï¼š`db.client.operations.count`

**æè¿°**ï¼šæ•°æ®åº“æ“ä½œæ¬¡æ•°

**å•ä½**ï¼š`{operation}`

**æŒ‡æ ‡ç±»å‹**ï¼šCounter

**å¿…éœ€å±æ€§**ï¼šåŒä¸Š

**æŒ‡æ ‡åç§°**ï¼š`db.client.rows_affected`

**æè¿°**ï¼šå—å½±å“çš„è¡Œæ•°

**å•ä½**ï¼š`{row}`

**æŒ‡æ ‡ç±»å‹**ï¼šHistogram

---

## 4. äº‹åŠ¡æŒ‡æ ‡

**æŒ‡æ ‡åç§°**ï¼š`db.client.transaction.duration`

**æè¿°**ï¼šäº‹åŠ¡æ‰§è¡Œæ—¶é—´

**å•ä½**ï¼š`s`

**æŒ‡æ ‡ç±»å‹**ï¼šHistogram

**å¿…éœ€å±æ€§**ï¼š
- `db.transaction.status`ï¼šäº‹åŠ¡çŠ¶æ€
  - `commit`ï¼šæäº¤
  - `rollback`ï¼šå›æ»š

**æŒ‡æ ‡åç§°**ï¼š`db.client.transaction.count`

**æè¿°**ï¼šäº‹åŠ¡è®¡æ•°

**å•ä½**ï¼š`{transaction}`

**æŒ‡æ ‡ç±»å‹**ï¼šCounter

**å¿…éœ€å±æ€§**ï¼šåŒä¸Š

---

## 5. Go å®ç°

### 5.1 database/sql é›†æˆ

```go
package dbmetrics

import (
    "context"
    "database/sql"
    "fmt"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// DBMetrics æ•°æ®åº“æŒ‡æ ‡
type DBMetrics struct {
    meter                metric.Meter
    connUsage            metric.Int64ObservableUpDownCounter
    connMax              metric.Int64ObservableUpDownCounter
    connIdleMax          metric.Int64ObservableUpDownCounter
    connIdleMin          metric.Int64ObservableUpDownCounter
    connWaitCount        metric.Int64ObservableCounter
    connWaitDuration     metric.Float64ObservableCounter
    connCreateTime       metric.Float64Histogram
    connWaitTime         metric.Float64Histogram
    connUseTime          metric.Float64Histogram
    operationDuration    metric.Float64Histogram
    operationCount       metric.Int64Counter
    rowsAffected         metric.Int64Histogram
    transactionDuration  metric.Float64Histogram
    transactionCount     metric.Int64Counter
    
    db *sql.DB
}

// NewDBMetrics åˆ›å»ºæ•°æ®åº“æŒ‡æ ‡æ”¶é›†å™¨
func NewDBMetrics(db *sql.DB, dbSystem string) (*DBMetrics, error) {
    meter := otel.Meter("db.client")
    
    dm := &DBMetrics{
        meter: meter,
        db:    db,
    }
    
    var err error
    
    // è¿æ¥æ± æŒ‡æ ‡
    dm.connUsage, err = meter.Int64ObservableUpDownCounter(
        "db.client.connections.usage",
        metric.WithDescription("Database connections usage"),
        metric.WithUnit("{connection}"),
    )
    if err != nil {
        return nil, err
    }
    
    dm.connMax, err = meter.Int64ObservableUpDownCounter(
        "db.client.connections.max",
        metric.WithDescription("Maximum database connections"),
        metric.WithUnit("{connection}"),
    )
    if err != nil {
        return nil, err
    }
    
    dm.connIdleMax, err = meter.Int64ObservableUpDownCounter(
        "db.client.connections.idle.max",
        metric.WithDescription("Maximum idle connections"),
        metric.WithUnit("{connection}"),
    )
    if err != nil {
        return nil, err
    }
    
    dm.connWaitCount, err = meter.Int64ObservableCounter(
        "db.client.connections.wait_count",
        metric.WithDescription("Connection wait count"),
        metric.WithUnit("{wait}"),
    )
    if err != nil {
        return nil, err
    }
    
    dm.connWaitDuration, err = meter.Float64ObservableCounter(
        "db.client.connections.wait_duration",
        metric.WithDescription("Connection wait duration"),
        metric.WithUnit("s"),
    )
    if err != nil {
        return nil, err
    }
    
    // æŸ¥è¯¢æ€§èƒ½æŒ‡æ ‡
    dm.operationDuration, err = meter.Float64Histogram(
        "db.client.operations.duration",
        metric.WithDescription("Database operation duration"),
        metric.WithUnit("s"),
        metric.WithExplicitBucketBoundaries(
            0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0,
        ),
    )
    if err != nil {
        return nil, err
    }
    
    dm.operationCount, err = meter.Int64Counter(
        "db.client.operations.count",
        metric.WithDescription("Database operation count"),
        metric.WithUnit("{operation}"),
    )
    if err != nil {
        return nil, err
    }
    
    dm.rowsAffected, err = meter.Int64Histogram(
        "db.client.rows_affected",
        metric.WithDescription("Rows affected by operation"),
        metric.WithUnit("{row}"),
    )
    if err != nil {
        return nil, err
    }
    
    // äº‹åŠ¡æŒ‡æ ‡
    dm.transactionDuration, err = meter.Float64Histogram(
        "db.client.transaction.duration",
        metric.WithDescription("Transaction duration"),
        metric.WithUnit("s"),
    )
    if err != nil {
        return nil, err
    }
    
    dm.transactionCount, err = meter.Int64Counter(
        "db.client.transaction.count",
        metric.WithDescription("Transaction count"),
        metric.WithUnit("{transaction}"),
    )
    if err != nil {
        return nil, err
    }
    
    // æ³¨å†Œè¿æ¥æ± æŒ‡æ ‡å›è°ƒ
    if _, err := meter.RegisterCallback(dm.observeConnectionPool,
        dm.connUsage, dm.connMax, dm.connIdleMax, dm.connWaitCount, dm.connWaitDuration,
    ); err != nil {
        return nil, err
    }
    
    return dm, nil
}

// observeConnectionPool è§‚å¯Ÿè¿æ¥æ± æŒ‡æ ‡
func (dm *DBMetrics) observeConnectionPool(ctx context.Context, observer metric.Observer) error {
    stats := dm.db.Stats()
    
    // è¿æ¥ä½¿ç”¨æƒ…å†µ
    observer.ObserveInt64(dm.connUsage, int64(stats.InUse),
        metric.WithAttributes(attribute.String("db.client.connections.state", "used")))
    observer.ObserveInt64(dm.connUsage, int64(stats.Idle),
        metric.WithAttributes(attribute.String("db.client.connections.state", "idle")))
    
    // æœ€å¤§è¿æ¥æ•°
    observer.ObserveInt64(dm.connMax, int64(stats.MaxOpenConnections))
    
    // æœ€å¤§ç©ºé—²è¿æ¥æ•°
    observer.ObserveInt64(dm.connIdleMax, int64(stats.MaxIdleClosed))
    
    // ç­‰å¾…è®¡æ•°å’Œæ—¶é•¿
    observer.ObserveInt64(dm.connWaitCount, stats.WaitCount)
    observer.ObserveFloat64(dm.connWaitDuration, stats.WaitDuration.Seconds())
    
    return nil
}

// WrapQuery åŒ…è£…æŸ¥è¯¢ä»¥è®°å½•æŒ‡æ ‡
func (dm *DBMetrics) WrapQuery(
    ctx context.Context,
    operation string,
    table string,
    fn func(context.Context) (sql.Result, error),
) (sql.Result, error) {
    start := time.Now()
    
    result, err := fn(ctx)
    
    duration := time.Since(start).Seconds()
    
    attrs := []attribute.KeyValue{
        attribute.String("db.operation", operation),
        attribute.String("db.sql.table", table),
    }
    
    // è®°å½•æ‰§è¡Œæ—¶é—´
    dm.operationDuration.Record(ctx, duration, metric.WithAttributes(attrs...))
    
    // è®°å½•æ“ä½œæ¬¡æ•°
    dm.operationCount.Add(ctx, 1, metric.WithAttributes(attrs...))
    
    // è®°å½•å—å½±å“çš„è¡Œæ•°
    if result != nil && err == nil {
        if rowsAffected, err := result.RowsAffected(); err == nil {
            dm.rowsAffected.Record(ctx, rowsAffected, metric.WithAttributes(attrs...))
        }
    }
    
    return result, err
}

// WrapTransaction åŒ…è£…äº‹åŠ¡ä»¥è®°å½•æŒ‡æ ‡
func (dm *DBMetrics) WrapTransaction(
    ctx context.Context,
    fn func(context.Context, *sql.Tx) error,
) error {
    start := time.Now()
    
    tx, err := dm.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    
    status := "commit"
    err = fn(ctx, tx)
    
    if err != nil {
        tx.Rollback()
        status = "rollback"
    } else {
        err = tx.Commit()
    }
    
    duration := time.Since(start).Seconds()
    attrs := []attribute.KeyValue{
        attribute.String("db.transaction.status", status),
    }
    
    dm.transactionDuration.Record(ctx, duration, metric.WithAttributes(attrs...))
    dm.transactionCount.Add(ctx, 1, metric.WithAttributes(attrs...))
    
    return err
}
```

### 5.2 GORM é›†æˆ

```go
package gormmetrics

import (
    "context"
    "time"

    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
    "gorm.io/gorm"
)

// GORMMetrics GORM æŒ‡æ ‡æ’ä»¶
type GORMMetrics struct {
    metrics *DBMetrics
}

// NewGORMMetrics åˆ›å»º GORM æŒ‡æ ‡æ’ä»¶
func NewGORMMetrics(metrics *DBMetrics) *GORMMetrics {
    return &GORMMetrics{metrics: metrics}
}

// Name æ’ä»¶åç§°
func (gm *GORMMetrics) Name() string {
    return "otel:metrics"
}

// Initialize åˆå§‹åŒ–æ’ä»¶
func (gm *GORMMetrics) Initialize(db *gorm.DB) error {
    // æ³¨å†Œå›è°ƒ
    db.Callback().Create().Before("gorm:create").Register("otel:metrics:before", gm.before)
    db.Callback().Create().After("gorm:create").Register("otel:metrics:after", gm.after)
    
    db.Callback().Query().Before("gorm:query").Register("otel:metrics:before", gm.before)
    db.Callback().Query().After("gorm:query").Register("otel:metrics:after", gm.after)
    
    db.Callback().Update().Before("gorm:update").Register("otel:metrics:before", gm.before)
    db.Callback().Update().After("gorm:update").Register("otel:metrics:after", gm.after)
    
    db.Callback().Delete().Before("gorm:delete").Register("otel:metrics:before", gm.before)
    db.Callback().Delete().After("gorm:delete").Register("otel:metrics:after", gm.after)
    
    return nil
}

func (gm *GORMMetrics) before(db *gorm.DB) {
    db.InstanceSet("otel:metrics:start_time", time.Now())
}

func (gm *GORMMetrics) after(db *gorm.DB) {
    start, ok := db.InstanceGet("otel:metrics:start_time")
    if !ok {
        return
    }
    
    duration := time.Since(start.(time.Now)).Seconds()
    
    operation := "unknown"
    switch {
    case db.Statement.Schema != nil:
        switch db.Statement.ReflectValue.Kind() {
        case reflect.Slice, reflect.Array:
            operation = "SELECT"
        default:
            if db.Statement.Changed() {
                operation = "UPDATE"
            } else {
                operation = "SELECT"
            }
        }
    }
    
    attrs := []attribute.KeyValue{
        attribute.String("db.operation", operation),
        attribute.String("db.sql.table", db.Statement.Table),
    }
    
    gm.metrics.operationDuration.Record(db.Statement.Context, duration,
        metric.WithAttributes(attrs...))
    gm.metrics.operationCount.Add(db.Statement.Context, 1,
        metric.WithAttributes(attrs...))
    
    if db.RowsAffected > 0 {
        gm.metrics.rowsAffected.Record(db.Statement.Context, db.RowsAffected,
            metric.WithAttributes(attrs...))
    }
}
```

### 5.3 sqlx é›†æˆ

```go
package sqlxmetrics

import (
    "context"
    "database/sql"
    "time"

    "github.com/jmoiron/sqlx"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// DB åŒ…è£… sqlx.DB
type DB struct {
    *sqlx.DB
    metrics *DBMetrics
}

// WrapDB åŒ…è£… sqlx.DB
func WrapDB(db *sqlx.DB, metrics *DBMetrics) *DB {
    return &DB{DB: db, metrics: metrics}
}

// QueryContext åŒ…è£… QueryContext
func (db *DB) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
    start := time.Now()
    rows, err := db.DB.QueryContext(ctx, query, args...)
    
    db.recordQuery(ctx, "SELECT", time.Since(start))
    return rows, err
}

// ExecContext åŒ…è£… ExecContext
func (db *DB) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
    start := time.Now()
    result, err := db.DB.ExecContext(ctx, query, args...)
    
    duration := time.Since(start)
    operation := "EXEC"
    
    db.recordExec(ctx, operation, duration, result)
    return result, err
}

func (db *DB) recordQuery(ctx context.Context, operation string, duration time.Duration) {
    attrs := []attribute.KeyValue{
        attribute.String("db.operation", operation),
    }
    
    db.metrics.operationDuration.Record(ctx, duration.Seconds(),
        metric.WithAttributes(attrs...))
    db.metrics.operationCount.Add(ctx, 1,
        metric.WithAttributes(attrs...))
}

func (db *DB) recordExec(ctx context.Context, operation string, duration time.Duration, result sql.Result) {
    attrs := []attribute.KeyValue{
        attribute.String("db.operation", operation),
    }
    
    db.metrics.operationDuration.Record(ctx, duration.Seconds(),
        metric.WithAttributes(attrs...))
    db.metrics.operationCount.Add(ctx, 1,
        metric.WithAttributes(attrs...))
    
    if result != nil {
        if rowsAffected, err := result.RowsAffected(); err == nil {
            db.metrics.rowsAffected.Record(ctx, rowsAffected,
                metric.WithAttributes(attrs...))
        }
    }
}
```

---

## 6. å®Œæ•´ç¤ºä¾‹

```go
package main

import (
    "context"
    "database/sql"
    "log"
    "time"

    _ "github.com/lib/pq"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
    "go.opentelemetry.io/otel/sdk/metric"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
)

func main() {
    ctx := context.Background()
    
    // åˆå§‹åŒ– OpenTelemetry
    res, _ := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName("db-service"),
        ),
    )
    
    exporter, _ := otlpmetricgrpc.New(ctx,
        otlpmetricgrpc.WithInsecure(),
        otlpmetricgrpc.WithEndpoint("localhost:4317"),
    )
    
    provider := metric.NewMeterProvider(
        metric.WithResource(res),
        metric.WithReader(metric.NewPeriodicReader(exporter,
            metric.WithInterval(10*time.Second),
        )),
    )
    defer provider.Shutdown(ctx)
    otel.SetMeterProvider(provider)
    
    // è¿æ¥æ•°æ®åº“
    db, err := sql.Open("postgres", "postgresql://user:pass@localhost/mydb?sslmode=disable")
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // é…ç½®è¿æ¥æ± 
    db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(5)
    db.SetConnMaxLifetime(5 * time.Minute)
    
    // åˆ›å»ºæŒ‡æ ‡
    metrics, _ := NewDBMetrics(db, "postgresql")
    
    // æ‰§è¡ŒæŸ¥è¯¢
    _, err = metrics.WrapQuery(ctx, "SELECT", "users", func(ctx context.Context) (sql.Result, error) {
        return db.ExecContext(ctx, "SELECT * FROM users LIMIT 10")
    })
    if err != nil {
        log.Fatal(err)
    }
    
    // æ‰§è¡Œäº‹åŠ¡
    err = metrics.WrapTransaction(ctx, func(ctx context.Context, tx *sql.Tx) error {
        _, err := tx.ExecContext(ctx, "INSERT INTO users (name) VALUES ($1)", "Alice")
        return err
    })
    if err != nil {
        log.Fatal(err)
    }
    
    log.Println("æ•°æ®åº“æ“ä½œå®Œæˆ")
    time.Sleep(15 * time.Second) // ç­‰å¾…æŒ‡æ ‡å¯¼å‡º
}
```

---

## 7. æœ€ä½³å®è·µ

### 7.1 è¿æ¥æ± é…ç½®

```go
// æ¨èé…ç½®
db.SetMaxOpenConns(25)              // æœ€å¤§è¿æ¥æ•°
db.SetMaxIdleConns(5)               // æœ€å¤§ç©ºé—²è¿æ¥
db.SetConnMaxLifetime(5 * time.Minute)  // è¿æ¥æœ€å¤§ç”Ÿå‘½å‘¨æœŸ
db.SetConnMaxIdleTime(10 * time.Minute) // ç©ºé—²è¿æ¥æœ€å¤§ç”Ÿå‘½å‘¨æœŸ
```

### 7.2 æ…¢æŸ¥è¯¢æ£€æµ‹

```go
const slowQueryThreshold = 1 * time.Second

func (dm *DBMetrics) detectSlowQuery(ctx context.Context, query string, duration time.Duration) {
    if duration > slowQueryThreshold {
        log.Printf("æ…¢æŸ¥è¯¢æ£€æµ‹: %s (è€—æ—¶ %v)", query, duration)
        // å‘é€å‘Šè­¦...
    }
}
```

### 7.3 å‘Šè­¦é…ç½®

```yaml
groups:
  - name: database_alerts
    rules:
      - alert: HighDBConnectionUsage
        expr: db_client_connections_usage{state="used"} / db_client_connections_max > 0.8
        for: 5m
        labels:
          severity: warning
      
      - alert: SlowDatabaseQuery
        expr: histogram_quantile(0.99, rate(db_client_operations_duration_bucket[5m])) > 1
        for: 5m
        labels:
          severity: warning
```

---

## 8. å¸¸è§é—®é¢˜

**Q1: å¦‚ä½•ç›‘æ§æ…¢æŸ¥è¯¢ï¼Ÿ**

A: ä½¿ç”¨ `db.client.operations.duration` çš„ P99 æŒ‡æ ‡ï¼Œæˆ–åœ¨æŸ¥è¯¢åŒ…è£…å™¨ä¸­æ·»åŠ æ…¢æŸ¥è¯¢æ—¥å¿—ã€‚

**Q2: è¿æ¥æ± é…ç½®å»ºè®®ï¼Ÿ**

A: `MaxOpenConns` = CPU æ ¸å¿ƒæ•° Ã— 2 +  æœ‰æ•ˆç£ç›˜æ•°ï¼Œ`MaxIdleConns` = `MaxOpenConns` / 5ã€‚

**Q3: å¦‚ä½•å¤„ç†è¿æ¥æ³„æ¼ï¼Ÿ**

A: ç›‘æ§ `db.client.connections.usage{state="used"}` çš„æŒç»­å¢é•¿ï¼Œç»“åˆ `pprof` åˆ†æ goroutine æ³„æ¼ã€‚

---

## æ€»ç»“

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº† OpenTelemetry æ•°æ®åº“æŒ‡æ ‡çš„è¯­ä¹‰çº¦å®šå’Œ Go 1.25.1 å®ç°æ–¹æ¡ˆï¼Œæ¶µç›–ï¼š

âœ… **è¿æ¥æ± æŒ‡æ ‡**ï¼šè¿æ¥æ•°ã€ç­‰å¾…æ—¶é—´  
âœ… **æŸ¥è¯¢æ€§èƒ½**ï¼šæ‰§è¡Œæ—¶é—´ã€å—å½±å“è¡Œæ•°  
âœ… **äº‹åŠ¡æŒ‡æ ‡**ï¼šæäº¤/å›æ»šç»Ÿè®¡  
âœ… **Go é›†æˆ**ï¼šdatabase/sqlã€GORMã€sqlx  
âœ… **æœ€ä½³å®è·µ**ï¼šè¿æ¥æ± é…ç½®ã€æ…¢æŸ¥è¯¢æ£€æµ‹ã€å‘Šè­¦  

**ä¸‹ä¸€æ­¥**ï¼š
- ğŸ“– é˜…è¯»ã€Šè‡ªå®šä¹‰æŒ‡æ ‡ã€‹å­¦ä¹ ä¸šåŠ¡æŒ‡æ ‡
- ğŸ”— å‚è€ƒ [OpenTelemetry Database Metrics](https://opentelemetry.io/docs/specs/semconv/database/database-metrics/)

