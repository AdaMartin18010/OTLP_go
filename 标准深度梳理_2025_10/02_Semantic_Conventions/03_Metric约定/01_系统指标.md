# 系统指标（System Metrics）

## 目录

- [系统指标（System Metrics）](#系统指标system-metrics)
  - [目录](#目录)
  - [1. 概述](#1-概述)
  - [2. CPU 指标](#2-cpu-指标)
    - [2.1 CPU 使用率](#21-cpu-使用率)
    - [2.2 CPU 时间](#22-cpu-时间)
    - [2.3 负载平均值](#23-负载平均值)
    - [2.4 CPU 核心数](#24-cpu-核心数)
    - [2.5 Go 实现](#25-go-实现)
  - [3. 内存指标](#3-内存指标)
    - [3.1 内存使用量](#31-内存使用量)
    - [3.2 内存利用率](#32-内存利用率)
    - [3.3 交换空间](#33-交换空间)
    - [3.4 Go 实现](#34-go-实现)
  - [4. 磁盘指标](#4-磁盘指标)
    - [4.1 磁盘 I/O](#41-磁盘-io)
    - [4.2 磁盘空间](#42-磁盘空间)
    - [4.3 磁盘延迟](#43-磁盘延迟)
    - [4.4 Go 实现](#44-go-实现)
  - [5. 网络指标](#5-网络指标)
    - [5.1 网络流量](#51-网络流量)
    - [5.2 网络连接](#52-网络连接)
    - [5.3 网络错误](#53-网络错误)
    - [5.4 Go 实现](#54-go-实现)
  - [6. 完整示例](#6-完整示例)
    - [6.1 系统监控器](#61-系统监控器)
    - [6.2 跨平台兼容性](#62-跨平台兼容性)
    - [6.3 容器环境](#63-容器环境)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 采集频率](#71-采集频率)
    - [7.2 指标聚合](#72-指标聚合)
    - [7.3 告警阈值](#73-告警阈值)
    - [7.4 性能优化](#74-性能优化)
  - [8. 常见问题](#8-常见问题)
  - [总结](#总结)

---

## 1. 概述

系统指标是监控系统健康状态的基础，包括 CPU、内存、磁盘、网络等关键资源的使用情况。
本文档遵循 OpenTelemetry Semantic Conventions，提供标准化的系统指标定义和 Go 1.25.1 实现方案。

**核心价值**：

- 🎯 **资源监控**：实时掌握系统资源使用情况
- 📊 **容量规划**：为容量规划提供数据支持
- 🚨 **异常告警**：及时发现资源瓶颈和异常
- 📈 **趋势分析**：分析资源使用趋势

**参考规范**：

- [OpenTelemetry Semantic Conventions - System Metrics](https://opentelemetry.io/docs/specs/semconv/system/system-metrics/)
- [Prometheus Naming Conventions](https://prometheus.io/docs/practices/naming/)

---

## 2. CPU 指标

### 2.1 CPU 使用率

**指标名称**：`system.cpu.utilization`

**描述**：CPU 使用率的比例（0.0 到 1.0）

**单位**：`1`（比例）

**指标类型**：Gauge

**必需属性**：

- `cpu`：CPU 核心编号（如 `"0"`, `"1"`, ...）
- `state`：CPU 状态
  - `"user"`：用户态
  - `"system"`：内核态
  - `"idle"`：空闲
  - `"iowait"`：等待 I/O
  - `"interrupt"`：中断处理
  - `"steal"`：虚拟化环境中被其他虚拟机占用

**示例**：

```text
system.cpu.utilization{cpu="0",state="user"} = 0.45
system.cpu.utilization{cpu="0",state="system"} = 0.15
system.cpu.utilization{cpu="0",state="idle"} = 0.40
```

### 2.2 CPU 时间

**指标名称**：`system.cpu.time`

**描述**：CPU 各状态累计时间

**单位**：`s`（秒）

**指标类型**：Counter

**必需属性**：

- `cpu`：CPU 核心编号
- `state`：CPU 状态（同上）

**示例**：

```text
system.cpu.time{cpu="0",state="user"} = 3600.5
system.cpu.time{cpu="0",state="system"} = 1200.3
```

### 2.3 负载平均值

**指标名称**：`system.cpu.load_average.1m` / `system.cpu.load_average.5m` / `system.cpu.load_average.15m`

**描述**：系统负载平均值（1 分钟、5 分钟、15 分钟）

**单位**：`1`

**指标类型**：Gauge

**示例**：

```text
system.cpu.load_average.1m = 2.5
system.cpu.load_average.5m = 1.8
system.cpu.load_average.15m = 1.2
```

### 2.4 CPU 核心数

**指标名称**：`system.cpu.logical.count`

**描述**：逻辑 CPU 核心数

**单位**：`{cpu}`

**指标类型**：UpDownCounter

### 2.5 Go 实现

```go
package systemmetrics

import (
    "context"
    "fmt"
    "runtime"
    "time"

    "github.com/shirou/gopsutil/v3/cpu"
    "github.com/shirou/gopsutil/v3/load"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// CPUMetrics 管理 CPU 指标
type CPUMetrics struct {
    meter          metric.Meter
    utilization    metric.Float64ObservableGauge
    time           metric.Float64ObservableCounter
    loadAvg1m      metric.Float64ObservableGauge
    loadAvg5m      metric.Float64ObservableGauge
    loadAvg15m     metric.Float64ObservableGauge
    logicalCount   metric.Int64ObservableUpDownCounter
}

// NewCPUMetrics 创建 CPU 指标收集器
func NewCPUMetrics() (*CPUMetrics, error) {
    meter := otel.Meter("system.cpu")
    
    cm := &CPUMetrics{
        meter: meter,
    }
    
    var err error
    
    // CPU 使用率
    cm.utilization, err = meter.Float64ObservableGauge(
        "system.cpu.utilization",
        metric.WithDescription("CPU utilization"),
        metric.WithUnit("1"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 CPU 使用率指标失败: %w", err)
    }
    
    // CPU 时间
    cm.time, err = meter.Float64ObservableCounter(
        "system.cpu.time",
        metric.WithDescription("CPU time"),
        metric.WithUnit("s"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 CPU 时间指标失败: %w", err)
    }
    
    // 负载平均值
    cm.loadAvg1m, err = meter.Float64ObservableGauge(
        "system.cpu.load_average.1m",
        metric.WithDescription("CPU load average 1m"),
        metric.WithUnit("1"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建负载平均值指标失败: %w", err)
    }
    
    cm.loadAvg5m, err = meter.Float64ObservableGauge(
        "system.cpu.load_average.5m",
        metric.WithDescription("CPU load average 5m"),
        metric.WithUnit("1"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建负载平均值指标失败: %w", err)
    }
    
    cm.loadAvg15m, err = meter.Float64ObservableGauge(
        "system.cpu.load_average.15m",
        metric.WithDescription("CPU load average 15m"),
        metric.WithUnit("1"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建负载平均值指标失败: %w", err)
    }
    
    // 逻辑核心数
    cm.logicalCount, err = meter.Int64ObservableUpDownCounter(
        "system.cpu.logical.count",
        metric.WithDescription("Number of logical CPU cores"),
        metric.WithUnit("{cpu}"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 CPU 核心数指标失败: %w", err)
    }
    
    // 注册回调
    if _, err := meter.RegisterCallback(cm.observeCPU,
        cm.utilization,
        cm.time,
        cm.loadAvg1m,
        cm.loadAvg5m,
        cm.loadAvg15m,
        cm.logicalCount,
    ); err != nil {
        return nil, fmt.Errorf("注册 CPU 指标回调失败: %w", err)
    }
    
    return cm, nil
}

// observeCPU 观察 CPU 指标
func (cm *CPUMetrics) observeCPU(ctx context.Context, observer metric.Observer) error {
    // CPU 使用率和时间
    percentages, err := cpu.PercentWithContext(ctx, 0, true)
    if err != nil {
        return fmt.Errorf("获取 CPU 使用率失败: %w", err)
    }
    
    times, err := cpu.TimesWithContext(ctx, true)
    if err != nil {
        return fmt.Errorf("获取 CPU 时间失败: %w", err)
    }
    
    for i, pct := range percentages {
        cpuAttr := attribute.String("cpu", fmt.Sprintf("%d", i))
        
        // 使用率（简化版，实际应按状态分类）
        observer.ObserveFloat64(cm.utilization, pct/100.0,
            metric.WithAttributes(
                cpuAttr,
                attribute.String("state", "used"),
            ),
        )
        
        // 时间
        if i < len(times) {
            t := times[i]
            observer.ObserveFloat64(cm.time, t.User,
                metric.WithAttributes(cpuAttr, attribute.String("state", "user")))
            observer.ObserveFloat64(cm.time, t.System,
                metric.WithAttributes(cpuAttr, attribute.String("state", "system")))
            observer.ObserveFloat64(cm.time, t.Idle,
                metric.WithAttributes(cpuAttr, attribute.String("state", "idle")))
            observer.ObserveFloat64(cm.time, t.Iowait,
                metric.WithAttributes(cpuAttr, attribute.String("state", "iowait")))
            observer.ObserveFloat64(cm.time, t.Irq,
                metric.WithAttributes(cpuAttr, attribute.String("state", "interrupt")))
            observer.ObserveFloat64(cm.time, t.Steal,
                metric.WithAttributes(cpuAttr, attribute.String("state", "steal")))
        }
    }
    
    // 负载平均值（Linux/Unix）
    if loadInfo, err := load.AvgWithContext(ctx); err == nil {
        observer.ObserveFloat64(cm.loadAvg1m, loadInfo.Load1)
        observer.ObserveFloat64(cm.loadAvg5m, loadInfo.Load5)
        observer.ObserveFloat64(cm.loadAvg15m, loadInfo.Load15)
    }
    
    // CPU 核心数
    observer.ObserveInt64(cm.logicalCount, int64(runtime.NumCPU()))
    
    return nil
}
```

---

## 3. 内存指标

### 3.1 内存使用量

**指标名称**：`system.memory.usage`

**描述**：内存使用量（字节）

**单位**：`By`

**指标类型**：UpDownCounter

**必需属性**：

- `state`：内存状态
  - `"used"`：已使用
  - `"free"`：空闲
  - `"cached"`：缓存
  - `"buffered"`：缓冲
  - `"slab_reclaimable"`：可回收 slab
  - `"slab_unreclaimable"`：不可回收 slab

**示例**：

```text
system.memory.usage{state="used"} = 8589934592  // 8 GB
system.memory.usage{state="free"} = 4294967296  // 4 GB
system.memory.usage{state="cached"} = 2147483648  // 2 GB
```

### 3.2 内存利用率

**指标名称**：`system.memory.utilization`

**描述**：内存使用率的比例（0.0 到 1.0）

**单位**：`1`

**指标类型**：Gauge

**必需属性**：

- `state`：内存状态（同上）

### 3.3 交换空间

**指标名称**：`system.paging.usage` / `system.paging.utilization`

**描述**：交换空间使用量/使用率

**单位**：`By` / `1`

**指标类型**：UpDownCounter / Gauge

**必需属性**：

- `state`：`"used"` / `"free"`

**其他分页指标**：

- `system.paging.operations`：分页操作次数（`direction`: `"in"` / `"out"`, `type`: `"major"` / `"minor"`）
- `system.paging.faults`：页面错误次数（`type`: `"major"` / `"minor"`）

### 3.4 Go 实现

```go
package systemmetrics

import (
    "context"
    "fmt"

    "github.com/shirou/gopsutil/v3/mem"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// MemoryMetrics 管理内存指标
type MemoryMetrics struct {
    meter           metric.Meter
    usage           metric.Int64ObservableUpDownCounter
    utilization     metric.Float64ObservableGauge
    swapUsage       metric.Int64ObservableUpDownCounter
    swapUtilization metric.Float64ObservableGauge
    pagingOps       metric.Int64ObservableCounter
}

// NewMemoryMetrics 创建内存指标收集器
func NewMemoryMetrics() (*MemoryMetrics, error) {
    meter := otel.Meter("system.memory")
    
    mm := &MemoryMetrics{
        meter: meter,
    }
    
    var err error
    
    // 内存使用量
    mm.usage, err = meter.Int64ObservableUpDownCounter(
        "system.memory.usage",
        metric.WithDescription("Memory usage"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建内存使用量指标失败: %w", err)
    }
    
    // 内存利用率
    mm.utilization, err = meter.Float64ObservableGauge(
        "system.memory.utilization",
        metric.WithDescription("Memory utilization"),
        metric.WithUnit("1"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建内存利用率指标失败: %w", err)
    }
    
    // 交换空间使用量
    mm.swapUsage, err = meter.Int64ObservableUpDownCounter(
        "system.paging.usage",
        metric.WithDescription("Swap usage"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建交换空间使用量指标失败: %w", err)
    }
    
    // 交换空间利用率
    mm.swapUtilization, err = meter.Float64ObservableGauge(
        "system.paging.utilization",
        metric.WithDescription("Swap utilization"),
        metric.WithUnit("1"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建交换空间利用率指标失败: %w", err)
    }
    
    // 分页操作
    mm.pagingOps, err = meter.Int64ObservableCounter(
        "system.paging.operations",
        metric.WithDescription("Paging operations"),
        metric.WithUnit("{operation}"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建分页操作指标失败: %w", err)
    }
    
    // 注册回调
    if _, err := meter.RegisterCallback(mm.observeMemory,
        mm.usage,
        mm.utilization,
        mm.swapUsage,
        mm.swapUtilization,
        mm.pagingOps,
    ); err != nil {
        return nil, fmt.Errorf("注册内存指标回调失败: %w", err)
    }
    
    return mm, nil
}

// observeMemory 观察内存指标
func (mm *MemoryMetrics) observeMemory(ctx context.Context, observer metric.Observer) error {
    // 虚拟内存
    vmem, err := mem.VirtualMemoryWithContext(ctx)
    if err != nil {
        return fmt.Errorf("获取虚拟内存信息失败: %w", err)
    }
    
    // 内存使用量
    observer.ObserveInt64(mm.usage, int64(vmem.Used),
        metric.WithAttributes(attribute.String("state", "used")))
    observer.ObserveInt64(mm.usage, int64(vmem.Free),
        metric.WithAttributes(attribute.String("state", "free")))
    observer.ObserveInt64(mm.usage, int64(vmem.Cached),
        metric.WithAttributes(attribute.String("state", "cached")))
    observer.ObserveInt64(mm.usage, int64(vmem.Buffers),
        metric.WithAttributes(attribute.String("state", "buffered")))
    
    // 内存利用率
    observer.ObserveFloat64(mm.utilization, vmem.UsedPercent/100.0,
        metric.WithAttributes(attribute.String("state", "used")))
    observer.ObserveFloat64(mm.utilization, (100.0-vmem.UsedPercent)/100.0,
        metric.WithAttributes(attribute.String("state", "free")))
    
    // 交换空间
    swap, err := mem.SwapMemoryWithContext(ctx)
    if err == nil {
        observer.ObserveInt64(mm.swapUsage, int64(swap.Used),
            metric.WithAttributes(attribute.String("state", "used")))
        observer.ObserveInt64(mm.swapUsage, int64(swap.Free),
            metric.WithAttributes(attribute.String("state", "free")))
        
        observer.ObserveFloat64(mm.swapUtilization, swap.UsedPercent/100.0,
            metric.WithAttributes(attribute.String("state", "used")))
        
        // 分页操作
        observer.ObserveInt64(mm.pagingOps, int64(swap.Sin),
            metric.WithAttributes(
                attribute.String("direction", "in"),
                attribute.String("type", "major"),
            ))
        observer.ObserveInt64(mm.pagingOps, int64(swap.Sout),
            metric.WithAttributes(
                attribute.String("direction", "out"),
                attribute.String("type", "major"),
            ))
    }
    
    return nil
}
```

---

## 4. 磁盘指标

### 4.1 磁盘 I/O

**指标名称**：`system.disk.io`

**描述**：磁盘 I/O 字节数

**单位**：`By`

**指标类型**：Counter

**必需属性**：

- `device`：设备名称（如 `"sda"`, `"nvme0n1"`）
- `direction`：方向
  - `"read"`：读取
  - `"write"`：写入

**指标名称**：`system.disk.operations`

**描述**：磁盘操作次数

**单位**：`{operation}`

**指标类型**：Counter

**必需属性**：

- `device`：设备名称
- `direction`：`"read"` / `"write"`

### 4.2 磁盘空间

**指标名称**：`system.filesystem.usage`

**描述**：文件系统使用量（字节）

**单位**：`By`

**指标类型**：UpDownCounter

**必需属性**：

- `device`：设备名称
- `mountpoint`：挂载点（如 `"/"`, `"/data"`）
- `type`：文件系统类型（如 `"ext4"`, `"xfs"`, `"ntfs"`）
- `mode`：挂载模式（`"rw"` / `"ro"`）
- `state`：`"used"` / `"free"` / `"reserved"`

**指标名称**：`system.filesystem.utilization`

**描述**：文件系统使用率

**单位**：`1`

**指标类型**：Gauge

### 4.3 磁盘延迟

**指标名称**：`system.disk.operation_time`

**描述**：磁盘操作延迟

**单位**：`s`

**指标类型**：Counter（累计时间）

**必需属性**：

- `device`：设备名称
- `direction`：`"read"` / `"write"`

### 4.4 Go 实现

```go
package systemmetrics

import (
    "context"
    "fmt"

    "github.com/shirou/gopsutil/v3/disk"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// DiskMetrics 管理磁盘指标
type DiskMetrics struct {
    meter         metric.Meter
    io            metric.Int64ObservableCounter
    operations    metric.Int64ObservableCounter
    opTime        metric.Float64ObservableCounter
    fsUsage       metric.Int64ObservableUpDownCounter
    fsUtilization metric.Float64ObservableGauge
}

// NewDiskMetrics 创建磁盘指标收集器
func NewDiskMetrics() (*DiskMetrics, error) {
    meter := otel.Meter("system.disk")
    
    dm := &DiskMetrics{
        meter: meter,
    }
    
    var err error
    
    // 磁盘 I/O
    dm.io, err = meter.Int64ObservableCounter(
        "system.disk.io",
        metric.WithDescription("Disk I/O bytes"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建磁盘 I/O 指标失败: %w", err)
    }
    
    // 磁盘操作次数
    dm.operations, err = meter.Int64ObservableCounter(
        "system.disk.operations",
        metric.WithDescription("Disk operations"),
        metric.WithUnit("{operation}"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建磁盘操作次数指标失败: %w", err)
    }
    
    // 磁盘操作时间
    dm.opTime, err = meter.Float64ObservableCounter(
        "system.disk.operation_time",
        metric.WithDescription("Disk operation time"),
        metric.WithUnit("s"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建磁盘操作时间指标失败: %w", err)
    }
    
    // 文件系统使用量
    dm.fsUsage, err = meter.Int64ObservableUpDownCounter(
        "system.filesystem.usage",
        metric.WithDescription("Filesystem usage"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建文件系统使用量指标失败: %w", err)
    }
    
    // 文件系统利用率
    dm.fsUtilization, err = meter.Float64ObservableGauge(
        "system.filesystem.utilization",
        metric.WithDescription("Filesystem utilization"),
        metric.WithUnit("1"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建文件系统利用率指标失败: %w", err)
    }
    
    // 注册回调
    if _, err := meter.RegisterCallback(dm.observeDisk,
        dm.io,
        dm.operations,
        dm.opTime,
        dm.fsUsage,
        dm.fsUtilization,
    ); err != nil {
        return nil, fmt.Errorf("注册磁盘指标回调失败: %w", err)
    }
    
    return dm, nil
}

// observeDisk 观察磁盘指标
func (dm *DiskMetrics) observeDisk(ctx context.Context, observer metric.Observer) error {
    // 磁盘 I/O 统计
    ioCounters, err := disk.IOCountersWithContext(ctx)
    if err != nil {
        return fmt.Errorf("获取磁盘 I/O 统计失败: %w", err)
    }
    
    for device, stat := range ioCounters {
        deviceAttr := attribute.String("device", device)
        
        // I/O 字节数
        observer.ObserveInt64(dm.io, int64(stat.ReadBytes),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "read")))
        observer.ObserveInt64(dm.io, int64(stat.WriteBytes),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "write")))
        
        // 操作次数
        observer.ObserveInt64(dm.operations, int64(stat.ReadCount),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "read")))
        observer.ObserveInt64(dm.operations, int64(stat.WriteCount),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "write")))
        
        // 操作时间（毫秒转秒）
        observer.ObserveFloat64(dm.opTime, float64(stat.ReadTime)/1000.0,
            metric.WithAttributes(deviceAttr, attribute.String("direction", "read")))
        observer.ObserveFloat64(dm.opTime, float64(stat.WriteTime)/1000.0,
            metric.WithAttributes(deviceAttr, attribute.String("direction", "write")))
    }
    
    // 文件系统使用情况
    partitions, err := disk.PartitionsWithContext(ctx, false)
    if err != nil {
        return fmt.Errorf("获取分区信息失败: %w", err)
    }
    
    for _, partition := range partitions {
        usage, err := disk.UsageWithContext(ctx, partition.Mountpoint)
        if err != nil {
            continue
        }
        
        attrs := []attribute.KeyValue{
            attribute.String("device", partition.Device),
            attribute.String("mountpoint", partition.Mountpoint),
            attribute.String("type", partition.Fstype),
        }
        
        // 使用量
        observer.ObserveInt64(dm.fsUsage, int64(usage.Used),
            metric.WithAttributes(append(attrs, attribute.String("state", "used"))...))
        observer.ObserveInt64(dm.fsUsage, int64(usage.Free),
            metric.WithAttributes(append(attrs, attribute.String("state", "free"))...))
        
        // 利用率
        observer.ObserveFloat64(dm.fsUtilization, usage.UsedPercent/100.0,
            metric.WithAttributes(attrs...))
    }
    
    return nil
}
```

---

## 5. 网络指标

### 5.1 网络流量

**指标名称**：`system.network.io`

**描述**：网络 I/O 字节数

**单位**：`By`

**指标类型**：Counter

**必需属性**：

- `device`：网络接口名称（如 `"eth0"`, `"wlan0"`）
- `direction`：`"transmit"` / `"receive"`

**指标名称**：`system.network.packets`

**描述**：网络包数量

**单位**：`{packet}`

**指标类型**：Counter

**必需属性**：

- `device`：网络接口名称
- `direction`：`"transmit"` / `"receive"`

### 5.2 网络连接

**指标名称**：`system.network.connections`

**描述**：网络连接数

**单位**：`{connection}`

**指标类型**：UpDownCounter

**必需属性**：

- `protocol`：协议（`"tcp"` / `"udp"`）
- `state`：连接状态
  - `"close"`
  - `"close_wait"`
  - `"closing"`
  - `"established"`
  - `"fin_wait_1"`
  - `"fin_wait_2"`
  - `"last_ack"`
  - `"listen"`
  - `"syn_recv"`
  - `"syn_sent"`
  - `"time_wait"`

### 5.3 网络错误

**指标名称**：`system.network.errors`

**描述**：网络错误数

**单位**：`{error}`

**指标类型**：Counter

**必需属性**：

- `device`：网络接口名称
- `direction`：`"transmit"` / `"receive"`

**指标名称**：`system.network.dropped`

**描述**：丢弃的网络包数

**单位**：`{packet}`

**指标类型**：Counter

**必需属性**：

- `device`：网络接口名称
- `direction`：`"transmit"` / `"receive"`

### 5.4 Go 实现

```go
package systemmetrics

import (
    "context"
    "fmt"

    "github.com/shirou/gopsutil/v3/net"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// NetworkMetrics 管理网络指标
type NetworkMetrics struct {
    meter       metric.Meter
    io          metric.Int64ObservableCounter
    packets     metric.Int64ObservableCounter
    errors      metric.Int64ObservableCounter
    dropped     metric.Int64ObservableCounter
    connections metric.Int64ObservableUpDownCounter
}

// NewNetworkMetrics 创建网络指标收集器
func NewNetworkMetrics() (*NetworkMetrics, error) {
    meter := otel.Meter("system.network")
    
    nm := &NetworkMetrics{
        meter: meter,
    }
    
    var err error
    
    // 网络 I/O
    nm.io, err = meter.Int64ObservableCounter(
        "system.network.io",
        metric.WithDescription("Network I/O bytes"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建网络 I/O 指标失败: %w", err)
    }
    
    // 网络包
    nm.packets, err = meter.Int64ObservableCounter(
        "system.network.packets",
        metric.WithDescription("Network packets"),
        metric.WithUnit("{packet}"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建网络包指标失败: %w", err)
    }
    
    // 网络错误
    nm.errors, err = meter.Int64ObservableCounter(
        "system.network.errors",
        metric.WithDescription("Network errors"),
        metric.WithUnit("{error}"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建网络错误指标失败: %w", err)
    }
    
    // 丢弃的包
    nm.dropped, err = meter.Int64ObservableCounter(
        "system.network.dropped",
        metric.WithDescription("Dropped network packets"),
        metric.WithUnit("{packet}"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建丢弃包指标失败: %w", err)
    }
    
    // 网络连接
    nm.connections, err = meter.Int64ObservableUpDownCounter(
        "system.network.connections",
        metric.WithDescription("Network connections"),
        metric.WithUnit("{connection}"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建网络连接指标失败: %w", err)
    }
    
    // 注册回调
    if _, err := meter.RegisterCallback(nm.observeNetwork,
        nm.io,
        nm.packets,
        nm.errors,
        nm.dropped,
        nm.connections,
    ); err != nil {
        return nil, fmt.Errorf("注册网络指标回调失败: %w", err)
    }
    
    return nm, nil
}

// observeNetwork 观察网络指标
func (nm *NetworkMetrics) observeNetwork(ctx context.Context, observer metric.Observer) error {
    // 网络 I/O 统计
    ioCounters, err := net.IOCountersWithContext(ctx, true)
    if err != nil {
        return fmt.Errorf("获取网络 I/O 统计失败: %w", err)
    }
    
    for _, stat := range ioCounters {
        deviceAttr := attribute.String("device", stat.Name)
        
        // I/O 字节数
        observer.ObserveInt64(nm.io, int64(stat.BytesRecv),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "receive")))
        observer.ObserveInt64(nm.io, int64(stat.BytesSent),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "transmit")))
        
        // 包数
        observer.ObserveInt64(nm.packets, int64(stat.PacketsRecv),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "receive")))
        observer.ObserveInt64(nm.packets, int64(stat.PacketsSent),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "transmit")))
        
        // 错误数
        observer.ObserveInt64(nm.errors, int64(stat.Errin),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "receive")))
        observer.ObserveInt64(nm.errors, int64(stat.Errout),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "transmit")))
        
        // 丢弃的包
        observer.ObserveInt64(nm.dropped, int64(stat.Dropin),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "receive")))
        observer.ObserveInt64(nm.dropped, int64(stat.Dropout),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "transmit")))
    }
    
    // 网络连接统计
    connections, err := net.ConnectionsWithContext(ctx, "all")
    if err == nil {
        connMap := make(map[string]map[string]int)
        
        for _, conn := range connections {
            protocol := conn.Type
            state := conn.Status
            
            if connMap[protocol] == nil {
                connMap[protocol] = make(map[string]int)
            }
            connMap[protocol][state]++
        }
        
        for protocol, states := range connMap {
            for state, count := range states {
                observer.ObserveInt64(nm.connections, int64(count),
                    metric.WithAttributes(
                        attribute.String("protocol", string(protocol)),
                        attribute.String("state", state),
                    ))
            }
        }
    }
    
    return nil
}
```

---

## 6. 完整示例

### 6.1 系统监控器

```go
package main

import (
    "context"
    "log"
    "os"
    "os/signal"
    "syscall"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
    "go.opentelemetry.io/otel/sdk/metric"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
)

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    // 创建资源
    res, err := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName("system-monitor"),
            semconv.ServiceVersion("1.0.0"),
        ),
    )
    if err != nil {
        log.Fatalf("创建资源失败: %v", err)
    }
    
    // 创建 OTLP 导出器
    exporter, err := otlpmetricgrpc.New(ctx,
        otlpmetricgrpc.WithInsecure(),
        otlpmetricgrpc.WithEndpoint("localhost:4317"),
    )
    if err != nil {
        log.Fatalf("创建导出器失败: %v", err)
    }
    defer exporter.Shutdown(ctx)
    
    // 创建 Meter Provider
    provider := metric.NewMeterProvider(
        metric.WithResource(res),
        metric.WithReader(metric.NewPeriodicReader(exporter,
            metric.WithInterval(10*time.Second),
        )),
    )
    defer provider.Shutdown(ctx)
    
    otel.SetMeterProvider(provider)
    
    // 初始化系统指标收集器
    if _, err := NewCPUMetrics(); err != nil {
        log.Fatalf("初始化 CPU 指标失败: %v", err)
    }
    
    if _, err := NewMemoryMetrics(); err != nil {
        log.Fatalf("初始化内存指标失败: %v", err)
    }
    
    if _, err := NewDiskMetrics(); err != nil {
        log.Fatalf("初始化磁盘指标失败: %v", err)
    }
    
    if _, err := NewNetworkMetrics(); err != nil {
        log.Fatalf("初始化网络指标失败: %v", err)
    }
    
    log.Println("系统监控启动，按 Ctrl+C 退出")
    
    // 等待信号
    sigCh := make(chan os.Signal, 1)
    signal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)
    <-sigCh
    
    log.Println("正在关闭系统监控...")
}
```

### 6.2 跨平台兼容性

```go
// +build linux darwin

package systemmetrics

import (
    "golang.org/x/sys/unix"
)

// getPlatformSpecificMetrics 获取平台特定指标（Unix/Linux）
func getPlatformSpecificMetrics() error {
    var sysinfo unix.Sysinfo_t
    if err := unix.Sysinfo(&sysinfo); err != nil {
        return err
    }
    
    // Linux 特定指标
    // ...
    
    return nil
}
```

```go
// +build windows

package systemmetrics

import (
    "golang.org/x/sys/windows"
)

// getPlatformSpecificMetrics 获取平台特定指标（Windows）
func getPlatformSpecificMetrics() error {
    // Windows 特定指标
    // 使用 windows 包或 WMI
    
    return nil
}
```

### 6.3 容器环境

在容器环境中，系统指标需要特殊处理：

```go
package systemmetrics

import (
    "os"
    "strconv"
    "strings"
)

// isContainer 检测是否运行在容器中
func isContainer() bool {
    // 检查 /.dockerenv 文件
    if _, err := os.Stat("/.dockerenv"); err == nil {
        return true
    }
    
    // 检查 cgroup
    data, err := os.ReadFile("/proc/1/cgroup")
    if err == nil {
        content := string(data)
        return strings.Contains(content, "docker") ||
               strings.Contains(content, "kubepods") ||
               strings.Contains(content, "containerd")
    }
    
    return false
}

// getContainerCPUQuota 获取容器 CPU 配额
func getContainerCPUQuota() (quota, period int64, err error) {
    // 读取 CPU 配额（cgroup v1）
    quotaData, err := os.ReadFile("/sys/fs/cgroup/cpu/cpu.cfs_quota_us")
    if err != nil {
        // 尝试 cgroup v2
        quotaData, err = os.ReadFile("/sys/fs/cgroup/cpu.max")
        if err != nil {
            return 0, 0, err
        }
        // cgroup v2 格式: "max 100000" 或 "50000 100000"
        parts := strings.Fields(strings.TrimSpace(string(quotaData)))
        if parts[0] != "max" {
            quota, _ = strconv.ParseInt(parts[0], 10, 64)
        }
        if len(parts) > 1 {
            period, _ = strconv.ParseInt(parts[1], 10, 64)
        }
        return quota, period, nil
    }
    
    // cgroup v1
    quota, _ = strconv.ParseInt(strings.TrimSpace(string(quotaData)), 10, 64)
    
    periodData, err := os.ReadFile("/sys/fs/cgroup/cpu/cpu.cfs_period_us")
    if err != nil {
        return quota, 0, err
    }
    period, _ = strconv.ParseInt(strings.TrimSpace(string(periodData)), 10, 64)
    
    return quota, period, nil
}

// getContainerMemoryLimit 获取容器内存限制
func getContainerMemoryLimit() (int64, error) {
    // cgroup v1
    data, err := os.ReadFile("/sys/fs/cgroup/memory/memory.limit_in_bytes")
    if err != nil {
        // 尝试 cgroup v2
        data, err = os.ReadFile("/sys/fs/cgroup/memory.max")
        if err != nil {
            return 0, err
        }
    }
    
    limitStr := strings.TrimSpace(string(data))
    if limitStr == "max" {
        return 0, nil // 无限制
    }
    
    limit, err := strconv.ParseInt(limitStr, 10, 64)
    return limit, err
}
```

---

## 7. 最佳实践

### 7.1 采集频率

| 指标类型 | 推荐频率 | 说明 |
|---------|---------|------|
| CPU | 10-30 秒 | 平衡精度和开销 |
| 内存 | 30-60 秒 | 变化相对缓慢 |
| 磁盘 | 30-60 秒 | I/O 统计更新较慢 |
| 网络 | 10-30 秒 | 流量变化较快 |
| 连接数 | 60 秒 | 统计开销较大 |

**动态调整**：

```go
type AdaptiveCollector struct {
    baseInterval time.Duration
    maxInterval  time.Duration
    minInterval  time.Duration
    currentInterval time.Duration
}

func (ac *AdaptiveCollector) adjustInterval(changeRate float64) {
    // 变化率高时增加采集频率
    if changeRate > 0.1 {
        ac.currentInterval = max(ac.minInterval, ac.currentInterval/2)
    } else {
        ac.currentInterval = min(ac.maxInterval, ac.currentInterval*2)
    }
}
```

### 7.2 指标聚合

使用 OpenTelemetry View 进行指标聚合：

```go
import (
    "go.opentelemetry.io/otel/sdk/metric"
)

func setupViews() []metric.View {
    return []metric.View{
        // CPU 使用率按 CPU 核心聚合
        metric.NewView(
            metric.Instrument{Name: "system.cpu.utilization"},
            metric.Stream{
                Aggregation: metric.AggregationLastValue{},
            },
        ),
        // 内存使用量使用直方图
        metric.NewView(
            metric.Instrument{Name: "system.memory.usage"},
            metric.Stream{
                Aggregation: metric.AggregationExplicitBucketHistogram{
                    Boundaries: []float64{
                        1 << 20,  // 1 MB
                        1 << 24,  // 16 MB
                        1 << 28,  // 256 MB
                        1 << 30,  // 1 GB
                        1 << 32,  // 4 GB
                        1 << 34,  // 16 GB
                    },
                },
            },
        ),
    }
}
```

### 7.3 告警阈值

**推荐阈值**：

| 指标 | 警告 | 严重 |
|-----|------|------|
| CPU 使用率 | > 70% | > 90% |
| 内存使用率 | > 80% | > 95% |
| 磁盘使用率 | > 80% | > 90% |
| 磁盘 I/O 等待 | > 10% | > 20% |
| 负载平均值 | > CPU 核心数 × 0.7 | > CPU 核心数 |
| 网络错误率 | > 0.1% | > 1% |

**告警规则（Prometheus 格式）**：

```yaml
groups:
  - name: system_alerts
    interval: 30s
    rules:
      - alert: HighCPUUsage
        expr: system_cpu_utilization{state="used"} > 0.9
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "高 CPU 使用率"
          description: "CPU 使用率 {{ $value | humanizePercentage }} 超过 90%"
      
      - alert: HighMemoryUsage
        expr: system_memory_utilization{state="used"} > 0.95
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "高内存使用率"
          description: "内存使用率 {{ $value | humanizePercentage }} 超过 95%"
      
      - alert: DiskSpaceLow
        expr: system_filesystem_utilization > 0.9
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "磁盘空间不足"
          description: "{{ $labels.mountpoint }} 使用率 {{ $value | humanizePercentage }} 超过 90%"
```

### 7.4 性能优化

**1. 缓存系统信息**：

```go
type CachedSystemInfo struct {
    cpuCount    int
    hostname    string
    os          string
    arch        string
    cachedAt    time.Time
    cacheTTL    time.Duration
}

func (csi *CachedSystemInfo) getCPUCount() int {
    if time.Since(csi.cachedAt) > csi.cacheTTL {
        csi.cpuCount = runtime.NumCPU()
        csi.cachedAt = time.Now()
    }
    return csi.cpuCount
}
```

**2. 批量采集**：

```go
type BatchCollector struct {
    collectors []MetricCollector
}

func (bc *BatchCollector) collectAll(ctx context.Context) error {
    var g errgroup.Group
    
    for _, collector := range bc.collectors {
        collector := collector // 避免闭包问题
        g.Go(func() error {
            return collector.Collect(ctx)
        })
    }
    
    return g.Wait()
}
```

**3. 增量采集**：

```go
type DeltaCollector struct {
    lastValue map[string]uint64
    mu        sync.RWMutex
}

func (dc *DeltaCollector) recordDelta(name string, current uint64) uint64 {
    dc.mu.Lock()
    defer dc.mu.Unlock()
    
    last := dc.lastValue[name]
    dc.lastValue[name] = current
    
    if last == 0 {
        return 0 // 首次采集
    }
    return current - last
}
```

---

## 8. 常见问题

**Q1: 为什么 CPU 使用率总和不等于 100%？**

A: 每个 CPU 核心单独报告使用率，多核系统的总使用率是所有核心的平均值。例如，4 核系统中 2 个核心满载，总使用率为 50%。

**Q2: 容器中的内存指标不准确？**

A: 容器环境中应读取 cgroup 限制，而不是宿主机的总内存：

```go
func getEffectiveMemoryLimit() uint64 {
    if isContainer() {
        if limit, err := getContainerMemoryLimit(); err == nil && limit > 0 {
            return uint64(limit)
        }
    }
    // 回退到系统总内存
    vmem, _ := mem.VirtualMemory()
    return vmem.Total
}
```

**Q3: 磁盘 I/O 指标总是增长？**

A: `system.disk.io` 是累计计数器（Counter），应使用导数计算速率：

```text
rate(system_disk_io[1m])  # Prometheus 查询
```

**Q4: 如何监控 NVMe 磁盘？**

A: NVMe 磁盘设备名通常为 `nvme0n1`, `nvme1n1`，确保设备过滤规则包含：

```go
func isMonitoredDevice(name string) bool {
    return strings.HasPrefix(name, "sd") ||   // SATA/SCSI
           strings.HasPrefix(name, "nvme") || // NVMe
           strings.HasPrefix(name, "vd") ||   // 虚拟磁盘
           strings.HasPrefix(name, "hd")      // IDE (legacy)
}
```

**Q5: 如何减少网络连接统计的开销？**

A: 网络连接统计（特别是 `net.Connections`）开销较大，可以：

1. 降低采集频率（60 秒或更长）
2. 仅统计特定状态（如 `ESTABLISHED`）
3. 使用采样策略

```go
func observeConnectionsSampled(ctx context.Context, sampleRate float64) error {
    if rand.Float64() > sampleRate {
        return nil // 跳过本次采集
    }
    return observeConnections(ctx)
}
```

**Q6: Go 1.25.1 有哪些系统指标相关的新特性？**

A: Go 1.25.1 增强了 `runtime/metrics` 包，提供更详细的运行时指标（详见下一篇文档《运行时指标》）。

---

## 总结

本文档详细介绍了 OpenTelemetry 系统指标的语义约定和 Go 1.25.1 实现方案，涵盖：

✅ **CPU 指标**：使用率、时间、负载平均值  
✅ **内存指标**：使用量、利用率、交换空间  
✅ **磁盘指标**：I/O、空间、延迟  
✅ **网络指标**：流量、连接、错误  
✅ **完整示例**：跨平台、容器环境  
✅ **最佳实践**：采集频率、聚合、告警、优化  

**下一步**：

- 📖 阅读《运行时指标》学习 Go runtime 监控
- 📖 阅读《HTTP 指标》学习应用层指标
- 🔗 参考 [gopsutil 文档](https://github.com/shirou/gopsutil)

**参考资源**：

- [OpenTelemetry System Metrics Semantic Conventions](https://opentelemetry.io/docs/specs/semconv/system/system-metrics/)
- [gopsutil - psutil for golang](https://github.com/shirou/gopsutil)
- [Prometheus Node Exporter](https://github.com/prometheus/node_exporter)
