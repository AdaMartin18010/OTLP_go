# ç³»ç»ŸæŒ‡æ ‡ï¼ˆSystem Metricsï¼‰

## ç›®å½•

- [ç³»ç»ŸæŒ‡æ ‡ï¼ˆSystem Metricsï¼‰](#ç³»ç»ŸæŒ‡æ ‡system-metrics)
  - [ç›®å½•](#ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. CPU æŒ‡æ ‡](#2-cpu-æŒ‡æ ‡)
    - [2.1 CPU ä½¿ç”¨ç‡](#21-cpu-ä½¿ç”¨ç‡)
    - [2.2 CPU æ—¶é—´](#22-cpu-æ—¶é—´)
    - [2.3 è´Ÿè½½å¹³å‡å€¼](#23-è´Ÿè½½å¹³å‡å€¼)
    - [2.4 CPU æ ¸å¿ƒæ•°](#24-cpu-æ ¸å¿ƒæ•°)
    - [2.5 Go å®ç°](#25-go-å®ç°)
  - [3. å†…å­˜æŒ‡æ ‡](#3-å†…å­˜æŒ‡æ ‡)
    - [3.1 å†…å­˜ä½¿ç”¨é‡](#31-å†…å­˜ä½¿ç”¨é‡)
    - [3.2 å†…å­˜åˆ©ç”¨ç‡](#32-å†…å­˜åˆ©ç”¨ç‡)
    - [3.3 äº¤æ¢ç©ºé—´](#33-äº¤æ¢ç©ºé—´)
    - [3.4 Go å®ç°](#34-go-å®ç°)
  - [4. ç£ç›˜æŒ‡æ ‡](#4-ç£ç›˜æŒ‡æ ‡)
    - [4.1 ç£ç›˜ I/O](#41-ç£ç›˜-io)
    - [4.2 ç£ç›˜ç©ºé—´](#42-ç£ç›˜ç©ºé—´)
    - [4.3 ç£ç›˜å»¶è¿Ÿ](#43-ç£ç›˜å»¶è¿Ÿ)
    - [4.4 Go å®ç°](#44-go-å®ç°)
  - [5. ç½‘ç»œæŒ‡æ ‡](#5-ç½‘ç»œæŒ‡æ ‡)
    - [5.1 ç½‘ç»œæµé‡](#51-ç½‘ç»œæµé‡)
    - [5.2 ç½‘ç»œè¿æ¥](#52-ç½‘ç»œè¿æ¥)
    - [5.3 ç½‘ç»œé”™è¯¯](#53-ç½‘ç»œé”™è¯¯)
    - [5.4 Go å®ç°](#54-go-å®ç°)
  - [6. å®Œæ•´ç¤ºä¾‹](#6-å®Œæ•´ç¤ºä¾‹)
    - [6.1 ç³»ç»Ÿç›‘æ§å™¨](#61-ç³»ç»Ÿç›‘æ§å™¨)
    - [6.2 è·¨å¹³å°å…¼å®¹æ€§](#62-è·¨å¹³å°å…¼å®¹æ€§)
    - [6.3 å®¹å™¨ç¯å¢ƒ](#63-å®¹å™¨ç¯å¢ƒ)
  - [7. æœ€ä½³å®è·µ](#7-æœ€ä½³å®è·µ)
    - [7.1 é‡‡é›†é¢‘ç‡](#71-é‡‡é›†é¢‘ç‡)
    - [7.2 æŒ‡æ ‡èšåˆ](#72-æŒ‡æ ‡èšåˆ)
    - [7.3 å‘Šè­¦é˜ˆå€¼](#73-å‘Šè­¦é˜ˆå€¼)
    - [7.4 æ€§èƒ½ä¼˜åŒ–](#74-æ€§èƒ½ä¼˜åŒ–)
  - [8. å¸¸è§é—®é¢˜](#8-å¸¸è§é—®é¢˜)
  - [æ€»ç»“](#æ€»ç»“)

---

## 1. æ¦‚è¿°

ç³»ç»ŸæŒ‡æ ‡æ˜¯ç›‘æ§ç³»ç»Ÿå¥åº·çŠ¶æ€çš„åŸºç¡€ï¼ŒåŒ…æ‹¬ CPUã€å†…å­˜ã€ç£ç›˜ã€ç½‘ç»œç­‰å…³é”®èµ„æºçš„ä½¿ç”¨æƒ…å†µã€‚
æœ¬æ–‡æ¡£éµå¾ª OpenTelemetry Semantic Conventionsï¼Œæä¾›æ ‡å‡†åŒ–çš„ç³»ç»ŸæŒ‡æ ‡å®šä¹‰å’Œ Go 1.25.1 å®ç°æ–¹æ¡ˆã€‚

**æ ¸å¿ƒä»·å€¼**ï¼š

- ğŸ¯ **èµ„æºç›‘æ§**ï¼šå®æ—¶æŒæ¡ç³»ç»Ÿèµ„æºä½¿ç”¨æƒ…å†µ
- ğŸ“Š **å®¹é‡è§„åˆ’**ï¼šä¸ºå®¹é‡è§„åˆ’æä¾›æ•°æ®æ”¯æŒ
- ğŸš¨ **å¼‚å¸¸å‘Šè­¦**ï¼šåŠæ—¶å‘ç°èµ„æºç“¶é¢ˆå’Œå¼‚å¸¸
- ğŸ“ˆ **è¶‹åŠ¿åˆ†æ**ï¼šåˆ†æèµ„æºä½¿ç”¨è¶‹åŠ¿

**å‚è€ƒè§„èŒƒ**ï¼š

- [OpenTelemetry Semantic Conventions - System Metrics](https://opentelemetry.io/docs/specs/semconv/system/system-metrics/)
- [Prometheus Naming Conventions](https://prometheus.io/docs/practices/naming/)

---

## 2. CPU æŒ‡æ ‡

### 2.1 CPU ä½¿ç”¨ç‡

**æŒ‡æ ‡åç§°**ï¼š`system.cpu.utilization`

**æè¿°**ï¼šCPU ä½¿ç”¨ç‡çš„æ¯”ä¾‹ï¼ˆ0.0 åˆ° 1.0ï¼‰

**å•ä½**ï¼š`1`ï¼ˆæ¯”ä¾‹ï¼‰

**æŒ‡æ ‡ç±»å‹**ï¼šGauge

**å¿…éœ€å±æ€§**ï¼š

- `cpu`ï¼šCPU æ ¸å¿ƒç¼–å·ï¼ˆå¦‚ `"0"`, `"1"`, ...ï¼‰
- `state`ï¼šCPU çŠ¶æ€
  - `"user"`ï¼šç”¨æˆ·æ€
  - `"system"`ï¼šå†…æ ¸æ€
  - `"idle"`ï¼šç©ºé—²
  - `"iowait"`ï¼šç­‰å¾… I/O
  - `"interrupt"`ï¼šä¸­æ–­å¤„ç†
  - `"steal"`ï¼šè™šæ‹ŸåŒ–ç¯å¢ƒä¸­è¢«å…¶ä»–è™šæ‹Ÿæœºå ç”¨

**ç¤ºä¾‹**ï¼š

```text
system.cpu.utilization{cpu="0",state="user"} = 0.45
system.cpu.utilization{cpu="0",state="system"} = 0.15
system.cpu.utilization{cpu="0",state="idle"} = 0.40
```

### 2.2 CPU æ—¶é—´

**æŒ‡æ ‡åç§°**ï¼š`system.cpu.time`

**æè¿°**ï¼šCPU å„çŠ¶æ€ç´¯è®¡æ—¶é—´

**å•ä½**ï¼š`s`ï¼ˆç§’ï¼‰

**æŒ‡æ ‡ç±»å‹**ï¼šCounter

**å¿…éœ€å±æ€§**ï¼š

- `cpu`ï¼šCPU æ ¸å¿ƒç¼–å·
- `state`ï¼šCPU çŠ¶æ€ï¼ˆåŒä¸Šï¼‰

**ç¤ºä¾‹**ï¼š

```text
system.cpu.time{cpu="0",state="user"} = 3600.5
system.cpu.time{cpu="0",state="system"} = 1200.3
```

### 2.3 è´Ÿè½½å¹³å‡å€¼

**æŒ‡æ ‡åç§°**ï¼š`system.cpu.load_average.1m` / `system.cpu.load_average.5m` / `system.cpu.load_average.15m`

**æè¿°**ï¼šç³»ç»Ÿè´Ÿè½½å¹³å‡å€¼ï¼ˆ1 åˆ†é’Ÿã€5 åˆ†é’Ÿã€15 åˆ†é’Ÿï¼‰

**å•ä½**ï¼š`1`

**æŒ‡æ ‡ç±»å‹**ï¼šGauge

**ç¤ºä¾‹**ï¼š

```text
system.cpu.load_average.1m = 2.5
system.cpu.load_average.5m = 1.8
system.cpu.load_average.15m = 1.2
```

### 2.4 CPU æ ¸å¿ƒæ•°

**æŒ‡æ ‡åç§°**ï¼š`system.cpu.logical.count`

**æè¿°**ï¼šé€»è¾‘ CPU æ ¸å¿ƒæ•°

**å•ä½**ï¼š`{cpu}`

**æŒ‡æ ‡ç±»å‹**ï¼šUpDownCounter

### 2.5 Go å®ç°

```go
package systemmetrics

import (
    "context"
    "fmt"
    "runtime"
    "time"

    "github.com/shirou/gopsutil/v3/cpu"
    "github.com/shirou/gopsutil/v3/load"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// CPUMetrics ç®¡ç† CPU æŒ‡æ ‡
type CPUMetrics struct {
    meter          metric.Meter
    utilization    metric.Float64ObservableGauge
    time           metric.Float64ObservableCounter
    loadAvg1m      metric.Float64ObservableGauge
    loadAvg5m      metric.Float64ObservableGauge
    loadAvg15m     metric.Float64ObservableGauge
    logicalCount   metric.Int64ObservableUpDownCounter
}

// NewCPUMetrics åˆ›å»º CPU æŒ‡æ ‡æ”¶é›†å™¨
func NewCPUMetrics() (*CPUMetrics, error) {
    meter := otel.Meter("system.cpu")
    
    cm := &CPUMetrics{
        meter: meter,
    }
    
    var err error
    
    // CPU ä½¿ç”¨ç‡
    cm.utilization, err = meter.Float64ObservableGauge(
        "system.cpu.utilization",
        metric.WithDescription("CPU utilization"),
        metric.WithUnit("1"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º CPU ä½¿ç”¨ç‡æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // CPU æ—¶é—´
    cm.time, err = meter.Float64ObservableCounter(
        "system.cpu.time",
        metric.WithDescription("CPU time"),
        metric.WithUnit("s"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º CPU æ—¶é—´æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // è´Ÿè½½å¹³å‡å€¼
    cm.loadAvg1m, err = meter.Float64ObservableGauge(
        "system.cpu.load_average.1m",
        metric.WithDescription("CPU load average 1m"),
        metric.WithUnit("1"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºè´Ÿè½½å¹³å‡å€¼æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    cm.loadAvg5m, err = meter.Float64ObservableGauge(
        "system.cpu.load_average.5m",
        metric.WithDescription("CPU load average 5m"),
        metric.WithUnit("1"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºè´Ÿè½½å¹³å‡å€¼æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    cm.loadAvg15m, err = meter.Float64ObservableGauge(
        "system.cpu.load_average.15m",
        metric.WithDescription("CPU load average 15m"),
        metric.WithUnit("1"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºè´Ÿè½½å¹³å‡å€¼æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // é€»è¾‘æ ¸å¿ƒæ•°
    cm.logicalCount, err = meter.Int64ObservableUpDownCounter(
        "system.cpu.logical.count",
        metric.WithDescription("Number of logical CPU cores"),
        metric.WithUnit("{cpu}"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º CPU æ ¸å¿ƒæ•°æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // æ³¨å†Œå›è°ƒ
    if _, err := meter.RegisterCallback(cm.observeCPU,
        cm.utilization,
        cm.time,
        cm.loadAvg1m,
        cm.loadAvg5m,
        cm.loadAvg15m,
        cm.logicalCount,
    ); err != nil {
        return nil, fmt.Errorf("æ³¨å†Œ CPU æŒ‡æ ‡å›è°ƒå¤±è´¥: %w", err)
    }
    
    return cm, nil
}

// observeCPU è§‚å¯Ÿ CPU æŒ‡æ ‡
func (cm *CPUMetrics) observeCPU(ctx context.Context, observer metric.Observer) error {
    // CPU ä½¿ç”¨ç‡å’Œæ—¶é—´
    percentages, err := cpu.PercentWithContext(ctx, 0, true)
    if err != nil {
        return fmt.Errorf("è·å– CPU ä½¿ç”¨ç‡å¤±è´¥: %w", err)
    }
    
    times, err := cpu.TimesWithContext(ctx, true)
    if err != nil {
        return fmt.Errorf("è·å– CPU æ—¶é—´å¤±è´¥: %w", err)
    }
    
    for i, pct := range percentages {
        cpuAttr := attribute.String("cpu", fmt.Sprintf("%d", i))
        
        // ä½¿ç”¨ç‡ï¼ˆç®€åŒ–ç‰ˆï¼Œå®é™…åº”æŒ‰çŠ¶æ€åˆ†ç±»ï¼‰
        observer.ObserveFloat64(cm.utilization, pct/100.0,
            metric.WithAttributes(
                cpuAttr,
                attribute.String("state", "used"),
            ),
        )
        
        // æ—¶é—´
        if i < len(times) {
            t := times[i]
            observer.ObserveFloat64(cm.time, t.User,
                metric.WithAttributes(cpuAttr, attribute.String("state", "user")))
            observer.ObserveFloat64(cm.time, t.System,
                metric.WithAttributes(cpuAttr, attribute.String("state", "system")))
            observer.ObserveFloat64(cm.time, t.Idle,
                metric.WithAttributes(cpuAttr, attribute.String("state", "idle")))
            observer.ObserveFloat64(cm.time, t.Iowait,
                metric.WithAttributes(cpuAttr, attribute.String("state", "iowait")))
            observer.ObserveFloat64(cm.time, t.Irq,
                metric.WithAttributes(cpuAttr, attribute.String("state", "interrupt")))
            observer.ObserveFloat64(cm.time, t.Steal,
                metric.WithAttributes(cpuAttr, attribute.String("state", "steal")))
        }
    }
    
    // è´Ÿè½½å¹³å‡å€¼ï¼ˆLinux/Unixï¼‰
    if loadInfo, err := load.AvgWithContext(ctx); err == nil {
        observer.ObserveFloat64(cm.loadAvg1m, loadInfo.Load1)
        observer.ObserveFloat64(cm.loadAvg5m, loadInfo.Load5)
        observer.ObserveFloat64(cm.loadAvg15m, loadInfo.Load15)
    }
    
    // CPU æ ¸å¿ƒæ•°
    observer.ObserveInt64(cm.logicalCount, int64(runtime.NumCPU()))
    
    return nil
}
```

---

## 3. å†…å­˜æŒ‡æ ‡

### 3.1 å†…å­˜ä½¿ç”¨é‡

**æŒ‡æ ‡åç§°**ï¼š`system.memory.usage`

**æè¿°**ï¼šå†…å­˜ä½¿ç”¨é‡ï¼ˆå­—èŠ‚ï¼‰

**å•ä½**ï¼š`By`

**æŒ‡æ ‡ç±»å‹**ï¼šUpDownCounter

**å¿…éœ€å±æ€§**ï¼š

- `state`ï¼šå†…å­˜çŠ¶æ€
  - `"used"`ï¼šå·²ä½¿ç”¨
  - `"free"`ï¼šç©ºé—²
  - `"cached"`ï¼šç¼“å­˜
  - `"buffered"`ï¼šç¼“å†²
  - `"slab_reclaimable"`ï¼šå¯å›æ”¶ slab
  - `"slab_unreclaimable"`ï¼šä¸å¯å›æ”¶ slab

**ç¤ºä¾‹**ï¼š

```text
system.memory.usage{state="used"} = 8589934592  // 8 GB
system.memory.usage{state="free"} = 4294967296  // 4 GB
system.memory.usage{state="cached"} = 2147483648  // 2 GB
```

### 3.2 å†…å­˜åˆ©ç”¨ç‡

**æŒ‡æ ‡åç§°**ï¼š`system.memory.utilization`

**æè¿°**ï¼šå†…å­˜ä½¿ç”¨ç‡çš„æ¯”ä¾‹ï¼ˆ0.0 åˆ° 1.0ï¼‰

**å•ä½**ï¼š`1`

**æŒ‡æ ‡ç±»å‹**ï¼šGauge

**å¿…éœ€å±æ€§**ï¼š

- `state`ï¼šå†…å­˜çŠ¶æ€ï¼ˆåŒä¸Šï¼‰

### 3.3 äº¤æ¢ç©ºé—´

**æŒ‡æ ‡åç§°**ï¼š`system.paging.usage` / `system.paging.utilization`

**æè¿°**ï¼šäº¤æ¢ç©ºé—´ä½¿ç”¨é‡/ä½¿ç”¨ç‡

**å•ä½**ï¼š`By` / `1`

**æŒ‡æ ‡ç±»å‹**ï¼šUpDownCounter / Gauge

**å¿…éœ€å±æ€§**ï¼š

- `state`ï¼š`"used"` / `"free"`

**å…¶ä»–åˆ†é¡µæŒ‡æ ‡**ï¼š

- `system.paging.operations`ï¼šåˆ†é¡µæ“ä½œæ¬¡æ•°ï¼ˆ`direction`: `"in"` / `"out"`, `type`: `"major"` / `"minor"`ï¼‰
- `system.paging.faults`ï¼šé¡µé¢é”™è¯¯æ¬¡æ•°ï¼ˆ`type`: `"major"` / `"minor"`ï¼‰

### 3.4 Go å®ç°

```go
package systemmetrics

import (
    "context"
    "fmt"

    "github.com/shirou/gopsutil/v3/mem"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// MemoryMetrics ç®¡ç†å†…å­˜æŒ‡æ ‡
type MemoryMetrics struct {
    meter           metric.Meter
    usage           metric.Int64ObservableUpDownCounter
    utilization     metric.Float64ObservableGauge
    swapUsage       metric.Int64ObservableUpDownCounter
    swapUtilization metric.Float64ObservableGauge
    pagingOps       metric.Int64ObservableCounter
}

// NewMemoryMetrics åˆ›å»ºå†…å­˜æŒ‡æ ‡æ”¶é›†å™¨
func NewMemoryMetrics() (*MemoryMetrics, error) {
    meter := otel.Meter("system.memory")
    
    mm := &MemoryMetrics{
        meter: meter,
    }
    
    var err error
    
    // å†…å­˜ä½¿ç”¨é‡
    mm.usage, err = meter.Int64ObservableUpDownCounter(
        "system.memory.usage",
        metric.WithDescription("Memory usage"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºå†…å­˜ä½¿ç”¨é‡æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // å†…å­˜åˆ©ç”¨ç‡
    mm.utilization, err = meter.Float64ObservableGauge(
        "system.memory.utilization",
        metric.WithDescription("Memory utilization"),
        metric.WithUnit("1"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºå†…å­˜åˆ©ç”¨ç‡æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // äº¤æ¢ç©ºé—´ä½¿ç”¨é‡
    mm.swapUsage, err = meter.Int64ObservableUpDownCounter(
        "system.paging.usage",
        metric.WithDescription("Swap usage"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºäº¤æ¢ç©ºé—´ä½¿ç”¨é‡æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // äº¤æ¢ç©ºé—´åˆ©ç”¨ç‡
    mm.swapUtilization, err = meter.Float64ObservableGauge(
        "system.paging.utilization",
        metric.WithDescription("Swap utilization"),
        metric.WithUnit("1"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºäº¤æ¢ç©ºé—´åˆ©ç”¨ç‡æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // åˆ†é¡µæ“ä½œ
    mm.pagingOps, err = meter.Int64ObservableCounter(
        "system.paging.operations",
        metric.WithDescription("Paging operations"),
        metric.WithUnit("{operation}"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºåˆ†é¡µæ“ä½œæŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // æ³¨å†Œå›è°ƒ
    if _, err := meter.RegisterCallback(mm.observeMemory,
        mm.usage,
        mm.utilization,
        mm.swapUsage,
        mm.swapUtilization,
        mm.pagingOps,
    ); err != nil {
        return nil, fmt.Errorf("æ³¨å†Œå†…å­˜æŒ‡æ ‡å›è°ƒå¤±è´¥: %w", err)
    }
    
    return mm, nil
}

// observeMemory è§‚å¯Ÿå†…å­˜æŒ‡æ ‡
func (mm *MemoryMetrics) observeMemory(ctx context.Context, observer metric.Observer) error {
    // è™šæ‹Ÿå†…å­˜
    vmem, err := mem.VirtualMemoryWithContext(ctx)
    if err != nil {
        return fmt.Errorf("è·å–è™šæ‹Ÿå†…å­˜ä¿¡æ¯å¤±è´¥: %w", err)
    }
    
    // å†…å­˜ä½¿ç”¨é‡
    observer.ObserveInt64(mm.usage, int64(vmem.Used),
        metric.WithAttributes(attribute.String("state", "used")))
    observer.ObserveInt64(mm.usage, int64(vmem.Free),
        metric.WithAttributes(attribute.String("state", "free")))
    observer.ObserveInt64(mm.usage, int64(vmem.Cached),
        metric.WithAttributes(attribute.String("state", "cached")))
    observer.ObserveInt64(mm.usage, int64(vmem.Buffers),
        metric.WithAttributes(attribute.String("state", "buffered")))
    
    // å†…å­˜åˆ©ç”¨ç‡
    observer.ObserveFloat64(mm.utilization, vmem.UsedPercent/100.0,
        metric.WithAttributes(attribute.String("state", "used")))
    observer.ObserveFloat64(mm.utilization, (100.0-vmem.UsedPercent)/100.0,
        metric.WithAttributes(attribute.String("state", "free")))
    
    // äº¤æ¢ç©ºé—´
    swap, err := mem.SwapMemoryWithContext(ctx)
    if err == nil {
        observer.ObserveInt64(mm.swapUsage, int64(swap.Used),
            metric.WithAttributes(attribute.String("state", "used")))
        observer.ObserveInt64(mm.swapUsage, int64(swap.Free),
            metric.WithAttributes(attribute.String("state", "free")))
        
        observer.ObserveFloat64(mm.swapUtilization, swap.UsedPercent/100.0,
            metric.WithAttributes(attribute.String("state", "used")))
        
        // åˆ†é¡µæ“ä½œ
        observer.ObserveInt64(mm.pagingOps, int64(swap.Sin),
            metric.WithAttributes(
                attribute.String("direction", "in"),
                attribute.String("type", "major"),
            ))
        observer.ObserveInt64(mm.pagingOps, int64(swap.Sout),
            metric.WithAttributes(
                attribute.String("direction", "out"),
                attribute.String("type", "major"),
            ))
    }
    
    return nil
}
```

---

## 4. ç£ç›˜æŒ‡æ ‡

### 4.1 ç£ç›˜ I/O

**æŒ‡æ ‡åç§°**ï¼š`system.disk.io`

**æè¿°**ï¼šç£ç›˜ I/O å­—èŠ‚æ•°

**å•ä½**ï¼š`By`

**æŒ‡æ ‡ç±»å‹**ï¼šCounter

**å¿…éœ€å±æ€§**ï¼š

- `device`ï¼šè®¾å¤‡åç§°ï¼ˆå¦‚ `"sda"`, `"nvme0n1"`ï¼‰
- `direction`ï¼šæ–¹å‘
  - `"read"`ï¼šè¯»å–
  - `"write"`ï¼šå†™å…¥

**æŒ‡æ ‡åç§°**ï¼š`system.disk.operations`

**æè¿°**ï¼šç£ç›˜æ“ä½œæ¬¡æ•°

**å•ä½**ï¼š`{operation}`

**æŒ‡æ ‡ç±»å‹**ï¼šCounter

**å¿…éœ€å±æ€§**ï¼š

- `device`ï¼šè®¾å¤‡åç§°
- `direction`ï¼š`"read"` / `"write"`

### 4.2 ç£ç›˜ç©ºé—´

**æŒ‡æ ‡åç§°**ï¼š`system.filesystem.usage`

**æè¿°**ï¼šæ–‡ä»¶ç³»ç»Ÿä½¿ç”¨é‡ï¼ˆå­—èŠ‚ï¼‰

**å•ä½**ï¼š`By`

**æŒ‡æ ‡ç±»å‹**ï¼šUpDownCounter

**å¿…éœ€å±æ€§**ï¼š

- `device`ï¼šè®¾å¤‡åç§°
- `mountpoint`ï¼šæŒ‚è½½ç‚¹ï¼ˆå¦‚ `"/"`, `"/data"`ï¼‰
- `type`ï¼šæ–‡ä»¶ç³»ç»Ÿç±»å‹ï¼ˆå¦‚ `"ext4"`, `"xfs"`, `"ntfs"`ï¼‰
- `mode`ï¼šæŒ‚è½½æ¨¡å¼ï¼ˆ`"rw"` / `"ro"`ï¼‰
- `state`ï¼š`"used"` / `"free"` / `"reserved"`

**æŒ‡æ ‡åç§°**ï¼š`system.filesystem.utilization`

**æè¿°**ï¼šæ–‡ä»¶ç³»ç»Ÿä½¿ç”¨ç‡

**å•ä½**ï¼š`1`

**æŒ‡æ ‡ç±»å‹**ï¼šGauge

### 4.3 ç£ç›˜å»¶è¿Ÿ

**æŒ‡æ ‡åç§°**ï¼š`system.disk.operation_time`

**æè¿°**ï¼šç£ç›˜æ“ä½œå»¶è¿Ÿ

**å•ä½**ï¼š`s`

**æŒ‡æ ‡ç±»å‹**ï¼šCounterï¼ˆç´¯è®¡æ—¶é—´ï¼‰

**å¿…éœ€å±æ€§**ï¼š

- `device`ï¼šè®¾å¤‡åç§°
- `direction`ï¼š`"read"` / `"write"`

### 4.4 Go å®ç°

```go
package systemmetrics

import (
    "context"
    "fmt"

    "github.com/shirou/gopsutil/v3/disk"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// DiskMetrics ç®¡ç†ç£ç›˜æŒ‡æ ‡
type DiskMetrics struct {
    meter         metric.Meter
    io            metric.Int64ObservableCounter
    operations    metric.Int64ObservableCounter
    opTime        metric.Float64ObservableCounter
    fsUsage       metric.Int64ObservableUpDownCounter
    fsUtilization metric.Float64ObservableGauge
}

// NewDiskMetrics åˆ›å»ºç£ç›˜æŒ‡æ ‡æ”¶é›†å™¨
func NewDiskMetrics() (*DiskMetrics, error) {
    meter := otel.Meter("system.disk")
    
    dm := &DiskMetrics{
        meter: meter,
    }
    
    var err error
    
    // ç£ç›˜ I/O
    dm.io, err = meter.Int64ObservableCounter(
        "system.disk.io",
        metric.WithDescription("Disk I/O bytes"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºç£ç›˜ I/O æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // ç£ç›˜æ“ä½œæ¬¡æ•°
    dm.operations, err = meter.Int64ObservableCounter(
        "system.disk.operations",
        metric.WithDescription("Disk operations"),
        metric.WithUnit("{operation}"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºç£ç›˜æ“ä½œæ¬¡æ•°æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // ç£ç›˜æ“ä½œæ—¶é—´
    dm.opTime, err = meter.Float64ObservableCounter(
        "system.disk.operation_time",
        metric.WithDescription("Disk operation time"),
        metric.WithUnit("s"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºç£ç›˜æ“ä½œæ—¶é—´æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // æ–‡ä»¶ç³»ç»Ÿä½¿ç”¨é‡
    dm.fsUsage, err = meter.Int64ObservableUpDownCounter(
        "system.filesystem.usage",
        metric.WithDescription("Filesystem usage"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºæ–‡ä»¶ç³»ç»Ÿä½¿ç”¨é‡æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // æ–‡ä»¶ç³»ç»Ÿåˆ©ç”¨ç‡
    dm.fsUtilization, err = meter.Float64ObservableGauge(
        "system.filesystem.utilization",
        metric.WithDescription("Filesystem utilization"),
        metric.WithUnit("1"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºæ–‡ä»¶ç³»ç»Ÿåˆ©ç”¨ç‡æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // æ³¨å†Œå›è°ƒ
    if _, err := meter.RegisterCallback(dm.observeDisk,
        dm.io,
        dm.operations,
        dm.opTime,
        dm.fsUsage,
        dm.fsUtilization,
    ); err != nil {
        return nil, fmt.Errorf("æ³¨å†Œç£ç›˜æŒ‡æ ‡å›è°ƒå¤±è´¥: %w", err)
    }
    
    return dm, nil
}

// observeDisk è§‚å¯Ÿç£ç›˜æŒ‡æ ‡
func (dm *DiskMetrics) observeDisk(ctx context.Context, observer metric.Observer) error {
    // ç£ç›˜ I/O ç»Ÿè®¡
    ioCounters, err := disk.IOCountersWithContext(ctx)
    if err != nil {
        return fmt.Errorf("è·å–ç£ç›˜ I/O ç»Ÿè®¡å¤±è´¥: %w", err)
    }
    
    for device, stat := range ioCounters {
        deviceAttr := attribute.String("device", device)
        
        // I/O å­—èŠ‚æ•°
        observer.ObserveInt64(dm.io, int64(stat.ReadBytes),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "read")))
        observer.ObserveInt64(dm.io, int64(stat.WriteBytes),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "write")))
        
        // æ“ä½œæ¬¡æ•°
        observer.ObserveInt64(dm.operations, int64(stat.ReadCount),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "read")))
        observer.ObserveInt64(dm.operations, int64(stat.WriteCount),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "write")))
        
        // æ“ä½œæ—¶é—´ï¼ˆæ¯«ç§’è½¬ç§’ï¼‰
        observer.ObserveFloat64(dm.opTime, float64(stat.ReadTime)/1000.0,
            metric.WithAttributes(deviceAttr, attribute.String("direction", "read")))
        observer.ObserveFloat64(dm.opTime, float64(stat.WriteTime)/1000.0,
            metric.WithAttributes(deviceAttr, attribute.String("direction", "write")))
    }
    
    // æ–‡ä»¶ç³»ç»Ÿä½¿ç”¨æƒ…å†µ
    partitions, err := disk.PartitionsWithContext(ctx, false)
    if err != nil {
        return fmt.Errorf("è·å–åˆ†åŒºä¿¡æ¯å¤±è´¥: %w", err)
    }
    
    for _, partition := range partitions {
        usage, err := disk.UsageWithContext(ctx, partition.Mountpoint)
        if err != nil {
            continue
        }
        
        attrs := []attribute.KeyValue{
            attribute.String("device", partition.Device),
            attribute.String("mountpoint", partition.Mountpoint),
            attribute.String("type", partition.Fstype),
        }
        
        // ä½¿ç”¨é‡
        observer.ObserveInt64(dm.fsUsage, int64(usage.Used),
            metric.WithAttributes(append(attrs, attribute.String("state", "used"))...))
        observer.ObserveInt64(dm.fsUsage, int64(usage.Free),
            metric.WithAttributes(append(attrs, attribute.String("state", "free"))...))
        
        // åˆ©ç”¨ç‡
        observer.ObserveFloat64(dm.fsUtilization, usage.UsedPercent/100.0,
            metric.WithAttributes(attrs...))
    }
    
    return nil
}
```

---

## 5. ç½‘ç»œæŒ‡æ ‡

### 5.1 ç½‘ç»œæµé‡

**æŒ‡æ ‡åç§°**ï¼š`system.network.io`

**æè¿°**ï¼šç½‘ç»œ I/O å­—èŠ‚æ•°

**å•ä½**ï¼š`By`

**æŒ‡æ ‡ç±»å‹**ï¼šCounter

**å¿…éœ€å±æ€§**ï¼š

- `device`ï¼šç½‘ç»œæ¥å£åç§°ï¼ˆå¦‚ `"eth0"`, `"wlan0"`ï¼‰
- `direction`ï¼š`"transmit"` / `"receive"`

**æŒ‡æ ‡åç§°**ï¼š`system.network.packets`

**æè¿°**ï¼šç½‘ç»œåŒ…æ•°é‡

**å•ä½**ï¼š`{packet}`

**æŒ‡æ ‡ç±»å‹**ï¼šCounter

**å¿…éœ€å±æ€§**ï¼š

- `device`ï¼šç½‘ç»œæ¥å£åç§°
- `direction`ï¼š`"transmit"` / `"receive"`

### 5.2 ç½‘ç»œè¿æ¥

**æŒ‡æ ‡åç§°**ï¼š`system.network.connections`

**æè¿°**ï¼šç½‘ç»œè¿æ¥æ•°

**å•ä½**ï¼š`{connection}`

**æŒ‡æ ‡ç±»å‹**ï¼šUpDownCounter

**å¿…éœ€å±æ€§**ï¼š

- `protocol`ï¼šåè®®ï¼ˆ`"tcp"` / `"udp"`ï¼‰
- `state`ï¼šè¿æ¥çŠ¶æ€
  - `"close"`
  - `"close_wait"`
  - `"closing"`
  - `"established"`
  - `"fin_wait_1"`
  - `"fin_wait_2"`
  - `"last_ack"`
  - `"listen"`
  - `"syn_recv"`
  - `"syn_sent"`
  - `"time_wait"`

### 5.3 ç½‘ç»œé”™è¯¯

**æŒ‡æ ‡åç§°**ï¼š`system.network.errors`

**æè¿°**ï¼šç½‘ç»œé”™è¯¯æ•°

**å•ä½**ï¼š`{error}`

**æŒ‡æ ‡ç±»å‹**ï¼šCounter

**å¿…éœ€å±æ€§**ï¼š

- `device`ï¼šç½‘ç»œæ¥å£åç§°
- `direction`ï¼š`"transmit"` / `"receive"`

**æŒ‡æ ‡åç§°**ï¼š`system.network.dropped`

**æè¿°**ï¼šä¸¢å¼ƒçš„ç½‘ç»œåŒ…æ•°

**å•ä½**ï¼š`{packet}`

**æŒ‡æ ‡ç±»å‹**ï¼šCounter

**å¿…éœ€å±æ€§**ï¼š

- `device`ï¼šç½‘ç»œæ¥å£åç§°
- `direction`ï¼š`"transmit"` / `"receive"`

### 5.4 Go å®ç°

```go
package systemmetrics

import (
    "context"
    "fmt"

    "github.com/shirou/gopsutil/v3/net"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// NetworkMetrics ç®¡ç†ç½‘ç»œæŒ‡æ ‡
type NetworkMetrics struct {
    meter       metric.Meter
    io          metric.Int64ObservableCounter
    packets     metric.Int64ObservableCounter
    errors      metric.Int64ObservableCounter
    dropped     metric.Int64ObservableCounter
    connections metric.Int64ObservableUpDownCounter
}

// NewNetworkMetrics åˆ›å»ºç½‘ç»œæŒ‡æ ‡æ”¶é›†å™¨
func NewNetworkMetrics() (*NetworkMetrics, error) {
    meter := otel.Meter("system.network")
    
    nm := &NetworkMetrics{
        meter: meter,
    }
    
    var err error
    
    // ç½‘ç»œ I/O
    nm.io, err = meter.Int64ObservableCounter(
        "system.network.io",
        metric.WithDescription("Network I/O bytes"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºç½‘ç»œ I/O æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // ç½‘ç»œåŒ…
    nm.packets, err = meter.Int64ObservableCounter(
        "system.network.packets",
        metric.WithDescription("Network packets"),
        metric.WithUnit("{packet}"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºç½‘ç»œåŒ…æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // ç½‘ç»œé”™è¯¯
    nm.errors, err = meter.Int64ObservableCounter(
        "system.network.errors",
        metric.WithDescription("Network errors"),
        metric.WithUnit("{error}"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºç½‘ç»œé”™è¯¯æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // ä¸¢å¼ƒçš„åŒ…
    nm.dropped, err = meter.Int64ObservableCounter(
        "system.network.dropped",
        metric.WithDescription("Dropped network packets"),
        metric.WithUnit("{packet}"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºä¸¢å¼ƒåŒ…æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // ç½‘ç»œè¿æ¥
    nm.connections, err = meter.Int64ObservableUpDownCounter(
        "system.network.connections",
        metric.WithDescription("Network connections"),
        metric.WithUnit("{connection}"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºç½‘ç»œè¿æ¥æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // æ³¨å†Œå›è°ƒ
    if _, err := meter.RegisterCallback(nm.observeNetwork,
        nm.io,
        nm.packets,
        nm.errors,
        nm.dropped,
        nm.connections,
    ); err != nil {
        return nil, fmt.Errorf("æ³¨å†Œç½‘ç»œæŒ‡æ ‡å›è°ƒå¤±è´¥: %w", err)
    }
    
    return nm, nil
}

// observeNetwork è§‚å¯Ÿç½‘ç»œæŒ‡æ ‡
func (nm *NetworkMetrics) observeNetwork(ctx context.Context, observer metric.Observer) error {
    // ç½‘ç»œ I/O ç»Ÿè®¡
    ioCounters, err := net.IOCountersWithContext(ctx, true)
    if err != nil {
        return fmt.Errorf("è·å–ç½‘ç»œ I/O ç»Ÿè®¡å¤±è´¥: %w", err)
    }
    
    for _, stat := range ioCounters {
        deviceAttr := attribute.String("device", stat.Name)
        
        // I/O å­—èŠ‚æ•°
        observer.ObserveInt64(nm.io, int64(stat.BytesRecv),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "receive")))
        observer.ObserveInt64(nm.io, int64(stat.BytesSent),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "transmit")))
        
        // åŒ…æ•°
        observer.ObserveInt64(nm.packets, int64(stat.PacketsRecv),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "receive")))
        observer.ObserveInt64(nm.packets, int64(stat.PacketsSent),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "transmit")))
        
        // é”™è¯¯æ•°
        observer.ObserveInt64(nm.errors, int64(stat.Errin),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "receive")))
        observer.ObserveInt64(nm.errors, int64(stat.Errout),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "transmit")))
        
        // ä¸¢å¼ƒçš„åŒ…
        observer.ObserveInt64(nm.dropped, int64(stat.Dropin),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "receive")))
        observer.ObserveInt64(nm.dropped, int64(stat.Dropout),
            metric.WithAttributes(deviceAttr, attribute.String("direction", "transmit")))
    }
    
    // ç½‘ç»œè¿æ¥ç»Ÿè®¡
    connections, err := net.ConnectionsWithContext(ctx, "all")
    if err == nil {
        connMap := make(map[string]map[string]int)
        
        for _, conn := range connections {
            protocol := conn.Type
            state := conn.Status
            
            if connMap[protocol] == nil {
                connMap[protocol] = make(map[string]int)
            }
            connMap[protocol][state]++
        }
        
        for protocol, states := range connMap {
            for state, count := range states {
                observer.ObserveInt64(nm.connections, int64(count),
                    metric.WithAttributes(
                        attribute.String("protocol", string(protocol)),
                        attribute.String("state", state),
                    ))
            }
        }
    }
    
    return nil
}
```

---

## 6. å®Œæ•´ç¤ºä¾‹

### 6.1 ç³»ç»Ÿç›‘æ§å™¨

```go
package main

import (
    "context"
    "log"
    "os"
    "os/signal"
    "syscall"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
    "go.opentelemetry.io/otel/sdk/metric"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
)

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    // åˆ›å»ºèµ„æº
    res, err := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName("system-monitor"),
            semconv.ServiceVersion("1.0.0"),
        ),
    )
    if err != nil {
        log.Fatalf("åˆ›å»ºèµ„æºå¤±è´¥: %v", err)
    }
    
    // åˆ›å»º OTLP å¯¼å‡ºå™¨
    exporter, err := otlpmetricgrpc.New(ctx,
        otlpmetricgrpc.WithInsecure(),
        otlpmetricgrpc.WithEndpoint("localhost:4317"),
    )
    if err != nil {
        log.Fatalf("åˆ›å»ºå¯¼å‡ºå™¨å¤±è´¥: %v", err)
    }
    defer exporter.Shutdown(ctx)
    
    // åˆ›å»º Meter Provider
    provider := metric.NewMeterProvider(
        metric.WithResource(res),
        metric.WithReader(metric.NewPeriodicReader(exporter,
            metric.WithInterval(10*time.Second),
        )),
    )
    defer provider.Shutdown(ctx)
    
    otel.SetMeterProvider(provider)
    
    // åˆå§‹åŒ–ç³»ç»ŸæŒ‡æ ‡æ”¶é›†å™¨
    if _, err := NewCPUMetrics(); err != nil {
        log.Fatalf("åˆå§‹åŒ– CPU æŒ‡æ ‡å¤±è´¥: %v", err)
    }
    
    if _, err := NewMemoryMetrics(); err != nil {
        log.Fatalf("åˆå§‹åŒ–å†…å­˜æŒ‡æ ‡å¤±è´¥: %v", err)
    }
    
    if _, err := NewDiskMetrics(); err != nil {
        log.Fatalf("åˆå§‹åŒ–ç£ç›˜æŒ‡æ ‡å¤±è´¥: %v", err)
    }
    
    if _, err := NewNetworkMetrics(); err != nil {
        log.Fatalf("åˆå§‹åŒ–ç½‘ç»œæŒ‡æ ‡å¤±è´¥: %v", err)
    }
    
    log.Println("ç³»ç»Ÿç›‘æ§å¯åŠ¨ï¼ŒæŒ‰ Ctrl+C é€€å‡º")
    
    // ç­‰å¾…ä¿¡å·
    sigCh := make(chan os.Signal, 1)
    signal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)
    <-sigCh
    
    log.Println("æ­£åœ¨å…³é—­ç³»ç»Ÿç›‘æ§...")
}
```

### 6.2 è·¨å¹³å°å…¼å®¹æ€§

```go
// +build linux darwin

package systemmetrics

import (
    "golang.org/x/sys/unix"
)

// getPlatformSpecificMetrics è·å–å¹³å°ç‰¹å®šæŒ‡æ ‡ï¼ˆUnix/Linuxï¼‰
func getPlatformSpecificMetrics() error {
    var sysinfo unix.Sysinfo_t
    if err := unix.Sysinfo(&sysinfo); err != nil {
        return err
    }
    
    // Linux ç‰¹å®šæŒ‡æ ‡
    // ...
    
    return nil
}
```

```go
// +build windows

package systemmetrics

import (
    "golang.org/x/sys/windows"
)

// getPlatformSpecificMetrics è·å–å¹³å°ç‰¹å®šæŒ‡æ ‡ï¼ˆWindowsï¼‰
func getPlatformSpecificMetrics() error {
    // Windows ç‰¹å®šæŒ‡æ ‡
    // ä½¿ç”¨ windows åŒ…æˆ– WMI
    
    return nil
}
```

### 6.3 å®¹å™¨ç¯å¢ƒ

åœ¨å®¹å™¨ç¯å¢ƒä¸­ï¼Œç³»ç»ŸæŒ‡æ ‡éœ€è¦ç‰¹æ®Šå¤„ç†ï¼š

```go
package systemmetrics

import (
    "os"
    "strconv"
    "strings"
)

// isContainer æ£€æµ‹æ˜¯å¦è¿è¡Œåœ¨å®¹å™¨ä¸­
func isContainer() bool {
    // æ£€æŸ¥ /.dockerenv æ–‡ä»¶
    if _, err := os.Stat("/.dockerenv"); err == nil {
        return true
    }
    
    // æ£€æŸ¥ cgroup
    data, err := os.ReadFile("/proc/1/cgroup")
    if err == nil {
        content := string(data)
        return strings.Contains(content, "docker") ||
               strings.Contains(content, "kubepods") ||
               strings.Contains(content, "containerd")
    }
    
    return false
}

// getContainerCPUQuota è·å–å®¹å™¨ CPU é…é¢
func getContainerCPUQuota() (quota, period int64, err error) {
    // è¯»å– CPU é…é¢ï¼ˆcgroup v1ï¼‰
    quotaData, err := os.ReadFile("/sys/fs/cgroup/cpu/cpu.cfs_quota_us")
    if err != nil {
        // å°è¯• cgroup v2
        quotaData, err = os.ReadFile("/sys/fs/cgroup/cpu.max")
        if err != nil {
            return 0, 0, err
        }
        // cgroup v2 æ ¼å¼: "max 100000" æˆ– "50000 100000"
        parts := strings.Fields(strings.TrimSpace(string(quotaData)))
        if parts[0] != "max" {
            quota, _ = strconv.ParseInt(parts[0], 10, 64)
        }
        if len(parts) > 1 {
            period, _ = strconv.ParseInt(parts[1], 10, 64)
        }
        return quota, period, nil
    }
    
    // cgroup v1
    quota, _ = strconv.ParseInt(strings.TrimSpace(string(quotaData)), 10, 64)
    
    periodData, err := os.ReadFile("/sys/fs/cgroup/cpu/cpu.cfs_period_us")
    if err != nil {
        return quota, 0, err
    }
    period, _ = strconv.ParseInt(strings.TrimSpace(string(periodData)), 10, 64)
    
    return quota, period, nil
}

// getContainerMemoryLimit è·å–å®¹å™¨å†…å­˜é™åˆ¶
func getContainerMemoryLimit() (int64, error) {
    // cgroup v1
    data, err := os.ReadFile("/sys/fs/cgroup/memory/memory.limit_in_bytes")
    if err != nil {
        // å°è¯• cgroup v2
        data, err = os.ReadFile("/sys/fs/cgroup/memory.max")
        if err != nil {
            return 0, err
        }
    }
    
    limitStr := strings.TrimSpace(string(data))
    if limitStr == "max" {
        return 0, nil // æ— é™åˆ¶
    }
    
    limit, err := strconv.ParseInt(limitStr, 10, 64)
    return limit, err
}
```

---

## 7. æœ€ä½³å®è·µ

### 7.1 é‡‡é›†é¢‘ç‡

| æŒ‡æ ‡ç±»å‹ | æ¨èé¢‘ç‡ | è¯´æ˜ |
|---------|---------|------|
| CPU | 10-30 ç§’ | å¹³è¡¡ç²¾åº¦å’Œå¼€é”€ |
| å†…å­˜ | 30-60 ç§’ | å˜åŒ–ç›¸å¯¹ç¼“æ…¢ |
| ç£ç›˜ | 30-60 ç§’ | I/O ç»Ÿè®¡æ›´æ–°è¾ƒæ…¢ |
| ç½‘ç»œ | 10-30 ç§’ | æµé‡å˜åŒ–è¾ƒå¿« |
| è¿æ¥æ•° | 60 ç§’ | ç»Ÿè®¡å¼€é”€è¾ƒå¤§ |

**åŠ¨æ€è°ƒæ•´**ï¼š

```go
type AdaptiveCollector struct {
    baseInterval time.Duration
    maxInterval  time.Duration
    minInterval  time.Duration
    currentInterval time.Duration
}

func (ac *AdaptiveCollector) adjustInterval(changeRate float64) {
    // å˜åŒ–ç‡é«˜æ—¶å¢åŠ é‡‡é›†é¢‘ç‡
    if changeRate > 0.1 {
        ac.currentInterval = max(ac.minInterval, ac.currentInterval/2)
    } else {
        ac.currentInterval = min(ac.maxInterval, ac.currentInterval*2)
    }
}
```

### 7.2 æŒ‡æ ‡èšåˆ

ä½¿ç”¨ OpenTelemetry View è¿›è¡ŒæŒ‡æ ‡èšåˆï¼š

```go
import (
    "go.opentelemetry.io/otel/sdk/metric"
)

func setupViews() []metric.View {
    return []metric.View{
        // CPU ä½¿ç”¨ç‡æŒ‰ CPU æ ¸å¿ƒèšåˆ
        metric.NewView(
            metric.Instrument{Name: "system.cpu.utilization"},
            metric.Stream{
                Aggregation: metric.AggregationLastValue{},
            },
        ),
        // å†…å­˜ä½¿ç”¨é‡ä½¿ç”¨ç›´æ–¹å›¾
        metric.NewView(
            metric.Instrument{Name: "system.memory.usage"},
            metric.Stream{
                Aggregation: metric.AggregationExplicitBucketHistogram{
                    Boundaries: []float64{
                        1 << 20,  // 1 MB
                        1 << 24,  // 16 MB
                        1 << 28,  // 256 MB
                        1 << 30,  // 1 GB
                        1 << 32,  // 4 GB
                        1 << 34,  // 16 GB
                    },
                },
            },
        ),
    }
}
```

### 7.3 å‘Šè­¦é˜ˆå€¼

**æ¨èé˜ˆå€¼**ï¼š

| æŒ‡æ ‡ | è­¦å‘Š | ä¸¥é‡ |
|-----|------|------|
| CPU ä½¿ç”¨ç‡ | > 70% | > 90% |
| å†…å­˜ä½¿ç”¨ç‡ | > 80% | > 95% |
| ç£ç›˜ä½¿ç”¨ç‡ | > 80% | > 90% |
| ç£ç›˜ I/O ç­‰å¾… | > 10% | > 20% |
| è´Ÿè½½å¹³å‡å€¼ | > CPU æ ¸å¿ƒæ•° Ã— 0.7 | > CPU æ ¸å¿ƒæ•° |
| ç½‘ç»œé”™è¯¯ç‡ | > 0.1% | > 1% |

**å‘Šè­¦è§„åˆ™ï¼ˆPrometheus æ ¼å¼ï¼‰**ï¼š

```yaml
groups:
  - name: system_alerts
    interval: 30s
    rules:
      - alert: HighCPUUsage
        expr: system_cpu_utilization{state="used"} > 0.9
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "é«˜ CPU ä½¿ç”¨ç‡"
          description: "CPU ä½¿ç”¨ç‡ {{ $value | humanizePercentage }} è¶…è¿‡ 90%"
      
      - alert: HighMemoryUsage
        expr: system_memory_utilization{state="used"} > 0.95
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "é«˜å†…å­˜ä½¿ç”¨ç‡"
          description: "å†…å­˜ä½¿ç”¨ç‡ {{ $value | humanizePercentage }} è¶…è¿‡ 95%"
      
      - alert: DiskSpaceLow
        expr: system_filesystem_utilization > 0.9
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "ç£ç›˜ç©ºé—´ä¸è¶³"
          description: "{{ $labels.mountpoint }} ä½¿ç”¨ç‡ {{ $value | humanizePercentage }} è¶…è¿‡ 90%"
```

### 7.4 æ€§èƒ½ä¼˜åŒ–

**1. ç¼“å­˜ç³»ç»Ÿä¿¡æ¯**ï¼š

```go
type CachedSystemInfo struct {
    cpuCount    int
    hostname    string
    os          string
    arch        string
    cachedAt    time.Time
    cacheTTL    time.Duration
}

func (csi *CachedSystemInfo) getCPUCount() int {
    if time.Since(csi.cachedAt) > csi.cacheTTL {
        csi.cpuCount = runtime.NumCPU()
        csi.cachedAt = time.Now()
    }
    return csi.cpuCount
}
```

**2. æ‰¹é‡é‡‡é›†**ï¼š

```go
type BatchCollector struct {
    collectors []MetricCollector
}

func (bc *BatchCollector) collectAll(ctx context.Context) error {
    var g errgroup.Group
    
    for _, collector := range bc.collectors {
        collector := collector // é¿å…é—­åŒ…é—®é¢˜
        g.Go(func() error {
            return collector.Collect(ctx)
        })
    }
    
    return g.Wait()
}
```

**3. å¢é‡é‡‡é›†**ï¼š

```go
type DeltaCollector struct {
    lastValue map[string]uint64
    mu        sync.RWMutex
}

func (dc *DeltaCollector) recordDelta(name string, current uint64) uint64 {
    dc.mu.Lock()
    defer dc.mu.Unlock()
    
    last := dc.lastValue[name]
    dc.lastValue[name] = current
    
    if last == 0 {
        return 0 // é¦–æ¬¡é‡‡é›†
    }
    return current - last
}
```

---

## 8. å¸¸è§é—®é¢˜

**Q1: ä¸ºä»€ä¹ˆ CPU ä½¿ç”¨ç‡æ€»å’Œä¸ç­‰äº 100%ï¼Ÿ**

A: æ¯ä¸ª CPU æ ¸å¿ƒå•ç‹¬æŠ¥å‘Šä½¿ç”¨ç‡ï¼Œå¤šæ ¸ç³»ç»Ÿçš„æ€»ä½¿ç”¨ç‡æ˜¯æ‰€æœ‰æ ¸å¿ƒçš„å¹³å‡å€¼ã€‚ä¾‹å¦‚ï¼Œ4 æ ¸ç³»ç»Ÿä¸­ 2 ä¸ªæ ¸å¿ƒæ»¡è½½ï¼Œæ€»ä½¿ç”¨ç‡ä¸º 50%ã€‚

**Q2: å®¹å™¨ä¸­çš„å†…å­˜æŒ‡æ ‡ä¸å‡†ç¡®ï¼Ÿ**

A: å®¹å™¨ç¯å¢ƒä¸­åº”è¯»å– cgroup é™åˆ¶ï¼Œè€Œä¸æ˜¯å®¿ä¸»æœºçš„æ€»å†…å­˜ï¼š

```go
func getEffectiveMemoryLimit() uint64 {
    if isContainer() {
        if limit, err := getContainerMemoryLimit(); err == nil && limit > 0 {
            return uint64(limit)
        }
    }
    // å›é€€åˆ°ç³»ç»Ÿæ€»å†…å­˜
    vmem, _ := mem.VirtualMemory()
    return vmem.Total
}
```

**Q3: ç£ç›˜ I/O æŒ‡æ ‡æ€»æ˜¯å¢é•¿ï¼Ÿ**

A: `system.disk.io` æ˜¯ç´¯è®¡è®¡æ•°å™¨ï¼ˆCounterï¼‰ï¼Œåº”ä½¿ç”¨å¯¼æ•°è®¡ç®—é€Ÿç‡ï¼š

```text
rate(system_disk_io[1m])  # Prometheus æŸ¥è¯¢
```

**Q4: å¦‚ä½•ç›‘æ§ NVMe ç£ç›˜ï¼Ÿ**

A: NVMe ç£ç›˜è®¾å¤‡åé€šå¸¸ä¸º `nvme0n1`, `nvme1n1`ï¼Œç¡®ä¿è®¾å¤‡è¿‡æ»¤è§„åˆ™åŒ…å«ï¼š

```go
func isMonitoredDevice(name string) bool {
    return strings.HasPrefix(name, "sd") ||   // SATA/SCSI
           strings.HasPrefix(name, "nvme") || // NVMe
           strings.HasPrefix(name, "vd") ||   // è™šæ‹Ÿç£ç›˜
           strings.HasPrefix(name, "hd")      // IDE (legacy)
}
```

**Q5: å¦‚ä½•å‡å°‘ç½‘ç»œè¿æ¥ç»Ÿè®¡çš„å¼€é”€ï¼Ÿ**

A: ç½‘ç»œè¿æ¥ç»Ÿè®¡ï¼ˆç‰¹åˆ«æ˜¯ `net.Connections`ï¼‰å¼€é”€è¾ƒå¤§ï¼Œå¯ä»¥ï¼š

1. é™ä½é‡‡é›†é¢‘ç‡ï¼ˆ60 ç§’æˆ–æ›´é•¿ï¼‰
2. ä»…ç»Ÿè®¡ç‰¹å®šçŠ¶æ€ï¼ˆå¦‚ `ESTABLISHED`ï¼‰
3. ä½¿ç”¨é‡‡æ ·ç­–ç•¥

```go
func observeConnectionsSampled(ctx context.Context, sampleRate float64) error {
    if rand.Float64() > sampleRate {
        return nil // è·³è¿‡æœ¬æ¬¡é‡‡é›†
    }
    return observeConnections(ctx)
}
```

**Q6: Go 1.25.1 æœ‰å“ªäº›ç³»ç»ŸæŒ‡æ ‡ç›¸å…³çš„æ–°ç‰¹æ€§ï¼Ÿ**

A: Go 1.25.1 å¢å¼ºäº† `runtime/metrics` åŒ…ï¼Œæä¾›æ›´è¯¦ç»†çš„è¿è¡Œæ—¶æŒ‡æ ‡ï¼ˆè¯¦è§ä¸‹ä¸€ç¯‡æ–‡æ¡£ã€Šè¿è¡Œæ—¶æŒ‡æ ‡ã€‹ï¼‰ã€‚

---

## æ€»ç»“

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº† OpenTelemetry ç³»ç»ŸæŒ‡æ ‡çš„è¯­ä¹‰çº¦å®šå’Œ Go 1.25.1 å®ç°æ–¹æ¡ˆï¼Œæ¶µç›–ï¼š

âœ… **CPU æŒ‡æ ‡**ï¼šä½¿ç”¨ç‡ã€æ—¶é—´ã€è´Ÿè½½å¹³å‡å€¼  
âœ… **å†…å­˜æŒ‡æ ‡**ï¼šä½¿ç”¨é‡ã€åˆ©ç”¨ç‡ã€äº¤æ¢ç©ºé—´  
âœ… **ç£ç›˜æŒ‡æ ‡**ï¼šI/Oã€ç©ºé—´ã€å»¶è¿Ÿ  
âœ… **ç½‘ç»œæŒ‡æ ‡**ï¼šæµé‡ã€è¿æ¥ã€é”™è¯¯  
âœ… **å®Œæ•´ç¤ºä¾‹**ï¼šè·¨å¹³å°ã€å®¹å™¨ç¯å¢ƒ  
âœ… **æœ€ä½³å®è·µ**ï¼šé‡‡é›†é¢‘ç‡ã€èšåˆã€å‘Šè­¦ã€ä¼˜åŒ–  

**ä¸‹ä¸€æ­¥**ï¼š

- ğŸ“– é˜…è¯»ã€Šè¿è¡Œæ—¶æŒ‡æ ‡ã€‹å­¦ä¹  Go runtime ç›‘æ§
- ğŸ“– é˜…è¯»ã€ŠHTTP æŒ‡æ ‡ã€‹å­¦ä¹ åº”ç”¨å±‚æŒ‡æ ‡
- ğŸ”— å‚è€ƒ [gopsutil æ–‡æ¡£](https://github.com/shirou/gopsutil)

**å‚è€ƒèµ„æº**ï¼š

- [OpenTelemetry System Metrics Semantic Conventions](https://opentelemetry.io/docs/specs/semconv/system/system-metrics/)
- [gopsutil - psutil for golang](https://github.com/shirou/gopsutil)
- [Prometheus Node Exporter](https://github.com/prometheus/node_exporter)
