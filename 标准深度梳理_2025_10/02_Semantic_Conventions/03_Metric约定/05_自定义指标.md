# è‡ªå®šä¹‰æŒ‡æ ‡ä¸ä¸šåŠ¡æŒ‡æ ‡ï¼ˆCustom & Business Metricsï¼‰

## ç›®å½•

- [è‡ªå®šä¹‰æŒ‡æ ‡ä¸ä¸šåŠ¡æŒ‡æ ‡ï¼ˆCustom \& Business Metricsï¼‰](#è‡ªå®šä¹‰æŒ‡æ ‡ä¸ä¸šåŠ¡æŒ‡æ ‡custom--business-metrics)
  - [ç›®å½•](#ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. ä¸šåŠ¡æŒ‡æ ‡è®¾è®¡](#2-ä¸šåŠ¡æŒ‡æ ‡è®¾è®¡)
    - [2.1 ä¸šåŠ¡ KPI æŒ‡æ ‡](#21-ä¸šåŠ¡-kpi-æŒ‡æ ‡)
    - [2.2 ç”¨æˆ·è¡Œä¸ºæŒ‡æ ‡](#22-ç”¨æˆ·è¡Œä¸ºæŒ‡æ ‡)
    - [2.3 ä¸šåŠ¡æµç¨‹æŒ‡æ ‡](#23-ä¸šåŠ¡æµç¨‹æŒ‡æ ‡)
  - [3. SLI/SLO æŒ‡æ ‡](#3-slislo-æŒ‡æ ‡)
    - [3.1 æœåŠ¡å¯ç”¨æ€§](#31-æœåŠ¡å¯ç”¨æ€§)
    - [3.2 å»¶è¿ŸæŒ‡æ ‡](#32-å»¶è¿ŸæŒ‡æ ‡)
    - [3.3 é”™è¯¯é¢„ç®—](#33-é”™è¯¯é¢„ç®—)
  - [4. Go å®ç°](#4-go-å®ç°)
    - [4.1 Counter æŒ‡æ ‡](#41-counter-æŒ‡æ ‡)
    - [4.2 Gauge æŒ‡æ ‡](#42-gauge-æŒ‡æ ‡)
    - [4.3 Histogram æŒ‡æ ‡](#43-histogram-æŒ‡æ ‡)
    - [4.4 æŒ‡æ ‡ç®¡ç†å™¨](#44-æŒ‡æ ‡ç®¡ç†å™¨)
  - [5. å®Œæ•´ç¤ºä¾‹](#5-å®Œæ•´ç¤ºä¾‹)
    - [5.1 ç”µå•†ç³»ç»Ÿ](#51-ç”µå•†ç³»ç»Ÿ)
    - [5.2 SaaS ç³»ç»Ÿ](#52-saas-ç³»ç»Ÿ)
    - [5.3 é‡‘èç³»ç»Ÿ](#53-é‡‘èç³»ç»Ÿ)
  - [6. æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)
    - [6.1 å‘½åè§„èŒƒ](#61-å‘½åè§„èŒƒ)
    - [6.2 æ ‡ç­¾è®¾è®¡](#62-æ ‡ç­¾è®¾è®¡)
    - [6.3 æ€§èƒ½ä¼˜åŒ–](#63-æ€§èƒ½ä¼˜åŒ–)
    - [6.4 å‘Šè­¦è§„åˆ™](#64-å‘Šè­¦è§„åˆ™)
  - [7. å¸¸è§æ¨¡å¼](#7-å¸¸è§æ¨¡å¼)
    - [7.1 æ¼æ–—åˆ†æ](#71-æ¼æ–—åˆ†æ)
    - [7.2 é˜Ÿåˆ—ç›‘æ§](#72-é˜Ÿåˆ—ç›‘æ§)
    - [7.3 é™æµç›‘æ§](#73-é™æµç›‘æ§)
  - [8. å¸¸è§é—®é¢˜](#8-å¸¸è§é—®é¢˜)
  - [æ€»ç»“](#æ€»ç»“)

---

## 1. æ¦‚è¿°

è‡ªå®šä¹‰æŒ‡æ ‡å’Œä¸šåŠ¡æŒ‡æ ‡æ˜¯è¿æ¥æŠ€æœ¯ç›‘æ§ä¸ä¸šåŠ¡ä»·å€¼çš„æ¡¥æ¢ã€‚ä¸ç³»ç»ŸæŒ‡æ ‡ï¼ˆCPUã€å†…å­˜ï¼‰ä¸åŒï¼Œä¸šåŠ¡æŒ‡æ ‡ç›´æ¥åæ˜ ä¸šåŠ¡å¥åº·åº¦å’Œç”¨æˆ·ä½“éªŒã€‚

**æ ¸å¿ƒä»·å€¼**ï¼š

- ğŸ“Š **ä¸šåŠ¡æ´å¯Ÿ**ï¼šå®æ—¶äº†è§£ä¸šåŠ¡è¿è¥çŠ¶æ€
- ğŸ¯ **ç›®æ ‡ç®¡ç†**ï¼šé€šè¿‡ SLI/SLO é‡åŒ–æœåŠ¡è´¨é‡
- ğŸ’¡ **å†³ç­–æ”¯æŒ**ï¼šä¸ºä¸šåŠ¡å†³ç­–æä¾›æ•°æ®æ”¯æ’‘
- ğŸš¨ **ä¸»åŠ¨å‘Šè­¦**ï¼šåœ¨å½±å“ç”¨æˆ·å‰å‘ç°é—®é¢˜

**æŒ‡æ ‡åˆ†ç±»**ï¼š

- **ä¸šåŠ¡ KPI æŒ‡æ ‡**ï¼šè®¢å•é‡ã€GMVã€æ´»è·ƒç”¨æˆ·æ•°
- **ç”¨æˆ·è¡Œä¸ºæŒ‡æ ‡**ï¼šç‚¹å‡»ç‡ã€è½¬åŒ–ç‡ã€ç•™å­˜ç‡
- **SLI/SLO æŒ‡æ ‡**ï¼šå¯ç”¨æ€§ã€å»¶è¿Ÿã€é”™è¯¯ç‡
- **ä¸šåŠ¡æµç¨‹æŒ‡æ ‡**ï¼šæ”¯ä»˜æˆåŠŸç‡ã€åº“å­˜å‡†ç¡®ç‡

---

## 2. ä¸šåŠ¡æŒ‡æ ‡è®¾è®¡

### 2.1 ä¸šåŠ¡ KPI æŒ‡æ ‡

**ç”µå•†æ ¸å¿ƒæŒ‡æ ‡**ï¼š

```go
package businessmetrics

import (
    "context"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// EcommerceMetrics ç”µå•†æŒ‡æ ‡
type EcommerceMetrics struct {
    // è®¢å•æŒ‡æ ‡
    ordersTotal     metric.Int64Counter      // æ€»è®¢å•æ•°
    ordersValue     metric.Float64Counter    // è®¢å•æ€»é‡‘é¢ï¼ˆGMVï¼‰
    ordersCancelled metric.Int64Counter      // å–æ¶ˆè®¢å•æ•°
    
    // æ”¯ä»˜æŒ‡æ ‡
    paymentsTotal   metric.Int64Counter      // æ”¯ä»˜æ¬¡æ•°
    paymentsSuccess metric.Int64Counter      // æ”¯ä»˜æˆåŠŸæ¬¡æ•°
    paymentsFailed  metric.Int64Counter      // æ”¯ä»˜å¤±è´¥æ¬¡æ•°
    paymentsAmount  metric.Float64Counter    // æ”¯ä»˜é‡‘é¢
    
    // ç”¨æˆ·æŒ‡æ ‡
    usersActive     metric.Int64ObservableUpDownCounter  // æ´»è·ƒç”¨æˆ·æ•°
    usersNew        metric.Int64Counter      // æ–°æ³¨å†Œç”¨æˆ·æ•°
    
    // å•†å“æŒ‡æ ‡
    productsViewed  metric.Int64Counter      // å•†å“æµè§ˆæ¬¡æ•°
    productsAdded   metric.Int64Counter      // åŠ å…¥è´­ç‰©è½¦æ¬¡æ•°
}

func NewEcommerceMetrics() (*EcommerceMetrics, error) {
    meter := otel.Meter("business.ecommerce")
    
    em := &EcommerceMetrics{}
    var err error
    
    // è®¢å•æŒ‡æ ‡
    em.ordersTotal, err = meter.Int64Counter(
        "ecommerce.orders.total",
        metric.WithDescription("Total number of orders"),
        metric.WithUnit("{order}"),
    )
    if err != nil {
        return nil, err
    }
    
    em.ordersValue, err = meter.Float64Counter(
        "ecommerce.orders.value",
        metric.WithDescription("Total order value (GMV)"),
        metric.WithUnit("USD"),
    )
    if err != nil {
        return nil, err
    }
    
    em.ordersCancelled, err = meter.Int64Counter(
        "ecommerce.orders.cancelled",
        metric.WithDescription("Number of cancelled orders"),
        metric.WithUnit("{order}"),
    )
    if err != nil {
        return nil, err
    }
    
    // æ”¯ä»˜æŒ‡æ ‡
    em.paymentsTotal, err = meter.Int64Counter(
        "ecommerce.payments.total",
        metric.WithDescription("Total payment attempts"),
        metric.WithUnit("{payment}"),
    )
    if err != nil {
        return nil, err
    }
    
    em.paymentsSuccess, err = meter.Int64Counter(
        "ecommerce.payments.success",
        metric.WithDescription("Successful payments"),
        metric.WithUnit("{payment}"),
    )
    if err != nil {
        return nil, err
    }
    
    em.paymentsFailed, err = meter.Int64Counter(
        "ecommerce.payments.failed",
        metric.WithDescription("Failed payments"),
        metric.WithUnit("{payment}"),
    )
    if err != nil {
        return nil, err
    }
    
    em.paymentsAmount, err = meter.Float64Counter(
        "ecommerce.payments.amount",
        metric.WithDescription("Total payment amount"),
        metric.WithUnit("USD"),
    )
    if err != nil {
        return nil, err
    }
    
    // ç”¨æˆ·æŒ‡æ ‡
    em.usersNew, err = meter.Int64Counter(
        "ecommerce.users.new",
        metric.WithDescription("New registered users"),
        metric.WithUnit("{user}"),
    )
    if err != nil {
        return nil, err
    }
    
    // å•†å“æŒ‡æ ‡
    em.productsViewed, err = meter.Int64Counter(
        "ecommerce.products.viewed",
        metric.WithDescription("Product views"),
        metric.WithUnit("{view}"),
    )
    if err != nil {
        return nil, err
    }
    
    em.productsAdded, err = meter.Int64Counter(
        "ecommerce.products.added_to_cart",
        metric.WithDescription("Products added to cart"),
        metric.WithUnit("{product}"),
    )
    if err != nil {
        return nil, err
    }
    
    return em, nil
}

// RecordOrder è®°å½•è®¢å•
func (em *EcommerceMetrics) RecordOrder(ctx context.Context, orderID string, amount float64, status string) {
    attrs := []attribute.KeyValue{
        attribute.String("order.status", status),
    }
    
    em.ordersTotal.Add(ctx, 1, metric.WithAttributes(attrs...))
    em.ordersValue.Add(ctx, amount, metric.WithAttributes(attrs...))
    
    if status == "cancelled" {
        em.ordersCancelled.Add(ctx, 1)
    }
}

// RecordPayment è®°å½•æ”¯ä»˜
func (em *EcommerceMetrics) RecordPayment(ctx context.Context, amount float64, success bool, method string) {
    attrs := []attribute.KeyValue{
        attribute.String("payment.method", method),
    }
    
    em.paymentsTotal.Add(ctx, 1, metric.WithAttributes(attrs...))
    
    if success {
        em.paymentsSuccess.Add(ctx, 1, metric.WithAttributes(attrs...))
        em.paymentsAmount.Add(ctx, amount, metric.WithAttributes(attrs...))
    } else {
        em.paymentsFailed.Add(ctx, 1, metric.WithAttributes(attrs...))
    }
}
```

### 2.2 ç”¨æˆ·è¡Œä¸ºæŒ‡æ ‡

```go
// UserBehaviorMetrics ç”¨æˆ·è¡Œä¸ºæŒ‡æ ‡
type UserBehaviorMetrics struct {
    pageViews       metric.Int64Counter          // é¡µé¢æµè§ˆé‡
    buttonClicks    metric.Int64Counter          // æŒ‰é’®ç‚¹å‡»
    sessionDuration metric.Float64Histogram      // ä¼šè¯æ—¶é•¿
    searchQueries   metric.Int64Counter          // æœç´¢æŸ¥è¯¢
    apiCalls        metric.Int64Counter          // API è°ƒç”¨
}

func NewUserBehaviorMetrics() (*UserBehaviorMetrics, error) {
    meter := otel.Meter("business.user_behavior")
    
    ubm := &UserBehaviorMetrics{}
    var err error
    
    ubm.pageViews, err = meter.Int64Counter(
        "user.page_views",
        metric.WithDescription("Page views"),
        metric.WithUnit("{view}"),
    )
    if err != nil {
        return nil, err
    }
    
    ubm.buttonClicks, err = meter.Int64Counter(
        "user.button_clicks",
        metric.WithDescription("Button clicks"),
        metric.WithUnit("{click}"),
    )
    if err != nil {
        return nil, err
    }
    
    ubm.sessionDuration, err = meter.Float64Histogram(
        "user.session.duration",
        metric.WithDescription("Session duration"),
        metric.WithUnit("s"),
        metric.WithExplicitBucketBoundaries(
            30, 60, 120, 300, 600, 1800, 3600, // 30såˆ°1h
        ),
    )
    if err != nil {
        return nil, err
    }
    
    ubm.searchQueries, err = meter.Int64Counter(
        "user.search_queries",
        metric.WithDescription("Search queries"),
        metric.WithUnit("{query}"),
    )
    if err != nil {
        return nil, err
    }
    
    return ubm, nil
}

// RecordPageView è®°å½•é¡µé¢æµè§ˆ
func (ubm *UserBehaviorMetrics) RecordPageView(ctx context.Context, page string, userID string) {
    attrs := []attribute.KeyValue{
        attribute.String("page.name", page),
        attribute.String("user.id", userID),
    }
    
    ubm.pageViews.Add(ctx, 1, metric.WithAttributes(attrs...))
}

// RecordButtonClick è®°å½•æŒ‰é’®ç‚¹å‡»
func (ubm *UserBehaviorMetrics) RecordButtonClick(ctx context.Context, buttonID string, page string) {
    attrs := []attribute.KeyValue{
        attribute.String("button.id", buttonID),
        attribute.String("page.name", page),
    }
    
    ubm.buttonClicks.Add(ctx, 1, metric.WithAttributes(attrs...))
}

// RecordSessionEnd è®°å½•ä¼šè¯ç»“æŸ
func (ubm *UserBehaviorMetrics) RecordSessionEnd(ctx context.Context, duration float64, userID string) {
    attrs := []attribute.KeyValue{
        attribute.String("user.id", userID),
    }
    
    ubm.sessionDuration.Record(ctx, duration, metric.WithAttributes(attrs...))
}
```

### 2.3 ä¸šåŠ¡æµç¨‹æŒ‡æ ‡

```go
// WorkflowMetrics ä¸šåŠ¡æµç¨‹æŒ‡æ ‡
type WorkflowMetrics struct {
    workflowStarts    metric.Int64Counter       // æµç¨‹å¼€å§‹æ¬¡æ•°
    workflowCompletes metric.Int64Counter       // æµç¨‹å®Œæˆæ¬¡æ•°
    workflowFails     metric.Int64Counter       // æµç¨‹å¤±è´¥æ¬¡æ•°
    workflowDuration  metric.Float64Histogram   // æµç¨‹è€—æ—¶
    stepDuration      metric.Float64Histogram   // æ­¥éª¤è€—æ—¶
}

func NewWorkflowMetrics() (*WorkflowMetrics, error) {
    meter := otel.Meter("business.workflow")
    
    wm := &WorkflowMetrics{}
    var err error
    
    wm.workflowStarts, err = meter.Int64Counter(
        "workflow.starts",
        metric.WithDescription("Workflow starts"),
        metric.WithUnit("{workflow}"),
    )
    if err != nil {
        return nil, err
    }
    
    wm.workflowCompletes, err = meter.Int64Counter(
        "workflow.completes",
        metric.WithDescription("Workflow completions"),
        metric.WithUnit("{workflow}"),
    )
    if err != nil {
        return nil, err
    }
    
    wm.workflowFails, err = meter.Int64Counter(
        "workflow.fails",
        metric.WithDescription("Workflow failures"),
        metric.WithUnit("{workflow}"),
    )
    if err != nil {
        return nil, err
    }
    
    wm.workflowDuration, err = meter.Float64Histogram(
        "workflow.duration",
        metric.WithDescription("Workflow duration"),
        metric.WithUnit("s"),
    )
    if err != nil {
        return nil, err
    }
    
    wm.stepDuration, err = meter.Float64Histogram(
        "workflow.step.duration",
        metric.WithDescription("Workflow step duration"),
        metric.WithUnit("s"),
    )
    if err != nil {
        return nil, err
    }
    
    return wm, nil
}

// RecordWorkflowStart è®°å½•æµç¨‹å¼€å§‹
func (wm *WorkflowMetrics) RecordWorkflowStart(ctx context.Context, workflowName string) {
    attrs := []attribute.KeyValue{
        attribute.String("workflow.name", workflowName),
    }
    
    wm.workflowStarts.Add(ctx, 1, metric.WithAttributes(attrs...))
}

// RecordWorkflowComplete è®°å½•æµç¨‹å®Œæˆ
func (wm *WorkflowMetrics) RecordWorkflowComplete(ctx context.Context, workflowName string, duration float64, success bool) {
    attrs := []attribute.KeyValue{
        attribute.String("workflow.name", workflowName),
        attribute.Bool("workflow.success", success),
    }
    
    if success {
        wm.workflowCompletes.Add(ctx, 1, metric.WithAttributes(attrs...))
    } else {
        wm.workflowFails.Add(ctx, 1, metric.WithAttributes(attrs...))
    }
    
    wm.workflowDuration.Record(ctx, duration, metric.WithAttributes(attrs...))
}

// RecordWorkflowStep è®°å½•æµç¨‹æ­¥éª¤
func (wm *WorkflowMetrics) RecordWorkflowStep(ctx context.Context, workflowName string, stepName string, duration float64) {
    attrs := []attribute.KeyValue{
        attribute.String("workflow.name", workflowName),
        attribute.String("workflow.step", stepName),
    }
    
    wm.stepDuration.Record(ctx, duration, metric.WithAttributes(attrs...))
}
```

---

## 3. SLI/SLO æŒ‡æ ‡

### 3.1 æœåŠ¡å¯ç”¨æ€§

```go
// SLIMetrics SLI æŒ‡æ ‡
type SLIMetrics struct {
    availability    metric.Float64ObservableGauge  // å¯ç”¨æ€§
    requestsTotal   metric.Int64Counter            // æ€»è¯·æ±‚æ•°
    requestsSuccess metric.Int64Counter            // æˆåŠŸè¯·æ±‚æ•°
    requestsFailed  metric.Int64Counter            // å¤±è´¥è¯·æ±‚æ•°
}

func NewSLIMetrics() (*SLIMetrics, error) {
    meter := otel.Meter("sli")
    
    sm := &SLIMetrics{}
    var err error
    
    sm.requestsTotal, err = meter.Int64Counter(
        "sli.requests.total",
        metric.WithDescription("Total requests"),
        metric.WithUnit("{request}"),
    )
    if err != nil {
        return nil, err
    }
    
    sm.requestsSuccess, err = meter.Int64Counter(
        "sli.requests.success",
        metric.WithDescription("Successful requests"),
        metric.WithUnit("{request}"),
    )
    if err != nil {
        return nil, err
    }
    
    sm.requestsFailed, err = meter.Int64Counter(
        "sli.requests.failed",
        metric.WithDescription("Failed requests"),
        metric.WithUnit("{request}"),
    )
    if err != nil {
        return nil, err
    }
    
    return sm, nil
}

// RecordRequest è®°å½•è¯·æ±‚
func (sm *SLIMetrics) RecordRequest(ctx context.Context, success bool, service string) {
    attrs := []attribute.KeyValue{
        attribute.String("service.name", service),
    }
    
    sm.requestsTotal.Add(ctx, 1, metric.WithAttributes(attrs...))
    
    if success {
        sm.requestsSuccess.Add(ctx, 1, metric.WithAttributes(attrs...))
    } else {
        sm.requestsFailed.Add(ctx, 1, metric.WithAttributes(attrs...))
    }
}

// CalculateAvailability è®¡ç®—å¯ç”¨æ€§ (ä½¿ç”¨ Prometheus æŸ¥è¯¢)
// availability = success_requests / total_requests
// SLO: availability >= 99.9% (ä¸‰ä¸ª9)
```

### 3.2 å»¶è¿ŸæŒ‡æ ‡

```go
// LatencySLI å»¶è¿Ÿ SLI
type LatencySLI struct {
    latency metric.Float64Histogram
}

func NewLatencySLI() (*LatencySLI, error) {
    meter := otel.Meter("sli")
    
    ls := &LatencySLI{}
    var err error
    
    ls.latency, err = meter.Float64Histogram(
        "sli.latency",
        metric.WithDescription("Request latency for SLI"),
        metric.WithUnit("s"),
        metric.WithExplicitBucketBoundaries(
            0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0,
        ),
    )
    if err != nil {
        return nil, err
    }
    
    return ls, nil
}

// RecordLatency è®°å½•å»¶è¿Ÿ
func (ls *LatencySLI) RecordLatency(ctx context.Context, latency float64, service string) {
    attrs := []attribute.KeyValue{
        attribute.String("service.name", service),
    }
    
    ls.latency.Record(ctx, latency, metric.WithAttributes(attrs...))
}

// SLO: P95 latency <= 100ms, P99 latency <= 500ms
```

### 3.3 é”™è¯¯é¢„ç®—

```go
// ErrorBudget é”™è¯¯é¢„ç®—
type ErrorBudget struct {
    slo             float64  // SLO ç›®æ ‡ (å¦‚ 99.9% = 0.999)
    totalRequests   int64
    failedRequests  int64
}

// NewErrorBudget åˆ›å»ºé”™è¯¯é¢„ç®—
func NewErrorBudget(slo float64) *ErrorBudget {
    return &ErrorBudget{
        slo: slo,
    }
}

// RecordRequest è®°å½•è¯·æ±‚
func (eb *ErrorBudget) RecordRequest(success bool) {
    eb.totalRequests++
    if !success {
        eb.failedRequests++
    }
}

// RemainingBudget å‰©ä½™é”™è¯¯é¢„ç®—
func (eb *ErrorBudget) RemainingBudget() float64 {
    if eb.totalRequests == 0 {
        return 1.0
    }
    
    allowedFailures := float64(eb.totalRequests) * (1.0 - eb.slo)
    return (allowedFailures - float64(eb.failedRequests)) / allowedFailures
}

// IsExhausted é”™è¯¯é¢„ç®—æ˜¯å¦è€—å°½
func (eb *ErrorBudget) IsExhausted() bool {
    return eb.RemainingBudget() <= 0
}
```

---

## 4. Go å®ç°

### 4.1 Counter æŒ‡æ ‡

```go
// Counter ç”¨äºåªå¢ä¸å‡çš„æŒ‡æ ‡ï¼ˆå¦‚è¯·æ±‚æ€»æ•°ã€é”™è¯¯æ€»æ•°ï¼‰
counter, _ := meter.Int64Counter(
    "app.requests.total",
    metric.WithDescription("Total requests"),
    metric.WithUnit("{request}"),
)

counter.Add(ctx, 1, metric.WithAttributes(
    attribute.String("method", "GET"),
    attribute.String("endpoint", "/api/users"),
))
```

### 4.2 Gauge æŒ‡æ ‡

```go
// Gauge ç”¨äºå¯å¢å¯å‡çš„æŒ‡æ ‡ï¼ˆå¦‚é˜Ÿåˆ—é•¿åº¦ã€åœ¨çº¿ç”¨æˆ·æ•°ï¼‰
gauge, _ := meter.Int64ObservableUpDownCounter(
    "app.queue.length",
    metric.WithDescription("Queue length"),
    metric.WithUnit("{item}"),
)

// åœ¨å›è°ƒä¸­æ›´æ–°
meter.RegisterCallback(func(ctx context.Context, observer metric.Observer) error {
    queueLength := getQueueLength()
    observer.ObserveInt64(gauge, queueLength)
    return nil
}, gauge)
```

### 4.3 Histogram æŒ‡æ ‡

```go
// Histogram ç”¨äºåˆ†å¸ƒç»Ÿè®¡ï¼ˆå¦‚å»¶è¿Ÿã€å¤§å°ï¼‰
histogram, _ := meter.Float64Histogram(
    "app.request.duration",
    metric.WithDescription("Request duration"),
    metric.WithUnit("s"),
    metric.WithExplicitBucketBoundaries(
        0.01, 0.05, 0.1, 0.5, 1.0, 5.0, 10.0,
    ),
)

histogram.Record(ctx, duration, metric.WithAttributes(
    attribute.String("endpoint", "/api/users"),
))
```

### 4.4 æŒ‡æ ‡ç®¡ç†å™¨

```go
// MetricsManager ç»Ÿä¸€ç®¡ç†æ‰€æœ‰ä¸šåŠ¡æŒ‡æ ‡
type MetricsManager struct {
    ecommerce    *EcommerceMetrics
    userBehavior *UserBehaviorMetrics
    workflow     *WorkflowMetrics
    sli          *SLIMetrics
}

func NewMetricsManager() (*MetricsManager, error) {
    mm := &MetricsManager{}
    var err error
    
    mm.ecommerce, err = NewEcommerceMetrics()
    if err != nil {
        return nil, err
    }
    
    mm.userBehavior, err = NewUserBehaviorMetrics()
    if err != nil {
        return nil, err
    }
    
    mm.workflow, err = NewWorkflowMetrics()
    if err != nil {
        return nil, err
    }
    
    mm.sli, err = NewSLIMetrics()
    if err != nil {
        return nil, err
    }
    
    return mm, nil
}

// Ecommerce è·å–ç”µå•†æŒ‡æ ‡
func (mm *MetricsManager) Ecommerce() *EcommerceMetrics {
    return mm.ecommerce
}

// UserBehavior è·å–ç”¨æˆ·è¡Œä¸ºæŒ‡æ ‡
func (mm *MetricsManager) UserBehavior() *UserBehaviorMetrics {
    return mm.userBehavior
}

// Workflow è·å–å·¥ä½œæµæŒ‡æ ‡
func (mm *MetricsManager) Workflow() *WorkflowMetrics {
    return mm.workflow
}

// SLI è·å– SLI æŒ‡æ ‡
func (mm *MetricsManager) SLI() *SLIMetrics {
    return mm.sli
}
```

---

## 5. å®Œæ•´ç¤ºä¾‹

### 5.1 ç”µå•†ç³»ç»Ÿ

*(è§ 2.1 ä¸šåŠ¡ KPI æŒ‡æ ‡)*-

### 5.2 SaaS ç³»ç»Ÿ

```go
// SaaSMetrics SaaS ç³»ç»ŸæŒ‡æ ‡
type SaaSMetrics struct {
    signups        metric.Int64Counter    // æ³¨å†Œæ•°
    activeUsers    metric.Int64Counter    // æ´»è·ƒç”¨æˆ·
    churn          metric.Int64Counter    // æµå¤±ç”¨æˆ·
    mrr            metric.Float64Counter  // æœˆåº¦ç»å¸¸æ€§æ”¶å…¥
    subscriptions  metric.Int64Counter    // è®¢é˜…æ•°
}
```

### 5.3 é‡‘èç³»ç»Ÿ

```go
// FinanceMetrics é‡‘èç³»ç»ŸæŒ‡æ ‡
type FinanceMetrics struct {
    transactionsTotal  metric.Int64Counter    // äº¤æ˜“æ€»æ•°
    transactionsValue  metric.Float64Counter  // äº¤æ˜“æ€»é¢
    fraudDetected      metric.Int64Counter    // æ£€æµ‹åˆ°çš„æ¬ºè¯ˆ
    riskScore          metric.Float64Histogram // é£é™©è¯„åˆ†åˆ†å¸ƒ
}
```

---

## 6. æœ€ä½³å®è·µ

### 6.1 å‘½åè§„èŒƒ

**éµå¾ª OpenTelemetry å‘½åçº¦å®š**ï¼š

- ä½¿ç”¨ç‚¹å·åˆ†éš”ï¼ˆå¦‚ `ecommerce.orders.total`ï¼‰
- ä½¿ç”¨å¤æ•°ï¼ˆå¦‚ `orders` è€Œé `order`ï¼‰
- é¿å…ç¼©å†™ï¼ˆå¦‚ `duration` è€Œé `dur`ï¼‰
- åŒ…å«å•ä½ï¼ˆå¦‚ `{order}`, `s`, `By`ï¼‰

**ç¤ºä¾‹**ï¼š

```go
// âœ… å¥½
"ecommerce.orders.total"  // {order}
"http.server.request.duration"  // s
"db.client.connections.usage"  // {connection}

// âŒ ä¸å¥½
"order_count"  // ä½¿ç”¨ä¸‹åˆ’çº¿
"req_dur"  // è¿‡åº¦ç¼©å†™
"httpLatency"  // é©¼å³°å‘½å
```

### 6.2 æ ‡ç­¾è®¾è®¡

**åŸåˆ™**ï¼š

1. **ä½åŸºæ•°**ï¼šé¿å…é«˜åŸºæ•°æ ‡ç­¾ï¼ˆå¦‚ç”¨æˆ· IDã€æ—¶é—´æˆ³ï¼‰
2. **æœ‰æ„ä¹‰**ï¼šæ ‡ç­¾åº”æœ‰åŠ©äºè¿‡æ»¤å’Œèšåˆ
3. **ä¸€è‡´æ€§**ï¼šåœ¨ä¸åŒæŒ‡æ ‡ä¸­ä½¿ç”¨ç›¸åŒçš„æ ‡ç­¾å

```go
// âœ… å¥½
attribute.String("order.status", "completed")
attribute.String("payment.method", "credit_card")
attribute.String("user.tier", "premium")

// âŒ ä¸å¥½
attribute.String("user.id", "12345678")  // é«˜åŸºæ•°
attribute.String("timestamp", "2025-10-09T12:34:56Z")  // ä¸å¿…è¦
```

### 6.3 æ€§èƒ½ä¼˜åŒ–

**1. æ‰¹é‡è®°å½•**ï¼š

```go
// âŒ ä½æ•ˆ
for _, order := range orders {
    metrics.ordersTotal.Add(ctx, 1)
}

// âœ… é«˜æ•ˆ
metrics.ordersTotal.Add(ctx, int64(len(orders)))
```

**2. æ¡ä»¶é‡‡æ ·**ï¼š

```go
// å¯¹é«˜é¢‘äº‹ä»¶é‡‡æ ·
if rand.Float64() < 0.1 { // 10% é‡‡æ ·
    metrics.pageViews.Add(ctx, 1)
}
```

**3. å¼‚æ­¥è®°å½•**ï¼š

```go
go func() {
    metrics.longRunning.Record(ctx, value)
}()
```

### 6.4 å‘Šè­¦è§„åˆ™

**ä¸šåŠ¡å‘Šè­¦ç¤ºä¾‹**ï¼š

```yaml
groups:
  - name: business_alerts
    rules:
      # è®¢å•ä¸‹é™å‘Šè­¦
      - alert: OrderRateDropping
        expr: |
          rate(ecommerce_orders_total[5m]) <
          0.8 * rate(ecommerce_orders_total[1h] offset 1d)
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "è®¢å•é€Ÿç‡ä¸‹é™è¶…è¿‡ 20%"
      
      # æ”¯ä»˜æˆåŠŸç‡ä½
      - alert: LowPaymentSuccessRate
        expr: |
          sum(rate(ecommerce_payments_success[5m])) /
          sum(rate(ecommerce_payments_total[5m])) < 0.95
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "æ”¯ä»˜æˆåŠŸç‡ä½äº 95%"
      
      # SLO è¿å
      - alert: SLOViolation
        expr: |
          sum(rate(sli_requests_success[30d])) /
          sum(rate(sli_requests_total[30d])) < 0.999
        for: 1h
        labels:
          severity: critical
        annotations:
          summary: "SLO è¿åï¼ˆå¯ç”¨æ€§ < 99.9%ï¼‰"
```

---

## 7. å¸¸è§æ¨¡å¼

### 7.1 æ¼æ–—åˆ†æ

```go
// FunnelMetrics æ¼æ–—æŒ‡æ ‡
type FunnelMetrics struct {
    step1 metric.Int64Counter  // ç¬¬ä¸€æ­¥
    step2 metric.Int64Counter  // ç¬¬äºŒæ­¥
    step3 metric.Int64Counter  // ç¬¬ä¸‰æ­¥
    step4 metric.Int64Counter  // ç¬¬å››æ­¥
}

// è®¡ç®—è½¬åŒ–ç‡ï¼š
// step1 -> step2: rate(step2) / rate(step1)
// step2 -> step3: rate(step3) / rate(step2)
```

### 7.2 é˜Ÿåˆ—ç›‘æ§

```go
// QueueMetrics é˜Ÿåˆ—æŒ‡æ ‡
type QueueMetrics struct {
    length      metric.Int64ObservableUpDownCounter  // é˜Ÿåˆ—é•¿åº¦
    enqueues    metric.Int64Counter                  // å…¥é˜Ÿæ¬¡æ•°
    dequeues    metric.Int64Counter                  // å‡ºé˜Ÿæ¬¡æ•°
    waitTime    metric.Float64Histogram              // ç­‰å¾…æ—¶é—´
}
```

### 7.3 é™æµç›‘æ§

```go
// RateLimiterMetrics é™æµå™¨æŒ‡æ ‡
type RateLimiterMetrics struct {
    requests  metric.Int64Counter  // æ€»è¯·æ±‚æ•°
    allowed   metric.Int64Counter  // å…è®¸çš„è¯·æ±‚
    rejected  metric.Int64Counter  // æ‹’ç»çš„è¯·æ±‚
}
```

---

## 8. å¸¸è§é—®é¢˜

**Q1: Counter å’Œ Histogram å¦‚ä½•é€‰æ‹©ï¼Ÿ**

A:

- **Counter**ï¼šé€‚åˆè®¡æ•°ï¼ˆå¦‚è®¢å•æ•°ã€è¯·æ±‚æ•°ï¼‰
- **Histogram**ï¼šé€‚åˆåˆ†å¸ƒç»Ÿè®¡ï¼ˆå¦‚å»¶è¿Ÿã€é‡‘é¢ï¼‰

**Q2: å¦‚ä½•é¿å…æŒ‡æ ‡çˆ†ç‚¸ï¼Ÿ**

A:

1. é™åˆ¶æ ‡ç­¾åŸºæ•°ï¼ˆé¿å…ç”¨æˆ· ID ç­‰é«˜åŸºæ•°æ ‡ç­¾ï¼‰
2. ä½¿ç”¨èšåˆï¼ˆå¦‚çŠ¶æ€ç åˆ†ç»„ä¸º `2xx`, `4xx`, `5xx`ï¼‰
3. å®šæœŸå®¡æŸ¥æŒ‡æ ‡ï¼Œåˆ é™¤æœªä½¿ç”¨çš„æŒ‡æ ‡

**Q3: å¦‚ä½•è®¾ç½® SLOï¼Ÿ**

A:

1. ä»ä¸šåŠ¡éœ€æ±‚å‡ºå‘ï¼ˆå¦‚"ç”¨æˆ·å¯æ¥å—çš„æœ€å¤§å»¶è¿Ÿæ˜¯å¤šå°‘ï¼Ÿ"ï¼‰
2. å‚è€ƒè¡Œä¸šæ ‡å‡†ï¼ˆå¦‚ Google SRE ä¹¦ç±ï¼‰
3. ä»å®½æ¾å¼€å§‹ï¼Œé€æ­¥æ”¶ç´§

**Q4: ä¸šåŠ¡æŒ‡æ ‡åº”è¯¥å¤šä¹…å¯¼å‡ºä¸€æ¬¡ï¼Ÿ**

A:

- **å®æ—¶æŒ‡æ ‡**ï¼ˆå¦‚æ”¯ä»˜æˆåŠŸç‡ï¼‰ï¼š10-30 ç§’
- **è¶‹åŠ¿æŒ‡æ ‡**ï¼ˆå¦‚ DAUï¼‰ï¼š1-5 åˆ†é’Ÿ
- **SLI/SLO**ï¼šæ ¹æ®æ—¶é—´çª—å£ï¼ˆå¦‚ 30 å¤©ï¼‰

**Q5: å¦‚ä½•æµ‹è¯•ä¸šåŠ¡æŒ‡æ ‡ï¼Ÿ**

A:

```go
func TestEcommerceMetrics(t *testing.T) {
    // ä½¿ç”¨å†…å­˜å¯¼å‡ºå™¨
    exporter := metric.NewManualReader()
    provider := metric.NewMeterProvider(
        metric.WithReader(exporter),
    )
    otel.SetMeterProvider(provider)
    
    metrics, _ := NewEcommerceMetrics()
    
    // è®°å½•æŒ‡æ ‡
    ctx := context.Background()
    metrics.RecordOrder(ctx, "order-123", 99.99, "completed")
    
    // è¯»å–æŒ‡æ ‡
    rm := metricdata.ResourceMetrics{}
    exporter.Collect(ctx, &rm)
    
    // æ–­è¨€
    // ...
}
```

---

## æ€»ç»“

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†è‡ªå®šä¹‰æŒ‡æ ‡å’Œä¸šåŠ¡æŒ‡æ ‡çš„è®¾è®¡ä¸å®ç°ï¼Œæ¶µç›–ï¼š

âœ… **ä¸šåŠ¡æŒ‡æ ‡**ï¼šKPIã€ç”¨æˆ·è¡Œä¸ºã€ä¸šåŠ¡æµç¨‹  
âœ… **SLI/SLO**ï¼šå¯ç”¨æ€§ã€å»¶è¿Ÿã€é”™è¯¯é¢„ç®—  
âœ… **Go å®ç°**ï¼šCounterã€Gaugeã€Histogramã€æŒ‡æ ‡ç®¡ç†å™¨  
âœ… **å®Œæ•´ç¤ºä¾‹**ï¼šç”µå•†ã€SaaSã€é‡‘èç³»ç»Ÿ  
âœ… **æœ€ä½³å®è·µ**ï¼šå‘½åè§„èŒƒã€æ ‡ç­¾è®¾è®¡ã€æ€§èƒ½ä¼˜åŒ–ã€å‘Šè­¦è§„åˆ™  
âœ… **å¸¸è§æ¨¡å¼**ï¼šæ¼æ–—åˆ†æã€é˜Ÿåˆ—ç›‘æ§ã€é™æµç›‘æ§  

**ä¸‹ä¸€æ­¥**ï¼š

- ğŸ“– å¤ä¹ ã€Šç³»ç»ŸæŒ‡æ ‡ã€‹ã€Šè¿è¡Œæ—¶æŒ‡æ ‡ã€‹ã€ŠHTTP æŒ‡æ ‡ã€‹ã€Šæ•°æ®åº“æŒ‡æ ‡ã€‹
- ğŸ“– é˜…è¯»ã€ŠLog çº¦å®šã€‹å­¦ä¹ æ—¥å¿—è¯­ä¹‰çº¦å®š
- ğŸ”— å‚è€ƒ [Google SRE Book - Implementing SLOs](https://sre.google/sre-book/implementing-slos/)

**å‚è€ƒèµ„æº**ï¼š

- [OpenTelemetry Metrics API](https://opentelemetry.io/docs/specs/otel/metrics/api/)
- [The Four Golden Signals (Google SRE)](https://sre.google/sre-book/monitoring-distributed-systems/)
- [RED Method](https://www.weave.works/blog/the-red-method-key-metrics-for-microservices-architecture/)
