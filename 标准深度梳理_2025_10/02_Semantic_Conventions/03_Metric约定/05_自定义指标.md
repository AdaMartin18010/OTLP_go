# 自定义指标与业务指标（Custom & Business Metrics）

## 目录

- [自定义指标与业务指标（Custom \& Business Metrics）](#自定义指标与业务指标custom--business-metrics)
  - [目录](#目录)
  - [1. 概述](#1-概述)
  - [2. 业务指标设计](#2-业务指标设计)
    - [2.1 业务 KPI 指标](#21-业务-kpi-指标)
    - [2.2 用户行为指标](#22-用户行为指标)
    - [2.3 业务流程指标](#23-业务流程指标)
  - [3. SLI/SLO 指标](#3-slislo-指标)
    - [3.1 服务可用性](#31-服务可用性)
    - [3.2 延迟指标](#32-延迟指标)
    - [3.3 错误预算](#33-错误预算)
  - [4. Go 实现](#4-go-实现)
    - [4.1 Counter 指标](#41-counter-指标)
    - [4.2 Gauge 指标](#42-gauge-指标)
    - [4.3 Histogram 指标](#43-histogram-指标)
    - [4.4 指标管理器](#44-指标管理器)
  - [5. 完整示例](#5-完整示例)
    - [5.1 电商系统](#51-电商系统)
    - [5.2 SaaS 系统](#52-saas-系统)
    - [5.3 金融系统](#53-金融系统)
  - [6. 最佳实践](#6-最佳实践)
    - [6.1 命名规范](#61-命名规范)
    - [6.2 标签设计](#62-标签设计)
    - [6.3 性能优化](#63-性能优化)
    - [6.4 告警规则](#64-告警规则)
  - [7. 常见模式](#7-常见模式)
    - [7.1 漏斗分析](#71-漏斗分析)
    - [7.2 队列监控](#72-队列监控)
    - [7.3 限流监控](#73-限流监控)
  - [8. 常见问题](#8-常见问题)
  - [总结](#总结)

---

## 1. 概述

自定义指标和业务指标是连接技术监控与业务价值的桥梁。与系统指标（CPU、内存）不同，业务指标直接反映业务健康度和用户体验。

**核心价值**：

- 📊 **业务洞察**：实时了解业务运营状态
- 🎯 **目标管理**：通过 SLI/SLO 量化服务质量
- 💡 **决策支持**：为业务决策提供数据支撑
- 🚨 **主动告警**：在影响用户前发现问题

**指标分类**：

- **业务 KPI 指标**：订单量、GMV、活跃用户数
- **用户行为指标**：点击率、转化率、留存率
- **SLI/SLO 指标**：可用性、延迟、错误率
- **业务流程指标**：支付成功率、库存准确率

---

## 2. 业务指标设计

### 2.1 业务 KPI 指标

**电商核心指标**：

```go
package businessmetrics

import (
    "context"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// EcommerceMetrics 电商指标
type EcommerceMetrics struct {
    // 订单指标
    ordersTotal     metric.Int64Counter      // 总订单数
    ordersValue     metric.Float64Counter    // 订单总金额（GMV）
    ordersCancelled metric.Int64Counter      // 取消订单数
    
    // 支付指标
    paymentsTotal   metric.Int64Counter      // 支付次数
    paymentsSuccess metric.Int64Counter      // 支付成功次数
    paymentsFailed  metric.Int64Counter      // 支付失败次数
    paymentsAmount  metric.Float64Counter    // 支付金额
    
    // 用户指标
    usersActive     metric.Int64ObservableUpDownCounter  // 活跃用户数
    usersNew        metric.Int64Counter      // 新注册用户数
    
    // 商品指标
    productsViewed  metric.Int64Counter      // 商品浏览次数
    productsAdded   metric.Int64Counter      // 加入购物车次数
}

func NewEcommerceMetrics() (*EcommerceMetrics, error) {
    meter := otel.Meter("business.ecommerce")
    
    em := &EcommerceMetrics{}
    var err error
    
    // 订单指标
    em.ordersTotal, err = meter.Int64Counter(
        "ecommerce.orders.total",
        metric.WithDescription("Total number of orders"),
        metric.WithUnit("{order}"),
    )
    if err != nil {
        return nil, err
    }
    
    em.ordersValue, err = meter.Float64Counter(
        "ecommerce.orders.value",
        metric.WithDescription("Total order value (GMV)"),
        metric.WithUnit("USD"),
    )
    if err != nil {
        return nil, err
    }
    
    em.ordersCancelled, err = meter.Int64Counter(
        "ecommerce.orders.cancelled",
        metric.WithDescription("Number of cancelled orders"),
        metric.WithUnit("{order}"),
    )
    if err != nil {
        return nil, err
    }
    
    // 支付指标
    em.paymentsTotal, err = meter.Int64Counter(
        "ecommerce.payments.total",
        metric.WithDescription("Total payment attempts"),
        metric.WithUnit("{payment}"),
    )
    if err != nil {
        return nil, err
    }
    
    em.paymentsSuccess, err = meter.Int64Counter(
        "ecommerce.payments.success",
        metric.WithDescription("Successful payments"),
        metric.WithUnit("{payment}"),
    )
    if err != nil {
        return nil, err
    }
    
    em.paymentsFailed, err = meter.Int64Counter(
        "ecommerce.payments.failed",
        metric.WithDescription("Failed payments"),
        metric.WithUnit("{payment}"),
    )
    if err != nil {
        return nil, err
    }
    
    em.paymentsAmount, err = meter.Float64Counter(
        "ecommerce.payments.amount",
        metric.WithDescription("Total payment amount"),
        metric.WithUnit("USD"),
    )
    if err != nil {
        return nil, err
    }
    
    // 用户指标
    em.usersNew, err = meter.Int64Counter(
        "ecommerce.users.new",
        metric.WithDescription("New registered users"),
        metric.WithUnit("{user}"),
    )
    if err != nil {
        return nil, err
    }
    
    // 商品指标
    em.productsViewed, err = meter.Int64Counter(
        "ecommerce.products.viewed",
        metric.WithDescription("Product views"),
        metric.WithUnit("{view}"),
    )
    if err != nil {
        return nil, err
    }
    
    em.productsAdded, err = meter.Int64Counter(
        "ecommerce.products.added_to_cart",
        metric.WithDescription("Products added to cart"),
        metric.WithUnit("{product}"),
    )
    if err != nil {
        return nil, err
    }
    
    return em, nil
}

// RecordOrder 记录订单
func (em *EcommerceMetrics) RecordOrder(ctx context.Context, orderID string, amount float64, status string) {
    attrs := []attribute.KeyValue{
        attribute.String("order.status", status),
    }
    
    em.ordersTotal.Add(ctx, 1, metric.WithAttributes(attrs...))
    em.ordersValue.Add(ctx, amount, metric.WithAttributes(attrs...))
    
    if status == "cancelled" {
        em.ordersCancelled.Add(ctx, 1)
    }
}

// RecordPayment 记录支付
func (em *EcommerceMetrics) RecordPayment(ctx context.Context, amount float64, success bool, method string) {
    attrs := []attribute.KeyValue{
        attribute.String("payment.method", method),
    }
    
    em.paymentsTotal.Add(ctx, 1, metric.WithAttributes(attrs...))
    
    if success {
        em.paymentsSuccess.Add(ctx, 1, metric.WithAttributes(attrs...))
        em.paymentsAmount.Add(ctx, amount, metric.WithAttributes(attrs...))
    } else {
        em.paymentsFailed.Add(ctx, 1, metric.WithAttributes(attrs...))
    }
}
```

### 2.2 用户行为指标

```go
// UserBehaviorMetrics 用户行为指标
type UserBehaviorMetrics struct {
    pageViews       metric.Int64Counter          // 页面浏览量
    buttonClicks    metric.Int64Counter          // 按钮点击
    sessionDuration metric.Float64Histogram      // 会话时长
    searchQueries   metric.Int64Counter          // 搜索查询
    apiCalls        metric.Int64Counter          // API 调用
}

func NewUserBehaviorMetrics() (*UserBehaviorMetrics, error) {
    meter := otel.Meter("business.user_behavior")
    
    ubm := &UserBehaviorMetrics{}
    var err error
    
    ubm.pageViews, err = meter.Int64Counter(
        "user.page_views",
        metric.WithDescription("Page views"),
        metric.WithUnit("{view}"),
    )
    if err != nil {
        return nil, err
    }
    
    ubm.buttonClicks, err = meter.Int64Counter(
        "user.button_clicks",
        metric.WithDescription("Button clicks"),
        metric.WithUnit("{click}"),
    )
    if err != nil {
        return nil, err
    }
    
    ubm.sessionDuration, err = meter.Float64Histogram(
        "user.session.duration",
        metric.WithDescription("Session duration"),
        metric.WithUnit("s"),
        metric.WithExplicitBucketBoundaries(
            30, 60, 120, 300, 600, 1800, 3600, // 30s到1h
        ),
    )
    if err != nil {
        return nil, err
    }
    
    ubm.searchQueries, err = meter.Int64Counter(
        "user.search_queries",
        metric.WithDescription("Search queries"),
        metric.WithUnit("{query}"),
    )
    if err != nil {
        return nil, err
    }
    
    return ubm, nil
}

// RecordPageView 记录页面浏览
func (ubm *UserBehaviorMetrics) RecordPageView(ctx context.Context, page string, userID string) {
    attrs := []attribute.KeyValue{
        attribute.String("page.name", page),
        attribute.String("user.id", userID),
    }
    
    ubm.pageViews.Add(ctx, 1, metric.WithAttributes(attrs...))
}

// RecordButtonClick 记录按钮点击
func (ubm *UserBehaviorMetrics) RecordButtonClick(ctx context.Context, buttonID string, page string) {
    attrs := []attribute.KeyValue{
        attribute.String("button.id", buttonID),
        attribute.String("page.name", page),
    }
    
    ubm.buttonClicks.Add(ctx, 1, metric.WithAttributes(attrs...))
}

// RecordSessionEnd 记录会话结束
func (ubm *UserBehaviorMetrics) RecordSessionEnd(ctx context.Context, duration float64, userID string) {
    attrs := []attribute.KeyValue{
        attribute.String("user.id", userID),
    }
    
    ubm.sessionDuration.Record(ctx, duration, metric.WithAttributes(attrs...))
}
```

### 2.3 业务流程指标

```go
// WorkflowMetrics 业务流程指标
type WorkflowMetrics struct {
    workflowStarts    metric.Int64Counter       // 流程开始次数
    workflowCompletes metric.Int64Counter       // 流程完成次数
    workflowFails     metric.Int64Counter       // 流程失败次数
    workflowDuration  metric.Float64Histogram   // 流程耗时
    stepDuration      metric.Float64Histogram   // 步骤耗时
}

func NewWorkflowMetrics() (*WorkflowMetrics, error) {
    meter := otel.Meter("business.workflow")
    
    wm := &WorkflowMetrics{}
    var err error
    
    wm.workflowStarts, err = meter.Int64Counter(
        "workflow.starts",
        metric.WithDescription("Workflow starts"),
        metric.WithUnit("{workflow}"),
    )
    if err != nil {
        return nil, err
    }
    
    wm.workflowCompletes, err = meter.Int64Counter(
        "workflow.completes",
        metric.WithDescription("Workflow completions"),
        metric.WithUnit("{workflow}"),
    )
    if err != nil {
        return nil, err
    }
    
    wm.workflowFails, err = meter.Int64Counter(
        "workflow.fails",
        metric.WithDescription("Workflow failures"),
        metric.WithUnit("{workflow}"),
    )
    if err != nil {
        return nil, err
    }
    
    wm.workflowDuration, err = meter.Float64Histogram(
        "workflow.duration",
        metric.WithDescription("Workflow duration"),
        metric.WithUnit("s"),
    )
    if err != nil {
        return nil, err
    }
    
    wm.stepDuration, err = meter.Float64Histogram(
        "workflow.step.duration",
        metric.WithDescription("Workflow step duration"),
        metric.WithUnit("s"),
    )
    if err != nil {
        return nil, err
    }
    
    return wm, nil
}

// RecordWorkflowStart 记录流程开始
func (wm *WorkflowMetrics) RecordWorkflowStart(ctx context.Context, workflowName string) {
    attrs := []attribute.KeyValue{
        attribute.String("workflow.name", workflowName),
    }
    
    wm.workflowStarts.Add(ctx, 1, metric.WithAttributes(attrs...))
}

// RecordWorkflowComplete 记录流程完成
func (wm *WorkflowMetrics) RecordWorkflowComplete(ctx context.Context, workflowName string, duration float64, success bool) {
    attrs := []attribute.KeyValue{
        attribute.String("workflow.name", workflowName),
        attribute.Bool("workflow.success", success),
    }
    
    if success {
        wm.workflowCompletes.Add(ctx, 1, metric.WithAttributes(attrs...))
    } else {
        wm.workflowFails.Add(ctx, 1, metric.WithAttributes(attrs...))
    }
    
    wm.workflowDuration.Record(ctx, duration, metric.WithAttributes(attrs...))
}

// RecordWorkflowStep 记录流程步骤
func (wm *WorkflowMetrics) RecordWorkflowStep(ctx context.Context, workflowName string, stepName string, duration float64) {
    attrs := []attribute.KeyValue{
        attribute.String("workflow.name", workflowName),
        attribute.String("workflow.step", stepName),
    }
    
    wm.stepDuration.Record(ctx, duration, metric.WithAttributes(attrs...))
}
```

---

## 3. SLI/SLO 指标

### 3.1 服务可用性

```go
// SLIMetrics SLI 指标
type SLIMetrics struct {
    availability    metric.Float64ObservableGauge  // 可用性
    requestsTotal   metric.Int64Counter            // 总请求数
    requestsSuccess metric.Int64Counter            // 成功请求数
    requestsFailed  metric.Int64Counter            // 失败请求数
}

func NewSLIMetrics() (*SLIMetrics, error) {
    meter := otel.Meter("sli")
    
    sm := &SLIMetrics{}
    var err error
    
    sm.requestsTotal, err = meter.Int64Counter(
        "sli.requests.total",
        metric.WithDescription("Total requests"),
        metric.WithUnit("{request}"),
    )
    if err != nil {
        return nil, err
    }
    
    sm.requestsSuccess, err = meter.Int64Counter(
        "sli.requests.success",
        metric.WithDescription("Successful requests"),
        metric.WithUnit("{request}"),
    )
    if err != nil {
        return nil, err
    }
    
    sm.requestsFailed, err = meter.Int64Counter(
        "sli.requests.failed",
        metric.WithDescription("Failed requests"),
        metric.WithUnit("{request}"),
    )
    if err != nil {
        return nil, err
    }
    
    return sm, nil
}

// RecordRequest 记录请求
func (sm *SLIMetrics) RecordRequest(ctx context.Context, success bool, service string) {
    attrs := []attribute.KeyValue{
        attribute.String("service.name", service),
    }
    
    sm.requestsTotal.Add(ctx, 1, metric.WithAttributes(attrs...))
    
    if success {
        sm.requestsSuccess.Add(ctx, 1, metric.WithAttributes(attrs...))
    } else {
        sm.requestsFailed.Add(ctx, 1, metric.WithAttributes(attrs...))
    }
}

// CalculateAvailability 计算可用性 (使用 Prometheus 查询)
// availability = success_requests / total_requests
// SLO: availability >= 99.9% (三个9)
```

### 3.2 延迟指标

```go
// LatencySLI 延迟 SLI
type LatencySLI struct {
    latency metric.Float64Histogram
}

func NewLatencySLI() (*LatencySLI, error) {
    meter := otel.Meter("sli")
    
    ls := &LatencySLI{}
    var err error
    
    ls.latency, err = meter.Float64Histogram(
        "sli.latency",
        metric.WithDescription("Request latency for SLI"),
        metric.WithUnit("s"),
        metric.WithExplicitBucketBoundaries(
            0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0,
        ),
    )
    if err != nil {
        return nil, err
    }
    
    return ls, nil
}

// RecordLatency 记录延迟
func (ls *LatencySLI) RecordLatency(ctx context.Context, latency float64, service string) {
    attrs := []attribute.KeyValue{
        attribute.String("service.name", service),
    }
    
    ls.latency.Record(ctx, latency, metric.WithAttributes(attrs...))
}

// SLO: P95 latency <= 100ms, P99 latency <= 500ms
```

### 3.3 错误预算

```go
// ErrorBudget 错误预算
type ErrorBudget struct {
    slo             float64  // SLO 目标 (如 99.9% = 0.999)
    totalRequests   int64
    failedRequests  int64
}

// NewErrorBudget 创建错误预算
func NewErrorBudget(slo float64) *ErrorBudget {
    return &ErrorBudget{
        slo: slo,
    }
}

// RecordRequest 记录请求
func (eb *ErrorBudget) RecordRequest(success bool) {
    eb.totalRequests++
    if !success {
        eb.failedRequests++
    }
}

// RemainingBudget 剩余错误预算
func (eb *ErrorBudget) RemainingBudget() float64 {
    if eb.totalRequests == 0 {
        return 1.0
    }
    
    allowedFailures := float64(eb.totalRequests) * (1.0 - eb.slo)
    return (allowedFailures - float64(eb.failedRequests)) / allowedFailures
}

// IsExhausted 错误预算是否耗尽
func (eb *ErrorBudget) IsExhausted() bool {
    return eb.RemainingBudget() <= 0
}
```

---

## 4. Go 实现

### 4.1 Counter 指标

```go
// Counter 用于只增不减的指标（如请求总数、错误总数）
counter, _ := meter.Int64Counter(
    "app.requests.total",
    metric.WithDescription("Total requests"),
    metric.WithUnit("{request}"),
)

counter.Add(ctx, 1, metric.WithAttributes(
    attribute.String("method", "GET"),
    attribute.String("endpoint", "/api/users"),
))
```

### 4.2 Gauge 指标

```go
// Gauge 用于可增可减的指标（如队列长度、在线用户数）
gauge, _ := meter.Int64ObservableUpDownCounter(
    "app.queue.length",
    metric.WithDescription("Queue length"),
    metric.WithUnit("{item}"),
)

// 在回调中更新
meter.RegisterCallback(func(ctx context.Context, observer metric.Observer) error {
    queueLength := getQueueLength()
    observer.ObserveInt64(gauge, queueLength)
    return nil
}, gauge)
```

### 4.3 Histogram 指标

```go
// Histogram 用于分布统计（如延迟、大小）
histogram, _ := meter.Float64Histogram(
    "app.request.duration",
    metric.WithDescription("Request duration"),
    metric.WithUnit("s"),
    metric.WithExplicitBucketBoundaries(
        0.01, 0.05, 0.1, 0.5, 1.0, 5.0, 10.0,
    ),
)

histogram.Record(ctx, duration, metric.WithAttributes(
    attribute.String("endpoint", "/api/users"),
))
```

### 4.4 指标管理器

```go
// MetricsManager 统一管理所有业务指标
type MetricsManager struct {
    ecommerce    *EcommerceMetrics
    userBehavior *UserBehaviorMetrics
    workflow     *WorkflowMetrics
    sli          *SLIMetrics
}

func NewMetricsManager() (*MetricsManager, error) {
    mm := &MetricsManager{}
    var err error
    
    mm.ecommerce, err = NewEcommerceMetrics()
    if err != nil {
        return nil, err
    }
    
    mm.userBehavior, err = NewUserBehaviorMetrics()
    if err != nil {
        return nil, err
    }
    
    mm.workflow, err = NewWorkflowMetrics()
    if err != nil {
        return nil, err
    }
    
    mm.sli, err = NewSLIMetrics()
    if err != nil {
        return nil, err
    }
    
    return mm, nil
}

// Ecommerce 获取电商指标
func (mm *MetricsManager) Ecommerce() *EcommerceMetrics {
    return mm.ecommerce
}

// UserBehavior 获取用户行为指标
func (mm *MetricsManager) UserBehavior() *UserBehaviorMetrics {
    return mm.userBehavior
}

// Workflow 获取工作流指标
func (mm *MetricsManager) Workflow() *WorkflowMetrics {
    return mm.workflow
}

// SLI 获取 SLI 指标
func (mm *MetricsManager) SLI() *SLIMetrics {
    return mm.sli
}
```

---

## 5. 完整示例

### 5.1 电商系统

*(见 2.1 业务 KPI 指标)*-

### 5.2 SaaS 系统

```go
// SaaSMetrics SaaS 系统指标
type SaaSMetrics struct {
    signups        metric.Int64Counter    // 注册数
    activeUsers    metric.Int64Counter    // 活跃用户
    churn          metric.Int64Counter    // 流失用户
    mrr            metric.Float64Counter  // 月度经常性收入
    subscriptions  metric.Int64Counter    // 订阅数
}
```

### 5.3 金融系统

```go
// FinanceMetrics 金融系统指标
type FinanceMetrics struct {
    transactionsTotal  metric.Int64Counter    // 交易总数
    transactionsValue  metric.Float64Counter  // 交易总额
    fraudDetected      metric.Int64Counter    // 检测到的欺诈
    riskScore          metric.Float64Histogram // 风险评分分布
}
```

---

## 6. 最佳实践

### 6.1 命名规范

**遵循 OpenTelemetry 命名约定**：

- 使用点号分隔（如 `ecommerce.orders.total`）
- 使用复数（如 `orders` 而非 `order`）
- 避免缩写（如 `duration` 而非 `dur`）
- 包含单位（如 `{order}`, `s`, `By`）

**示例**：

```go
// ✅ 好
"ecommerce.orders.total"  // {order}
"http.server.request.duration"  // s
"db.client.connections.usage"  // {connection}

// ❌ 不好
"order_count"  // 使用下划线
"req_dur"  // 过度缩写
"httpLatency"  // 驼峰命名
```

### 6.2 标签设计

**原则**：

1. **低基数**：避免高基数标签（如用户 ID、时间戳）
2. **有意义**：标签应有助于过滤和聚合
3. **一致性**：在不同指标中使用相同的标签名

```go
// ✅ 好
attribute.String("order.status", "completed")
attribute.String("payment.method", "credit_card")
attribute.String("user.tier", "premium")

// ❌ 不好
attribute.String("user.id", "12345678")  // 高基数
attribute.String("timestamp", "2025-10-09T12:34:56Z")  // 不必要
```

### 6.3 性能优化

**1. 批量记录**：

```go
// ❌ 低效
for _, order := range orders {
    metrics.ordersTotal.Add(ctx, 1)
}

// ✅ 高效
metrics.ordersTotal.Add(ctx, int64(len(orders)))
```

**2. 条件采样**：

```go
// 对高频事件采样
if rand.Float64() < 0.1 { // 10% 采样
    metrics.pageViews.Add(ctx, 1)
}
```

**3. 异步记录**：

```go
go func() {
    metrics.longRunning.Record(ctx, value)
}()
```

### 6.4 告警规则

**业务告警示例**：

```yaml
groups:
  - name: business_alerts
    rules:
      # 订单下降告警
      - alert: OrderRateDropping
        expr: |
          rate(ecommerce_orders_total[5m]) <
          0.8 * rate(ecommerce_orders_total[1h] offset 1d)
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "订单速率下降超过 20%"
      
      # 支付成功率低
      - alert: LowPaymentSuccessRate
        expr: |
          sum(rate(ecommerce_payments_success[5m])) /
          sum(rate(ecommerce_payments_total[5m])) < 0.95
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "支付成功率低于 95%"
      
      # SLO 违反
      - alert: SLOViolation
        expr: |
          sum(rate(sli_requests_success[30d])) /
          sum(rate(sli_requests_total[30d])) < 0.999
        for: 1h
        labels:
          severity: critical
        annotations:
          summary: "SLO 违反（可用性 < 99.9%）"
```

---

## 7. 常见模式

### 7.1 漏斗分析

```go
// FunnelMetrics 漏斗指标
type FunnelMetrics struct {
    step1 metric.Int64Counter  // 第一步
    step2 metric.Int64Counter  // 第二步
    step3 metric.Int64Counter  // 第三步
    step4 metric.Int64Counter  // 第四步
}

// 计算转化率：
// step1 -> step2: rate(step2) / rate(step1)
// step2 -> step3: rate(step3) / rate(step2)
```

### 7.2 队列监控

```go
// QueueMetrics 队列指标
type QueueMetrics struct {
    length      metric.Int64ObservableUpDownCounter  // 队列长度
    enqueues    metric.Int64Counter                  // 入队次数
    dequeues    metric.Int64Counter                  // 出队次数
    waitTime    metric.Float64Histogram              // 等待时间
}
```

### 7.3 限流监控

```go
// RateLimiterMetrics 限流器指标
type RateLimiterMetrics struct {
    requests  metric.Int64Counter  // 总请求数
    allowed   metric.Int64Counter  // 允许的请求
    rejected  metric.Int64Counter  // 拒绝的请求
}
```

---

## 8. 常见问题

**Q1: Counter 和 Histogram 如何选择？**

A:

- **Counter**：适合计数（如订单数、请求数）
- **Histogram**：适合分布统计（如延迟、金额）

**Q2: 如何避免指标爆炸？**

A:

1. 限制标签基数（避免用户 ID 等高基数标签）
2. 使用聚合（如状态码分组为 `2xx`, `4xx`, `5xx`）
3. 定期审查指标，删除未使用的指标

**Q3: 如何设置 SLO？**

A:

1. 从业务需求出发（如"用户可接受的最大延迟是多少？"）
2. 参考行业标准（如 Google SRE 书籍）
3. 从宽松开始，逐步收紧

**Q4: 业务指标应该多久导出一次？**

A:

- **实时指标**（如支付成功率）：10-30 秒
- **趋势指标**（如 DAU）：1-5 分钟
- **SLI/SLO**：根据时间窗口（如 30 天）

**Q5: 如何测试业务指标？**

A:

```go
func TestEcommerceMetrics(t *testing.T) {
    // 使用内存导出器
    exporter := metric.NewManualReader()
    provider := metric.NewMeterProvider(
        metric.WithReader(exporter),
    )
    otel.SetMeterProvider(provider)
    
    metrics, _ := NewEcommerceMetrics()
    
    // 记录指标
    ctx := context.Background()
    metrics.RecordOrder(ctx, "order-123", 99.99, "completed")
    
    // 读取指标
    rm := metricdata.ResourceMetrics{}
    exporter.Collect(ctx, &rm)
    
    // 断言
    // ...
}
```

---

## 总结

本文档详细介绍了自定义指标和业务指标的设计与实现，涵盖：

✅ **业务指标**：KPI、用户行为、业务流程  
✅ **SLI/SLO**：可用性、延迟、错误预算  
✅ **Go 实现**：Counter、Gauge、Histogram、指标管理器  
✅ **完整示例**：电商、SaaS、金融系统  
✅ **最佳实践**：命名规范、标签设计、性能优化、告警规则  
✅ **常见模式**：漏斗分析、队列监控、限流监控  

**下一步**：

- 📖 复习《系统指标》《运行时指标》《HTTP 指标》《数据库指标》
- 📖 阅读《Log 约定》学习日志语义约定
- 🔗 参考 [Google SRE Book - Implementing SLOs](https://sre.google/sre-book/implementing-slos/)

**参考资源**：

- [OpenTelemetry Metrics API](https://opentelemetry.io/docs/specs/otel/metrics/api/)
- [The Four Golden Signals (Google SRE)](https://sre.google/sre-book/monitoring-distributed-systems/)
- [RED Method](https://www.weave.works/blog/the-red-method-key-metrics-for-microservices-architecture/)
