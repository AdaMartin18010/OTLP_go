# Go 运行时指标（Go Runtime Metrics）

## 目录

- [Go 运行时指标（Go Runtime Metrics）](#go-运行时指标go-runtime-metrics)
  - [目录](#目录)
  - [1. 概述](#1-概述)
  - [2. 内存指标](#2-内存指标)
    - [2.1 堆内存](#21-堆内存)
    - [2.2 栈内存](#22-栈内存)
    - [2.3 内存分配](#23-内存分配)
    - [2.4 Go 1.25.1 实现](#24-go-1251-实现)
  - [3. GC 指标](#3-gc-指标)
    - [3.1 GC 周期](#31-gc-周期)
    - [3.2 GC 暂停](#32-gc-暂停)
    - [3.3 GC CPU 占用](#33-gc-cpu-占用)
    - [3.4 Go 1.25.1 实现](#34-go-1251-实现)
  - [4. Goroutine 指标](#4-goroutine-指标)
    - [4.1 Goroutine 数量](#41-goroutine-数量)
    - [4.2 调度器指标](#42-调度器指标)
    - [4.3 Go 1.25.1 实现](#43-go-1251-实现)
  - [5. CGO 指标](#5-cgo-指标)
    - [5.1 CGO 调用](#51-cgo-调用)
    - [5.2 Go 1.25.1 实现](#52-go-1251-实现)
  - [6. runtime/metrics 深度集成](#6-runtimemetrics-深度集成)
    - [6.1 指标发现](#61-指标发现)
    - [6.2 批量采集](#62-批量采集)
    - [6.3 Go 1.25.1 新特性](#63-go-1251-新特性)
  - [7. 完整示例](#7-完整示例)
    - [7.1 运行时监控器](#71-运行时监控器)
    - [7.2 性能分析集成](#72-性能分析集成)
    - [7.3 生产环境配置](#73-生产环境配置)
  - [8. 最佳实践](#8-最佳实践)
    - [8.1 指标选择](#81-指标选择)
    - [8.2 采集频率](#82-采集频率)
    - [8.3 内存优化](#83-内存优化)
    - [8.4 告警配置](#84-告警配置)
  - [9. 常见问题](#9-常见问题)
  - [总结](#总结)

---

## 1. 概述

Go 运行时指标提供了 Go 程序内部状态的深入洞察，包括内存管理、垃圾回收、Goroutine 调度等关键信息。Go 1.25.1 通过增强的 `runtime/metrics` 包提供了更全面的运行时可观测性。

**核心价值**：

- 🎯 **性能诊断**：识别内存泄漏、GC 压力、Goroutine 泄漏
- 📊 **容量规划**：了解应用的资源需求
- 🚨 **异常告警**：及时发现运行时异常
- 📈 **趋势分析**：跟踪应用性能演变

**OpenTelemetry 规范**：

- [Runtime Metrics Semantic Conventions](https://opentelemetry.io/docs/specs/semconv/runtime/)
- [Go Runtime Metrics](https://pkg.go.dev/runtime/metrics)

---

## 2. 内存指标

### 2.1 堆内存

**指标名称**：`runtime.go.mem.heap`

**描述**：堆内存使用情况

**单位**：`By`

**指标类型**：UpDownCounter

**子指标**：

- `runtime.go.mem.heap.alloc`：当前分配的堆内存（字节）
- `runtime.go.mem.heap.idle`：空闲堆内存（字节）
- `runtime.go.mem.heap.inuse`：正在使用的堆内存（字节）
- `runtime.go.mem.heap.released`：已释放给操作系统的内存（字节）
- `runtime.go.mem.heap.objects`：堆上的对象数量

**对应 runtime 指标**：

```go
var m runtime.MemStats
runtime.ReadMemStats(&m)

m.HeapAlloc    // 已分配且仍在使用
m.HeapIdle     // 空闲但未释放
m.HeapInuse    // 正在使用
m.HeapReleased // 已释放给 OS
m.HeapObjects  // 对象数
```

### 2.2 栈内存

**指标名称**：`runtime.go.mem.stack`

**描述**：栈内存使用情况

**单位**：`By`

**指标类型**：UpDownCounter

**子指标**：

- `runtime.go.mem.stack.inuse`：栈内存使用量
- `runtime.go.mem.stack.sys`：从操作系统获取的栈内存总量

### 2.3 内存分配

**指标名称**：`runtime.go.mem.alloc`

**描述**：内存分配统计

**单位**：`By` / `{allocation}`

**指标类型**：Counter

**子指标**：

- `runtime.go.mem.alloc.total`：累计分配的内存（字节）
- `runtime.go.mem.alloc.mallocs`：累计分配次数
- `runtime.go.mem.alloc.frees`：累计释放次数
- `runtime.go.mem.alloc.lookups`：指针查找次数

### 2.4 Go 1.25.1 实现

```go
package runtimemetrics

import (
    "context"
    "fmt"
    "runtime"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// MemoryMetrics Go 内存指标
type MemoryMetrics struct {
    meter        metric.Meter
    heapAlloc    metric.Int64ObservableUpDownCounter
    heapIdle     metric.Int64ObservableUpDownCounter
    heapInuse    metric.Int64ObservableUpDownCounter
    heapReleased metric.Int64ObservableUpDownCounter
    heapObjects  metric.Int64ObservableUpDownCounter
    stackInuse   metric.Int64ObservableUpDownCounter
    stackSys     metric.Int64ObservableUpDownCounter
    allocTotal   metric.Int64ObservableCounter
    mallocs      metric.Int64ObservableCounter
    frees        metric.Int64ObservableCounter
    lookups      metric.Int64ObservableCounter
}

// NewMemoryMetrics 创建 Go 内存指标收集器
func NewMemoryMetrics() (*MemoryMetrics, error) {
    meter := otel.Meter("runtime.go")
    
    mm := &MemoryMetrics{
        meter: meter,
    }
    
    var err error
    
    // 堆内存指标
    mm.heapAlloc, err = meter.Int64ObservableUpDownCounter(
        "runtime.go.mem.heap.alloc",
        metric.WithDescription("Heap memory allocated"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 heap.alloc 指标失败: %w", err)
    }
    
    mm.heapIdle, err = meter.Int64ObservableUpDownCounter(
        "runtime.go.mem.heap.idle",
        metric.WithDescription("Heap memory idle"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 heap.idle 指标失败: %w", err)
    }
    
    mm.heapInuse, err = meter.Int64ObservableUpDownCounter(
        "runtime.go.mem.heap.inuse",
        metric.WithDescription("Heap memory in use"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 heap.inuse 指标失败: %w", err)
    }
    
    mm.heapReleased, err = meter.Int64ObservableUpDownCounter(
        "runtime.go.mem.heap.released",
        metric.WithDescription("Heap memory released to OS"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 heap.released 指标失败: %w", err)
    }
    
    mm.heapObjects, err = meter.Int64ObservableUpDownCounter(
        "runtime.go.mem.heap.objects",
        metric.WithDescription("Number of heap objects"),
        metric.WithUnit("{object}"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 heap.objects 指标失败: %w", err)
    }
    
    // 栈内存指标
    mm.stackInuse, err = meter.Int64ObservableUpDownCounter(
        "runtime.go.mem.stack.inuse",
        metric.WithDescription("Stack memory in use"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 stack.inuse 指标失败: %w", err)
    }
    
    mm.stackSys, err = meter.Int64ObservableUpDownCounter(
        "runtime.go.mem.stack.sys",
        metric.WithDescription("Stack memory from OS"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 stack.sys 指标失败: %w", err)
    }
    
    // 分配统计
    mm.allocTotal, err = meter.Int64ObservableCounter(
        "runtime.go.mem.alloc.total",
        metric.WithDescription("Total bytes allocated"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 alloc.total 指标失败: %w", err)
    }
    
    mm.mallocs, err = meter.Int64ObservableCounter(
        "runtime.go.mem.alloc.mallocs",
        metric.WithDescription("Total number of mallocs"),
        metric.WithUnit("{allocation}"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 mallocs 指标失败: %w", err)
    }
    
    mm.frees, err = meter.Int64ObservableCounter(
        "runtime.go.mem.alloc.frees",
        metric.WithDescription("Total number of frees"),
        metric.WithUnit("{allocation}"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 frees 指标失败: %w", err)
    }
    
    mm.lookups, err = meter.Int64ObservableCounter(
        "runtime.go.mem.alloc.lookups",
        metric.WithDescription("Total number of pointer lookups"),
        metric.WithUnit("{lookup}"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 lookups 指标失败: %w", err)
    }
    
    // 注册回调
    if _, err := meter.RegisterCallback(mm.observeMemory,
        mm.heapAlloc, mm.heapIdle, mm.heapInuse, mm.heapReleased, mm.heapObjects,
        mm.stackInuse, mm.stackSys,
        mm.allocTotal, mm.mallocs, mm.frees, mm.lookups,
    ); err != nil {
        return nil, fmt.Errorf("注册内存指标回调失败: %w", err)
    }
    
    return mm, nil
}

// observeMemory 观察内存指标
func (mm *MemoryMetrics) observeMemory(ctx context.Context, observer metric.Observer) error {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    // 堆内存
    observer.ObserveInt64(mm.heapAlloc, int64(m.HeapAlloc))
    observer.ObserveInt64(mm.heapIdle, int64(m.HeapIdle))
    observer.ObserveInt64(mm.heapInuse, int64(m.HeapInuse))
    observer.ObserveInt64(mm.heapReleased, int64(m.HeapReleased))
    observer.ObserveInt64(mm.heapObjects, int64(m.HeapObjects))
    
    // 栈内存
    observer.ObserveInt64(mm.stackInuse, int64(m.StackInuse))
    observer.ObserveInt64(mm.stackSys, int64(m.StackSys))
    
    // 分配统计
    observer.ObserveInt64(mm.allocTotal, int64(m.TotalAlloc))
    observer.ObserveInt64(mm.mallocs, int64(m.Mallocs))
    observer.ObserveInt64(mm.frees, int64(m.Frees))
    observer.ObserveInt64(mm.lookups, int64(m.Lookups))
    
    return nil
}
```

---

## 3. GC 指标

### 3.1 GC 周期

**指标名称**：`runtime.go.gc.count`

**描述**：GC 周期计数

**单位**：`{gc}`

**指标类型**：Counter

**指标名称**：`runtime.go.gc.pause.total`

**描述**：GC 暂停总时间（秒）

**单位**：`s`

**指标类型**：Counter

### 3.2 GC 暂停

**指标名称**：`runtime.go.gc.pause.duration`

**描述**：GC 暂停时间分布（直方图）

**单位**：`s`

**指标类型**：Histogram

**推荐桶边界**：

```go
[]float64{
    0.000001,  // 1 µs
    0.00001,   // 10 µs
    0.0001,    // 100 µs
    0.001,     // 1 ms
    0.01,      // 10 ms
    0.1,       // 100 ms
    1.0,       // 1 s
}
```

### 3.3 GC CPU 占用

**指标名称**：`runtime.go.gc.cpu.fraction`

**描述**：GC 占用的 CPU 比例（0.0 到 1.0）

**单位**：`1`

**指标类型**：Gauge

### 3.4 Go 1.25.1 实现

```go
package runtimemetrics

import (
    "context"
    "fmt"
    "runtime"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/metric"
)

// GCMetrics Go GC 指标
type GCMetrics struct {
    meter          metric.Meter
    gcCount        metric.Int64ObservableCounter
    pauseTotal     metric.Float64ObservableCounter
    pauseDuration  metric.Float64Histogram
    cpuFraction    metric.Float64ObservableGauge
    lastNumGC      uint32
}

// NewGCMetrics 创建 GC 指标收集器
func NewGCMetrics() (*GCMetrics, error) {
    meter := otel.Meter("runtime.go")
    
    gm := &GCMetrics{
        meter: meter,
    }
    
    var err error
    
    // GC 次数
    gm.gcCount, err = meter.Int64ObservableCounter(
        "runtime.go.gc.count",
        metric.WithDescription("Number of completed GC cycles"),
        metric.WithUnit("{gc}"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 gc.count 指标失败: %w", err)
    }
    
    // GC 暂停总时间
    gm.pauseTotal, err = meter.Float64ObservableCounter(
        "runtime.go.gc.pause.total",
        metric.WithDescription("Total GC pause time"),
        metric.WithUnit("s"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 gc.pause.total 指标失败: %w", err)
    }
    
    // GC 暂停时间直方图
    gm.pauseDuration, err = meter.Float64Histogram(
        "runtime.go.gc.pause.duration",
        metric.WithDescription("GC pause duration"),
        metric.WithUnit("s"),
        metric.WithExplicitBucketBoundaries(
            0.000001, 0.00001, 0.0001, 0.001, 0.01, 0.1, 1.0,
        ),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 gc.pause.duration 指标失败: %w", err)
    }
    
    // GC CPU 占用比例
    gm.cpuFraction, err = meter.Float64ObservableGauge(
        "runtime.go.gc.cpu.fraction",
        metric.WithDescription("Fraction of CPU time used by GC"),
        metric.WithUnit("1"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 gc.cpu.fraction 指标失败: %w", err)
    }
    
    // 注册回调
    if _, err := meter.RegisterCallback(gm.observeGC,
        gm.gcCount,
        gm.pauseTotal,
        gm.cpuFraction,
    ); err != nil {
        return nil, fmt.Errorf("注册 GC 指标回调失败: %w", err)
    }
    
    return gm, nil
}

// observeGC 观察 GC 指标
func (gm *GCMetrics) observeGC(ctx context.Context, observer metric.Observer) error {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    // GC 次数
    observer.ObserveInt64(gm.gcCount, int64(m.NumGC))
    
    // GC 暂停总时间（纳秒转秒）
    observer.ObserveFloat64(gm.pauseTotal, float64(m.PauseTotalNs)/1e9)
    
    // GC CPU 占用比例
    observer.ObserveFloat64(gm.cpuFraction, m.GCCPUFraction)
    
    // 记录新的 GC 暂停（直方图）
    // 注意：这里只记录自上次采集以来的新 GC 暂停
    numGC := m.NumGC
    if numGC > gm.lastNumGC {
        // 最近的 GC 暂停存储在循环缓冲区中
        for i := gm.lastNumGC; i < numGC; i++ {
            idx := i % uint32(len(m.PauseNs))
            pauseNs := m.PauseNs[idx]
            pauseS := float64(pauseNs) / 1e9
            gm.pauseDuration.Record(ctx, pauseS)
        }
        gm.lastNumGC = numGC
    }
    
    return nil
}
```

---

## 4. Goroutine 指标

### 4.1 Goroutine 数量

**指标名称**：`runtime.go.goroutines`

**描述**：当前 Goroutine 数量

**单位**：`{goroutine}`

**指标类型**：UpDownCounter

### 4.2 调度器指标

**指标名称**：`runtime.go.sched.*`

**描述**：调度器相关指标

**子指标**：

- `runtime.go.sched.procs`：GOMAXPROCS 值（P 的数量）
- `runtime.go.sched.threads`：操作系统线程数（M 的数量）
- `runtime.go.sched.idle.threads`：空闲线程数

### 4.3 Go 1.25.1 实现

```go
package runtimemetrics

import (
    "context"
    "fmt"
    "runtime"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/metric"
)

// GoroutineMetrics Goroutine 指标
type GoroutineMetrics struct {
    meter       metric.Meter
    goroutines  metric.Int64ObservableUpDownCounter
    procs       metric.Int64ObservableUpDownCounter
    threads     metric.Int64ObservableUpDownCounter
}

// NewGoroutineMetrics 创建 Goroutine 指标收集器
func NewGoroutineMetrics() (*GoroutineMetrics, error) {
    meter := otel.Meter("runtime.go")
    
    gm := &GoroutineMetrics{
        meter: meter,
    }
    
    var err error
    
    // Goroutine 数量
    gm.goroutines, err = meter.Int64ObservableUpDownCounter(
        "runtime.go.goroutines",
        metric.WithDescription("Number of goroutines"),
        metric.WithUnit("{goroutine}"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 goroutines 指标失败: %w", err)
    }
    
    // GOMAXPROCS
    gm.procs, err = meter.Int64ObservableUpDownCounter(
        "runtime.go.sched.procs",
        metric.WithDescription("Number of OS threads for goroutines (GOMAXPROCS)"),
        metric.WithUnit("{thread}"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 sched.procs 指标失败: %w", err)
    }
    
    // 线程数（M）
    gm.threads, err = meter.Int64ObservableUpDownCounter(
        "runtime.go.sched.threads",
        metric.WithDescription("Number of OS threads"),
        metric.WithUnit("{thread}"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 sched.threads 指标失败: %w", err)
    }
    
    // 注册回调
    if _, err := meter.RegisterCallback(gm.observeGoroutines,
        gm.goroutines,
        gm.procs,
        gm.threads,
    ); err != nil {
        return nil, fmt.Errorf("注册 Goroutine 指标回调失败: %w", err)
    }
    
    return gm, nil
}

// observeGoroutines 观察 Goroutine 指标
func (gm *GoroutineMetrics) observeGoroutines(ctx context.Context, observer metric.Observer) error {
    // Goroutine 数量
    observer.ObserveInt64(gm.goroutines, int64(runtime.NumGoroutine()))
    
    // GOMAXPROCS
    observer.ObserveInt64(gm.procs, int64(runtime.GOMAXPROCS(0)))
    
    // 线程数（需要 runtime.NumCgoCall 间接估算，或使用 runtime/metrics）
    // 这里使用简化版本
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    observer.ObserveInt64(gm.threads, int64(m.NumCgoCall)) // 近似值
    
    return nil
}
```

---

## 5. CGO 指标

### 5.1 CGO 调用

**指标名称**：`runtime.go.cgo.calls`

**描述**：CGO 调用次数

**单位**：`{call}`

**指标类型**：Counter

### 5.2 Go 1.25.1 实现

```go
package runtimemetrics

import (
    "context"
    "fmt"
    "runtime"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/metric"
)

// CGOMetrics CGO 指标
type CGOMetrics struct {
    meter     metric.Meter
    cgoCalls  metric.Int64ObservableCounter
}

// NewCGOMetrics 创建 CGO 指标收集器
func NewCGOMetrics() (*CGOMetrics, error) {
    meter := otel.Meter("runtime.go")
    
    cm := &CGOMetrics{
        meter: meter,
    }
    
    var err error
    
    cm.cgoCalls, err = meter.Int64ObservableCounter(
        "runtime.go.cgo.calls",
        metric.WithDescription("Number of CGO calls"),
        metric.WithUnit("{call}"),
    )
    if err != nil {
        return nil, fmt.Errorf("创建 cgo.calls 指标失败: %w", err)
    }
    
    if _, err := meter.RegisterCallback(cm.observeCGO, cm.cgoCalls); err != nil {
        return nil, fmt.Errorf("注册 CGO 指标回调失败: %w", err)
    }
    
    return cm, nil
}

// observeCGO 观察 CGO 指标
func (cm *CGOMetrics) observeCGO(ctx context.Context, observer metric.Observer) error {
    observer.ObserveInt64(cm.cgoCalls, runtime.NumCgoCall())
    return nil
}
```

---

## 6. runtime/metrics 深度集成

Go 1.16+ 引入了 `runtime/metrics` 包，提供了更详细的运行时指标。Go 1.25.1 进一步增强了该包。

### 6.1 指标发现

```go
package runtimemetrics

import (
    "runtime/metrics"
    "strings"
)

// DiscoverMetrics 发现所有可用的 runtime 指标
func DiscoverMetrics() []metrics.Description {
    return metrics.All()
}

// FilterMetrics 过滤指标
func FilterMetrics(prefix string) []metrics.Description {
    all := metrics.All()
    var filtered []metrics.Description
    
    for _, desc := range all {
        if strings.HasPrefix(desc.Name, prefix) {
            filtered = append(filtered, desc)
        }
    }
    
    return filtered
}

// PrintMetrics 打印所有指标（调试用）
func PrintMetrics() {
    for _, desc := range metrics.All() {
        fmt.Printf("%s (%s): %s\n", desc.Name, desc.Kind, desc.Description)
    }
}
```

**示例输出**（部分）：

```text
/gc/cycles/automatic:gc-cycles: Number of automatic GC cycles
/gc/cycles/forced:gc-cycles: Number of forced GC cycles
/gc/cycles/total:gc-cycles: Total number of GC cycles
/gc/heap/allocs:bytes: Cumulative sum of heap allocations
/gc/heap/frees:bytes: Cumulative sum of heap frees
/gc/heap/goal:bytes: Heap size target for the end of the GC cycle
/gc/heap/objects:objects: Number of objects allocated
/gc/pauses:seconds: Distribution of GC pause times
/memory/classes/heap/free:bytes: Free heap memory
/memory/classes/heap/objects:bytes: Memory used by heap objects
/sched/goroutines:goroutines: Number of goroutines
/sched/latencies:seconds: Distribution of scheduling latencies
```

### 6.2 批量采集

```go
package runtimemetrics

import (
    "context"
    "fmt"
    "runtime/metrics"
    "strings"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/metric"
)

// RuntimeMetricsCollector 统一的 runtime/metrics 收集器
type RuntimeMetricsCollector struct {
    meter   metric.Meter
    samples []metrics.Sample
    instruments map[string]any // 缓存 OTel 仪器
}

// NewRuntimeMetricsCollector 创建收集器
func NewRuntimeMetricsCollector() (*RuntimeMetricsCollector, error) {
    meter := otel.Meter("runtime.go")
    
    // 获取所有指标描述
    descs := metrics.All()
    
    // 准备样本切片
    samples := make([]metrics.Sample, len(descs))
    for i, desc := range descs {
        samples[i].Name = desc.Name
    }
    
    rmc := &RuntimeMetricsCollector{
        meter:       meter,
        samples:     samples,
        instruments: make(map[string]any),
    }
    
    // 为每个 runtime 指标创建对应的 OTel 仪器
    if err := rmc.createInstruments(descs); err != nil {
        return nil, err
    }
    
    return rmc, nil
}

// createInstruments 为 runtime 指标创建 OTel 仪器
func (rmc *RuntimeMetricsCollector) createInstruments(descs []metrics.Description) error {
    for _, desc := range descs {
        // 转换指标名称：/gc/cycles/total -> runtime.go.gc.cycles.total
        name := "runtime.go" + strings.ReplaceAll(desc.Name, "/", ".")
        
        // 根据 Kind 创建不同类型的仪器
        switch desc.Kind {
        case metrics.KindUint64:
            if desc.Cumulative {
                inst, err := rmc.meter.Int64ObservableCounter(
                    name,
                    metric.WithDescription(desc.Description),
                )
                if err != nil {
                    return err
                }
                rmc.instruments[desc.Name] = inst
            } else {
                inst, err := rmc.meter.Int64ObservableUpDownCounter(
                    name,
                    metric.WithDescription(desc.Description),
                )
                if err != nil {
                    return err
                }
                rmc.instruments[desc.Name] = inst
            }
        case metrics.KindFloat64:
            if desc.Cumulative {
                inst, err := rmc.meter.Float64ObservableCounter(
                    name,
                    metric.WithDescription(desc.Description),
                )
                if err != nil {
                    return err
                }
                rmc.instruments[desc.Name] = inst
            } else {
                inst, err := rmc.meter.Float64ObservableGauge(
                    name,
                    metric.WithDescription(desc.Description),
                )
                if err != nil {
                    return err
                }
                rmc.instruments[desc.Name] = inst
            }
        case metrics.KindFloat64Histogram:
            // 直方图需要特殊处理（见下文）
            continue
        }
    }
    
    // 注册回调
    var instruments []metric.Observable
    for _, inst := range rmc.instruments {
        if obs, ok := inst.(metric.Observable); ok {
            instruments = append(instruments, obs)
        }
    }
    
    if _, err := rmc.meter.RegisterCallback(rmc.observe, instruments...); err != nil {
        return fmt.Errorf("注册回调失败: %w", err)
    }
    
    return nil
}

// observe 观察所有 runtime 指标
func (rmc *RuntimeMetricsCollector) observe(ctx context.Context, observer metric.Observer) error {
    // 批量读取所有指标
    metrics.Read(rmc.samples)
    
    // 报告每个指标
    for _, sample := range rmc.samples {
        inst, ok := rmc.instruments[sample.Name]
        if !ok {
            continue
        }
        
        switch sample.Value.Kind() {
        case metrics.KindUint64:
            val := int64(sample.Value.Uint64())
            switch i := inst.(type) {
            case metric.Int64ObservableCounter:
                observer.ObserveInt64(i, val)
            case metric.Int64ObservableUpDownCounter:
                observer.ObserveInt64(i, val)
            }
        case metrics.KindFloat64:
            val := sample.Value.Float64()
            switch i := inst.(type) {
            case metric.Float64ObservableCounter:
                observer.ObserveFloat64(i, val)
            case metric.Float64ObservableGauge:
                observer.ObserveFloat64(i, val)
            }
        case metrics.KindFloat64Histogram:
            // 直方图需要转换为 OTel 直方图（复杂，见下文）
        }
    }
    
    return nil
}
```

### 6.3 Go 1.25.1 新特性

Go 1.25.1 在 `runtime/metrics` 中新增了以下指标（示例）：

- `/sched/latencies:seconds`：调度延迟分布
- `/sync/mutex/wait/total:seconds`：互斥锁等待总时间
- `/gc/limiter/last-enabled:gc-cycle`：GC 限制器最后启用的周期

```go
// 示例：监控调度延迟
func monitorSchedLatencies(ctx context.Context, histogram metric.Float64Histogram) {
    samples := []metrics.Sample{
        {Name: "/sched/latencies:seconds"},
    }
    
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            metrics.Read(samples)
            
            if samples[0].Value.Kind() == metrics.KindFloat64Histogram {
                hist := samples[0].Value.Float64Histogram()
                
                // 转换为 OTel 直方图记录
                for i, count := range hist.Counts {
                    if count > 0 {
                        // 使用桶的中点作为样本值
                        midpoint := (hist.Buckets[i] + hist.Buckets[i+1]) / 2
                        for j := uint64(0); j < count; j++ {
                            histogram.Record(ctx, midpoint)
                        }
                    }
                }
            }
        }
    }
}
```

---

## 7. 完整示例

### 7.1 运行时监控器

```go
package main

import (
    "context"
    "log"
    "os"
    "os/signal"
    "syscall"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
    "go.opentelemetry.io/otel/sdk/metric"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
)

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    // 创建资源
    res, err := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName("runtime-monitor"),
            semconv.ServiceVersion("1.0.0"),
        ),
    )
    if err != nil {
        log.Fatalf("创建资源失败: %v", err)
    }
    
    // 创建导出器
    exporter, err := otlpmetricgrpc.New(ctx,
        otlpmetricgrpc.WithInsecure(),
        otlpmetricgrpc.WithEndpoint("localhost:4317"),
    )
    if err != nil {
        log.Fatalf("创建导出器失败: %v", err)
    }
    defer exporter.Shutdown(ctx)
    
    // 创建 Meter Provider
    provider := metric.NewMeterProvider(
        metric.WithResource(res),
        metric.WithReader(metric.NewPeriodicReader(exporter,
            metric.WithInterval(10*time.Second),
        )),
    )
    defer provider.Shutdown(ctx)
    
    otel.SetMeterProvider(provider)
    
    // 初始化运行时指标收集器
    if _, err := NewMemoryMetrics(); err != nil {
        log.Fatalf("初始化内存指标失败: %v", err)
    }
    
    if _, err := NewGCMetrics(); err != nil {
        log.Fatalf("初始化 GC 指标失败: %v", err)
    }
    
    if _, err := NewGoroutineMetrics(); err != nil {
        log.Fatalf("初始化 Goroutine 指标失败: %v", err)
    }
    
    if _, err := NewCGOMetrics(); err != nil {
        log.Fatalf("初始化 CGO 指标失败: %v", err)
    }
    
    // 可选：使用统一的 runtime/metrics 收集器
    if _, err := NewRuntimeMetricsCollector(); err != nil {
        log.Fatalf("初始化 runtime/metrics 收集器失败: %v", err)
    }
    
    log.Println("运行时监控启动，按 Ctrl+C 退出")
    
    // 模拟应用负载（可选）
    go simulateLoad(ctx)
    
    // 等待信号
    sigCh := make(chan os.Signal, 1)
    signal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)
    <-sigCh
    
    log.Println("正在关闭运行时监控...")
}

// simulateLoad 模拟应用负载
func simulateLoad(ctx context.Context) {
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            // 分配一些内存
            data := make([]byte, 1024*1024) // 1 MB
            _ = data
            
            // 启动一些 goroutines
            for i := 0; i < 10; i++ {
                go func() {
                    time.Sleep(100 * time.Millisecond)
                }()
            }
        }
    }
}
```

### 7.2 性能分析集成

将运行时指标与 `runtime/pprof` 结合：

```go
package runtimemetrics

import (
    "runtime"
    "runtime/pprof"
    "time"
)

// EnableProfiling 启用性能分析
func EnableProfiling() {
    // 启用阻塞分析
    runtime.SetBlockProfileRate(1)
    
    // 启用互斥锁分析
    runtime.SetMutexProfileFraction(1)
}

// CollectProfile 收集性能分析数据
func CollectProfile(name string, duration time.Duration) error {
    p := pprof.Lookup(name)
    if p == nil {
        return fmt.Errorf("profile %s not found", name)
    }
    
    // 写入到文件或导出到监控系统
    // ...
    
    return nil
}
```

### 7.3 生产环境配置

```go
package config

import (
    "time"
)

// RuntimeMetricsConfig 运行时指标配置
type RuntimeMetricsConfig struct {
    // 采集间隔
    CollectionInterval time.Duration
    
    // 启用的指标
    EnableMemory     bool
    EnableGC         bool
    EnableGoroutines bool
    EnableCGO        bool
    EnableScheduler  bool
    
    // GC 触发阈值
    GCPauseThreshold time.Duration
    
    // Goroutine 泄漏阈值
    GoroutineLeakThreshold int
    
    // 内存泄漏检测
    MemoryLeakDetection bool
    MemoryGrowthRate    float64 // MB/s
}

// DefaultConfig 默认配置
func DefaultConfig() RuntimeMetricsConfig {
    return RuntimeMetricsConfig{
        CollectionInterval:     10 * time.Second,
        EnableMemory:           true,
        EnableGC:               true,
        EnableGoroutines:       true,
        EnableCGO:              false, // 仅在使用 CGO 时启用
        EnableScheduler:        true,
        GCPauseThreshold:       100 * time.Millisecond,
        GoroutineLeakThreshold: 10000,
        MemoryLeakDetection:    true,
        MemoryGrowthRate:       10.0, // 10 MB/s
    }
}

// ProductionConfig 生产环境配置
func ProductionConfig() RuntimeMetricsConfig {
    cfg := DefaultConfig()
    cfg.CollectionInterval = 30 * time.Second // 减少采集频率
    cfg.EnableScheduler = false               // 调度器指标开销较大
    return cfg
}
```

---

## 8. 最佳实践

### 8.1 指标选择

**必须监控的指标**：

- ✅ `runtime.go.mem.heap.alloc`：堆内存使用
- ✅ `runtime.go.gc.pause.duration`：GC 暂停时间
- ✅ `runtime.go.goroutines`：Goroutine 数量

**可选指标**：

- `runtime.go.mem.stack.inuse`：栈内存（高并发场景）
- `runtime.go.gc.cpu.fraction`：GC CPU 占用（性能敏感场景）
- `runtime.go.cgo.calls`：CGO 调用（使用 CGO 时）

### 8.2 采集频率

| 指标类型 | 推荐频率 | 说明 |
|---------|---------|------|
| 内存 | 30-60 秒 | 平衡精度和 `ReadMemStats` 开销 |
| GC | 每次 GC 后 | 使用回调而非轮询 |
| Goroutine | 10-30 秒 | `NumGoroutine()` 开销较小 |
| runtime/metrics | 60 秒 | 批量读取开销较大 |

**注意**：`runtime.ReadMemStats()` 会触发 STW（Stop-The-World），频繁调用会影响性能。

### 8.3 内存优化

**检测内存泄漏**：

```go
func detectMemoryLeak(ctx context.Context, threshold float64) {
    var lastHeapAlloc uint64
    ticker := time.NewTicker(1 * time.Minute)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            var m runtime.MemStats
            runtime.ReadMemStats(&m)
            
            if lastHeapAlloc > 0 {
                growth := float64(m.HeapAlloc-lastHeapAlloc) / 1024 / 1024 / 60 // MB/s
                if growth > threshold {
                    log.Printf("警告：检测到内存增长 %.2f MB/s", growth)
                }
            }
            
            lastHeapAlloc = m.HeapAlloc
        }
    }
}
```

**强制 GC（谨慎使用）**：

```go
// 仅在确实需要时调用
runtime.GC()
```

### 8.4 告警配置

**推荐告警规则**：

```yaml
groups:
  - name: go_runtime_alerts
    interval: 30s
    rules:
      - alert: HighHeapMemory
        expr: runtime_go_mem_heap_alloc > 1073741824  # 1 GB
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "堆内存使用过高"
          description: "堆内存使用 {{ $value | humanize1024 }}"
      
      - alert: LongGCPause
        expr: histogram_quantile(0.99, rate(runtime_go_gc_pause_duration_bucket[5m])) > 0.1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "GC 暂停时间过长"
          description: "P99 GC 暂停时间 {{ $value }}s"
      
      - alert: GoroutineLeak
        expr: runtime_go_goroutines > 10000
        for: 10m
        labels:
          severity: critical
        annotations:
          summary: "Goroutine 泄漏"
          description: "Goroutine 数量 {{ $value }}"
      
      - alert: HighGCCPUFraction
        expr: runtime_go_gc_cpu_fraction > 0.3
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "GC 占用 CPU 过高"
          description: "GC 占用 {{ $value | humanizePercentage }} 的 CPU"
```

---

## 9. 常见问题

**Q1: `runtime.ReadMemStats()` 的开销有多大？**

A: `ReadMemStats()` 会触发 STW，通常耗时 50-100 µs，但在堆较大时可能达到几毫秒。建议采集间隔 ≥ 30 秒。

**Q2: 如何区分内存泄漏和正常增长？**

A: 观察 `HeapInuse` 和 `HeapIdle` 的比例。如果 `HeapIdle` 持续增长而不释放给 OS，可能存在碎片问题；如果 `HeapInuse` 持续增长，可能存在泄漏。

```go
func analyzeMemory() {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    inuseRatio := float64(m.HeapInuse) / float64(m.HeapSys)
    idleRatio := float64(m.HeapIdle) / float64(m.HeapSys)
    
    fmt.Printf("HeapInuse 比例: %.2f%%\n", inuseRatio*100)
    fmt.Printf("HeapIdle 比例: %.2f%%\n", idleRatio*100)
    
    if idleRatio > 0.5 {
        fmt.Println("提示：大量空闲内存，考虑调用 debug.FreeOSMemory()")
    }
}
```

**Q3: Goroutine 数量多少算正常？**

A: 取决于应用。一般来说：

- Web 服务：几百到几千（取决于并发请求）
- 后台任务：几十到几百
- 超过 10,000 通常不正常，需要检查是否有泄漏

**Q4: 如何优化 GC 性能？**

A:

1. 增加 `GOGC` 值（默认 100，可设为 200 或更高）
2. 使用 `debug.SetGCPercent(-1)` 禁用自动 GC（需手动触发）
3. 减少堆上的小对象分配（使用 `sync.Pool`）
4. 避免大量指针（影响 GC 扫描时间）

**Q5: Go 1.25.1 对运行时指标有什么改进？**

A: Go 1.25.1 主要改进：

- `runtime/metrics` 新增调度延迟分布
- 更详细的 GC 阶段指标
- 改进的内存分类（`/memory/classes/*`）

---

## 总结

本文档详细介绍了 Go 运行时指标的语义约定和 Go 1.25.1 实现方案，涵盖：

✅ **内存指标**：堆、栈、分配统计  
✅ **GC 指标**：周期、暂停、CPU 占用  
✅ **Goroutine 指标**：数量、调度器状态  
✅ **CGO 指标**：CGO 调用统计  
✅ **runtime/metrics**：深度集成、批量采集  
✅ **完整示例**：监控器、性能分析、生产配置  
✅ **最佳实践**：指标选择、采集频率、优化、告警  

**下一步**：

- 📖 阅读《HTTP 指标》学习应用层指标
- 📖 阅读《自定义指标》学习业务指标
- 🔗 参考 [runtime/metrics 文档](https://pkg.go.dev/runtime/metrics)

**参考资源**：

- [Go Runtime Metrics](https://pkg.go.dev/runtime/metrics)
- [OpenTelemetry Go Runtime Instrumentation](https://github.com/open-telemetry/opentelemetry-go-contrib/tree/main/instrumentation/runtime)
- [A Guide to the Go Garbage Collector](https://tip.golang.org/doc/gc-guide)
