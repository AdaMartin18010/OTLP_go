# Go è¿è¡Œæ—¶æŒ‡æ ‡ï¼ˆGo Runtime Metricsï¼‰

## ç›®å½•

- [Go è¿è¡Œæ—¶æŒ‡æ ‡ï¼ˆGo Runtime Metricsï¼‰](#go-è¿è¡Œæ—¶æŒ‡æ ‡go-runtime-metrics)
  - [ç›®å½•](#ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. å†…å­˜æŒ‡æ ‡](#2-å†…å­˜æŒ‡æ ‡)
    - [2.1 å †å†…å­˜](#21-å †å†…å­˜)
    - [2.2 æ ˆå†…å­˜](#22-æ ˆå†…å­˜)
    - [2.3 å†…å­˜åˆ†é…](#23-å†…å­˜åˆ†é…)
    - [2.4 Go 1.25.1 å®ç°](#24-go-1251-å®ç°)
  - [3. GC æŒ‡æ ‡](#3-gc-æŒ‡æ ‡)
    - [3.1 GC å‘¨æœŸ](#31-gc-å‘¨æœŸ)
    - [3.2 GC æš‚åœ](#32-gc-æš‚åœ)
    - [3.3 GC CPU å ç”¨](#33-gc-cpu-å ç”¨)
    - [3.4 Go 1.25.1 å®ç°](#34-go-1251-å®ç°)
  - [4. Goroutine æŒ‡æ ‡](#4-goroutine-æŒ‡æ ‡)
    - [4.1 Goroutine æ•°é‡](#41-goroutine-æ•°é‡)
    - [4.2 è°ƒåº¦å™¨æŒ‡æ ‡](#42-è°ƒåº¦å™¨æŒ‡æ ‡)
    - [4.3 Go 1.25.1 å®ç°](#43-go-1251-å®ç°)
  - [5. CGO æŒ‡æ ‡](#5-cgo-æŒ‡æ ‡)
    - [5.1 CGO è°ƒç”¨](#51-cgo-è°ƒç”¨)
    - [5.2 Go 1.25.1 å®ç°](#52-go-1251-å®ç°)
  - [6. runtime/metrics æ·±åº¦é›†æˆ](#6-runtimemetrics-æ·±åº¦é›†æˆ)
    - [6.1 æŒ‡æ ‡å‘ç°](#61-æŒ‡æ ‡å‘ç°)
    - [6.2 æ‰¹é‡é‡‡é›†](#62-æ‰¹é‡é‡‡é›†)
    - [6.3 Go 1.25.1 æ–°ç‰¹æ€§](#63-go-1251-æ–°ç‰¹æ€§)
  - [7. å®Œæ•´ç¤ºä¾‹](#7-å®Œæ•´ç¤ºä¾‹)
    - [7.1 è¿è¡Œæ—¶ç›‘æ§å™¨](#71-è¿è¡Œæ—¶ç›‘æ§å™¨)
    - [7.2 æ€§èƒ½åˆ†æé›†æˆ](#72-æ€§èƒ½åˆ†æé›†æˆ)
    - [7.3 ç”Ÿäº§ç¯å¢ƒé…ç½®](#73-ç”Ÿäº§ç¯å¢ƒé…ç½®)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
    - [8.1 æŒ‡æ ‡é€‰æ‹©](#81-æŒ‡æ ‡é€‰æ‹©)
    - [8.2 é‡‡é›†é¢‘ç‡](#82-é‡‡é›†é¢‘ç‡)
    - [8.3 å†…å­˜ä¼˜åŒ–](#83-å†…å­˜ä¼˜åŒ–)
    - [8.4 å‘Šè­¦é…ç½®](#84-å‘Šè­¦é…ç½®)
  - [9. å¸¸è§é—®é¢˜](#9-å¸¸è§é—®é¢˜)
  - [æ€»ç»“](#æ€»ç»“)

---

## 1. æ¦‚è¿°

Go è¿è¡Œæ—¶æŒ‡æ ‡æä¾›äº† Go ç¨‹åºå†…éƒ¨çŠ¶æ€çš„æ·±å…¥æ´å¯Ÿï¼ŒåŒ…æ‹¬å†…å­˜ç®¡ç†ã€åƒåœ¾å›æ”¶ã€Goroutine è°ƒåº¦ç­‰å…³é”®ä¿¡æ¯ã€‚Go 1.25.1 é€šè¿‡å¢å¼ºçš„ `runtime/metrics` åŒ…æä¾›äº†æ›´å…¨é¢çš„è¿è¡Œæ—¶å¯è§‚æµ‹æ€§ã€‚

**æ ¸å¿ƒä»·å€¼**ï¼š

- ğŸ¯ **æ€§èƒ½è¯Šæ–­**ï¼šè¯†åˆ«å†…å­˜æ³„æ¼ã€GC å‹åŠ›ã€Goroutine æ³„æ¼
- ğŸ“Š **å®¹é‡è§„åˆ’**ï¼šäº†è§£åº”ç”¨çš„èµ„æºéœ€æ±‚
- ğŸš¨ **å¼‚å¸¸å‘Šè­¦**ï¼šåŠæ—¶å‘ç°è¿è¡Œæ—¶å¼‚å¸¸
- ğŸ“ˆ **è¶‹åŠ¿åˆ†æ**ï¼šè·Ÿè¸ªåº”ç”¨æ€§èƒ½æ¼”å˜

**OpenTelemetry è§„èŒƒ**ï¼š

- [Runtime Metrics Semantic Conventions](https://opentelemetry.io/docs/specs/semconv/runtime/)
- [Go Runtime Metrics](https://pkg.go.dev/runtime/metrics)

---

## 2. å†…å­˜æŒ‡æ ‡

### 2.1 å †å†…å­˜

**æŒ‡æ ‡åç§°**ï¼š`runtime.go.mem.heap`

**æè¿°**ï¼šå †å†…å­˜ä½¿ç”¨æƒ…å†µ

**å•ä½**ï¼š`By`

**æŒ‡æ ‡ç±»å‹**ï¼šUpDownCounter

**å­æŒ‡æ ‡**ï¼š

- `runtime.go.mem.heap.alloc`ï¼šå½“å‰åˆ†é…çš„å †å†…å­˜ï¼ˆå­—èŠ‚ï¼‰
- `runtime.go.mem.heap.idle`ï¼šç©ºé—²å †å†…å­˜ï¼ˆå­—èŠ‚ï¼‰
- `runtime.go.mem.heap.inuse`ï¼šæ­£åœ¨ä½¿ç”¨çš„å †å†…å­˜ï¼ˆå­—èŠ‚ï¼‰
- `runtime.go.mem.heap.released`ï¼šå·²é‡Šæ”¾ç»™æ“ä½œç³»ç»Ÿçš„å†…å­˜ï¼ˆå­—èŠ‚ï¼‰
- `runtime.go.mem.heap.objects`ï¼šå †ä¸Šçš„å¯¹è±¡æ•°é‡

**å¯¹åº” runtime æŒ‡æ ‡**ï¼š

```go
var m runtime.MemStats
runtime.ReadMemStats(&m)

m.HeapAlloc    // å·²åˆ†é…ä¸”ä»åœ¨ä½¿ç”¨
m.HeapIdle     // ç©ºé—²ä½†æœªé‡Šæ”¾
m.HeapInuse    // æ­£åœ¨ä½¿ç”¨
m.HeapReleased // å·²é‡Šæ”¾ç»™ OS
m.HeapObjects  // å¯¹è±¡æ•°
```

### 2.2 æ ˆå†…å­˜

**æŒ‡æ ‡åç§°**ï¼š`runtime.go.mem.stack`

**æè¿°**ï¼šæ ˆå†…å­˜ä½¿ç”¨æƒ…å†µ

**å•ä½**ï¼š`By`

**æŒ‡æ ‡ç±»å‹**ï¼šUpDownCounter

**å­æŒ‡æ ‡**ï¼š

- `runtime.go.mem.stack.inuse`ï¼šæ ˆå†…å­˜ä½¿ç”¨é‡
- `runtime.go.mem.stack.sys`ï¼šä»æ“ä½œç³»ç»Ÿè·å–çš„æ ˆå†…å­˜æ€»é‡

### 2.3 å†…å­˜åˆ†é…

**æŒ‡æ ‡åç§°**ï¼š`runtime.go.mem.alloc`

**æè¿°**ï¼šå†…å­˜åˆ†é…ç»Ÿè®¡

**å•ä½**ï¼š`By` / `{allocation}`

**æŒ‡æ ‡ç±»å‹**ï¼šCounter

**å­æŒ‡æ ‡**ï¼š

- `runtime.go.mem.alloc.total`ï¼šç´¯è®¡åˆ†é…çš„å†…å­˜ï¼ˆå­—èŠ‚ï¼‰
- `runtime.go.mem.alloc.mallocs`ï¼šç´¯è®¡åˆ†é…æ¬¡æ•°
- `runtime.go.mem.alloc.frees`ï¼šç´¯è®¡é‡Šæ”¾æ¬¡æ•°
- `runtime.go.mem.alloc.lookups`ï¼šæŒ‡é’ˆæŸ¥æ‰¾æ¬¡æ•°

### 2.4 Go 1.25.1 å®ç°

```go
package runtimemetrics

import (
    "context"
    "fmt"
    "runtime"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// MemoryMetrics Go å†…å­˜æŒ‡æ ‡
type MemoryMetrics struct {
    meter        metric.Meter
    heapAlloc    metric.Int64ObservableUpDownCounter
    heapIdle     metric.Int64ObservableUpDownCounter
    heapInuse    metric.Int64ObservableUpDownCounter
    heapReleased metric.Int64ObservableUpDownCounter
    heapObjects  metric.Int64ObservableUpDownCounter
    stackInuse   metric.Int64ObservableUpDownCounter
    stackSys     metric.Int64ObservableUpDownCounter
    allocTotal   metric.Int64ObservableCounter
    mallocs      metric.Int64ObservableCounter
    frees        metric.Int64ObservableCounter
    lookups      metric.Int64ObservableCounter
}

// NewMemoryMetrics åˆ›å»º Go å†…å­˜æŒ‡æ ‡æ”¶é›†å™¨
func NewMemoryMetrics() (*MemoryMetrics, error) {
    meter := otel.Meter("runtime.go")
    
    mm := &MemoryMetrics{
        meter: meter,
    }
    
    var err error
    
    // å †å†…å­˜æŒ‡æ ‡
    mm.heapAlloc, err = meter.Int64ObservableUpDownCounter(
        "runtime.go.mem.heap.alloc",
        metric.WithDescription("Heap memory allocated"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º heap.alloc æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    mm.heapIdle, err = meter.Int64ObservableUpDownCounter(
        "runtime.go.mem.heap.idle",
        metric.WithDescription("Heap memory idle"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º heap.idle æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    mm.heapInuse, err = meter.Int64ObservableUpDownCounter(
        "runtime.go.mem.heap.inuse",
        metric.WithDescription("Heap memory in use"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º heap.inuse æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    mm.heapReleased, err = meter.Int64ObservableUpDownCounter(
        "runtime.go.mem.heap.released",
        metric.WithDescription("Heap memory released to OS"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º heap.released æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    mm.heapObjects, err = meter.Int64ObservableUpDownCounter(
        "runtime.go.mem.heap.objects",
        metric.WithDescription("Number of heap objects"),
        metric.WithUnit("{object}"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º heap.objects æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // æ ˆå†…å­˜æŒ‡æ ‡
    mm.stackInuse, err = meter.Int64ObservableUpDownCounter(
        "runtime.go.mem.stack.inuse",
        metric.WithDescription("Stack memory in use"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º stack.inuse æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    mm.stackSys, err = meter.Int64ObservableUpDownCounter(
        "runtime.go.mem.stack.sys",
        metric.WithDescription("Stack memory from OS"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º stack.sys æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // åˆ†é…ç»Ÿè®¡
    mm.allocTotal, err = meter.Int64ObservableCounter(
        "runtime.go.mem.alloc.total",
        metric.WithDescription("Total bytes allocated"),
        metric.WithUnit("By"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º alloc.total æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    mm.mallocs, err = meter.Int64ObservableCounter(
        "runtime.go.mem.alloc.mallocs",
        metric.WithDescription("Total number of mallocs"),
        metric.WithUnit("{allocation}"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º mallocs æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    mm.frees, err = meter.Int64ObservableCounter(
        "runtime.go.mem.alloc.frees",
        metric.WithDescription("Total number of frees"),
        metric.WithUnit("{allocation}"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º frees æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    mm.lookups, err = meter.Int64ObservableCounter(
        "runtime.go.mem.alloc.lookups",
        metric.WithDescription("Total number of pointer lookups"),
        metric.WithUnit("{lookup}"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º lookups æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // æ³¨å†Œå›è°ƒ
    if _, err := meter.RegisterCallback(mm.observeMemory,
        mm.heapAlloc, mm.heapIdle, mm.heapInuse, mm.heapReleased, mm.heapObjects,
        mm.stackInuse, mm.stackSys,
        mm.allocTotal, mm.mallocs, mm.frees, mm.lookups,
    ); err != nil {
        return nil, fmt.Errorf("æ³¨å†Œå†…å­˜æŒ‡æ ‡å›è°ƒå¤±è´¥: %w", err)
    }
    
    return mm, nil
}

// observeMemory è§‚å¯Ÿå†…å­˜æŒ‡æ ‡
func (mm *MemoryMetrics) observeMemory(ctx context.Context, observer metric.Observer) error {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    // å †å†…å­˜
    observer.ObserveInt64(mm.heapAlloc, int64(m.HeapAlloc))
    observer.ObserveInt64(mm.heapIdle, int64(m.HeapIdle))
    observer.ObserveInt64(mm.heapInuse, int64(m.HeapInuse))
    observer.ObserveInt64(mm.heapReleased, int64(m.HeapReleased))
    observer.ObserveInt64(mm.heapObjects, int64(m.HeapObjects))
    
    // æ ˆå†…å­˜
    observer.ObserveInt64(mm.stackInuse, int64(m.StackInuse))
    observer.ObserveInt64(mm.stackSys, int64(m.StackSys))
    
    // åˆ†é…ç»Ÿè®¡
    observer.ObserveInt64(mm.allocTotal, int64(m.TotalAlloc))
    observer.ObserveInt64(mm.mallocs, int64(m.Mallocs))
    observer.ObserveInt64(mm.frees, int64(m.Frees))
    observer.ObserveInt64(mm.lookups, int64(m.Lookups))
    
    return nil
}
```

---

## 3. GC æŒ‡æ ‡

### 3.1 GC å‘¨æœŸ

**æŒ‡æ ‡åç§°**ï¼š`runtime.go.gc.count`

**æè¿°**ï¼šGC å‘¨æœŸè®¡æ•°

**å•ä½**ï¼š`{gc}`

**æŒ‡æ ‡ç±»å‹**ï¼šCounter

**æŒ‡æ ‡åç§°**ï¼š`runtime.go.gc.pause.total`

**æè¿°**ï¼šGC æš‚åœæ€»æ—¶é—´ï¼ˆç§’ï¼‰

**å•ä½**ï¼š`s`

**æŒ‡æ ‡ç±»å‹**ï¼šCounter

### 3.2 GC æš‚åœ

**æŒ‡æ ‡åç§°**ï¼š`runtime.go.gc.pause.duration`

**æè¿°**ï¼šGC æš‚åœæ—¶é—´åˆ†å¸ƒï¼ˆç›´æ–¹å›¾ï¼‰

**å•ä½**ï¼š`s`

**æŒ‡æ ‡ç±»å‹**ï¼šHistogram

**æ¨èæ¡¶è¾¹ç•Œ**ï¼š

```go
[]float64{
    0.000001,  // 1 Âµs
    0.00001,   // 10 Âµs
    0.0001,    // 100 Âµs
    0.001,     // 1 ms
    0.01,      // 10 ms
    0.1,       // 100 ms
    1.0,       // 1 s
}
```

### 3.3 GC CPU å ç”¨

**æŒ‡æ ‡åç§°**ï¼š`runtime.go.gc.cpu.fraction`

**æè¿°**ï¼šGC å ç”¨çš„ CPU æ¯”ä¾‹ï¼ˆ0.0 åˆ° 1.0ï¼‰

**å•ä½**ï¼š`1`

**æŒ‡æ ‡ç±»å‹**ï¼šGauge

### 3.4 Go 1.25.1 å®ç°

```go
package runtimemetrics

import (
    "context"
    "fmt"
    "runtime"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/metric"
)

// GCMetrics Go GC æŒ‡æ ‡
type GCMetrics struct {
    meter          metric.Meter
    gcCount        metric.Int64ObservableCounter
    pauseTotal     metric.Float64ObservableCounter
    pauseDuration  metric.Float64Histogram
    cpuFraction    metric.Float64ObservableGauge
    lastNumGC      uint32
}

// NewGCMetrics åˆ›å»º GC æŒ‡æ ‡æ”¶é›†å™¨
func NewGCMetrics() (*GCMetrics, error) {
    meter := otel.Meter("runtime.go")
    
    gm := &GCMetrics{
        meter: meter,
    }
    
    var err error
    
    // GC æ¬¡æ•°
    gm.gcCount, err = meter.Int64ObservableCounter(
        "runtime.go.gc.count",
        metric.WithDescription("Number of completed GC cycles"),
        metric.WithUnit("{gc}"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º gc.count æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // GC æš‚åœæ€»æ—¶é—´
    gm.pauseTotal, err = meter.Float64ObservableCounter(
        "runtime.go.gc.pause.total",
        metric.WithDescription("Total GC pause time"),
        metric.WithUnit("s"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º gc.pause.total æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // GC æš‚åœæ—¶é—´ç›´æ–¹å›¾
    gm.pauseDuration, err = meter.Float64Histogram(
        "runtime.go.gc.pause.duration",
        metric.WithDescription("GC pause duration"),
        metric.WithUnit("s"),
        metric.WithExplicitBucketBoundaries(
            0.000001, 0.00001, 0.0001, 0.001, 0.01, 0.1, 1.0,
        ),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º gc.pause.duration æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // GC CPU å ç”¨æ¯”ä¾‹
    gm.cpuFraction, err = meter.Float64ObservableGauge(
        "runtime.go.gc.cpu.fraction",
        metric.WithDescription("Fraction of CPU time used by GC"),
        metric.WithUnit("1"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º gc.cpu.fraction æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // æ³¨å†Œå›è°ƒ
    if _, err := meter.RegisterCallback(gm.observeGC,
        gm.gcCount,
        gm.pauseTotal,
        gm.cpuFraction,
    ); err != nil {
        return nil, fmt.Errorf("æ³¨å†Œ GC æŒ‡æ ‡å›è°ƒå¤±è´¥: %w", err)
    }
    
    return gm, nil
}

// observeGC è§‚å¯Ÿ GC æŒ‡æ ‡
func (gm *GCMetrics) observeGC(ctx context.Context, observer metric.Observer) error {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    // GC æ¬¡æ•°
    observer.ObserveInt64(gm.gcCount, int64(m.NumGC))
    
    // GC æš‚åœæ€»æ—¶é—´ï¼ˆçº³ç§’è½¬ç§’ï¼‰
    observer.ObserveFloat64(gm.pauseTotal, float64(m.PauseTotalNs)/1e9)
    
    // GC CPU å ç”¨æ¯”ä¾‹
    observer.ObserveFloat64(gm.cpuFraction, m.GCCPUFraction)
    
    // è®°å½•æ–°çš„ GC æš‚åœï¼ˆç›´æ–¹å›¾ï¼‰
    // æ³¨æ„ï¼šè¿™é‡Œåªè®°å½•è‡ªä¸Šæ¬¡é‡‡é›†ä»¥æ¥çš„æ–° GC æš‚åœ
    numGC := m.NumGC
    if numGC > gm.lastNumGC {
        // æœ€è¿‘çš„ GC æš‚åœå­˜å‚¨åœ¨å¾ªç¯ç¼“å†²åŒºä¸­
        for i := gm.lastNumGC; i < numGC; i++ {
            idx := i % uint32(len(m.PauseNs))
            pauseNs := m.PauseNs[idx]
            pauseS := float64(pauseNs) / 1e9
            gm.pauseDuration.Record(ctx, pauseS)
        }
        gm.lastNumGC = numGC
    }
    
    return nil
}
```

---

## 4. Goroutine æŒ‡æ ‡

### 4.1 Goroutine æ•°é‡

**æŒ‡æ ‡åç§°**ï¼š`runtime.go.goroutines`

**æè¿°**ï¼šå½“å‰ Goroutine æ•°é‡

**å•ä½**ï¼š`{goroutine}`

**æŒ‡æ ‡ç±»å‹**ï¼šUpDownCounter

### 4.2 è°ƒåº¦å™¨æŒ‡æ ‡

**æŒ‡æ ‡åç§°**ï¼š`runtime.go.sched.*`

**æè¿°**ï¼šè°ƒåº¦å™¨ç›¸å…³æŒ‡æ ‡

**å­æŒ‡æ ‡**ï¼š

- `runtime.go.sched.procs`ï¼šGOMAXPROCS å€¼ï¼ˆP çš„æ•°é‡ï¼‰
- `runtime.go.sched.threads`ï¼šæ“ä½œç³»ç»Ÿçº¿ç¨‹æ•°ï¼ˆM çš„æ•°é‡ï¼‰
- `runtime.go.sched.idle.threads`ï¼šç©ºé—²çº¿ç¨‹æ•°

### 4.3 Go 1.25.1 å®ç°

```go
package runtimemetrics

import (
    "context"
    "fmt"
    "runtime"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/metric"
)

// GoroutineMetrics Goroutine æŒ‡æ ‡
type GoroutineMetrics struct {
    meter       metric.Meter
    goroutines  metric.Int64ObservableUpDownCounter
    procs       metric.Int64ObservableUpDownCounter
    threads     metric.Int64ObservableUpDownCounter
}

// NewGoroutineMetrics åˆ›å»º Goroutine æŒ‡æ ‡æ”¶é›†å™¨
func NewGoroutineMetrics() (*GoroutineMetrics, error) {
    meter := otel.Meter("runtime.go")
    
    gm := &GoroutineMetrics{
        meter: meter,
    }
    
    var err error
    
    // Goroutine æ•°é‡
    gm.goroutines, err = meter.Int64ObservableUpDownCounter(
        "runtime.go.goroutines",
        metric.WithDescription("Number of goroutines"),
        metric.WithUnit("{goroutine}"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º goroutines æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // GOMAXPROCS
    gm.procs, err = meter.Int64ObservableUpDownCounter(
        "runtime.go.sched.procs",
        metric.WithDescription("Number of OS threads for goroutines (GOMAXPROCS)"),
        metric.WithUnit("{thread}"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º sched.procs æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // çº¿ç¨‹æ•°ï¼ˆMï¼‰
    gm.threads, err = meter.Int64ObservableUpDownCounter(
        "runtime.go.sched.threads",
        metric.WithDescription("Number of OS threads"),
        metric.WithUnit("{thread}"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º sched.threads æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    // æ³¨å†Œå›è°ƒ
    if _, err := meter.RegisterCallback(gm.observeGoroutines,
        gm.goroutines,
        gm.procs,
        gm.threads,
    ); err != nil {
        return nil, fmt.Errorf("æ³¨å†Œ Goroutine æŒ‡æ ‡å›è°ƒå¤±è´¥: %w", err)
    }
    
    return gm, nil
}

// observeGoroutines è§‚å¯Ÿ Goroutine æŒ‡æ ‡
func (gm *GoroutineMetrics) observeGoroutines(ctx context.Context, observer metric.Observer) error {
    // Goroutine æ•°é‡
    observer.ObserveInt64(gm.goroutines, int64(runtime.NumGoroutine()))
    
    // GOMAXPROCS
    observer.ObserveInt64(gm.procs, int64(runtime.GOMAXPROCS(0)))
    
    // çº¿ç¨‹æ•°ï¼ˆéœ€è¦ runtime.NumCgoCall é—´æ¥ä¼°ç®—ï¼Œæˆ–ä½¿ç”¨ runtime/metricsï¼‰
    // è¿™é‡Œä½¿ç”¨ç®€åŒ–ç‰ˆæœ¬
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    observer.ObserveInt64(gm.threads, int64(m.NumCgoCall)) // è¿‘ä¼¼å€¼
    
    return nil
}
```

---

## 5. CGO æŒ‡æ ‡

### 5.1 CGO è°ƒç”¨

**æŒ‡æ ‡åç§°**ï¼š`runtime.go.cgo.calls`

**æè¿°**ï¼šCGO è°ƒç”¨æ¬¡æ•°

**å•ä½**ï¼š`{call}`

**æŒ‡æ ‡ç±»å‹**ï¼šCounter

### 5.2 Go 1.25.1 å®ç°

```go
package runtimemetrics

import (
    "context"
    "fmt"
    "runtime"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/metric"
)

// CGOMetrics CGO æŒ‡æ ‡
type CGOMetrics struct {
    meter     metric.Meter
    cgoCalls  metric.Int64ObservableCounter
}

// NewCGOMetrics åˆ›å»º CGO æŒ‡æ ‡æ”¶é›†å™¨
func NewCGOMetrics() (*CGOMetrics, error) {
    meter := otel.Meter("runtime.go")
    
    cm := &CGOMetrics{
        meter: meter,
    }
    
    var err error
    
    cm.cgoCalls, err = meter.Int64ObservableCounter(
        "runtime.go.cgo.calls",
        metric.WithDescription("Number of CGO calls"),
        metric.WithUnit("{call}"),
    )
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º cgo.calls æŒ‡æ ‡å¤±è´¥: %w", err)
    }
    
    if _, err := meter.RegisterCallback(cm.observeCGO, cm.cgoCalls); err != nil {
        return nil, fmt.Errorf("æ³¨å†Œ CGO æŒ‡æ ‡å›è°ƒå¤±è´¥: %w", err)
    }
    
    return cm, nil
}

// observeCGO è§‚å¯Ÿ CGO æŒ‡æ ‡
func (cm *CGOMetrics) observeCGO(ctx context.Context, observer metric.Observer) error {
    observer.ObserveInt64(cm.cgoCalls, runtime.NumCgoCall())
    return nil
}
```

---

## 6. runtime/metrics æ·±åº¦é›†æˆ

Go 1.16+ å¼•å…¥äº† `runtime/metrics` åŒ…ï¼Œæä¾›äº†æ›´è¯¦ç»†çš„è¿è¡Œæ—¶æŒ‡æ ‡ã€‚Go 1.25.1 è¿›ä¸€æ­¥å¢å¼ºäº†è¯¥åŒ…ã€‚

### 6.1 æŒ‡æ ‡å‘ç°

```go
package runtimemetrics

import (
    "runtime/metrics"
    "strings"
)

// DiscoverMetrics å‘ç°æ‰€æœ‰å¯ç”¨çš„ runtime æŒ‡æ ‡
func DiscoverMetrics() []metrics.Description {
    return metrics.All()
}

// FilterMetrics è¿‡æ»¤æŒ‡æ ‡
func FilterMetrics(prefix string) []metrics.Description {
    all := metrics.All()
    var filtered []metrics.Description
    
    for _, desc := range all {
        if strings.HasPrefix(desc.Name, prefix) {
            filtered = append(filtered, desc)
        }
    }
    
    return filtered
}

// PrintMetrics æ‰“å°æ‰€æœ‰æŒ‡æ ‡ï¼ˆè°ƒè¯•ç”¨ï¼‰
func PrintMetrics() {
    for _, desc := range metrics.All() {
        fmt.Printf("%s (%s): %s\n", desc.Name, desc.Kind, desc.Description)
    }
}
```

**ç¤ºä¾‹è¾“å‡º**ï¼ˆéƒ¨åˆ†ï¼‰ï¼š

```text
/gc/cycles/automatic:gc-cycles: Number of automatic GC cycles
/gc/cycles/forced:gc-cycles: Number of forced GC cycles
/gc/cycles/total:gc-cycles: Total number of GC cycles
/gc/heap/allocs:bytes: Cumulative sum of heap allocations
/gc/heap/frees:bytes: Cumulative sum of heap frees
/gc/heap/goal:bytes: Heap size target for the end of the GC cycle
/gc/heap/objects:objects: Number of objects allocated
/gc/pauses:seconds: Distribution of GC pause times
/memory/classes/heap/free:bytes: Free heap memory
/memory/classes/heap/objects:bytes: Memory used by heap objects
/sched/goroutines:goroutines: Number of goroutines
/sched/latencies:seconds: Distribution of scheduling latencies
```

### 6.2 æ‰¹é‡é‡‡é›†

```go
package runtimemetrics

import (
    "context"
    "fmt"
    "runtime/metrics"
    "strings"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/metric"
)

// RuntimeMetricsCollector ç»Ÿä¸€çš„ runtime/metrics æ”¶é›†å™¨
type RuntimeMetricsCollector struct {
    meter   metric.Meter
    samples []metrics.Sample
    instruments map[string]any // ç¼“å­˜ OTel ä»ªå™¨
}

// NewRuntimeMetricsCollector åˆ›å»ºæ”¶é›†å™¨
func NewRuntimeMetricsCollector() (*RuntimeMetricsCollector, error) {
    meter := otel.Meter("runtime.go")
    
    // è·å–æ‰€æœ‰æŒ‡æ ‡æè¿°
    descs := metrics.All()
    
    // å‡†å¤‡æ ·æœ¬åˆ‡ç‰‡
    samples := make([]metrics.Sample, len(descs))
    for i, desc := range descs {
        samples[i].Name = desc.Name
    }
    
    rmc := &RuntimeMetricsCollector{
        meter:       meter,
        samples:     samples,
        instruments: make(map[string]any),
    }
    
    // ä¸ºæ¯ä¸ª runtime æŒ‡æ ‡åˆ›å»ºå¯¹åº”çš„ OTel ä»ªå™¨
    if err := rmc.createInstruments(descs); err != nil {
        return nil, err
    }
    
    return rmc, nil
}

// createInstruments ä¸º runtime æŒ‡æ ‡åˆ›å»º OTel ä»ªå™¨
func (rmc *RuntimeMetricsCollector) createInstruments(descs []metrics.Description) error {
    for _, desc := range descs {
        // è½¬æ¢æŒ‡æ ‡åç§°ï¼š/gc/cycles/total -> runtime.go.gc.cycles.total
        name := "runtime.go" + strings.ReplaceAll(desc.Name, "/", ".")
        
        // æ ¹æ® Kind åˆ›å»ºä¸åŒç±»å‹çš„ä»ªå™¨
        switch desc.Kind {
        case metrics.KindUint64:
            if desc.Cumulative {
                inst, err := rmc.meter.Int64ObservableCounter(
                    name,
                    metric.WithDescription(desc.Description),
                )
                if err != nil {
                    return err
                }
                rmc.instruments[desc.Name] = inst
            } else {
                inst, err := rmc.meter.Int64ObservableUpDownCounter(
                    name,
                    metric.WithDescription(desc.Description),
                )
                if err != nil {
                    return err
                }
                rmc.instruments[desc.Name] = inst
            }
        case metrics.KindFloat64:
            if desc.Cumulative {
                inst, err := rmc.meter.Float64ObservableCounter(
                    name,
                    metric.WithDescription(desc.Description),
                )
                if err != nil {
                    return err
                }
                rmc.instruments[desc.Name] = inst
            } else {
                inst, err := rmc.meter.Float64ObservableGauge(
                    name,
                    metric.WithDescription(desc.Description),
                )
                if err != nil {
                    return err
                }
                rmc.instruments[desc.Name] = inst
            }
        case metrics.KindFloat64Histogram:
            // ç›´æ–¹å›¾éœ€è¦ç‰¹æ®Šå¤„ç†ï¼ˆè§ä¸‹æ–‡ï¼‰
            continue
        }
    }
    
    // æ³¨å†Œå›è°ƒ
    var instruments []metric.Observable
    for _, inst := range rmc.instruments {
        if obs, ok := inst.(metric.Observable); ok {
            instruments = append(instruments, obs)
        }
    }
    
    if _, err := rmc.meter.RegisterCallback(rmc.observe, instruments...); err != nil {
        return fmt.Errorf("æ³¨å†Œå›è°ƒå¤±è´¥: %w", err)
    }
    
    return nil
}

// observe è§‚å¯Ÿæ‰€æœ‰ runtime æŒ‡æ ‡
func (rmc *RuntimeMetricsCollector) observe(ctx context.Context, observer metric.Observer) error {
    // æ‰¹é‡è¯»å–æ‰€æœ‰æŒ‡æ ‡
    metrics.Read(rmc.samples)
    
    // æŠ¥å‘Šæ¯ä¸ªæŒ‡æ ‡
    for _, sample := range rmc.samples {
        inst, ok := rmc.instruments[sample.Name]
        if !ok {
            continue
        }
        
        switch sample.Value.Kind() {
        case metrics.KindUint64:
            val := int64(sample.Value.Uint64())
            switch i := inst.(type) {
            case metric.Int64ObservableCounter:
                observer.ObserveInt64(i, val)
            case metric.Int64ObservableUpDownCounter:
                observer.ObserveInt64(i, val)
            }
        case metrics.KindFloat64:
            val := sample.Value.Float64()
            switch i := inst.(type) {
            case metric.Float64ObservableCounter:
                observer.ObserveFloat64(i, val)
            case metric.Float64ObservableGauge:
                observer.ObserveFloat64(i, val)
            }
        case metrics.KindFloat64Histogram:
            // ç›´æ–¹å›¾éœ€è¦è½¬æ¢ä¸º OTel ç›´æ–¹å›¾ï¼ˆå¤æ‚ï¼Œè§ä¸‹æ–‡ï¼‰
        }
    }
    
    return nil
}
```

### 6.3 Go 1.25.1 æ–°ç‰¹æ€§

Go 1.25.1 åœ¨ `runtime/metrics` ä¸­æ–°å¢äº†ä»¥ä¸‹æŒ‡æ ‡ï¼ˆç¤ºä¾‹ï¼‰ï¼š

- `/sched/latencies:seconds`ï¼šè°ƒåº¦å»¶è¿Ÿåˆ†å¸ƒ
- `/sync/mutex/wait/total:seconds`ï¼šäº’æ–¥é”ç­‰å¾…æ€»æ—¶é—´
- `/gc/limiter/last-enabled:gc-cycle`ï¼šGC é™åˆ¶å™¨æœ€åå¯ç”¨çš„å‘¨æœŸ

```go
// ç¤ºä¾‹ï¼šç›‘æ§è°ƒåº¦å»¶è¿Ÿ
func monitorSchedLatencies(ctx context.Context, histogram metric.Float64Histogram) {
    samples := []metrics.Sample{
        {Name: "/sched/latencies:seconds"},
    }
    
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            metrics.Read(samples)
            
            if samples[0].Value.Kind() == metrics.KindFloat64Histogram {
                hist := samples[0].Value.Float64Histogram()
                
                // è½¬æ¢ä¸º OTel ç›´æ–¹å›¾è®°å½•
                for i, count := range hist.Counts {
                    if count > 0 {
                        // ä½¿ç”¨æ¡¶çš„ä¸­ç‚¹ä½œä¸ºæ ·æœ¬å€¼
                        midpoint := (hist.Buckets[i] + hist.Buckets[i+1]) / 2
                        for j := uint64(0); j < count; j++ {
                            histogram.Record(ctx, midpoint)
                        }
                    }
                }
            }
        }
    }
}
```

---

## 7. å®Œæ•´ç¤ºä¾‹

### 7.1 è¿è¡Œæ—¶ç›‘æ§å™¨

```go
package main

import (
    "context"
    "log"
    "os"
    "os/signal"
    "syscall"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
    "go.opentelemetry.io/otel/sdk/metric"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
)

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    // åˆ›å»ºèµ„æº
    res, err := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName("runtime-monitor"),
            semconv.ServiceVersion("1.0.0"),
        ),
    )
    if err != nil {
        log.Fatalf("åˆ›å»ºèµ„æºå¤±è´¥: %v", err)
    }
    
    // åˆ›å»ºå¯¼å‡ºå™¨
    exporter, err := otlpmetricgrpc.New(ctx,
        otlpmetricgrpc.WithInsecure(),
        otlpmetricgrpc.WithEndpoint("localhost:4317"),
    )
    if err != nil {
        log.Fatalf("åˆ›å»ºå¯¼å‡ºå™¨å¤±è´¥: %v", err)
    }
    defer exporter.Shutdown(ctx)
    
    // åˆ›å»º Meter Provider
    provider := metric.NewMeterProvider(
        metric.WithResource(res),
        metric.WithReader(metric.NewPeriodicReader(exporter,
            metric.WithInterval(10*time.Second),
        )),
    )
    defer provider.Shutdown(ctx)
    
    otel.SetMeterProvider(provider)
    
    // åˆå§‹åŒ–è¿è¡Œæ—¶æŒ‡æ ‡æ”¶é›†å™¨
    if _, err := NewMemoryMetrics(); err != nil {
        log.Fatalf("åˆå§‹åŒ–å†…å­˜æŒ‡æ ‡å¤±è´¥: %v", err)
    }
    
    if _, err := NewGCMetrics(); err != nil {
        log.Fatalf("åˆå§‹åŒ– GC æŒ‡æ ‡å¤±è´¥: %v", err)
    }
    
    if _, err := NewGoroutineMetrics(); err != nil {
        log.Fatalf("åˆå§‹åŒ– Goroutine æŒ‡æ ‡å¤±è´¥: %v", err)
    }
    
    if _, err := NewCGOMetrics(); err != nil {
        log.Fatalf("åˆå§‹åŒ– CGO æŒ‡æ ‡å¤±è´¥: %v", err)
    }
    
    // å¯é€‰ï¼šä½¿ç”¨ç»Ÿä¸€çš„ runtime/metrics æ”¶é›†å™¨
    if _, err := NewRuntimeMetricsCollector(); err != nil {
        log.Fatalf("åˆå§‹åŒ– runtime/metrics æ”¶é›†å™¨å¤±è´¥: %v", err)
    }
    
    log.Println("è¿è¡Œæ—¶ç›‘æ§å¯åŠ¨ï¼ŒæŒ‰ Ctrl+C é€€å‡º")
    
    // æ¨¡æ‹Ÿåº”ç”¨è´Ÿè½½ï¼ˆå¯é€‰ï¼‰
    go simulateLoad(ctx)
    
    // ç­‰å¾…ä¿¡å·
    sigCh := make(chan os.Signal, 1)
    signal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)
    <-sigCh
    
    log.Println("æ­£åœ¨å…³é—­è¿è¡Œæ—¶ç›‘æ§...")
}

// simulateLoad æ¨¡æ‹Ÿåº”ç”¨è´Ÿè½½
func simulateLoad(ctx context.Context) {
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            // åˆ†é…ä¸€äº›å†…å­˜
            data := make([]byte, 1024*1024) // 1 MB
            _ = data
            
            // å¯åŠ¨ä¸€äº› goroutines
            for i := 0; i < 10; i++ {
                go func() {
                    time.Sleep(100 * time.Millisecond)
                }()
            }
        }
    }
}
```

### 7.2 æ€§èƒ½åˆ†æé›†æˆ

å°†è¿è¡Œæ—¶æŒ‡æ ‡ä¸ `runtime/pprof` ç»“åˆï¼š

```go
package runtimemetrics

import (
    "runtime"
    "runtime/pprof"
    "time"
)

// EnableProfiling å¯ç”¨æ€§èƒ½åˆ†æ
func EnableProfiling() {
    // å¯ç”¨é˜»å¡åˆ†æ
    runtime.SetBlockProfileRate(1)
    
    // å¯ç”¨äº’æ–¥é”åˆ†æ
    runtime.SetMutexProfileFraction(1)
}

// CollectProfile æ”¶é›†æ€§èƒ½åˆ†ææ•°æ®
func CollectProfile(name string, duration time.Duration) error {
    p := pprof.Lookup(name)
    if p == nil {
        return fmt.Errorf("profile %s not found", name)
    }
    
    // å†™å…¥åˆ°æ–‡ä»¶æˆ–å¯¼å‡ºåˆ°ç›‘æ§ç³»ç»Ÿ
    // ...
    
    return nil
}
```

### 7.3 ç”Ÿäº§ç¯å¢ƒé…ç½®

```go
package config

import (
    "time"
)

// RuntimeMetricsConfig è¿è¡Œæ—¶æŒ‡æ ‡é…ç½®
type RuntimeMetricsConfig struct {
    // é‡‡é›†é—´éš”
    CollectionInterval time.Duration
    
    // å¯ç”¨çš„æŒ‡æ ‡
    EnableMemory     bool
    EnableGC         bool
    EnableGoroutines bool
    EnableCGO        bool
    EnableScheduler  bool
    
    // GC è§¦å‘é˜ˆå€¼
    GCPauseThreshold time.Duration
    
    // Goroutine æ³„æ¼é˜ˆå€¼
    GoroutineLeakThreshold int
    
    // å†…å­˜æ³„æ¼æ£€æµ‹
    MemoryLeakDetection bool
    MemoryGrowthRate    float64 // MB/s
}

// DefaultConfig é»˜è®¤é…ç½®
func DefaultConfig() RuntimeMetricsConfig {
    return RuntimeMetricsConfig{
        CollectionInterval:     10 * time.Second,
        EnableMemory:           true,
        EnableGC:               true,
        EnableGoroutines:       true,
        EnableCGO:              false, // ä»…åœ¨ä½¿ç”¨ CGO æ—¶å¯ç”¨
        EnableScheduler:        true,
        GCPauseThreshold:       100 * time.Millisecond,
        GoroutineLeakThreshold: 10000,
        MemoryLeakDetection:    true,
        MemoryGrowthRate:       10.0, // 10 MB/s
    }
}

// ProductionConfig ç”Ÿäº§ç¯å¢ƒé…ç½®
func ProductionConfig() RuntimeMetricsConfig {
    cfg := DefaultConfig()
    cfg.CollectionInterval = 30 * time.Second // å‡å°‘é‡‡é›†é¢‘ç‡
    cfg.EnableScheduler = false               // è°ƒåº¦å™¨æŒ‡æ ‡å¼€é”€è¾ƒå¤§
    return cfg
}
```

---

## 8. æœ€ä½³å®è·µ

### 8.1 æŒ‡æ ‡é€‰æ‹©

**å¿…é¡»ç›‘æ§çš„æŒ‡æ ‡**ï¼š

- âœ… `runtime.go.mem.heap.alloc`ï¼šå †å†…å­˜ä½¿ç”¨
- âœ… `runtime.go.gc.pause.duration`ï¼šGC æš‚åœæ—¶é—´
- âœ… `runtime.go.goroutines`ï¼šGoroutine æ•°é‡

**å¯é€‰æŒ‡æ ‡**ï¼š

- `runtime.go.mem.stack.inuse`ï¼šæ ˆå†…å­˜ï¼ˆé«˜å¹¶å‘åœºæ™¯ï¼‰
- `runtime.go.gc.cpu.fraction`ï¼šGC CPU å ç”¨ï¼ˆæ€§èƒ½æ•æ„Ÿåœºæ™¯ï¼‰
- `runtime.go.cgo.calls`ï¼šCGO è°ƒç”¨ï¼ˆä½¿ç”¨ CGO æ—¶ï¼‰

### 8.2 é‡‡é›†é¢‘ç‡

| æŒ‡æ ‡ç±»å‹ | æ¨èé¢‘ç‡ | è¯´æ˜ |
|---------|---------|------|
| å†…å­˜ | 30-60 ç§’ | å¹³è¡¡ç²¾åº¦å’Œ `ReadMemStats` å¼€é”€ |
| GC | æ¯æ¬¡ GC å | ä½¿ç”¨å›è°ƒè€Œéè½®è¯¢ |
| Goroutine | 10-30 ç§’ | `NumGoroutine()` å¼€é”€è¾ƒå° |
| runtime/metrics | 60 ç§’ | æ‰¹é‡è¯»å–å¼€é”€è¾ƒå¤§ |

**æ³¨æ„**ï¼š`runtime.ReadMemStats()` ä¼šè§¦å‘ STWï¼ˆStop-The-Worldï¼‰ï¼Œé¢‘ç¹è°ƒç”¨ä¼šå½±å“æ€§èƒ½ã€‚

### 8.3 å†…å­˜ä¼˜åŒ–

**æ£€æµ‹å†…å­˜æ³„æ¼**ï¼š

```go
func detectMemoryLeak(ctx context.Context, threshold float64) {
    var lastHeapAlloc uint64
    ticker := time.NewTicker(1 * time.Minute)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            var m runtime.MemStats
            runtime.ReadMemStats(&m)
            
            if lastHeapAlloc > 0 {
                growth := float64(m.HeapAlloc-lastHeapAlloc) / 1024 / 1024 / 60 // MB/s
                if growth > threshold {
                    log.Printf("è­¦å‘Šï¼šæ£€æµ‹åˆ°å†…å­˜å¢é•¿ %.2f MB/s", growth)
                }
            }
            
            lastHeapAlloc = m.HeapAlloc
        }
    }
}
```

**å¼ºåˆ¶ GCï¼ˆè°¨æ…ä½¿ç”¨ï¼‰**ï¼š

```go
// ä»…åœ¨ç¡®å®éœ€è¦æ—¶è°ƒç”¨
runtime.GC()
```

### 8.4 å‘Šè­¦é…ç½®

**æ¨èå‘Šè­¦è§„åˆ™**ï¼š

```yaml
groups:
  - name: go_runtime_alerts
    interval: 30s
    rules:
      - alert: HighHeapMemory
        expr: runtime_go_mem_heap_alloc > 1073741824  # 1 GB
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "å †å†…å­˜ä½¿ç”¨è¿‡é«˜"
          description: "å †å†…å­˜ä½¿ç”¨ {{ $value | humanize1024 }}"
      
      - alert: LongGCPause
        expr: histogram_quantile(0.99, rate(runtime_go_gc_pause_duration_bucket[5m])) > 0.1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "GC æš‚åœæ—¶é—´è¿‡é•¿"
          description: "P99 GC æš‚åœæ—¶é—´ {{ $value }}s"
      
      - alert: GoroutineLeak
        expr: runtime_go_goroutines > 10000
        for: 10m
        labels:
          severity: critical
        annotations:
          summary: "Goroutine æ³„æ¼"
          description: "Goroutine æ•°é‡ {{ $value }}"
      
      - alert: HighGCCPUFraction
        expr: runtime_go_gc_cpu_fraction > 0.3
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "GC å ç”¨ CPU è¿‡é«˜"
          description: "GC å ç”¨ {{ $value | humanizePercentage }} çš„ CPU"
```

---

## 9. å¸¸è§é—®é¢˜

**Q1: `runtime.ReadMemStats()` çš„å¼€é”€æœ‰å¤šå¤§ï¼Ÿ**

A: `ReadMemStats()` ä¼šè§¦å‘ STWï¼Œé€šå¸¸è€—æ—¶ 50-100 Âµsï¼Œä½†åœ¨å †è¾ƒå¤§æ—¶å¯èƒ½è¾¾åˆ°å‡ æ¯«ç§’ã€‚å»ºè®®é‡‡é›†é—´éš” â‰¥ 30 ç§’ã€‚

**Q2: å¦‚ä½•åŒºåˆ†å†…å­˜æ³„æ¼å’Œæ­£å¸¸å¢é•¿ï¼Ÿ**

A: è§‚å¯Ÿ `HeapInuse` å’Œ `HeapIdle` çš„æ¯”ä¾‹ã€‚å¦‚æœ `HeapIdle` æŒç»­å¢é•¿è€Œä¸é‡Šæ”¾ç»™ OSï¼Œå¯èƒ½å­˜åœ¨ç¢ç‰‡é—®é¢˜ï¼›å¦‚æœ `HeapInuse` æŒç»­å¢é•¿ï¼Œå¯èƒ½å­˜åœ¨æ³„æ¼ã€‚

```go
func analyzeMemory() {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    inuseRatio := float64(m.HeapInuse) / float64(m.HeapSys)
    idleRatio := float64(m.HeapIdle) / float64(m.HeapSys)
    
    fmt.Printf("HeapInuse æ¯”ä¾‹: %.2f%%\n", inuseRatio*100)
    fmt.Printf("HeapIdle æ¯”ä¾‹: %.2f%%\n", idleRatio*100)
    
    if idleRatio > 0.5 {
        fmt.Println("æç¤ºï¼šå¤§é‡ç©ºé—²å†…å­˜ï¼Œè€ƒè™‘è°ƒç”¨ debug.FreeOSMemory()")
    }
}
```

**Q3: Goroutine æ•°é‡å¤šå°‘ç®—æ­£å¸¸ï¼Ÿ**

A: å–å†³äºåº”ç”¨ã€‚ä¸€èˆ¬æ¥è¯´ï¼š

- Web æœåŠ¡ï¼šå‡ ç™¾åˆ°å‡ åƒï¼ˆå–å†³äºå¹¶å‘è¯·æ±‚ï¼‰
- åå°ä»»åŠ¡ï¼šå‡ ååˆ°å‡ ç™¾
- è¶…è¿‡ 10,000 é€šå¸¸ä¸æ­£å¸¸ï¼Œéœ€è¦æ£€æŸ¥æ˜¯å¦æœ‰æ³„æ¼

**Q4: å¦‚ä½•ä¼˜åŒ– GC æ€§èƒ½ï¼Ÿ**

A:

1. å¢åŠ  `GOGC` å€¼ï¼ˆé»˜è®¤ 100ï¼Œå¯è®¾ä¸º 200 æˆ–æ›´é«˜ï¼‰
2. ä½¿ç”¨ `debug.SetGCPercent(-1)` ç¦ç”¨è‡ªåŠ¨ GCï¼ˆéœ€æ‰‹åŠ¨è§¦å‘ï¼‰
3. å‡å°‘å †ä¸Šçš„å°å¯¹è±¡åˆ†é…ï¼ˆä½¿ç”¨ `sync.Pool`ï¼‰
4. é¿å…å¤§é‡æŒ‡é’ˆï¼ˆå½±å“ GC æ‰«ææ—¶é—´ï¼‰

**Q5: Go 1.25.1 å¯¹è¿è¡Œæ—¶æŒ‡æ ‡æœ‰ä»€ä¹ˆæ”¹è¿›ï¼Ÿ**

A: Go 1.25.1 ä¸»è¦æ”¹è¿›ï¼š

- `runtime/metrics` æ–°å¢è°ƒåº¦å»¶è¿Ÿåˆ†å¸ƒ
- æ›´è¯¦ç»†çš„ GC é˜¶æ®µæŒ‡æ ‡
- æ”¹è¿›çš„å†…å­˜åˆ†ç±»ï¼ˆ`/memory/classes/*`ï¼‰

---

## æ€»ç»“

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº† Go è¿è¡Œæ—¶æŒ‡æ ‡çš„è¯­ä¹‰çº¦å®šå’Œ Go 1.25.1 å®ç°æ–¹æ¡ˆï¼Œæ¶µç›–ï¼š

âœ… **å†…å­˜æŒ‡æ ‡**ï¼šå †ã€æ ˆã€åˆ†é…ç»Ÿè®¡  
âœ… **GC æŒ‡æ ‡**ï¼šå‘¨æœŸã€æš‚åœã€CPU å ç”¨  
âœ… **Goroutine æŒ‡æ ‡**ï¼šæ•°é‡ã€è°ƒåº¦å™¨çŠ¶æ€  
âœ… **CGO æŒ‡æ ‡**ï¼šCGO è°ƒç”¨ç»Ÿè®¡  
âœ… **runtime/metrics**ï¼šæ·±åº¦é›†æˆã€æ‰¹é‡é‡‡é›†  
âœ… **å®Œæ•´ç¤ºä¾‹**ï¼šç›‘æ§å™¨ã€æ€§èƒ½åˆ†æã€ç”Ÿäº§é…ç½®  
âœ… **æœ€ä½³å®è·µ**ï¼šæŒ‡æ ‡é€‰æ‹©ã€é‡‡é›†é¢‘ç‡ã€ä¼˜åŒ–ã€å‘Šè­¦  

**ä¸‹ä¸€æ­¥**ï¼š

- ğŸ“– é˜…è¯»ã€ŠHTTP æŒ‡æ ‡ã€‹å­¦ä¹ åº”ç”¨å±‚æŒ‡æ ‡
- ğŸ“– é˜…è¯»ã€Šè‡ªå®šä¹‰æŒ‡æ ‡ã€‹å­¦ä¹ ä¸šåŠ¡æŒ‡æ ‡
- ğŸ”— å‚è€ƒ [runtime/metrics æ–‡æ¡£](https://pkg.go.dev/runtime/metrics)

**å‚è€ƒèµ„æº**ï¼š

- [Go Runtime Metrics](https://pkg.go.dev/runtime/metrics)
- [OpenTelemetry Go Runtime Instrumentation](https://github.com/open-telemetry/opentelemetry-go-contrib/tree/main/instrumentation/runtime)
- [A Guide to the Go Garbage Collector](https://tip.golang.org/doc/gc-guide)
