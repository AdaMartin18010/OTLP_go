# OTLP 日志与追踪关联完整指南

## 目录

- [OTLP 日志与追踪关联完整指南](#otlp-日志与追踪关联完整指南)
  - [目录](#目录)
  - [1. 日志追踪关联概述](#1-日志追踪关联概述)
    - [1.1 为什么需要关联](#11-为什么需要关联)
    - [1.2 关联模型](#12-关联模型)
  - [2. Trace ID 和 Span ID 注入](#2-trace-id-和-span-id-注入)
    - [2.1 自动注入](#21-自动注入)
    - [2.2 OTLP 原生注入](#22-otlp-原生注入)
  - [3. Go 实现](#3-go-实现)
    - [3.1 完整的日志追踪集成](#31-完整的日志追踪集成)
    - [3.2 Slog 集成](#32-slog-集成)
    - [3.3 中间件集成](#33-中间件集成)
  - [4. 跨服务关联](#4-跨服务关联)
    - [4.1 Context 传播](#41-context-传播)
    - [4.2 完整的分布式追踪示例](#42-完整的分布式追踪示例)
  - [5. 查询与可视化](#5-查询与可视化)
    - [5.1 按 Trace ID 查询日志](#51-按-trace-id-查询日志)
    - [5.2 Grafana 集成](#52-grafana-集成)
    - [5.3 Jaeger 集成](#53-jaeger-集成)
  - [6. 性能优化](#6-性能优化)
    - [6.1 条件注入](#61-条件注入)
    - [6.2 字符串缓存](#62-字符串缓存)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 始终使用 Context](#71-始终使用-context)
    - [7.2 日志级别与 Span 事件](#72-日志级别与-span-事件)
    - [7.3 错误关联](#73-错误关联)
  - [8. 完整示例](#8-完整示例)
    - [8.1 端到端示例](#81-端到端示例)
  - [9. 参考资料](#9-参考资料)

---

## 1. 日志追踪关联概述

### 1.1 为什么需要关联

日志与追踪关联可以：

- 快速定位问题根因
- 查看请求完整生命周期
- 关联分布式系统中的所有日志
- 提供完整的可观测性

### 1.2 关联模型

```go
// 日志记录包含 Trace 上下文
type LogRecord struct {
    Timestamp      time.Time
    Message        string
    Severity       log.Severity
    
    // Trace 上下文
    TraceID        trace.TraceID    // 追踪 ID
    SpanID         trace.SpanID     // Span ID
    TraceFlags     trace.TraceFlags // 采样标志
    
    Attributes     []log.KeyValue
}
```

---

## 2. Trace ID 和 Span ID 注入

### 2.1 自动注入

使用 OpenTelemetry 的 Context 自动注入：

```go
import (
    "context"
    "log/slog"
    
    "go.opentelemetry.io/otel/trace"
    sdklog "go.opentelemetry.io/otel/sdk/log"
)

// TraceAwareHandler 自动注入 Trace ID
type TraceAwareHandler struct {
    base slog.Handler
}

func (h *TraceAwareHandler) Handle(ctx context.Context, record slog.Record) error {
    // 从上下文中提取 Span
    span := trace.SpanFromContext(ctx)
    spanCtx := span.SpanContext()
    
    // 注入 Trace ID 和 Span ID
    if spanCtx.IsValid() {
        record = record.Clone()
        record.AddAttrs(
            slog.String("trace.id", spanCtx.TraceID().String()),
            slog.String("span.id", spanCtx.SpanID().String()),
            slog.Bool("trace.sampled", spanCtx.IsSampled()),
        )
    }
    
    return h.base.Handle(ctx, record)
}

// 使用示例
func HandleRequest(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    // 创建 Span
    ctx, span := tracer.Start(ctx, "handle_request")
    defer span.End()
    
    // 日志自动包含 Trace ID
    slog.InfoContext(ctx, "Processing request",
        "method", r.Method,
        "path", r.URL.Path,
    )
    // 输出: trace.id=4bf92f3577b34da6 span.id=00f067aa0ba902b7
}
```

### 2.2 OTLP 原生注入

在 OTLP 日志记录中直接设置：

```go
func emitLogWithTrace(ctx context.Context, logger log.Logger, msg string) {
    var record log.Record
    
    // 基本字段
    record.SetTimestamp(time.Now())
    record.SetBody(log.StringValue(msg))
    record.SetSeverityNumber(log.SeverityInfo)
    
    // 提取并设置 Trace 上下文
    span := trace.SpanFromContext(ctx)
    if spanCtx := span.SpanContext(); spanCtx.IsValid() {
        record.SetTraceID(spanCtx.TraceID())
        record.SetSpanID(spanCtx.SpanID())
        record.SetTraceFlags(spanCtx.TraceFlags())
    }
    
    logger.Emit(ctx, record)
}
```

---

## 3. Go 实现

### 3.1 完整的日志追踪集成

```go
package logging

import (
    "context"
    "log/slog"
    
    "go.opentelemetry.io/otel/log"
    "go.opentelemetry.io/otel/trace"
    sdklog "go.opentelemetry.io/otel/sdk/log"
)

// TraceLogger 集成 Trace 的日志器
type TraceLogger struct {
    provider *sdklog.LoggerProvider
    logger   log.Logger
    tracer   trace.Tracer
}

func NewTraceLogger(
    provider *sdklog.LoggerProvider,
    tracer trace.Tracer,
) *TraceLogger {
    return &TraceLogger{
        provider: provider,
        logger:   provider.Logger("app"),
        tracer:   tracer,
    }
}

// InfoWithSpan 在日志中记录 Span 信息
func (l *TraceLogger) InfoWithSpan(
    ctx context.Context,
    msg string,
    attrs ...log.KeyValue,
) {
    span := trace.SpanFromContext(ctx)
    spanCtx := span.SpanContext()
    
    var record log.Record
    record.SetTimestamp(time.Now())
    record.SetBody(log.StringValue(msg))
    record.SetSeverityNumber(log.SeverityInfo)
    
    // Trace 上下文
    if spanCtx.IsValid() {
        record.SetTraceID(spanCtx.TraceID())
        record.SetSpanID(spanCtx.SpanID())
        record.SetTraceFlags(spanCtx.TraceFlags())
        
        // 添加 Span 名称作为属性
        attrs = append(attrs, log.String("span.name", span.Name()))
    }
    
    record.AddAttributes(attrs...)
    l.logger.Emit(ctx, record)
}

// ErrorWithSpan 记录错误并添加到 Span
func (l *TraceLogger) ErrorWithSpan(
    ctx context.Context,
    msg string,
    err error,
    attrs ...log.KeyValue,
) {
    span := trace.SpanFromContext(ctx)
    
    // 记录错误到 Span
    span.RecordError(err)
    
    // 记录日志
    allAttrs := append(attrs, log.String("error", err.Error()))
    l.InfoWithSpan(ctx, msg, allAttrs...)
}
```

### 3.2 Slog 集成

```go
// SlogWithTrace 集成 Trace 的 slog.Handler
type SlogWithTrace struct {
    base slog.Handler
}

func NewSlogWithTrace(base slog.Handler) *SlogWithTrace {
    return &SlogWithTrace{base: base}
}

func (h *SlogWithTrace) Enabled(ctx context.Context, level slog.Level) bool {
    return h.base.Enabled(ctx, level)
}

func (h *SlogWithTrace) Handle(ctx context.Context, record slog.Record) error {
    span := trace.SpanFromContext(ctx)
    spanCtx := span.SpanContext()
    
    if spanCtx.IsValid() {
        // 克隆记录并添加 Trace 字段
        newRecord := slog.NewRecord(record.Time, record.Level, record.Message, record.PC)
        
        // 添加原有属性
        record.Attrs(func(attr slog.Attr) bool {
            newRecord.AddAttrs(attr)
            return true
        })
        
        // 添加 Trace 字段
        newRecord.AddAttrs(
            slog.String("trace_id", spanCtx.TraceID().String()),
            slog.String("span_id", spanCtx.SpanID().String()),
            slog.String("trace_flags", spanCtx.TraceFlags().String()),
        )
        
        return h.base.Handle(ctx, newRecord)
    }
    
    return h.base.Handle(ctx, record)
}

func (h *SlogWithTrace) WithAttrs(attrs []slog.Attr) slog.Handler {
    return &SlogWithTrace{base: h.base.WithAttrs(attrs)}
}

func (h *SlogWithTrace) WithGroup(name string) slog.Handler {
    return &SlogWithTrace{base: h.base.WithGroup(name)}
}
```

### 3.3 中间件集成

```go
// LoggingMiddleware HTTP 中间件
func LoggingMiddleware(logger *slog.Logger) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            ctx := r.Context()
            
            // 创建 Span
            ctx, span := tracer.Start(ctx, "http_request")
            defer span.End()
            
            // 记录请求开始
            logger.InfoContext(ctx, "Request started",
                "method", r.Method,
                "path", r.URL.Path,
                "remote_addr", r.RemoteAddr,
            )
            
            // 包装 ResponseWriter 以捕获状态码
            rw := &responseWriter{ResponseWriter: w}
            
            // 处理请求
            next.ServeHTTP(rw, r.WithContext(ctx))
            
            // 记录请求完成
            logger.InfoContext(ctx, "Request completed",
                "status", rw.status,
                "bytes", rw.written,
            )
        })
    }
}

type responseWriter struct {
    http.ResponseWriter
    status  int
    written int64
}

func (rw *responseWriter) WriteHeader(status int) {
    rw.status = status
    rw.ResponseWriter.WriteHeader(status)
}

func (rw *responseWriter) Write(b []byte) (int, error) {
    n, err := rw.ResponseWriter.Write(b)
    rw.written += int64(n)
    return n, err
}
```

---

## 4. 跨服务关联

### 4.1 Context 传播

```go
import (
    "go.opentelemetry.io/otel/propagation"
)

// 服务 A：传播 Trace 上下文
func callServiceB(ctx context.Context) error {
    // 创建请求
    req, _ := http.NewRequestWithContext(ctx, "GET", "http://service-b/api", nil)
    
    // 注入 Trace 上下文到 HTTP Header
    propagator := otel.GetTextMapPropagator()
    propagator.Inject(ctx, propagation.HeaderCarrier(req.Header))
    
    // 记录日志
    slog.InfoContext(ctx, "Calling service B")
    
    // 发送请求
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        slog.ErrorContext(ctx, "Failed to call service B", "error", err)
        return err
    }
    defer resp.Body.Close()
    
    slog.InfoContext(ctx, "Service B responded", "status", resp.StatusCode)
    return nil
}

// 服务 B：提取 Trace 上下文
func HandleServiceB(w http.ResponseWriter, r *http.Request) {
    // 提取 Trace 上下文
    propagator := otel.GetTextMapPropagator()
    ctx := propagator.Extract(r.Context(), propagation.HeaderCarrier(r.Header))
    
    // 创建新 Span（继承 Trace ID）
    ctx, span := tracer.Start(ctx, "service_b_handler")
    defer span.End()
    
    // 日志自动关联到相同的 Trace ID
    slog.InfoContext(ctx, "Processing request in service B")
    
    w.WriteHeader(http.StatusOK)
}
```

### 4.2 完整的分布式追踪示例

```go
// 服务 A
func ServiceAHandler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    ctx, span := tracer.Start(ctx, "service_a_handler")
    defer span.End()
    
    slog.InfoContext(ctx, "Service A: Processing request")
    
    // 调用服务 B
    if err := callServiceB(ctx); err != nil {
        slog.ErrorContext(ctx, "Service A: Failed", "error", err)
        http.Error(w, "Internal error", http.StatusInternalServerError)
        return
    }
    
    // 调用服务 C
    if err := callServiceC(ctx); err != nil {
        slog.ErrorContext(ctx, "Service A: Failed", "error", err)
        http.Error(w, "Internal error", http.StatusInternalServerError)
        return
    }
    
    slog.InfoContext(ctx, "Service A: Completed successfully")
    w.WriteHeader(http.StatusOK)
}

// 所有日志将共享相同的 trace_id，便于关联查询
```

---

## 5. 查询与可视化

### 5.1 按 Trace ID 查询日志

在 Loki/Elasticsearch 中查询：

```bash
# Loki (LogQL)
{service_name="myapp"} | json | trace_id="4bf92f3577b34da6a3ce929d0e0e4736"

# Elasticsearch
GET /logs-*/_search
{
  "query": {
    "term": {
      "trace_id": "4bf92f3577b34da6a3ce929d0e0e4736"
    }
  },
  "sort": [{"@timestamp": "asc"}]
}
```

### 5.2 Grafana 集成

在 Grafana 中关联 Trace 和 Logs：

```go
// 在 Tempo 中查看 Trace，点击 Span 可以查看关联的日志
// Grafana 配置：
// 1. 添加 Tempo 数据源
// 2. 添加 Loki 数据源
// 3. 在 Tempo 数据源中配置 Logs 关联：
//    - Data source: Loki
//    - Tags: trace_id
```

### 5.3 Jaeger 集成

```go
// Jaeger 可以从 Span 标签中读取日志
func AddLogToSpan(ctx context.Context, msg string, fields ...log.Field) {
    span := trace.SpanFromContext(ctx)
    
    // 添加事件到 Span
    span.AddEvent(msg, trace.WithAttributes(
        attribute.String("log.message", msg),
        attribute.String("log.level", "INFO"),
    ))
    
    // 同时记录日志
    slog.InfoContext(ctx, msg)
}
```

---

## 6. 性能优化

### 6.1 条件注入

仅在采样时注入：

```go
func (h *TraceAwareHandler) Handle(ctx context.Context, record slog.Record) error {
    span := trace.SpanFromContext(ctx)
    spanCtx := span.SpanContext()
    
    // 仅在采样时注入 Trace ID
    if spanCtx.IsValid() && spanCtx.IsSampled() {
        record = record.Clone()
        record.AddAttrs(
            slog.String("trace.id", spanCtx.TraceID().String()),
            slog.String("span.id", spanCtx.SpanID().String()),
        )
    }
    
    return h.base.Handle(ctx, record)
}
```

### 6.2 字符串缓存

缓存 Trace ID 字符串：

```go
type TraceIDCache struct {
    cache sync.Map // map[trace.TraceID]string
}

func (c *TraceIDCache) String(traceID trace.TraceID) string {
    if cached, ok := c.cache.Load(traceID); ok {
        return cached.(string)
    }
    
    str := traceID.String()
    c.cache.Store(traceID, str)
    return str
}
```

---

## 7. 最佳实践

### 7.1 始终使用 Context

```go
// ✅ 好的做法
func ProcessOrder(ctx context.Context, orderID string) error {
    ctx, span := tracer.Start(ctx, "process_order")
    defer span.End()
    
    slog.InfoContext(ctx, "Processing order", "order_id", orderID)
    // ...
    return nil
}

// ❌ 避免
func ProcessOrder(orderID string) error {
    ctx := context.Background() // 丢失了 Trace 上下文！
    // ...
}
```

### 7.2 日志级别与 Span 事件

```go
// 将重要日志也记录为 Span 事件
func LogAndEvent(ctx context.Context, level slog.Level, msg string, attrs ...any) {
    // 记录日志
    slog.Log(ctx, level, msg, attrs...)
    
    // 添加到 Span
    if level >= slog.LevelWarn {
        span := trace.SpanFromContext(ctx)
        span.AddEvent(msg, trace.WithAttributes(
            attribute.String("log.level", level.String()),
        ))
    }
}
```

### 7.3 错误关联

```go
func HandleError(ctx context.Context, operation string, err error) {
    span := trace.SpanFromContext(ctx)
    
    // 记录错误到 Span
    span.RecordError(err)
    span.SetStatus(codes.Error, err.Error())
    
    // 记录错误日志
    slog.ErrorContext(ctx, "Operation failed",
        "operation", operation,
        "error", err.Error(),
    )
}
```

---

## 8. 完整示例

### 8.1 端到端示例

```go
package main

import (
    "context"
    "log/slog"
    "net/http"
    "os"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlplog/otlploggrpc"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    sdklog "go.opentelemetry.io/otel/sdk/log"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

func main() {
    ctx := context.Background()
    
    // 1. 创建资源
    res, _ := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName("myapp"),
            semconv.ServiceVersion("1.0.0"),
        ),
    )
    
    // 2. 设置 Trace
    traceExporter, _ := otlptracegrpc.New(ctx,
        otlptracegrpc.WithEndpoint("localhost:4317"),
        otlptracegrpc.WithInsecure(),
    )
    tracerProvider := sdktrace.NewTracerProvider(
        sdktrace.WithResource(res),
        sdktrace.WithBatcher(traceExporter),
    )
    otel.SetTracerProvider(tracerProvider)
    defer tracerProvider.Shutdown(ctx)
    
    // 3. 设置 Logs
    logExporter, _ := otlploggrpc.New(ctx,
        otlploggrpc.WithEndpoint("localhost:4317"),
        otlploggrpc.WithInsecure(),
    )
    loggerProvider := sdklog.NewLoggerProvider(
        sdklog.WithResource(res),
        sdklog.WithProcessor(sdklog.NewBatchProcessor(logExporter)),
    )
    defer loggerProvider.Shutdown(ctx)
    
    // 4. 创建集成 Trace 的日志处理器
    baseHandler := slog.NewJSONHandler(os.Stdout, nil)
    traceHandler := NewSlogWithTrace(baseHandler)
    logger := slog.New(traceHandler)
    slog.SetDefault(logger)
    
    // 5. 设置 HTTP 服务器
    tracer := otel.Tracer("myapp")
    
    http.HandleFunc("/api/orders", func(w http.ResponseWriter, r *http.Request) {
        ctx := r.Context()
        ctx, span := tracer.Start(ctx, "handle_order")
        defer span.End()
        
        slog.InfoContext(ctx, "Received order request")
        
        // 调用其他服务
        if err := callPaymentService(ctx); err != nil {
            slog.ErrorContext(ctx, "Payment failed", "error", err)
            http.Error(w, "Payment failed", http.StatusInternalServerError)
            return
        }
        
        slog.InfoContext(ctx, "Order completed successfully")
        w.WriteHeader(http.StatusOK)
    })
    
    slog.Info("Server starting", "port", 8080)
    http.ListenAndServe(":8080", nil)
}

func callPaymentService(ctx context.Context) error {
    ctx, span := otel.Tracer("myapp").Start(ctx, "payment_service")
    defer span.End()
    
    slog.InfoContext(ctx, "Calling payment service")
    
    // 模拟处理
    // ...
    
    slog.InfoContext(ctx, "Payment service responded")
    return nil
}
```

---

## 9. 参考资料

1. **OpenTelemetry Logs and Traces**  
   <https://opentelemetry.io/docs/specs/otel/logs/>

2. **W3C Trace Context**  
   <https://www.w3.org/TR/trace-context/>

3. **Grafana Tempo**  
   <https://grafana.com/docs/tempo/>

4. **Jaeger Architecture**  
   <https://www.jaegertracing.io/docs/architecture/>

---

**文档版本**: v1.0.0  
**最后更新**: 2025-10-09  
**Go 版本**: 1.25.1  
**OpenTelemetry**: v1.32.0
