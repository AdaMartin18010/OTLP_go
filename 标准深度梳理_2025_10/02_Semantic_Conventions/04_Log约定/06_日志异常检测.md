# OTLP 日志异常检测与 Go 实现完整指南

## 目录

- [OTLP 日志异常检测与 Go 实现完整指南](#otlp-日志异常检测与-go-实现完整指南)
  - [目录](#目录)
  - [1. 异常检测概述](#1-异常检测概述)
    - [1.1 异常类型](#11-异常类型)
    - [1.2 检测策略](#12-检测策略)
  - [2. 错误模式识别](#2-错误模式识别)
    - [2.1 正则表达式模式](#21-正则表达式模式)
    - [2.2 错误聚类](#22-错误聚类)
  - [3. 统计分析](#3-统计分析)
    - [3.1 时间序列分析](#31-时间序列分析)
    - [3.2 滑动窗口检测](#32-滑动窗口检测)
  - [4. 告警系统](#4-告警系统)
    - [4.1 告警规则](#41-告警规则)
    - [4.2 Slack 通知](#42-slack-通知)
  - [5. 机器学习检测](#5-机器学习检测)
    - [5.1 简单异常检测模型](#51-简单异常检测模型)
  - [6. 完整示例](#6-完整示例)
    - [6.1 综合异常检测系统](#61-综合异常检测系统)
  - [7. 参考资料](#7-参考资料)

---

## 1. 异常检测概述

### 1.1 异常类型

```go
type AnomalyType string

const (
    // 频率异常：日志频率突增/突降
    AnomalyFrequency AnomalyType = "frequency"
    
    // 模式异常：出现新的错误模式
    AnomalyPattern AnomalyType = "pattern"
    
    // 值异常：指标值异常（如响应时间）
    AnomalyValue AnomalyType = "value"
    
    // 关联异常：跨服务异常关联
    AnomalyCorrelation AnomalyType = "correlation"
)

type Anomaly struct {
    Type        AnomalyType
    Timestamp   time.Time
    Severity    string // "low", "medium", "high", "critical"
    Description string
    Metrics     map[string]float64
    Logs        []LogEntry
}
```

### 1.2 检测策略

```go
type AnomalyDetector interface {
    // Detect 检测异常
    Detect(ctx context.Context, logs []LogEntry) ([]Anomaly, error)
    
    // Train 训练模型（如果需要）
    Train(ctx context.Context, historicalLogs []LogEntry) error
    
    // UpdateBaseline 更新基线
    UpdateBaseline(ctx context.Context) error
}
```

---

## 2. 错误模式识别

### 2.1 正则表达式模式

```go
type PatternDetector struct {
    patterns map[string]*regexp.Regexp
    counts   map[string]int
    mu       sync.RWMutex
}

func NewPatternDetector() *PatternDetector {
    return &PatternDetector{
        patterns: map[string]*regexp.Regexp{
            "connection_error":  regexp.MustCompile(`connection (refused|timeout|reset)`),
            "out_of_memory":     regexp.MustCompile(`out of memory|OOM`),
            "null_pointer":      regexp.MustCompile(`nil pointer|null reference`),
            "database_error":    regexp.MustCompile(`database (connection|query|timeout)`),
            "auth_error":        regexp.MustCompile(`auth(entication|orization) (failed|denied)`),
            "rate_limit":        regexp.MustCompile(`rate limit exceeded|too many requests`),
            "panic":             regexp.MustCompile(`panic:|runtime error:`),
        },
        counts: make(map[string]int),
    }
}

func (d *PatternDetector) Detect(ctx context.Context, logs []LogEntry) ([]Anomaly, error) {
    d.mu.Lock()
    defer d.mu.Unlock()
    
    // 重置计数
    for k := range d.counts {
        d.counts[k] = 0
    }
    
    // 匹配模式
    matchedLogs := make(map[string][]LogEntry)
    for _, log := range logs {
        for patternName, pattern := range d.patterns {
            if pattern.MatchString(log.Message) {
                d.counts[patternName]++
                matchedLogs[patternName] = append(matchedLogs[patternName], log)
            }
        }
    }
    
    // 生成异常
    var anomalies []Anomaly
    for patternName, count := range d.counts {
        if count > 0 {
            anomaly := Anomaly{
                Type:        AnomalyPattern,
                Timestamp:   time.Now(),
                Severity:    d.calculateSeverity(patternName, count),
                Description: fmt.Sprintf("Detected %d occurrences of pattern: %s", count, patternName),
                Metrics: map[string]float64{
                    "count": float64(count),
                },
                Logs: matchedLogs[patternName],
            }
            anomalies = append(anomalies, anomaly)
        }
    }
    
    return anomalies, nil
}

func (d *PatternDetector) calculateSeverity(pattern string, count int) string {
    // 根据模式和数量计算严重性
    criticalPatterns := map[string]bool{
        "panic":         true,
        "out_of_memory": true,
    }
    
    if criticalPatterns[pattern] {
        if count > 0 {
            return "critical"
        }
    }
    
    switch {
    case count >= 100:
        return "critical"
    case count >= 50:
        return "high"
    case count >= 10:
        return "medium"
    default:
        return "low"
    }
}
```

### 2.2 错误聚类

```go
import (
    "github.com/pemistahl/lingua-go"
)

type ErrorCluster struct {
    Pattern    string
    Count      int
    Samples    []LogEntry
    FirstSeen  time.Time
    LastSeen   time.Time
}

type ClusterDetector struct {
    clusters map[string]*ErrorCluster
    mu       sync.RWMutex
}

func NewClusterDetector() *ClusterDetector {
    return &ClusterDetector{
        clusters: make(map[string]*ErrorCluster),
    }
}

func (d *ClusterDetector) Detect(ctx context.Context, logs []LogEntry) ([]Anomaly, error) {
    d.mu.Lock()
    defer d.mu.Unlock()
    
    for _, log := range logs {
        if log.Level != "ERROR" {
            continue
        }
        
        // 提取错误签名
        signature := d.extractSignature(log.Message)
        
        cluster, exists := d.clusters[signature]
        if !exists {
            cluster = &ErrorCluster{
                Pattern:   signature,
                FirstSeen: log.TimeParsed,
                Samples:   []LogEntry{log},
            }
            d.clusters[signature] = cluster
        }
        
        cluster.Count++
        cluster.LastSeen = log.TimeParsed
        
        // 保留样本（最多10个）
        if len(cluster.Samples) < 10 {
            cluster.Samples = append(cluster.Samples, log)
        }
    }
    
    // 生成异常（新出现的错误模式）
    var anomalies []Anomaly
    for _, cluster := range d.clusters {
        // 检测新模式（首次出现时间在最近5分钟内）
        if time.Since(cluster.FirstSeen) < 5*time.Minute {
            anomaly := Anomaly{
                Type:        AnomalyPattern,
                Timestamp:   cluster.FirstSeen,
                Severity:    "medium",
                Description: fmt.Sprintf("New error pattern detected: %s (count: %d)", cluster.Pattern, cluster.Count),
                Metrics: map[string]float64{
                    "count": float64(cluster.Count),
                },
                Logs: cluster.Samples,
            }
            anomalies = append(anomalies, anomaly)
        }
    }
    
    return anomalies, nil
}

func (d *ClusterDetector) extractSignature(message string) string {
    // 移除数字、UUID、时间戳等可变部分
    re := regexp.MustCompile(`\d+|[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|\d{4}-\d{2}-\d{2}`)
    normalized := re.ReplaceAllString(message, "*")
    
    // 限制长度
    if len(normalized) > 200 {
        normalized = normalized[:200]
    }
    
    return normalized
}
```

---

## 3. 统计分析

### 3.1 时间序列分析

```go
type TimeSeriesAnalyzer struct {
    window   time.Duration
    baseline map[string]*Baseline
    mu       sync.RWMutex
}

type Baseline struct {
    Mean   float64
    StdDev float64
    Min    float64
    Max    float64
}

func NewTimeSeriesAnalyzer(window time.Duration) *TimeSeriesAnalyzer {
    return &TimeSeriesAnalyzer{
        window:   window,
        baseline: make(map[string]*Baseline),
    }
}

func (a *TimeSeriesAnalyzer) Detect(ctx context.Context, logs []LogEntry) ([]Anomaly, error) {
    // 按时间窗口分组
    buckets := a.groupByTimeWindow(logs)
    
    var anomalies []Anomaly
    
    for level, counts := range buckets {
        // 计算统计指标
        mean, stdDev := a.calculateStats(counts)
        
        a.mu.RLock()
        baseline, exists := a.baseline[level]
        a.mu.RUnlock()
        
        if !exists {
            // 创建基线
            a.mu.Lock()
            a.baseline[level] = &Baseline{
                Mean:   mean,
                StdDev: stdDev,
            }
            a.mu.Unlock()
            continue
        }
        
        // 检测异常（超过3个标准差）
        for ts, count := range counts {
            zscore := (float64(count) - baseline.Mean) / baseline.StdDev
            
            if math.Abs(zscore) > 3.0 {
                anomaly := Anomaly{
                    Type:        AnomalyFrequency,
                    Timestamp:   ts,
                    Severity:    a.calculateSeverityByZScore(zscore),
                    Description: fmt.Sprintf("Abnormal log frequency for level %s: %.2f (z-score: %.2f)", level, float64(count), zscore),
                    Metrics: map[string]float64{
                        "count":    float64(count),
                        "mean":     baseline.Mean,
                        "std_dev":  baseline.StdDev,
                        "z_score":  zscore,
                    },
                }
                anomalies = append(anomalies, anomaly)
            }
        }
    }
    
    return anomalies, nil
}

func (a *TimeSeriesAnalyzer) groupByTimeWindow(logs []LogEntry) map[string]map[time.Time]int {
    buckets := make(map[string]map[time.Time]int)
    
    for _, log := range logs {
        if log.Level == "" {
            continue
        }
        
        if buckets[log.Level] == nil {
            buckets[log.Level] = make(map[time.Time]int)
        }
        
        // 对齐到时间窗口
        bucket := log.TimeParsed.Truncate(a.window)
        buckets[log.Level][bucket]++
    }
    
    return buckets
}

func (a *TimeSeriesAnalyzer) calculateStats(counts map[time.Time]int) (mean, stdDev float64) {
    if len(counts) == 0 {
        return 0, 0
    }
    
    var sum float64
    for _, count := range counts {
        sum += float64(count)
    }
    mean = sum / float64(len(counts))
    
    var variance float64
    for _, count := range counts {
        diff := float64(count) - mean
        variance += diff * diff
    }
    variance /= float64(len(counts))
    stdDev = math.Sqrt(variance)
    
    return mean, stdDev
}

func (a *TimeSeriesAnalyzer) calculateSeverityByZScore(zscore float64) string {
    absZ := math.Abs(zscore)
    switch {
    case absZ > 5:
        return "critical"
    case absZ > 4:
        return "high"
    case absZ > 3:
        return "medium"
    default:
        return "low"
    }
}
```

### 3.2 滑动窗口检测

```go
type SlidingWindowDetector struct {
    windowSize time.Duration
    threshold  float64
    history    *ring.Ring
    mu         sync.Mutex
}

func NewSlidingWindowDetector(windowSize time.Duration, threshold float64) *SlidingWindowDetector {
    return &SlidingWindowDetector{
        windowSize: windowSize,
        threshold:  threshold,
        history:    ring.New(100), // 保留最近100个窗口
    }
}

func (d *SlidingWindowDetector) Detect(ctx context.Context, logs []LogEntry) ([]Anomaly, error) {
    d.mu.Lock()
    defer d.mu.Unlock()
    
    // 计算当前窗口的错误率
    errorCount := 0
    totalCount := len(logs)
    
    for _, log := range logs {
        if log.Level == "ERROR" || log.Level == "FATAL" {
            errorCount++
        }
    }
    
    errorRate := float64(errorCount) / float64(totalCount)
    
    // 记录到历史
    d.history.Value = errorRate
    d.history = d.history.Next()
    
    // 计算历史平均错误率
    var historicalSum float64
    count := 0
    d.history.Do(func(v interface{}) {
        if v != nil {
            historicalSum += v.(float64)
            count++
        }
    })
    
    if count == 0 {
        return nil, nil
    }
    
    historicalAvg := historicalSum / float64(count)
    
    // 检测异常（当前错误率超过历史平均的阈值倍数）
    if errorRate > historicalAvg*d.threshold {
        anomaly := Anomaly{
            Type:        AnomalyFrequency,
            Timestamp:   time.Now(),
            Severity:    "high",
            Description: fmt.Sprintf("High error rate detected: %.2f%% (threshold: %.2f%%)", errorRate*100, historicalAvg*d.threshold*100),
            Metrics: map[string]float64{
                "current_rate":    errorRate,
                "historical_avg":  historicalAvg,
                "threshold":       d.threshold,
            },
        }
        return []Anomaly{anomaly}, nil
    }
    
    return nil, nil
}
```

---

## 4. 告警系统

### 4.1 告警规则

```go
type AlertRule struct {
    Name        string
    Condition   func(Anomaly) bool
    Severity    string
    Cooldown    time.Duration
    lastTrigger time.Time
    mu          sync.Mutex
}

type AlertManager struct {
    rules     []*AlertRule
    notifiers []Notifier
}

type Notifier interface {
    Notify(ctx context.Context, alert Alert) error
}

type Alert struct {
    Rule      string
    Anomaly   Anomaly
    Timestamp time.Time
    Message   string
}

func NewAlertManager() *AlertManager {
    return &AlertManager{
        rules: []*AlertRule{
            {
                Name: "HighErrorRate",
                Condition: func(a Anomaly) bool {
                    return a.Type == AnomalyFrequency && a.Metrics["current_rate"] > 0.1
                },
                Severity: "high",
                Cooldown: 5 * time.Minute,
            },
            {
                Name: "CriticalPattern",
                Condition: func(a Anomaly) bool {
                    return a.Type == AnomalyPattern && a.Severity == "critical"
                },
                Severity: "critical",
                Cooldown: 1 * time.Minute,
            },
        },
    }
}

func (m *AlertManager) ProcessAnomalies(ctx context.Context, anomalies []Anomaly) error {
    for _, anomaly := range anomalies {
        for _, rule := range m.rules {
            if rule.ShouldTrigger(anomaly) {
                alert := Alert{
                    Rule:      rule.Name,
                    Anomaly:   anomaly,
                    Timestamp: time.Now(),
                    Message:   fmt.Sprintf("[%s] %s", rule.Severity, anomaly.Description),
                }
                
                // 发送通知
                for _, notifier := range m.notifiers {
                    if err := notifier.Notify(ctx, alert); err != nil {
                        log.Printf("Failed to send notification: %v", err)
                    }
                }
            }
        }
    }
    
    return nil
}

func (r *AlertRule) ShouldTrigger(anomaly Anomaly) bool {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    // 检查冷却期
    if time.Since(r.lastTrigger) < r.Cooldown {
        return false
    }
    
    // 检查条件
    if r.Condition(anomaly) {
        r.lastTrigger = time.Now()
        return true
    }
    
    return false
}
```

### 4.2 Slack 通知

```go
type SlackNotifier struct {
    webhookURL string
    client     *http.Client
}

func NewSlackNotifier(webhookURL string) *SlackNotifier {
    return &SlackNotifier{
        webhookURL: webhookURL,
        client:     &http.Client{Timeout: 10 * time.Second},
    }
}

func (n *SlackNotifier) Notify(ctx context.Context, alert Alert) error {
    payload := map[string]interface{}{
        "text": alert.Message,
        "attachments": []map[string]interface{}{
            {
                "color": n.severityColor(alert.Anomaly.Severity),
                "fields": []map[string]interface{}{
                    {
                        "title": "Rule",
                        "value": alert.Rule,
                        "short": true,
                    },
                    {
                        "title": "Severity",
                        "value": alert.Anomaly.Severity,
                        "short": true,
                    },
                    {
                        "title": "Timestamp",
                        "value": alert.Timestamp.Format(time.RFC3339),
                        "short": false,
                    },
                },
            },
        },
    }
    
    data, err := json.Marshal(payload)
    if err != nil {
        return err
    }
    
    req, err := http.NewRequestWithContext(ctx, "POST", n.webhookURL, bytes.NewReader(data))
    if err != nil {
        return err
    }
    req.Header.Set("Content-Type", "application/json")
    
    resp, err := n.client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("slack notification failed: %s", resp.Status)
    }
    
    return nil
}

func (n *SlackNotifier) severityColor(severity string) string {
    switch severity {
    case "critical":
        return "danger"
    case "high":
        return "warning"
    case "medium":
        return "#FFA500"
    default:
        return "good"
    }
}
```

---

## 5. 机器学习检测

### 5.1 简单异常检测模型

```go
import (
    "gonum.org/v1/gonum/stat"
)

type MLAnomalyDetector struct {
    features   [][]float64
    threshold  float64
    trained    bool
    mu         sync.RWMutex
}

func NewMLAnomalyDetector(threshold float64) *MLAnomalyDetector {
    return &MLAnomalyDetector{
        threshold: threshold,
    }
}

func (d *MLAnomalyDetector) Train(ctx context.Context, historicalLogs []LogEntry) error {
    d.mu.Lock()
    defer d.mu.Unlock()
    
    // 提取特征
    features := d.extractFeatures(historicalLogs)
    d.features = features
    d.trained = true
    
    return nil
}

func (d *MLAnomalyDetector) Detect(ctx context.Context, logs []LogEntry) ([]Anomaly, error) {
    d.mu.RLock()
    defer d.mu.RUnlock()
    
    if !d.trained {
        return nil, fmt.Errorf("model not trained")
    }
    
    // 提取当前特征
    currentFeatures := d.extractFeatures(logs)
    
    var anomalies []Anomaly
    
    // 使用 Isolation Forest 或简单的距离度量
    for i, features := range currentFeatures {
        distance := d.calculateDistance(features)
        
        if distance > d.threshold {
            anomaly := Anomaly{
                Type:        AnomalyValue,
                Timestamp:   time.Now(),
                Severity:    "medium",
                Description: fmt.Sprintf("Anomalous log behavior detected (distance: %.2f)", distance),
                Metrics: map[string]float64{
                    "distance":  distance,
                    "threshold": d.threshold,
                },
                Logs: []LogEntry{logs[i]},
            }
            anomalies = append(anomalies, anomaly)
        }
    }
    
    return anomalies, nil
}

func (d *MLAnomalyDetector) extractFeatures(logs []LogEntry) [][]float64 {
    var features [][]float64
    
    for _, log := range logs {
        feature := []float64{
            float64(len(log.Message)),                    // 消息长度
            float64(strings.Count(log.Message, "error")), // 错误关键词数量
            float64(len(log.Attributes)),                  // 属性数量
            d.severityToFloat(log.Level),                  // 级别
        }
        features = append(features, feature)
    }
    
    return features
}

func (d *MLAnomalyDetector) calculateDistance(features []float64) float64 {
    // 计算与训练数据的平均距离
    var totalDistance float64
    
    for _, trainFeatures := range d.features {
        distance := d.euclideanDistance(features, trainFeatures)
        totalDistance += distance
    }
    
    return totalDistance / float64(len(d.features))
}

func (d *MLAnomalyDetector) euclideanDistance(a, b []float64) float64 {
    var sum float64
    for i := range a {
        diff := a[i] - b[i]
        sum += diff * diff
    }
    return math.Sqrt(sum)
}

func (d *MLAnomalyDetector) severityToFloat(level string) float64 {
    switch level {
    case "TRACE":
        return 1.0
    case "DEBUG":
        return 2.0
    case "INFO":
        return 3.0
    case "WARN":
        return 4.0
    case "ERROR":
        return 5.0
    case "FATAL":
        return 6.0
    default:
        return 3.0
    }
}
```

---

## 6. 完整示例

### 6.1 综合异常检测系统

```go
package main

import (
    "context"
    "log"
    "time"
)

type AnomalyDetectionSystem struct {
    detectors []AnomalyDetector
    alertMgr  *AlertManager
}

func NewAnomalyDetectionSystem() *AnomalyDetectionSystem {
    alertMgr := NewAlertManager()
    alertMgr.notifiers = append(alertMgr.notifiers,
        NewSlackNotifier("https://hooks.slack.com/services/YOUR/WEBHOOK/URL"),
    )
    
    return &AnomalyDetectionSystem{
        detectors: []AnomalyDetector{
            NewPatternDetector(),
            NewClusterDetector(),
            NewTimeSeriesAnalyzer(1 * time.Minute),
            NewSlidingWindowDetector(5*time.Minute, 2.0),
        },
        alertMgr: alertMgr,
    }
}

func (s *AnomalyDetectionSystem) Run(ctx context.Context, logStream <-chan []LogEntry) error {
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        case logs := <-logStream:
            if err := s.process(ctx, logs); err != nil {
                log.Printf("Error processing logs: %v", err)
            }
        }
    }
}

func (s *AnomalyDetectionSystem) process(ctx context.Context, logs []LogEntry) error {
    var allAnomalies []Anomaly
    
    // 运行所有检测器
    for _, detector := range s.detectors {
        anomalies, err := detector.Detect(ctx, logs)
        if err != nil {
            log.Printf("Detector error: %v", err)
            continue
        }
        allAnomalies = append(allAnomalies, anomalies...)
    }
    
    // 处理异常告警
    if len(allAnomalies) > 0 {
        log.Printf("Detected %d anomalies", len(allAnomalies))
        if err := s.alertMgr.ProcessAnomalies(ctx, allAnomalies); err != nil {
            return err
        }
    }
    
    return nil
}

func main() {
    system := NewAnomalyDetectionSystem()
    
    // 创建日志流
    logStream := make(chan []LogEntry)
    
    // 模拟日志源
    go func() {
        ticker := time.NewTicker(1 * time.Minute)
        defer ticker.Stop()
        
        for range ticker.C {
            logs := fetchLogsFromLoki() // 从 Loki 获取日志
            logStream <- logs
        }
    }()
    
    // 运行检测系统
    ctx := context.Background()
    if err := system.Run(ctx, logStream); err != nil {
        log.Fatal(err)
    }
}
```

---

## 7. 参考资料

1. **Anomaly Detection in Logs**  
   <https://www.elastic.co/what-is/log-anomaly-detection>

2. **Statistical Anomaly Detection**  
   <https://towardsdatascience.com/anomaly-detection-for-dummies>

3. **gonum - Scientific Computing**  
   <https://www.gonum.org/>

---

**文档版本**: v1.0.0  
**最后更新**: 2025-10-09  
**Go 版本**: 1.25.1  
**OpenTelemetry**: v1.32.0
