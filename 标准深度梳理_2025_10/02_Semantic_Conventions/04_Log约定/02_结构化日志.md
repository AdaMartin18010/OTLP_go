# OTLP 结构化日志与 Go 实现完整指南

## 目录

- [OTLP 结构化日志与 Go 实现完整指南](#otlp-结构化日志与-go-实现完整指南)
  - [目录](#目录)
  - [1. 结构化日志概述](#1-结构化日志概述)
    - [1.1 什么是结构化日志](#11-什么是结构化日志)
    - [1.2 OpenTelemetry 日志数据模型](#12-opentelemetry-日志数据模型)
  - [2. Go slog 结构化日志](#2-go-slog-结构化日志)
    - [2.1 基本用法](#21-基本用法)
    - [2.2 自定义处理器](#22-自定义处理器)
  - [3. OTLP 日志模型](#3-otlp-日志模型)
    - [3.1 日志记录结构](#31-日志记录结构)
    - [3.2 Body 类型](#32-body-类型)
  - [4. 字段标准化](#4-字段标准化)
    - [4.1 常用字段约定](#41-常用字段约定)
    - [4.2 字段命名规范](#42-字段命名规范)
  - [5. JSON 日志格式](#5-json-日志格式)
    - [5.1 JSON Handler](#51-json-handler)
    - [5.2 自定义 JSON 格式](#52-自定义-json-格式)
  - [6. 高级模式](#6-高级模式)
    - [6.1 日志分组](#61-日志分组)
    - [6.2 LogValuer 接口](#62-logvaluer-接口)
    - [6.3 上下文传播](#63-上下文传播)
  - [7. 性能优化](#7-性能优化)
    - [7.1 预分配字段](#71-预分配字段)
    - [7.2 对象池](#72-对象池)
  - [8. 最佳实践](#8-最佳实践)
    - [8.1 字段命名](#81-字段命名)
    - [8.2 敏感信息处理](#82-敏感信息处理)
  - [9. 完整示例](#9-完整示例)
    - [9.1 企业级结构化日志](#91-企业级结构化日志)
  - [10. 参考资料](#10-参考资料)

---

## 1. 结构化日志概述

### 1.1 什么是结构化日志

结构化日志以键值对形式记录数据，而非自由文本：

```go
// ❌ 非结构化日志
log.Println("User John logged in from 192.168.1.1")

// ✅ 结构化日志
slog.Info("User logged in",
    "user.name", "John",
    "user.id", 12345,
    "network.peer.address", "192.168.1.1",
)
```

**优势**：

- 易于解析和查询
- 支持自动化分析
- 更好的可观测性
- 跨服务一致性

### 1.2 OpenTelemetry 日志数据模型

```go
type LogRecord struct {
    Timestamp            time.Time
    ObservedTimestamp    time.Time
    TraceID              trace.TraceID
    SpanID               trace.SpanID
    TraceFlags           trace.TraceFlags
    SeverityText         string
    SeverityNumber       log.Severity
    Body                 log.Value
    Attributes           []log.KeyValue
    Resource             *resource.Resource
    InstrumentationScope instrumentation.Scope
}
```

---

## 2. Go slog 结构化日志

### 2.1 基本用法

```go
import "log/slog"

func main() {
    // 基本记录
    slog.Info("Application started",
        "version", "1.0.0",
        "pid", os.Getpid(),
    )
    
    // 使用不同类型
    slog.Info("Request processed",
        "duration_ms", 250,
        "success", true,
        "bytes", 1024,
    )
    
    // 嵌套对象
    slog.Info("Database query",
        "query", "SELECT * FROM users",
        slog.Group("timing",
            "parse_ms", 5,
            "execute_ms", 120,
            "fetch_ms", 30,
        ),
    )
}
```

### 2.2 自定义处理器

```go
type StructuredOTelHandler struct {
    provider *sdklog.LoggerProvider
    logger   log.Logger
    level    slog.Leveler
}

func (h *StructuredOTelHandler) Handle(ctx context.Context, record slog.Record) error {
    var logRecord log.Record
    
    // 时间戳
    logRecord.SetTimestamp(record.Time)
    logRecord.SetObservedTimestamp(time.Now())
    
    // 消息体
    logRecord.SetBody(log.StringValue(record.Message))
    
    // 级别
    logRecord.SetSeverityNumber(SlogLevelToOTel(record.Level))
    logRecord.SetSeverityText(record.Level.String())
    
    // 属性
    record.Attrs(func(attr slog.Attr) bool {
        logRecord.AddAttributes(convertAttr(attr))
        return true
    })
    
    // Trace 上下文
    if span := trace.SpanFromContext(ctx); span.SpanContext().IsValid() {
        logRecord.SetTraceID(span.SpanContext().TraceID())
        logRecord.SetSpanID(span.SpanContext().SpanID())
        logRecord.SetTraceFlags(span.SpanContext().TraceFlags())
    }
    
    h.logger.Emit(ctx, logRecord)
    return nil
}

func convertAttr(attr slog.Attr) log.KeyValue {
    switch attr.Value.Kind() {
    case slog.KindBool:
        return log.Bool(attr.Key, attr.Value.Bool())
    case slog.KindInt64:
        return log.Int64(attr.Key, attr.Value.Int64())
    case slog.KindFloat64:
        return log.Float64(attr.Key, attr.Value.Float64())
    case slog.KindString:
        return log.String(attr.Key, attr.Value.String())
    case slog.KindGroup:
        // 递归处理组
        var kvs []log.KeyValue
        for _, groupAttr := range attr.Value.Group() {
            kvs = append(kvs, convertAttr(groupAttr))
        }
        return log.Map(attr.Key, kvs...)
    default:
        return log.String(attr.Key, attr.Value.String())
    }
}
```

---

## 3. OTLP 日志模型

### 3.1 日志记录结构

```go
// 完整的 OTLP 日志记录
func emitStructuredLog(ctx context.Context, logger log.Logger) {
    var record log.Record
    
    // 时间戳
    record.SetTimestamp(time.Now())
    record.SetObservedTimestamp(time.Now())
    
    // 消息体（可以是复杂对象）
    record.SetBody(log.MapValue(
        log.String("message", "Order processed"),
        log.String("order_id", "ORD-12345"),
        log.Float64("amount", 99.99),
    ))
    
    // 级别
    record.SetSeverityNumber(log.SeverityInfo)
    record.SetSeverityText("INFO")
    
    // 属性
    record.AddAttributes(
        log.String("service.name", "order-service"),
        log.String("service.version", "1.0.0"),
        log.String("http.method", "POST"),
        log.String("http.target", "/api/orders"),
        log.Int("http.status_code", 200),
        log.Int("http.response_size", 1024),
    )
    
    // Trace 上下文
    span := trace.SpanFromContext(ctx)
    if span.SpanContext().IsValid() {
        record.SetTraceID(span.SpanContext().TraceID())
        record.SetSpanID(span.SpanContext().SpanID())
        record.SetTraceFlags(span.SpanContext().TraceFlags())
    }
    
    logger.Emit(ctx, record)
}
```

### 3.2 Body 类型

OTLP 支持多种 Body 类型：

```go
// String Body
record.SetBody(log.StringValue("Simple message"))

// Map Body
record.SetBody(log.MapValue(
    log.String("event", "user.login"),
    log.Int64("user.id", 12345),
    log.Bool("success", true),
))

// Slice Body
record.SetBody(log.SliceValue(
    log.StringValue("error1"),
    log.StringValue("error2"),
))

// 嵌套结构
record.SetBody(log.MapValue(
    log.String("message", "Complex event"),
    log.Map("metadata", 
        log.String("source", "api"),
        log.String("version", "v1"),
    ),
    log.Slice("tags",
        log.StringValue("critical"),
        log.StringValue("production"),
    ),
))
```

---

## 4. 字段标准化

### 4.1 常用字段约定

遵循 OpenTelemetry 语义约定：

```go
// HTTP 字段
slog.Info("HTTP request",
    "http.method", "GET",
    "http.target", "/api/users",
    "http.status_code", 200,
    "http.request_content_length", 0,
    "http.response_content_length", 1024,
    "http.user_agent", "Mozilla/5.0...",
)

// 数据库字段
slog.Info("Database query",
    "db.system", "postgresql",
    "db.name", "myapp",
    "db.statement", "SELECT * FROM users WHERE id = $1",
    "db.operation", "SELECT",
)

// 消息队列字段
slog.Info("Message published",
    "messaging.system", "kafka",
    "messaging.destination", "orders",
    "messaging.destination_kind", "topic",
    "messaging.message_id", "msg-12345",
)

// 网络字段
slog.Info("Connection established",
    "network.peer.address", "192.168.1.1",
    "network.peer.port", 8080,
    "network.transport", "tcp",
)
```

### 4.2 字段命名规范

```go
// FieldNamingConvention 字段命名规范
type FieldNamingConvention struct {
    separator string // 分隔符，如 "."
}

func (f *FieldNamingConvention) ServiceField(key string) string {
    return fmt.Sprintf("service%s%s", f.separator, key)
}

func (f *FieldNamingConvention) HTTPField(key string) string {
    return fmt.Sprintf("http%s%s", f.separator, key)
}

// 使用示例
conv := &FieldNamingConvention{separator: "."}
slog.Info("Request",
    conv.ServiceField("name"), "api",
    conv.HTTPField("method"), "GET",
)
```

---

## 5. JSON 日志格式

### 5.1 JSON Handler

```go
import (
    "encoding/json"
    "io"
    "log/slog"
)

type JSONOTelHandler struct {
    w     io.Writer
    level slog.Leveler
}

func NewJSONOTelHandler(w io.Writer, level slog.Leveler) *JSONOTelHandler {
    return &JSONOTelHandler{w: w, level: level}
}

func (h *JSONOTelHandler) Handle(ctx context.Context, record slog.Record) error {
    // 构建 JSON 对象
    obj := map[string]any{
        "timestamp":     record.Time.Format(time.RFC3339Nano),
        "severity":      record.Level.String(),
        "message":       record.Message,
        "attributes":    make(map[string]any),
    }
    
    // 添加 Trace 上下文
    if span := trace.SpanFromContext(ctx); span.SpanContext().IsValid() {
        obj["trace_id"] = span.SpanContext().TraceID().String()
        obj["span_id"] = span.SpanContext().SpanID().String()
    }
    
    // 添加属性
    record.Attrs(func(attr slog.Attr) bool {
        obj["attributes"].(map[string]any)[attr.Key] = attr.Value.Any()
        return true
    })
    
    // 编码并写入
    encoder := json.NewEncoder(h.w)
    return encoder.Encode(obj)
}

// 输出示例
// {
//   "timestamp": "2025-10-09T10:30:45.123456789Z",
//   "severity": "INFO",
//   "message": "User logged in",
//   "trace_id": "4bf92f3577b34da6a3ce929d0e0e4736",
//   "span_id": "00f067aa0ba902b7",
//   "attributes": {
//     "user.id": 12345,
//     "user.name": "john"
//   }
// }
```

### 5.2 自定义 JSON 格式

```go
type CustomJSONFormat struct {
    TimeFormat    string
    IncludeSource bool
    PrettyPrint   bool
}

func (f *CustomJSONFormat) Format(record slog.Record, traceCtx trace.SpanContext) ([]byte, error) {
    obj := map[string]any{
        "@timestamp": record.Time.Format(f.TimeFormat),
        "level":      record.Level.String(),
        "msg":        record.Message,
    }
    
    // Trace 上下文
    if traceCtx.IsValid() {
        obj["trace"] = map[string]string{
            "id":   traceCtx.TraceID().String(),
            "span": traceCtx.SpanID().String(),
        }
    }
    
    // 属性
    attrs := make(map[string]any)
    record.Attrs(func(attr slog.Attr) bool {
        attrs[attr.Key] = attr.Value.Any()
        return true
    })
    obj["fields"] = attrs
    
    // 源信息
    if f.IncludeSource && record.PC != 0 {
        fs := runtime.CallersFrames([]uintptr{record.PC})
        frame, _ := fs.Next()
        obj["source"] = map[string]any{
            "file":     frame.File,
            "line":     frame.Line,
            "function": frame.Function,
        }
    }
    
    if f.PrettyPrint {
        return json.MarshalIndent(obj, "", "  ")
    }
    return json.Marshal(obj)
}
```

---

## 6. 高级模式

### 6.1 日志分组

```go
// Group 用于组织相关字段
slog.Info("Request completed",
    "duration_ms", 250,
    slog.Group("http",
        "method", "POST",
        "path", "/api/users",
        "status", 201,
    ),
    slog.Group("user",
        "id", 12345,
        "name", "john",
    ),
)

// JSON 输出：
// {
//   "duration_ms": 250,
//   "http": {
//     "method": "POST",
//     "path": "/api/users",
//     "status": 201
//   },
//   "user": {
//     "id": 12345,
//     "name": "john"
//   }
// }
```

### 6.2 LogValuer 接口

```go
// LogValuer 自定义类型的日志表示
type User struct {
    ID   int
    Name string
    Email string
}

func (u User) LogValue() slog.Value {
    return slog.GroupValue(
        slog.Int("id", u.ID),
        slog.String("name", u.Name),
        // 不记录敏感信息（如 email）
    )
}

// 使用
user := User{ID: 12345, Name: "john", Email: "john@example.com"}
slog.Info("User action", "user", user)
// 输出: {"user": {"id": 12345, "name": "john"}}
```

### 6.3 上下文传播

```go
// ContextLogger 从上下文中提取字段
type ContextLogger struct {
    *slog.Logger
}

func (l *ContextLogger) InfoContext(ctx context.Context, msg string, args ...any) {
    // 提取通用字段
    fields := extractCommonFields(ctx)
    
    // 合并用户提供的字段
    allArgs := append(fields, args...)
    
    l.Logger.InfoContext(ctx, msg, allArgs...)
}

func extractCommonFields(ctx context.Context) []any {
    var fields []any
    
    // Trace ID
    if span := trace.SpanFromContext(ctx); span.SpanContext().IsValid() {
        fields = append(fields,
            "trace.id", span.SpanContext().TraceID().String(),
            "span.id", span.SpanContext().SpanID().String(),
        )
    }
    
    // 请求 ID
    if requestID := ctx.Value("request_id"); requestID != nil {
        fields = append(fields, "request.id", requestID)
    }
    
    // 用户信息
    if userID := ctx.Value("user_id"); userID != nil {
        fields = append(fields, "user.id", userID)
    }
    
    return fields
}
```

---

## 7. 性能优化

### 7.1 预分配字段

```go
type PreallocLogger struct {
    baseAttrs []log.KeyValue
    logger    log.Logger
}

func NewPreallocLogger(logger log.Logger, baseAttrs ...log.KeyValue) *PreallocLogger {
    return &PreallocLogger{
        baseAttrs: baseAttrs,
        logger:    logger,
    }
}

func (l *PreallocLogger) Info(ctx context.Context, msg string, attrs ...log.KeyValue) {
    var record log.Record
    record.SetTimestamp(time.Now())
    record.SetBody(log.StringValue(msg))
    record.SetSeverityNumber(log.SeverityInfo)
    
    // 预分配的基础属性
    record.AddAttributes(l.baseAttrs...)
    
    // 额外属性
    record.AddAttributes(attrs...)
    
    l.logger.Emit(ctx, record)
}
```

### 7.2 对象池

```go
var recordPool = sync.Pool{
    New: func() any {
        return &log.Record{}
    },
}

func emitPooledLog(ctx context.Context, logger log.Logger, msg string) {
    record := recordPool.Get().(*log.Record)
    defer func() {
        *record = log.Record{}
        recordPool.Put(record)
    }()
    
    record.SetTimestamp(time.Now())
    record.SetBody(log.StringValue(msg))
    record.SetSeverityNumber(log.SeverityInfo)
    
    logger.Emit(ctx, *record)
}
```

---

## 8. 最佳实践

### 8.1 字段命名

```go
// ✅ 好的命名
slog.Info("Request",
    "http.method", "GET",        // 使用点分隔的命名空间
    "http.status_code", 200,     // 使用下划线连接单词
    "duration_ms", 150,          // 包含单位
)

// ❌ 避免的命名
slog.Info("Request",
    "Method", "GET",             // 避免大写开头
    "httpStatusCode", 200,       // 避免驼峰命名
    "time", 150,                 // 避免模糊的名称
)
```

### 8.2 敏感信息处理

```go
type SensitiveString string

func (s SensitiveString) LogValue() slog.Value {
    return slog.StringValue("***REDACTED***")
}

// 使用
password := SensitiveString("secret123")
slog.Info("User login", "password", password)
// 输出: {"password": "***REDACTED***"}
```

---

## 9. 完整示例

### 9.1 企业级结构化日志

```go
package main

import (
    "context"
    "log/slog"
    "os"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlplog/otlploggrpc"
    sdklog "go.opentelemetry.io/otel/sdk/log"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

func main() {
    // 创建 OTLP 导出器
    exporter, _ := otlploggrpc.New(
        context.Background(),
        otlploggrpc.WithEndpoint("localhost:4317"),
        otlploggrpc.WithInsecure(),
    )
    
    // 创建资源
    res, _ := resource.New(
        context.Background(),
        resource.WithAttributes(
            semconv.ServiceName("myapp"),
            semconv.ServiceVersion("1.0.0"),
        ),
    )
    
    // 创建提供者
    provider := sdklog.NewLoggerProvider(
        sdklog.WithResource(res),
        sdklog.WithProcessor(sdklog.NewBatchProcessor(exporter)),
    )
    defer provider.Shutdown(context.Background())
    
    // 创建结构化日志处理器
    handler := NewStructuredOTelHandler(provider, slog.LevelInfo)
    logger := slog.New(handler)
    slog.SetDefault(logger)
    
    // 使用结构化日志
    logger.Info("Application started",
        "version", "1.0.0",
        "pid", os.Getpid(),
        slog.Group("config",
            "port", 8080,
            "debug", false,
        ),
    )
}
```

---

## 10. 参考资料

1. **OpenTelemetry Logs Specification**  
   <https://opentelemetry.io/docs/specs/otel/logs/>

2. **Go log/slog Package**  
   <https://pkg.go.dev/log/slog>

3. **Semantic Conventions for Logs**  
   <https://opentelemetry.io/docs/specs/semconv/general/logs/>

---

**文档版本**: v1.0.0  
**最后更新**: 2025-10-09  
**Go 版本**: 1.25.1  
**OpenTelemetry**: v1.32.0
