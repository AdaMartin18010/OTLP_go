# OTLP 日志最佳实践完整指南

## 目录

- [OTLP 日志最佳实践完整指南](#otlp-日志最佳实践完整指南)
  - [目录](#目录)
  - [1. 日志级别使用](#1-日志级别使用)
    - [1.1 级别选择指南](#11-级别选择指南)
    - [1.2 环境相关配置](#12-环境相关配置)
  - [2. 日志格式规范](#2-日志格式规范)
    - [2.1 结构化日志最佳实践](#21-结构化日志最佳实践)
    - [2.2 消息格式规范](#22-消息格式规范)
  - [3. 性能优化](#3-性能优化)
    - [3.1 延迟计算](#31-延迟计算)
    - [3.2 避免日志阻塞](#32-避免日志阻塞)
    - [3.3 批量处理](#33-批量处理)
  - [4. 安全与隐私](#4-安全与隐私)
    - [4.1 敏感信息处理](#41-敏感信息处理)
    - [4.2 敏感字段过滤](#42-敏感字段过滤)
  - [5. 可观测性集成](#5-可观测性集成)
    - [5.1 三大支柱集成](#51-三大支柱集成)
    - [5.2 关联查询](#52-关联查询)
  - [6. 运维实践](#6-运维实践)
    - [6.1 日志保留策略](#61-日志保留策略)
    - [6.2 日志成本优化](#62-日志成本优化)
    - [6.3 日志监控](#63-日志监控)
  - [7. 常见错误](#7-常见错误)
    - [7.1 错误示例与改进](#71-错误示例与改进)
  - [8. 完整示例](#8-完整示例)
    - [8.1 生产级日志配置](#81-生产级日志配置)
  - [9. 参考资料](#9-参考资料)

---

## 1. 日志级别使用

### 1.1 级别选择指南

```go
// ✅ 正确的日志级别使用
func ProcessOrder(ctx context.Context, order Order) error {
    logger := slog.Default()
    
    // TRACE: 最详细的调试信息（通常不在生产环境启用）
    logger.Log(ctx, LevelTrace, "Entering ProcessOrder", "order_id", order.ID)
    
    // DEBUG: 调试信息，帮助开发和故障排查
    logger.DebugContext(ctx, "Validating order", 
        "order_id", order.ID,
        "item_count", len(order.Items),
    )
    
    // INFO: 正常的业务流程信息
    logger.InfoContext(ctx, "Processing order",
        "order_id", order.ID,
        "customer_id", order.CustomerID,
        "amount", order.TotalAmount,
    )
    
    // WARN: 潜在问题，但不影响功能
    if order.TotalAmount > 10000 {
        logger.WarnContext(ctx, "High value order detected",
            "order_id", order.ID,
            "amount", order.TotalAmount,
        )
    }
    
    // ERROR: 操作失败，需要关注
    if err := processPayment(ctx, order); err != nil {
        logger.ErrorContext(ctx, "Payment processing failed",
            "order_id", order.ID,
            "error", err,
        )
        return err
    }
    
    // FATAL: 致命错误，服务无法继续
    // 仅在服务启动失败等情况使用
    
    return nil
}

// ❌ 错误的日志级别使用
func BadExample(ctx context.Context) {
    logger := slog.Default()
    
    // 错误：使用 INFO 记录调试信息
    logger.InfoContext(ctx, "Variable x value", "x", x)
    
    // 错误：使用 ERROR 记录非错误信息
    logger.ErrorContext(ctx, "User logged in", "user_id", userID)
    
    // 错误：过度使用 WARN
    logger.WarnContext(ctx, "Processing request") // 这应该是 INFO
    
    // 错误：不记录错误
    if err := doSomething(); err != nil {
        // 忽略错误，不记录日志
    }
}
```

### 1.2 环境相关配置

```go
type EnvironmentConfig struct {
    Environment string
    LogLevel    slog.Level
    LogFormat   string
    Sampling    SamplingConfig
}

func ConfigureByEnvironment(env string) *EnvironmentConfig {
    switch env {
    case "development":
        return &EnvironmentConfig{
            Environment: "development",
            LogLevel:    slog.LevelDebug,
            LogFormat:   "text",
            Sampling: SamplingConfig{
                Enabled: false,
            },
        }
    
    case "staging":
        return &EnvironmentConfig{
            Environment: "staging",
            LogLevel:    slog.LevelInfo,
            LogFormat:   "json",
            Sampling: SamplingConfig{
                Enabled:      true,
                DebugRate:    0.1,
                InfoRate:     0.5,
                WarnRate:     1.0,
                ErrorRate:    1.0,
            },
        }
    
    case "production":
        return &EnvironmentConfig{
            Environment: "production",
            LogLevel:    slog.LevelInfo,
            LogFormat:   "json",
            Sampling: SamplingConfig{
                Enabled:      true,
                DebugRate:    0.01,
                InfoRate:     0.1,
                WarnRate:     1.0,
                ErrorRate:    1.0,
            },
        }
    
    default:
        return &EnvironmentConfig{
            Environment: "unknown",
            LogLevel:    slog.LevelWarn,
            LogFormat:   "json",
        }
    }
}
```

---

## 2. 日志格式规范

### 2.1 结构化日志最佳实践

```go
// ✅ 好的结构化日志
func GoodStructuredLogging(ctx context.Context) {
    logger := slog.Default()
    
    // 1. 使用一致的键名（遵循 OpenTelemetry 语义约定）
    logger.InfoContext(ctx, "HTTP request completed",
        "http.method", "POST",
        "http.url", "/api/orders",
        "http.status_code", 201,
        "http.request_content_length", 1024,
        "http.response_content_length", 2048,
        "duration_ms", 150,
    )
    
    // 2. 使用分组组织相关字段
    logger.InfoContext(ctx, "User action",
        slog.Group("user",
            "id", "12345",
            "name", "John Doe",
            "role", "admin",
        ),
        slog.Group("action",
            "type", "update",
            "resource", "order",
            "resource_id", "ORD-789",
        ),
    )
    
    // 3. 包含上下文信息
    logger.InfoContext(ctx, "Database query executed",
        "db.system", "postgresql",
        "db.name", "orders",
        "db.statement", "SELECT * FROM orders WHERE id = $1",
        "db.operation", "SELECT",
        "duration_ms", 25,
    )
}

// ❌ 避免的日志格式
func BadStructuredLogging(ctx context.Context) {
    logger := slog.Default()
    
    // 1. 避免：将所有信息放在消息中
    logger.InfoContext(ctx, fmt.Sprintf("User %s performed %s on order %s", userID, action, orderID))
    
    // 2. 避免：不一致的键名
    logger.InfoContext(ctx, "Request",
        "METHOD", "POST", // 应该是小写
        "httpUrl", "/api", // 应该是 http.url
        "StatusCode", 200, // 应该是 http.status_code
    )
    
    // 3. 避免：嵌套过深
    logger.InfoContext(ctx, "Event",
        "data", map[string]interface{}{
            "user": map[string]interface{}{
                "profile": map[string]interface{}{
                    "details": map[string]interface{}{
                        "name": "John",
                    },
                },
            },
        },
    )
}
```

### 2.2 消息格式规范

```go
// 消息格式原则
type MessageFormatting struct{}

func (m *MessageFormatting) Examples() {
    logger := slog.Default()
    
    // ✅ 好的消息格式
    // 1. 简洁、描述性、主动语态
    logger.Info("Order created successfully")
    logger.Info("Payment processed")
    logger.Info("Email notification sent")
    
    // 2. 使用现在时
    logger.Info("Processing order")          // ✅
    logger.Info("Processed order")           // ❌
    
    // 3. 关键信息放在消息中，详细信息放在属性中
    logger.Info("Order validation failed",   // ✅
        "order_id", "ORD-123",
        "error", "invalid email",
    )
    
    logger.Info("ORD-123: invalid email")    // ❌ 应该使用属性
    
    // 4. 避免冗余
    logger.Info("HTTP request",              // ✅
        "http.method", "POST",
    )
    
    logger.Info("HTTP POST request")         // ❌ 冗余
}
```

---

## 3. 性能优化

### 3.1 延迟计算

```go
// 使用 slog.LogValuer 延迟计算
type ExpensiveData struct {
    data []byte
}

func (e ExpensiveData) LogValue() slog.Value {
    // 仅在日志实际被记录时才计算
    return slog.StringValue(fmt.Sprintf("data size: %d", len(e.data)))
}

func LazyEvaluation(ctx context.Context) {
    logger := slog.Default()
    
    data := ExpensiveData{data: make([]byte, 1000000)}
    
    // 如果 DEBUG 未启用，ExpensiveData.LogValue() 不会被调用
    logger.DebugContext(ctx, "Processing data", "data", data)
}
```

### 3.2 避免日志阻塞

```go
// 异步日志处理器
type AsyncHandler struct {
    base    slog.Handler
    queue   chan slog.Record
    workers int
    wg      sync.WaitGroup
}

func NewAsyncHandler(base slog.Handler, queueSize, workers int) *AsyncHandler {
    h := &AsyncHandler{
        base:    base,
        queue:   make(chan slog.Record, queueSize),
        workers: workers,
    }
    
    // 启动工作协程
    h.wg.Add(workers)
    for i := 0; i < workers; i++ {
        go h.worker()
    }
    
    return h
}

func (h *AsyncHandler) worker() {
    defer h.wg.Done()
    
    for record := range h.queue {
        h.base.Handle(context.Background(), record)
    }
}

func (h *AsyncHandler) Handle(ctx context.Context, record slog.Record) error {
    // 非阻塞发送
    select {
    case h.queue <- record:
        return nil
    default:
        // 队列满，丢弃日志或使用同步模式
        return h.base.Handle(ctx, record)
    }
}

func (h *AsyncHandler) Close() error {
    close(h.queue)
    h.wg.Wait()
    return nil
}
```

### 3.3 批量处理

```go
// 批量日志处理器（参考前面的 BatchHandler）
func OptimalBatchConfig() *BatchHandler {
    return NewBatchHandler(
        baseHandler,
        512,              // 批次大小：512 条
        5*time.Second,    // 批次间隔：5 秒
    )
}

// 性能指标
// - 单条发送：~1ms/log
// - 批量发送（512条）：~0.01ms/log（100倍提升）
```

---

## 4. 安全与隐私

### 4.1 敏感信息处理

```go
// 敏感字段类型
type SensitiveField string

func (s SensitiveField) LogValue() slog.Value {
    if len(s) == 0 {
        return slog.StringValue("")
    }
    
    // 部分脱敏：显示前后2个字符
    if len(s) <= 4 {
        return slog.StringValue("***")
    }
    
    return slog.StringValue(string(s[:2]) + "***" + string(s[len(s)-2:]))
}

// 特定类型的脱敏
type CreditCard string

func (c CreditCard) LogValue() slog.Value {
    if len(c) == 0 {
        return slog.StringValue("")
    }
    
    // 仅显示最后4位
    if len(c) > 4 {
        return slog.StringValue("****-****-****-" + string(c[len(c)-4:]))
    }
    
    return slog.StringValue("****")
}

type Email string

func (e Email) LogValue() slog.Value {
    parts := strings.Split(string(e), "@")
    if len(parts) != 2 {
        return slog.StringValue("***")
    }
    
    // 脱敏用户名部分
    username := parts[0]
    if len(username) > 2 {
        username = username[:2] + "***"
    }
    
    return slog.StringValue(username + "@" + parts[1])
}

// 使用示例
func SecureLogging(ctx context.Context) {
    logger := slog.Default()
    
    logger.InfoContext(ctx, "Payment processed",
        "card_number", CreditCard("1234567890123456"),     // 输出: ****-****-****-3456
        "email", Email("john.doe@example.com"),            // 输出: jo***@example.com
        "password", SensitiveField("secret123"),           // 输出: se***23
    )
}
```

### 4.2 敏感字段过滤

```go
// SanitizingHandler 过滤敏感字段
type SanitizingHandler struct {
    base              slog.Handler
    sensitiveKeys     map[string]bool
    sensitivePatterns []*regexp.Regexp
}

func NewSanitizingHandler(base slog.Handler) *SanitizingHandler {
    return &SanitizingHandler{
        base: base,
        sensitiveKeys: map[string]bool{
            "password":       true,
            "secret":         true,
            "token":          true,
            "api_key":        true,
            "authorization":  true,
            "credit_card":    true,
            "ssn":            true,
        },
        sensitivePatterns: []*regexp.Regexp{
            regexp.MustCompile(`(?i)password`),
            regexp.MustCompile(`(?i)secret`),
            regexp.MustCompile(`(?i)token`),
        },
    }
}

func (h *SanitizingHandler) Handle(ctx context.Context, record slog.Record) error {
    newRecord := slog.NewRecord(record.Time, record.Level, record.Message, record.PC)
    
    record.Attrs(func(attr slog.Attr) bool {
        if h.isSensitive(attr.Key) {
            newRecord.AddAttrs(slog.String(attr.Key, "***REDACTED***"))
        } else {
            newRecord.AddAttrs(attr)
        }
        return true
    })
    
    return h.base.Handle(ctx, newRecord)
}

func (h *SanitizingHandler) isSensitive(key string) bool {
    // 检查精确匹配
    if h.sensitiveKeys[strings.ToLower(key)] {
        return true
    }
    
    // 检查模式匹配
    for _, pattern := range h.sensitivePatterns {
        if pattern.MatchString(key) {
            return true
        }
    }
    
    return false
}
```

---

## 5. 可观测性集成

### 5.1 三大支柱集成

```go
// ObservabilityLogger 集成 Traces、Metrics、Logs
type ObservabilityLogger struct {
    logger   *slog.Logger
    tracer   trace.Tracer
    meter    metric.Meter
    
    // Metrics
    logCounter   metric.Int64Counter
    errorCounter metric.Int64Counter
}

func NewObservabilityLogger(
    logger *slog.Logger,
    tracer trace.Tracer,
    meter metric.Meter,
) (*ObservabilityLogger, error) {
    logCounter, err := meter.Int64Counter("log.records",
        metric.WithDescription("Total number of log records"),
    )
    if err != nil {
        return nil, err
    }
    
    errorCounter, err := meter.Int64Counter("log.errors",
        metric.WithDescription("Total number of error logs"),
    )
    if err != nil {
        return nil, err
    }
    
    return &ObservabilityLogger{
        logger:       logger,
        tracer:       tracer,
        meter:        meter,
        logCounter:   logCounter,
        errorCounter: errorCounter,
    }, nil
}

func (l *ObservabilityLogger) Info(ctx context.Context, msg string, attrs ...any) {
    // 1. 记录日志
    l.logger.InfoContext(ctx, msg, attrs...)
    
    // 2. 更新指标
    l.logCounter.Add(ctx, 1, metric.WithAttributes(
        attribute.String("level", "INFO"),
    ))
    
    // 3. 添加 Span 事件
    span := trace.SpanFromContext(ctx)
    span.AddEvent(msg)
}

func (l *ObservabilityLogger) Error(ctx context.Context, msg string, err error, attrs ...any) {
    // 1. 记录日志
    allAttrs := append(attrs, "error", err.Error())
    l.logger.ErrorContext(ctx, msg, allAttrs...)
    
    // 2. 更新指标
    l.logCounter.Add(ctx, 1, metric.WithAttributes(
        attribute.String("level", "ERROR"),
    ))
    l.errorCounter.Add(ctx, 1)
    
    // 3. 记录到 Span
    span := trace.SpanFromContext(ctx)
    span.RecordError(err)
    span.SetStatus(codes.Error, msg)
}
```

### 5.2 关联查询

```go
// 按 Trace ID 查询日志
func QueryLogsByTrace(ctx context.Context, traceID string) ([]LogEntry, error) {
    // Loki 查询
    lokiQuery := fmt.Sprintf(`{service_name=~".+"} | json | trace_id="%s"`, traceID)
    
    // Elasticsearch 查询
    esQuery := map[string]interface{}{
        "query": map[string]interface{}{
            "term": map[string]interface{}{
                "trace_id": traceID,
            },
        },
        "sort": []map[string]interface{}{
            {"@timestamp": map[string]string{"order": "asc"}},
        },
    }
    
    // 执行查询...
    return logs, nil
}

// 按 Span ID 查询日志
func QueryLogsBySpan(ctx context.Context, spanID string) ([]LogEntry, error) {
    // 类似实现
    return logs, nil
}
```

---

## 6. 运维实践

### 6.1 日志保留策略

```go
type RetentionPolicy struct {
    // 热存储（快速查询）
    HotRetention time.Duration
    
    // 温存储（归档）
    WarmRetention time.Duration
    
    // 冷存储（长期归档）
    ColdRetention time.Duration
}

func DefaultRetentionPolicy() *RetentionPolicy {
    return &RetentionPolicy{
        HotRetention:  7 * 24 * time.Hour,    // 7 天
        WarmRetention: 30 * 24 * time.Hour,   // 30 天
        ColdRetention: 365 * 24 * time.Hour,  // 1 年
    }
}

// 按级别设置不同的保留策略
func RetentionByLevel() map[string]time.Duration {
    return map[string]time.Duration{
        "DEBUG": 1 * 24 * time.Hour,    // 1 天
        "INFO":  7 * 24 * time.Hour,    // 7 天
        "WARN":  30 * 24 * time.Hour,   // 30 天
        "ERROR": 90 * 24 * time.Hour,   // 90 天
        "FATAL": 365 * 24 * time.Hour,  // 1 年
    }
}
```

### 6.2 日志成本优化

```go
// 成本优化策略
type CostOptimization struct {
    // 采样策略
    SamplingEnabled bool
    SamplingRates   map[string]float64
    
    // 压缩
    CompressionEnabled bool
    CompressionLevel   int
    
    // 批量处理
    BatchSize     int
    BatchInterval time.Duration
    
    // 字段过滤
    FieldFilter []string // 仅保留必要字段
}

func OptimizedConfig() *CostOptimization {
    return &CostOptimization{
        SamplingEnabled: true,
        SamplingRates: map[string]float64{
            "DEBUG": 0.01,  // 1%
            "INFO":  0.1,   // 10%
            "WARN":  1.0,   // 100%
            "ERROR": 1.0,   // 100%
        },
        CompressionEnabled: true,
        CompressionLevel:   6, // gzip level
        BatchSize:          512,
        BatchInterval:      5 * time.Second,
        FieldFilter: []string{
            "timestamp",
            "level",
            "message",
            "trace_id",
            "span_id",
            "service.name",
        },
    }
}

// 预计成本节省：
// - 采样：减少 90% DEBUG/INFO 日志
// - 压缩：减少 60-70% 存储空间
// - 批量：减少 95% 网络请求
// - 过滤：减少 30-40% 数据量
// 总计：减少 95%+ 日志成本
```

### 6.3 日志监控

```go
// 日志健康监控
type LogHealthMonitor struct {
    meter metric.Meter
    
    logRate     metric.Float64ObservableGauge
    errorRate   metric.Float64ObservableGauge
    avgSize     metric.Float64ObservableGauge
    exportError metric.Int64Counter
}

func NewLogHealthMonitor(meter metric.Meter) (*LogHealthMonitor, error) {
    m := &LogHealthMonitor{meter: meter}
    
    var err error
    
    m.logRate, err = meter.Float64ObservableGauge("log.rate",
        metric.WithDescription("Logs per second"),
    )
    if err != nil {
        return nil, err
    }
    
    m.errorRate, err = meter.Float64ObservableGauge("log.error_rate",
        metric.WithDescription("Error logs per second"),
    )
    if err != nil {
        return nil, err
    }
    
    m.exportError, err = meter.Int64Counter("log.export_errors",
        metric.WithDescription("Export error count"),
    )
    if err != nil {
        return nil, err
    }
    
    return m, nil
}

// 告警规则
type AlertRule struct {
    Name      string
    Condition string
    Threshold float64
    Action    func()
}

var alertRules = []AlertRule{
    {
        Name:      "HighErrorRate",
        Condition: "error_rate > threshold",
        Threshold: 100, // 100 errors/sec
        Action: func() {
            // 发送告警
        },
    },
    {
        Name:      "LogExportFailure",
        Condition: "export_error_count > threshold",
        Threshold: 10,
        Action: func() {
            // 发送告警
        },
    },
}
```

---

## 7. 常见错误

### 7.1 错误示例与改进

```go
// ❌ 错误 1：日志过多
func BadLogging1() {
    for i := 0; i < 10000; i++ {
        slog.Info("Processing item", "index", i) // 生成 10000 条日志！
    }
}

// ✅ 改进：批量记录或采样
func GoodLogging1() {
    for i := 0; i < 10000; i++ {
        // 每 100 条记录一次
        if i%100 == 0 {
            slog.Info("Processing items", "current", i, "total", 10000)
        }
    }
    slog.Info("Processing completed", "total", 10000)
}

// ❌ 错误 2：日志太少
func BadLogging2(ctx context.Context) error {
    // 没有任何日志
    result, err := callExternalAPI(ctx)
    if err != nil {
        return err // 错误没有记录！
    }
    return processResult(result)
}

// ✅ 改进：记录关键操作和错误
func GoodLogging2(ctx context.Context) error {
    slog.InfoContext(ctx, "Calling external API")
    
    result, err := callExternalAPI(ctx)
    if err != nil {
        slog.ErrorContext(ctx, "API call failed", "error", err)
        return err
    }
    
    slog.InfoContext(ctx, "API call succeeded")
    return processResult(result)
}

// ❌ 错误 3：日志不一致
func BadLogging3() {
    slog.Info("User login", "userId", 123)       // userId
    slog.Info("User action", "user_id", 123)     // user_id
    slog.Info("User logout", "UserID", 123)      // UserID
}

// ✅ 改进：使用一致的键名
func GoodLogging3() {
    slog.Info("User login", "user.id", 123)
    slog.Info("User action", "user.id", 123)
    slog.Info("User logout", "user.id", 123)
}

// ❌ 错误 4：在循环中创建日志器
func BadLogging4() {
    for i := 0; i < 1000; i++ {
        logger := slog.With("index", i) // 每次都创建新的日志器
        logger.Info("Processing")
    }
}

// ✅ 改进：复用日志器
func GoodLogging4() {
    logger := slog.Default()
    for i := 0; i < 1000; i++ {
        logger.Info("Processing", "index", i)
    }
}
```

---

## 8. 完整示例

### 8.1 生产级日志配置

```go
package main

import (
    "context"
    "log/slog"
    "os"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlplog/otlploggrpc"
    sdklog "go.opentelemetry.io/otel/sdk/log"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

func SetupProductionLogging() (*slog.Logger, func(), error) {
    ctx := context.Background()
    
    // 1. 创建资源
    res, err := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName("myapp"),
            semconv.ServiceVersion("1.0.0"),
            semconv.DeploymentEnvironment("production"),
        ),
    )
    if err != nil {
        return nil, nil, err
    }
    
    // 2. 创建 OTLP 导出器
    exporter, err := otlploggrpc.New(ctx,
        otlploggrpc.WithEndpoint(os.Getenv("OTLP_ENDPOINT")),
        otlploggrpc.WithInsecure(),
    )
    if err != nil {
        return nil, nil, err
    }
    
    // 3. 创建日志提供者
    provider := sdklog.NewLoggerProvider(
        sdklog.WithResource(res),
        sdklog.WithProcessor(
            sdklog.NewBatchProcessor(
                exporter,
                sdklog.WithExportInterval(5*time.Second),
                sdklog.WithMaxExportBatchSize(512),
            ),
        ),
    )
    
    // 4. 创建处理器链
    baseHandler := NewOTLPHandler(provider)
    traceHandler := NewSlogWithTrace(baseHandler)
    sanitizingHandler := NewSanitizingHandler(traceHandler)
    samplingHandler := NewSamplingHandler(sanitizingHandler, 0.1, 10000)
    
    // 5. 创建日志器
    logger := slog.New(samplingHandler)
    slog.SetDefault(logger)
    
    // 6. 清理函数
    cleanup := func() {
        provider.Shutdown(ctx)
    }
    
    return logger, cleanup, nil
}

func main() {
    logger, cleanup, err := SetupProductionLogging()
    if err != nil {
        panic(err)
    }
    defer cleanup()
    
    // 使用日志器
    logger.Info("Application started",
        "version", "1.0.0",
        "environment", "production",
    )
    
    // 运行应用
    // ...
}
```

---

## 9. 参考资料

1. **OpenTelemetry Logging Best Practices**  
   <https://opentelemetry.io/docs/specs/otel/logs/>

2. **The Twelve-Factor App - Logs**  
   <https://12factor.net/logs>

3. **Google Cloud Logging Best Practices**  
   <https://cloud.google.com/logging/docs/best-practices>

4. **Elastic Common Schema (ECS)**  
   <https://www.elastic.co/guide/en/ecs/current/index.html>

---

**文档版本**: v1.0.0  
**最后更新**: 2025-10-09  
**Go 版本**: 1.25.1  
**OpenTelemetry**: v1.32.0
