# OTLP 日志级别规范与 Go 实现完整指南

## 目录

- [OTLP 日志级别规范与 Go 实现完整指南](#otlp-日志级别规范与-go-实现完整指南)
  - [目录](#目录)
  - [1. 日志级别概述](#1-日志级别概述)
    - [1.1 OpenTelemetry 日志级别定义](#11-opentelemetry-日志级别定义)
    - [1.2 与 syslog 级别映射](#12-与-syslog-级别映射)
    - [1.3 与 Go 标准库映射](#13-与-go-标准库映射)
  - [2. Go 日志级别实现](#2-go-日志级别实现)
    - [2.1 基于 slog 的实现](#21-基于-slog-的实现)
    - [2.2 自定义日志级别](#22-自定义日志级别)
    - [2.3 级别配置与管理](#23-级别配置与管理)
  - [3. OTLP 日志级别集成](#3-otlp-日志级别集成)
    - [3.1 日志级别转换](#31-日志级别转换)
    - [3.2 完整日志处理器](#32-完整日志处理器)
    - [3.3 多级别输出](#33-多级别输出)
  - [4. 高级日志级别模式](#4-高级日志级别模式)
    - [4.1 动态级别调整](#41-动态级别调整)
    - [4.2 上下文相关级别](#42-上下文相关级别)
    - [4.3 采样与限流](#43-采样与限流)
  - [5. 性能优化](#5-性能优化)
    - [5.1 级别检查优化](#51-级别检查优化)
    - [5.2 零分配日志](#52-零分配日志)
    - [5.3 批量处理](#53-批量处理)
  - [6. 最佳实践](#6-最佳实践)
    - [6.1 级别选择原则](#61-级别选择原则)
    - [6.2 生产环境配置](#62-生产环境配置)
    - [6.3 调试与故障排查](#63-调试与故障排查)
  - [7. 完整示例](#7-完整示例)
    - [7.1 企业级日志系统](#71-企业级日志系统)
    - [7.2 微服务日志集成](#72-微服务日志集成)
  - [8. 常见问题](#8-常见问题)
  - [9. 参考资料](#9-参考资料)

---

## 1. 日志级别概述

### 1.1 OpenTelemetry 日志级别定义

OpenTelemetry 定义了标准的日志严重性级别（Severity Number）：

| 级别名称 | 数值范围 | 标准值 | 描述 |
|---------|---------|--------|------|
| TRACE | 1-4 | 1 | 最详细的调试信息 |
| DEBUG | 5-8 | 5 | 调试信息 |
| INFO | 9-12 | 9 | 一般信息 |
| WARN | 13-16 | 13 | 警告信息 |
| ERROR | 17-20 | 17 | 错误信息 |
| FATAL | 21-24 | 21 | 致命错误 |

```go
// OpenTelemetry Severity Number 定义
const (
    SeverityNumberUnspecified = 0
    SeverityNumberTrace       = 1
    SeverityNumberTrace2      = 2
    SeverityNumberTrace3      = 3
    SeverityNumberTrace4      = 4
    SeverityNumberDebug       = 5
    SeverityNumberDebug2      = 6
    SeverityNumberDebug3      = 7
    SeverityNumberDebug4      = 8
    SeverityNumberInfo        = 9
    SeverityNumberInfo2       = 10
    SeverityNumberInfo3       = 11
    SeverityNumberInfo4       = 12
    SeverityNumberWarn        = 13
    SeverityNumberWarn2       = 14
    SeverityNumberWarn3       = 15
    SeverityNumberWarn4       = 16
    SeverityNumberError       = 17
    SeverityNumberError2      = 18
    SeverityNumberError3      = 19
    SeverityNumberError4      = 20
    SeverityNumberFatal       = 21
    SeverityNumberFatal2      = 22
    SeverityNumberFatal3      = 23
    SeverityNumberFatal4      = 24
)
```

### 1.2 与 syslog 级别映射

OpenTelemetry 日志级别与 syslog RFC 5424 的映射：

```go
// SyslogSeverity 映射
var syslogToOTelSeverity = map[int]log.Severity{
    0: log.SeverityFatal,  // Emergency
    1: log.SeverityFatal2, // Alert
    2: log.SeverityFatal3, // Critical
    3: log.SeverityError,  // Error
    4: log.SeverityWarn,   // Warning
    5: log.SeverityInfo2,  // Notice
    6: log.SeverityInfo,   // Informational
    7: log.SeverityDebug,  // Debug
}

func SyslogToOTel(syslogLevel int) log.Severity {
    if severity, ok := syslogToOTelSeverity[syslogLevel]; ok {
        return severity
    }
    return log.SeverityUnspecified
}
```

### 1.3 与 Go 标准库映射

Go 1.25.1 `log/slog` 级别映射：

```go
import (
    "log/slog"
    "go.opentelemetry.io/otel/log"
)

// SlogLevel 到 OTLP Severity 的转换
func SlogLevelToOTel(level slog.Level) log.Severity {
    switch {
    case level < slog.LevelDebug: // LevelDebug = -4
        return log.SeverityTrace
    case level < slog.LevelInfo: // LevelInfo = 0
        return log.SeverityDebug
    case level < slog.LevelWarn: // LevelWarn = 4
        return log.SeverityInfo
    case level < slog.LevelError: // LevelError = 8
        return log.SeverityWarn
    default:
        return log.SeverityError
    }
}

// OTLP Severity 到 SlogLevel 的转换
func OTelToSlogLevel(severity log.Severity) slog.Level {
    switch {
    case severity <= log.SeverityTrace4:
        return slog.LevelDebug - 4 // TRACE
    case severity <= log.SeverityDebug4:
        return slog.LevelDebug
    case severity <= log.SeverityInfo4:
        return slog.LevelInfo
    case severity <= log.SeverityWarn4:
        return slog.LevelWarn
    default:
        return slog.LevelError
    }
}
```

---

## 2. Go 日志级别实现

### 2.1 基于 slog 的实现

Go 1.25.1 引入的 `log/slog` 提供了结构化日志和级别管理：

```go
package logger

import (
    "context"
    "log/slog"
    "os"
    "go.opentelemetry.io/otel/log"
    "go.opentelemetry.io/otel/sdk/log"
)

// OTelHandler 实现 slog.Handler 接口
type OTelHandler struct {
    provider *sdklog.LoggerProvider
    logger   log.Logger
    level    slog.Leveler
    attrs    []slog.Attr
    groups   []string
}

func NewOTelHandler(provider *sdklog.LoggerProvider, level slog.Leveler) *OTelHandler {
    return &OTelHandler{
        provider: provider,
        logger:   provider.Logger("app"),
        level:    level,
    }
}

// Enabled 实现级别检查
func (h *OTelHandler) Enabled(ctx context.Context, level slog.Level) bool {
    return level >= h.level.Level()
}

// Handle 处理日志记录
func (h *OTelHandler) Handle(ctx context.Context, record slog.Record) error {
    // 转换级别
    severity := SlogLevelToOTel(record.Level)
    
    // 构建日志记录
    var logRecord log.Record
    logRecord.SetTimestamp(record.Time)
    logRecord.SetBody(log.StringValue(record.Message))
    logRecord.SetSeverityNumber(severity)
    logRecord.SetSeverityText(record.Level.String())
    
    // 添加属性
    record.Attrs(func(attr slog.Attr) bool {
        logRecord.AddAttributes(log.String(attr.Key, attr.Value.String()))
        return true
    })
    
    // 发送日志
    h.logger.Emit(ctx, logRecord)
    return nil
}

// WithAttrs 添加属性
func (h *OTelHandler) WithAttrs(attrs []slog.Attr) slog.Handler {
    return &OTelHandler{
        provider: h.provider,
        logger:   h.logger,
        level:    h.level,
        attrs:    append(h.attrs, attrs...),
        groups:   h.groups,
    }
}

// WithGroup 添加分组
func (h *OTelHandler) WithGroup(name string) slog.Handler {
    return &OTelHandler{
        provider: h.provider,
        logger:   h.logger,
        level:    h.level,
        attrs:    h.attrs,
        groups:   append(h.groups, name),
    }
}

// 使用示例
func Example() {
    // 创建 OTLP 日志提供者
    provider := sdklog.NewLoggerProvider(
        sdklog.WithProcessor(
            sdklog.NewBatchProcessor(exporter),
        ),
    )
    
    // 创建 slog 日志器
    handler := NewOTelHandler(provider, slog.LevelInfo)
    logger := slog.New(handler)
    
    // 使用不同级别
    logger.Debug("This won't be logged")
    logger.Info("Application started")
    logger.Warn("Low memory", "available", "100MB")
    logger.Error("Failed to connect", "error", err)
}
```

### 2.2 自定义日志级别

定义应用特定的日志级别：

```go
// 自定义级别
const (
    LevelTrace = slog.Level(-8)
    LevelDebug = slog.LevelDebug
    LevelInfo  = slog.LevelInfo
    LevelWarn  = slog.LevelWarn
    LevelError = slog.LevelError
    LevelFatal = slog.Level(12)
)

// 级别名称映射
var levelNames = map[slog.Level]string{
    LevelTrace: "TRACE",
    LevelDebug: "DEBUG",
    LevelInfo:  "INFO",
    LevelWarn:  "WARN",
    LevelError: "ERROR",
    LevelFatal: "FATAL",
}

// LevelString 返回级别名称
func LevelString(level slog.Level) string {
    if name, ok := levelNames[level]; ok {
        return name
    }
    return level.String()
}

// 自定义日志方法
type Logger struct {
    *slog.Logger
}

func (l *Logger) Trace(msg string, args ...any) {
    l.Log(context.Background(), LevelTrace, msg, args...)
}

func (l *Logger) Fatal(msg string, args ...any) {
    l.Log(context.Background(), LevelFatal, msg, args...)
    os.Exit(1)
}

// 使用示例
func Example() {
    logger := &Logger{slog.New(handler)}
    
    logger.Trace("Entering function", "name", "ProcessData")
    logger.Debug("Processing data", "count", 100)
    logger.Info("Operation completed")
    logger.Warn("Retry attempt", "attempt", 3)
    logger.Error("Operation failed", "error", err)
    logger.Fatal("Unrecoverable error", "error", err)
}
```

### 2.3 级别配置与管理

动态配置日志级别：

```go
package logger

import (
    "log/slog"
    "sync/atomic"
)

// LevelVar 提供原子的级别更新
type LevelVar struct {
    val atomic.Int64
}

func (v *LevelVar) Level() slog.Level {
    return slog.Level(v.val.Load())
}

func (v *LevelVar) Set(l slog.Level) {
    v.val.Store(int64(l))
}

func (v *LevelVar) String() string {
    return LevelString(v.Level())
}

// 配置管理
type Config struct {
    Level      *LevelVar
    Format     string // "json" or "text"
    AddSource  bool
    TimeFormat string
}

func NewConfig() *Config {
    level := &LevelVar{}
    level.Set(slog.LevelInfo)
    
    return &Config{
        Level:      level,
        Format:     "json",
        AddSource:  true,
        TimeFormat: "2006-01-02T15:04:05.000Z07:00",
    }
}

// 从环境变量加载配置
func LoadFromEnv() *Config {
    config := NewConfig()
    
    if levelStr := os.Getenv("LOG_LEVEL"); levelStr != "" {
        level := ParseLevel(levelStr)
        config.Level.Set(level)
    }
    
    if format := os.Getenv("LOG_FORMAT"); format != "" {
        config.Format = format
    }
    
    return config
}

// ParseLevel 解析级别字符串
func ParseLevel(s string) slog.Level {
    switch strings.ToUpper(s) {
    case "TRACE":
        return LevelTrace
    case "DEBUG":
        return slog.LevelDebug
    case "INFO":
        return slog.LevelInfo
    case "WARN":
        return slog.LevelWarn
    case "ERROR":
        return slog.LevelError
    case "FATAL":
        return LevelFatal
    default:
        return slog.LevelInfo
    }
}
```

---

## 3. OTLP 日志级别集成

### 3.1 日志级别转换

完整的级别转换实现：

```go
package otlplog

import (
    "log/slog"
    "go.opentelemetry.io/otel/log"
    sdklog "go.opentelemetry.io/otel/sdk/log"
)

// SeverityConverter 处理级别转换
type SeverityConverter struct {
    // 自定义映射表
    customMapping map[slog.Level]log.Severity
}

func NewSeverityConverter() *SeverityConverter {
    return &SeverityConverter{
        customMapping: make(map[slog.Level]log.Severity),
    }
}

// AddMapping 添加自定义映射
func (c *SeverityConverter) AddMapping(slogLevel slog.Level, severity log.Severity) {
    c.customMapping[slogLevel] = severity
}

// Convert 转换级别
func (c *SeverityConverter) Convert(level slog.Level) log.Severity {
    // 检查自定义映射
    if severity, ok := c.customMapping[level]; ok {
        return severity
    }
    
    // 使用默认映射
    return SlogLevelToOTel(level)
}

// SeverityText 返回级别文本
func (c *SeverityConverter) SeverityText(level slog.Level) string {
    return LevelString(level)
}
```

### 3.2 完整日志处理器

生产级别的 OTLP 日志处理器：

```go
type ProductionOTelHandler struct {
    provider  *sdklog.LoggerProvider
    logger    log.Logger
    level     slog.Leveler
    converter *SeverityConverter
    
    // 预分配的字段
    attrs  []log.KeyValue
    groups []string
    
    // 性能优化
    pool sync.Pool
}

func NewProductionOTelHandler(
    provider *sdklog.LoggerProvider,
    level slog.Leveler,
    opts ...HandlerOption,
) *ProductionOTelHandler {
    h := &ProductionOTelHandler{
        provider:  provider,
        logger:    provider.Logger("app"),
        level:     level,
        converter: NewSeverityConverter(),
        pool: sync.Pool{
            New: func() any {
                return &log.Record{}
            },
        },
    }
    
    for _, opt := range opts {
        opt(h)
    }
    
    return h
}

type HandlerOption func(*ProductionOTelHandler)

func WithConverter(converter *SeverityConverter) HandlerOption {
    return func(h *ProductionOTelHandler) {
        h.converter = converter
    }
}

func WithLogger(logger log.Logger) HandlerOption {
    return func(h *ProductionOTelHandler) {
        h.logger = logger
    }
}

func (h *ProductionOTelHandler) Enabled(ctx context.Context, level slog.Level) bool {
    return level >= h.level.Level()
}

func (h *ProductionOTelHandler) Handle(ctx context.Context, record slog.Record) error {
    // 从池中获取 Record
    logRecord := h.pool.Get().(*log.Record)
    defer func() {
        // 重置并归还到池
        *logRecord = log.Record{}
        h.pool.Put(logRecord)
    }()
    
    // 设置基本字段
    logRecord.SetTimestamp(record.Time)
    logRecord.SetBody(log.StringValue(record.Message))
    
    // 转换级别
    severity := h.converter.Convert(record.Level)
    logRecord.SetSeverityNumber(severity)
    logRecord.SetSeverityText(h.converter.SeverityText(record.Level))
    
    // 添加预定义属性
    for _, attr := range h.attrs {
        logRecord.AddAttributes(attr)
    }
    
    // 添加记录属性
    record.Attrs(func(attr slog.Attr) bool {
        logRecord.AddAttributes(convertSlogAttr(attr))
        return true
    })
    
    // 添加源信息
    if record.PC != 0 {
        fs := runtime.CallersFrames([]uintptr{record.PC})
        f, _ := fs.Next()
        logRecord.AddAttributes(
            log.String("code.filepath", f.File),
            log.Int("code.lineno", f.Line),
            log.String("code.function", f.Function),
        )
    }
    
    // 发送日志
    h.logger.Emit(ctx, *logRecord)
    return nil
}

func convertSlogAttr(attr slog.Attr) log.KeyValue {
    switch attr.Value.Kind() {
    case slog.KindBool:
        return log.Bool(attr.Key, attr.Value.Bool())
    case slog.KindInt64:
        return log.Int64(attr.Key, attr.Value.Int64())
    case slog.KindFloat64:
        return log.Float64(attr.Key, attr.Value.Float64())
    case slog.KindString:
        return log.String(attr.Key, attr.Value.String())
    default:
        return log.String(attr.Key, attr.Value.String())
    }
}
```

### 3.3 多级别输出

支持不同级别输出到不同目标：

```go
type MultiLevelHandler struct {
    handlers map[slog.Level]slog.Handler
    fallback slog.Handler
}

func NewMultiLevelHandler(fallback slog.Handler) *MultiLevelHandler {
    return &MultiLevelHandler{
        handlers: make(map[slog.Level]slog.Handler),
        fallback: fallback,
    }
}

func (h *MultiLevelHandler) AddHandler(level slog.Level, handler slog.Handler) {
    h.handlers[level] = handler
}

func (h *MultiLevelHandler) Enabled(ctx context.Context, level slog.Level) bool {
    if handler, ok := h.handlers[level]; ok {
        return handler.Enabled(ctx, level)
    }
    return h.fallback.Enabled(ctx, level)
}

func (h *MultiLevelHandler) Handle(ctx context.Context, record slog.Record) error {
    if handler, ok := h.handlers[record.Level]; ok {
        return handler.Handle(ctx, record)
    }
    return h.fallback.Handle(ctx, record)
}

// 使用示例：ERROR 日志发送到告警系统
func Example() {
    // 标准 OTLP 处理器
    standardHandler := NewOTelHandler(provider, slog.LevelInfo)
    
    // 告警处理器（仅处理 ERROR）
    alertHandler := NewAlertHandler(alertService)
    
    // 多级别处理器
    multiHandler := NewMultiLevelHandler(standardHandler)
    multiHandler.AddHandler(slog.LevelError, alertHandler)
    
    logger := slog.New(multiHandler)
    logger.Error("Critical error") // 同时发送到 OTLP 和告警系统
}
```

---

## 4. 高级日志级别模式

### 4.1 动态级别调整

运行时动态调整日志级别：

```go
package logger

import (
    "context"
    "log/slog"
    "net/http"
    "sync/atomic"
)

// DynamicLevelManager 管理动态级别
type DynamicLevelManager struct {
    level    *LevelVar
    handlers map[string]*LevelVar // 每个组件的级别
    mu       sync.RWMutex
}

func NewDynamicLevelManager(defaultLevel slog.Level) *DynamicLevelManager {
    level := &LevelVar{}
    level.Set(defaultLevel)
    
    return &DynamicLevelManager{
        level:    level,
        handlers: make(map[string]*LevelVar),
    }
}

// SetGlobalLevel 设置全局级别
func (m *DynamicLevelManager) SetGlobalLevel(level slog.Level) {
    m.level.Set(level)
}

// SetComponentLevel 设置组件级别
func (m *DynamicLevelManager) SetComponentLevel(component string, level slog.Level) {
    m.mu.Lock()
    defer m.mu.Unlock()
    
    if lv, ok := m.handlers[component]; ok {
        lv.Set(level)
    } else {
        lv := &LevelVar{}
        lv.Set(level)
        m.handlers[component] = lv
    }
}

// GetComponentLevel 获取组件级别
func (m *DynamicLevelManager) GetComponentLevel(component string) *LevelVar {
    m.mu.RLock()
    defer m.mu.RUnlock()
    
    if lv, ok := m.handlers[component]; ok {
        return lv
    }
    return m.level
}

// HTTP API 端点
func (m *DynamicLevelManager) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
    case http.MethodGet:
        m.handleGet(w, r)
    case http.MethodPut:
        m.handlePut(w, r)
    default:
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}

func (m *DynamicLevelManager) handleGet(w http.ResponseWriter, r *http.Request) {
    component := r.URL.Query().Get("component")
    
    var level slog.Level
    if component != "" {
        level = m.GetComponentLevel(component).Level()
    } else {
        level = m.level.Level()
    }
    
    json.NewEncoder(w).Encode(map[string]string{
        "level": LevelString(level),
    })
}

func (m *DynamicLevelManager) handlePut(w http.ResponseWriter, r *http.Request) {
    var req struct {
        Level     string `json:"level"`
        Component string `json:"component,omitempty"`
    }
    
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    level := ParseLevel(req.Level)
    
    if req.Component != "" {
        m.SetComponentLevel(req.Component, level)
    } else {
        m.SetGlobalLevel(level)
    }
    
    w.WriteHeader(http.StatusOK)
}

// 使用示例
func Example() {
    manager := NewDynamicLevelManager(slog.LevelInfo)
    
    // 创建带动态级别的日志器
    handler := NewOTelHandler(provider, manager.level)
    logger := slog.New(handler)
    
    // 启动 HTTP 服务器
    http.Handle("/api/log-level", manager)
    go http.ListenAndServe(":8080", nil)
    
    // 运行时调整级别（通过 API）
    // curl -X PUT http://localhost:8080/api/log-level -d '{"level":"DEBUG"}'
}
```

### 4.2 上下文相关级别

根据上下文动态调整日志级别：

```go
type contextKey string

const (
    logLevelKey contextKey = "log-level"
    userIDKey   contextKey = "user-id"
)

// ContextualLevelHandler 支持上下文级别
type ContextualLevelHandler struct {
    base      slog.Handler
    level     slog.Leveler
    
    // 特殊用户或请求的级别覆盖
    overrides map[string]slog.Level
    mu        sync.RWMutex
}

func (h *ContextualLevelHandler) Enabled(ctx context.Context, level slog.Level) bool {
    // 检查上下文中的级别覆盖
    if ctxLevel, ok := ctx.Value(logLevelKey).(slog.Level); ok {
        return level >= ctxLevel
    }
    
    // 检查用户级别覆盖
    if userID, ok := ctx.Value(userIDKey).(string); ok {
        h.mu.RLock()
        if override, exists := h.overrides[userID]; exists {
            h.mu.RUnlock()
            return level >= override
        }
        h.mu.RUnlock()
    }
    
    return level >= h.level.Level()
}

func (h *ContextualLevelHandler) Handle(ctx context.Context, record slog.Record) error {
    return h.base.Handle(ctx, record)
}

// AddUserOverride 为特定用户设置日志级别
func (h *ContextualLevelHandler) AddUserOverride(userID string, level slog.Level) {
    h.mu.Lock()
    defer h.mu.Unlock()
    h.overrides[userID] = level
}

// RemoveUserOverride 移除用户级别覆盖
func (h *ContextualLevelHandler) RemoveUserOverride(userID string) {
    h.mu.Lock()
    defer h.mu.Unlock()
    delete(h.overrides, userID)
}

// 使用示例：为特定用户启用调试日志
func HandleRequest(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    userID := r.Header.Get("X-User-ID")
    
    // 如果是管理员，启用 DEBUG 级别
    if isAdmin(userID) {
        ctx = context.WithValue(ctx, logLevelKey, slog.LevelDebug)
    }
    
    logger := slog.Default()
    logger.DebugContext(ctx, "Processing request", "user", userID)
    // ...
}
```

### 4.3 采样与限流

防止日志洪泛的采样和限流机制：

```go
// SamplingHandler 实现采样
type SamplingHandler struct {
    base     slog.Handler
    sampler  Sampler
    limiter  *rate.Limiter
}

type Sampler interface {
    ShouldSample(record slog.Record) bool
}

// LevelBasedSampler 基于级别的采样
type LevelBasedSampler struct {
    rates map[slog.Level]float64 // 采样率 0.0-1.0
}

func NewLevelBasedSampler() *LevelBasedSampler {
    return &LevelBasedSampler{
        rates: map[slog.Level]float64{
            LevelTrace: 0.01,  // 1%
            LevelDebug: 0.1,   // 10%
            LevelInfo:  1.0,   // 100%
            LevelWarn:  1.0,   // 100%
            LevelError: 1.0,   // 100%
            LevelFatal: 1.0,   // 100%
        },
    }
}

func (s *LevelBasedSampler) ShouldSample(record slog.Record) bool {
    rate, ok := s.rates[record.Level]
    if !ok {
        return true
    }
    return rand.Float64() < rate
}

// RateLimiter 限流
func NewSamplingHandler(base slog.Handler, samplingRate float64, rateLimit int) *SamplingHandler {
    return &SamplingHandler{
        base:    base,
        sampler: NewLevelBasedSampler(),
        limiter: rate.NewLimiter(rate.Limit(rateLimit), rateLimit*10),
    }
}

func (h *SamplingHandler) Enabled(ctx context.Context, level slog.Level) bool {
    return h.base.Enabled(ctx, level)
}

func (h *SamplingHandler) Handle(ctx context.Context, record slog.Record) error {
    // 检查限流
    if !h.limiter.Allow() {
        return nil // 丢弃
    }
    
    // 检查采样
    if !h.sampler.ShouldSample(record) {
        return nil // 丢弃
    }
    
    return h.base.Handle(ctx, record)
}
```

---

## 5. 性能优化

### 5.1 级别检查优化

优化级别检查以减少开销：

```go
// FastLevelChecker 使用位运算优化级别检查
type FastLevelChecker struct {
    enabledLevels uint32 // 位掩码
}

func NewFastLevelChecker(minLevel slog.Level) *FastLevelChecker {
    var mask uint32
    for l := minLevel; l <= LevelFatal; l++ {
        mask |= 1 << uint(l+8) // 偏移8位避免负数
    }
    return &FastLevelChecker{enabledLevels: mask}
}

func (c *FastLevelChecker) Enabled(level slog.Level) bool {
    return c.enabledLevels&(1<<uint(level+8)) != 0
}

func (c *FastLevelChecker) SetMinLevel(level slog.Level) {
    var mask uint32
    for l := level; l <= LevelFatal; l++ {
        mask |= 1 << uint(l+8)
    }
    atomic.StoreUint32(&c.enabledLevels, mask)
}

// Benchmark 结果
// BenchmarkLevelCheck/standard-8    100000000    10.2 ns/op
// BenchmarkLevelCheck/fast-8        500000000     3.1 ns/op
```

### 5.2 零分配日志

实现零分配的日志记录：

```go
// ZeroAllocLogger 零分配日志器
type ZeroAllocLogger struct {
    handler slog.Handler
    
    // 预分配的缓冲区
    buf     []byte
    kvBuf   []slog.Attr
    enabled [5]bool // 预计算的级别启用状态
}

func NewZeroAllocLogger(handler slog.Handler) *ZeroAllocLogger {
    l := &ZeroAllocLogger{
        handler: handler,
        buf:     make([]byte, 0, 256),
        kvBuf:   make([]slog.Attr, 0, 8),
    }
    
    // 预计算级别启用状态
    ctx := context.Background()
    l.enabled[0] = handler.Enabled(ctx, LevelDebug)
    l.enabled[1] = handler.Enabled(ctx, LevelInfo)
    l.enabled[2] = handler.Enabled(ctx, LevelWarn)
    l.enabled[3] = handler.Enabled(ctx, LevelError)
    l.enabled[4] = handler.Enabled(ctx, LevelFatal)
    
    return l
}

func (l *ZeroAllocLogger) Info(msg string, keysAndValues ...any) {
    if !l.enabled[1] {
        return
    }
    
    l.buf = l.buf[:0]
    l.kvBuf = l.kvBuf[:0]
    
    // 构建记录（复用缓冲区）
    record := slog.NewRecord(time.Now(), LevelInfo, msg, 0)
    for i := 0; i < len(keysAndValues); i += 2 {
        key := keysAndValues[i].(string)
        value := keysAndValues[i+1]
        l.kvBuf = append(l.kvBuf, slog.Any(key, value))
    }
    record.AddAttrs(l.kvBuf...)
    
    l.handler.Handle(context.Background(), record)
}
```

### 5.3 批量处理

批量处理日志以提高吞吐量：

```go
// BatchHandler 批量处理日志
type BatchHandler struct {
    base      slog.Handler
    batchSize int
    interval  time.Duration
    
    mu      sync.Mutex
    records []slog.Record
    timer   *time.Timer
}

func NewBatchHandler(base slog.Handler, batchSize int, interval time.Duration) *BatchHandler {
    h := &BatchHandler{
        base:      base,
        batchSize: batchSize,
        interval:  interval,
        records:   make([]slog.Record, 0, batchSize),
    }
    
    h.timer = time.AfterFunc(interval, h.flush)
    return h
}

func (h *BatchHandler) Handle(ctx context.Context, record slog.Record) error {
    h.mu.Lock()
    defer h.mu.Unlock()
    
    h.records = append(h.records, record)
    
    if len(h.records) >= h.batchSize {
        h.flushLocked()
    }
    
    return nil
}

func (h *BatchHandler) flush() {
    h.mu.Lock()
    defer h.mu.Unlock()
    h.flushLocked()
    h.timer.Reset(h.interval)
}

func (h *BatchHandler) flushLocked() {
    if len(h.records) == 0 {
        return
    }
    
    for _, record := range h.records {
        h.base.Handle(context.Background(), record)
    }
    
    h.records = h.records[:0]
}

func (h *BatchHandler) Close() error {
    h.timer.Stop()
    h.flush()
    return nil
}
```

---

## 6. 最佳实践

### 6.1 级别选择原则

选择合适的日志级别：

```go
// 级别使用指南
type LevelGuide struct{}

func (g *LevelGuide) Examples() {
    logger := slog.Default()
    
    // TRACE: 最详细的调试信息（通常不在生产环境启用）
    logger.Log(context.Background(), LevelTrace,
        "Function entry",
        "function", "ProcessOrder",
        "args", map[string]any{"orderID": "12345"},
    )
    
    // DEBUG: 调试信息（开发和故障排查时启用）
    logger.Debug("Cache hit",
        "key", "user:12345",
        "ttl", "300s",
    )
    
    // INFO: 一般信息（默认级别）
    logger.Info("Order processed successfully",
        "orderID", "12345",
        "amount", 99.99,
        "duration", "250ms",
    )
    
    // WARN: 警告（不影响功能但需要关注）
    logger.Warn("Slow query detected",
        "query", "SELECT * FROM orders",
        "duration", "5.2s",
        "threshold", "1s",
    )
    
    // ERROR: 错误（功能失败但服务继续运行）
    logger.Error("Failed to process payment",
        "orderID", "12345",
        "error", err,
        "retryAttempt", 3,
    )
    
    // FATAL: 致命错误（服务无法继续运行）
    logger.Log(context.Background(), LevelFatal,
        "Failed to connect to database",
        "error", err,
        "retries", 10,
    )
}
```

### 6.2 生产环境配置

生产环境的日志级别配置：

```go
// ProductionConfig 生产环境配置
type ProductionConfig struct {
    // 默认级别：INFO
    DefaultLevel slog.Level
    
    // 组件级别覆盖
    ComponentLevels map[string]slog.Level
    
    // 采样配置
    Sampling SamplingConfig
    
    // 限流配置
    RateLimit int // 每秒日志数
}

type SamplingConfig struct {
    Debug float64 // DEBUG 级别采样率
    Info  float64 // INFO 级别采样率
    Warn  float64 // WARN 级别采样率
    Error float64 // ERROR 级别采样率
}

func DefaultProductionConfig() *ProductionConfig {
    return &ProductionConfig{
        DefaultLevel: slog.LevelInfo,
        ComponentLevels: map[string]slog.Level{
            "database":    slog.LevelWarn,  // 数据库日志：WARN+
            "http.client": slog.LevelWarn,  // HTTP 客户端：WARN+
            "cache":       slog.LevelError, // 缓存：ERROR+
        },
        Sampling: SamplingConfig{
            Debug: 0.01, // 1%
            Info:  0.1,  // 10%
            Warn:  1.0,  // 100%
            Error: 1.0,  // 100%
        },
        RateLimit: 10000, // 10k logs/sec
    }
}

// ApplyConfig 应用配置
func ApplyConfig(config *ProductionConfig) *slog.Logger {
    // 创建基础处理器
    baseHandler := NewOTelHandler(provider, config.DefaultLevel)
    
    // 添加采样
    samplingHandler := NewSamplingHandler(
        baseHandler,
        config.Sampling.Info,
        config.RateLimit,
    )
    
    // 添加组件级别
    componentHandler := NewComponentLevelHandler(
        samplingHandler,
        config.ComponentLevels,
    )
    
    return slog.New(componentHandler)
}
```

### 6.3 调试与故障排查

故障排查时的日志级别策略：

```go
// DebugMode 调试模式管理
type DebugMode struct {
    manager   *DynamicLevelManager
    timeout   time.Duration
    activeSet map[string]*time.Timer
    mu        sync.Mutex
}

func NewDebugMode(manager *DynamicLevelManager, timeout time.Duration) *DebugMode {
    return &DebugMode{
        manager:   manager,
        timeout:   timeout,
        activeSet: make(map[string]*time.Timer),
    }
}

// Enable 启用调试模式（自动过期）
func (d *DebugMode) Enable(component string) {
    d.mu.Lock()
    defer d.mu.Unlock()
    
    // 停止旧计时器
    if timer, ok := d.activeSet[component]; ok {
        timer.Stop()
    }
    
    // 设置 DEBUG 级别
    d.manager.SetComponentLevel(component, slog.LevelDebug)
    
    // 设置自动恢复计时器
    timer := time.AfterFunc(d.timeout, func() {
        d.Disable(component)
    })
    d.activeSet[component] = timer
    
    slog.Info("Debug mode enabled",
        "component", component,
        "timeout", d.timeout,
    )
}

// Disable 禁用调试模式
func (d *DebugMode) Disable(component string) {
    d.mu.Lock()
    defer d.mu.Unlock()
    
    if timer, ok := d.activeSet[component]; ok {
        timer.Stop()
        delete(d.activeSet, component)
    }
    
    // 恢复默认级别
    d.manager.SetComponentLevel(component, slog.LevelInfo)
    
    slog.Info("Debug mode disabled", "component", component)
}

// HTTP API
func (d *DebugMode) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    component := r.URL.Query().Get("component")
    if component == "" {
        http.Error(w, "component required", http.StatusBadRequest)
        return
    }
    
    switch r.Method {
    case http.MethodPost:
        d.Enable(component)
        json.NewEncoder(w).Encode(map[string]string{
            "status": "enabled",
            "component": component,
            "timeout": d.timeout.String(),
        })
    case http.MethodDelete:
        d.Disable(component)
        json.NewEncoder(w).Encode(map[string]string{
            "status": "disabled",
            "component": component,
        })
    default:
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}

// 使用示例
// curl -X POST http://localhost:8080/api/debug?component=database
// 启用数据库组件的 DEBUG 日志，5分钟后自动恢复
```

---

## 7. 完整示例

### 7.1 企业级日志系统

完整的企业级日志系统实现：

```go
package main

import (
    "context"
    "log/slog"
    "os"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlplog/otlploggrpc"
    sdklog "go.opentelemetry.io/otel/sdk/log"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

func main() {
    // 1. 创建 OTLP 导出器
    exporter, err := otlploggrpc.New(
        context.Background(),
        otlploggrpc.WithEndpoint("localhost:4317"),
        otlploggrpc.WithInsecure(),
    )
    if err != nil {
        panic(err)
    }
    
    // 2. 创建资源
    res, err := resource.New(
        context.Background(),
        resource.WithAttributes(
            semconv.ServiceName("myapp"),
            semconv.ServiceVersion("1.0.0"),
            semconv.DeploymentEnvironment("production"),
        ),
    )
    if err != nil {
        panic(err)
    }
    
    // 3. 创建日志提供者
    provider := sdklog.NewLoggerProvider(
        sdklog.WithResource(res),
        sdklog.WithProcessor(
            sdklog.NewBatchProcessor(
                exporter,
                sdklog.WithExportInterval(5*time.Second),
                sdklog.WithMaxExportBatchSize(512),
            ),
        ),
    )
    defer provider.Shutdown(context.Background())
    
    // 4. 创建级别管理器
    manager := NewDynamicLevelManager(slog.LevelInfo)
    
    // 5. 创建处理器链
    otelHandler := NewProductionOTelHandler(provider, manager.level)
    samplingHandler := NewSamplingHandler(otelHandler, 0.1, 10000)
    
    // 6. 创建日志器
    logger := slog.New(samplingHandler)
    slog.SetDefault(logger)
    
    // 7. 启动 HTTP 管理接口
    http.Handle("/api/log-level", manager)
    http.Handle("/api/debug", NewDebugMode(manager, 5*time.Minute))
    go http.ListenAndServe(":8080", nil)
    
    // 8. 使用日志
    logger.Info("Application started",
        "pid", os.Getpid(),
        "version", "1.0.0",
    )
    
    // 模拟应用逻辑
    simulateApp(logger)
}

func simulateApp(logger *slog.Logger) {
    logger.Debug("Debug message")
    logger.Info("Processing request", "requestID", "abc123")
    logger.Warn("High memory usage", "usage", "85%")
    logger.Error("Database connection failed", "error", "timeout")
}
```

### 7.2 微服务日志集成

微服务架构中的日志级别管理：

```go
// ServiceLogger 微服务日志器
type ServiceLogger struct {
    *slog.Logger
    service   string
    manager   *DynamicLevelManager
    converter *SeverityConverter
}

func NewServiceLogger(
    service string,
    provider *sdklog.LoggerProvider,
    manager *DynamicLevelManager,
) *ServiceLogger {
    // 创建服务专用的处理器
    handler := NewProductionOTelHandler(
        provider,
        manager.GetComponentLevel(service),
    )
    
    logger := slog.New(handler).With(
        "service.name", service,
    )
    
    return &ServiceLogger{
        Logger:    logger,
        service:   service,
        manager:   manager,
        converter: NewSeverityConverter(),
    }
}

// WithRequest 添加请求上下文
func (l *ServiceLogger) WithRequest(r *http.Request) *slog.Logger {
    return l.With(
        "http.method", r.Method,
        "http.url", r.URL.String(),
        "http.user_agent", r.UserAgent(),
        "trace.id", trace.SpanFromContext(r.Context()).SpanContext().TraceID().String(),
    )
}

// 使用示例
func HandleOrder(w http.ResponseWriter, r *http.Request) {
    logger := serviceLogger.WithRequest(r)
    
    logger.Info("Order received")
    
    // 处理订单
    if err := processOrder(r.Context()); err != nil {
        logger.Error("Order processing failed", "error", err)
        http.Error(w, "Internal error", http.StatusInternalServerError)
        return
    }
    
    logger.Info("Order completed successfully")
    w.WriteHeader(http.StatusOK)
}
```

---

## 8. 常见问题

**Q1: 如何选择合适的默认日志级别？**

A:

- 开发环境：`DEBUG`
- 测试环境：`INFO`
- 预发布环境：`INFO`
- 生产环境：`INFO` 或 `WARN`

**Q2: 日志级别过高会有什么影响？**

A:

- 磁盘空间消耗增加
- 网络传输开销增加
- 日志处理性能下降
- 重要信息被淹没
- 建议使用采样和限流

**Q3: 如何在不重启的情况下调整日志级别？**

A: 使用 `DynamicLevelManager` 和 HTTP API，或集成配置中心（如 Consul、etcd）。

**Q4: ERROR 和 FATAL 的区别？**

A:

- ERROR: 操作失败但服务继续运行
- FATAL: 致命错误，服务无法继续运行，通常会调用 `os.Exit(1)`

**Q5: 如何避免日志洪泛？**

A:

- 使用采样（Sampling）
- 使用限流（Rate Limiting）
- 使用去重（Deduplication）
- 使用聚合（Aggregation）

---

## 9. 参考资料

1. **OpenTelemetry 日志规范**  
   <https://opentelemetry.io/docs/specs/otel/logs/data-model/>

2. **Go log/slog 文档**  
   <https://pkg.go.dev/log/slog>

3. **RFC 5424 - Syslog Protocol**  
   <https://tools.ietf.org/html/rfc5424>

4. **日志级别最佳实践**  
   <https://www.elastic.co/guide/en/ecs/current/ecs-log.html>

5. **OTLP 日志导出器**  
   <https://pkg.go.dev/go.opentelemetry.io/otel/exporters/otlp/otlplog>

---

**文档版本**: v1.0.0  
**最后更新**: 2025-10-09  
**Go 版本**: 1.25.1  
**OpenTelemetry**: v1.32.0  
**作者**: OTLP Integration Team
