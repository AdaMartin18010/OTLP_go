# OTLP 日志查询与 Go 实现完整指南

## 目录

- [OTLP 日志查询与 Go 实现完整指南](#otlp-日志查询与-go-实现完整指南)
  - [目录](#目录)
  - [1. 日志查询概述](#1-日志查询概述)
    - [1.1 查询后端](#11-查询后端)
    - [1.2 查询模式](#12-查询模式)
  - [2. Loki 集成](#2-loki-集成)
    - [2.1 LogQL 基础](#21-logql-基础)
    - [2.2 Go Loki 客户端](#22-go-loki-客户端)
    - [2.3 Loki 推送 API](#23-loki-推送-api)
  - [3. Elasticsearch 集成](#3-elasticsearch-集成)
    - [3.1 Elasticsearch DSL](#31-elasticsearch-dsl)
    - [3.2 Go Elasticsearch 客户端](#32-go-elasticsearch-客户端)
  - [4. Go 查询客户端](#4-go-查询客户端)
    - [4.1 统一查询接口](#41-统一查询接口)
    - [4.2 Loki 实现](#42-loki-实现)
    - [4.3 查询缓存](#43-查询缓存)
  - [5. 高级查询模式](#5-高级查询模式)
    - [5.1 分页查询](#51-分页查询)
    - [5.2 实时查询（Tail）](#52-实时查询tail)
  - [6. 性能优化](#6-性能优化)
    - [6.1 批量查询](#61-批量查询)
    - [6.2 查询优化](#62-查询优化)
  - [7. 完整示例](#7-完整示例)
    - [7.1 日志查询服务](#71-日志查询服务)
  - [8. 参考资料](#8-参考资料)

---

## 1. 日志查询概述

### 1.1 查询后端

常见的日志查询后端：

| 后端 | 特点 | 查询语言 | 适用场景 |
|------|------|----------|----------|
| **Loki** | 低成本、高效 | LogQL | Kubernetes、云原生 |
| **Elasticsearch** | 功能丰富 | Lucene、DSL | 复杂查询、全文搜索 |
| **ClickHouse** | 超高性能 | SQL | 大规模、OLAP |
| **BigQuery** | 云原生 | SQL | Google Cloud |

### 1.2 查询模式

```go
// 常见查询模式
type QueryPattern struct {
    // 按时间范围
    TimeRange struct {
        Start time.Time
        End   time.Time
    }
    
    // 按标签/属性
    Labels map[string]string
    
    // 按 Trace ID
    TraceID string
    
    // 全文搜索
    Query string
    
    // 聚合
    Aggregation string
}
```

---

## 2. Loki 集成

### 2.1 LogQL 基础

```bash
# 基本查询
{service_name="myapp"}

# 过滤
{service_name="myapp"} |= "error"

# 正则表达式
{service_name="myapp"} |~ "error|failed"

# JSON 解析
{service_name="myapp"} | json | level="ERROR"

# 按 Trace ID 查询
{service_name="myapp"} | json | trace_id="4bf92f3577b34da6"

# 聚合
sum(rate({service_name="myapp"} |= "error" [5m])) by (level)

# 统计
count_over_time({service_name="myapp"} [1h])
```

### 2.2 Go Loki 客户端

```go
import (
    "context"
    "fmt"
    "net/http"
    "net/url"
    "encoding/json"
    "io"
)

type LokiClient struct {
    baseURL string
    client  *http.Client
}

func NewLokiClient(baseURL string) *LokiClient {
    return &LokiClient{
        baseURL: baseURL,
        client:  &http.Client{Timeout: 30 * time.Second},
    }
}

// Query 执行 LogQL 查询
func (c *LokiClient) Query(ctx context.Context, query string, start, end time.Time) (*QueryResult, error) {
    u, _ := url.Parse(c.baseURL + "/loki/api/v1/query_range")
    
    params := url.Values{}
    params.Set("query", query)
    params.Set("start", fmt.Sprintf("%d", start.UnixNano()))
    params.Set("end", fmt.Sprintf("%d", end.UnixNano()))
    params.Set("limit", "1000")
    
    u.RawQuery = params.Encode()
    
    req, err := http.NewRequestWithContext(ctx, "GET", u.String(), nil)
    if err != nil {
        return nil, err
    }
    
    resp, err := c.client.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        body, _ := io.ReadAll(resp.Body)
        return nil, fmt.Errorf("loki error: %s", body)
    }
    
    var result QueryResult
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return nil, err
    }
    
    return &result, nil
}

type QueryResult struct {
    Status string `json:"status"`
    Data   struct {
        ResultType string   `json:"resultType"`
        Result     []Stream `json:"result"`
    } `json:"data"`
}

type Stream struct {
    Labels map[string]string `json:"stream"`
    Values [][]string        `json:"values"` // [timestamp, line]
}

// QueryByTraceID 按 Trace ID 查询日志
func (c *LokiClient) QueryByTraceID(ctx context.Context, traceID string, start, end time.Time) ([]LogEntry, error) {
    query := fmt.Sprintf(`{service_name=~".+"} | json | trace_id="%s"`, traceID)
    
    result, err := c.Query(ctx, query, start, end)
    if err != nil {
        return nil, err
    }
    
    var entries []LogEntry
    for _, stream := range result.Data.Result {
        for _, value := range stream.Values {
            timestamp, _ := strconv.ParseInt(value[0], 10, 64)
            line := value[1]
            
            var entry LogEntry
            if err := json.Unmarshal([]byte(line), &entry); err == nil {
                entry.Timestamp = time.Unix(0, timestamp).Format(time.RFC3339Nano)
                entries = append(entries, entry)
            }
        }
    }
    
    return entries, nil
}

// 使用示例
func main() {
    client := NewLokiClient("http://localhost:3100")
    
    // 查询最近1小时的错误日志
    start := time.Now().Add(-1 * time.Hour)
    end := time.Now()
    
    result, err := client.Query(
        context.Background(),
        `{service_name="myapp"} | json | level="ERROR"`,
        start,
        end,
    )
    if err != nil {
        log.Fatal(err)
    }
    
    // 打印结果
    for _, stream := range result.Data.Result {
        fmt.Printf("Labels: %v\n", stream.Labels)
        for _, value := range stream.Values {
            fmt.Printf("  %s: %s\n", value[0], value[1])
        }
    }
}
```

### 2.3 Loki 推送 API

```go
// Push 推送日志到 Loki
func (c *LokiClient) Push(ctx context.Context, streams []Stream) error {
    payload := struct {
        Streams []Stream `json:"streams"`
    }{
        Streams: streams,
    }
    
    data, err := json.Marshal(payload)
    if err != nil {
        return err
    }
    
    req, err := http.NewRequestWithContext(
        ctx,
        "POST",
        c.baseURL+"/loki/api/v1/push",
        bytes.NewReader(data),
    )
    if err != nil {
        return err
    }
    
    req.Header.Set("Content-Type", "application/json")
    
    resp, err := c.client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusNoContent {
        body, _ := io.ReadAll(resp.Body)
        return fmt.Errorf("push failed: %s", body)
    }
    
    return nil
}
```

---

## 3. Elasticsearch 集成

### 3.1 Elasticsearch DSL

```json
{
  "query": {
    "bool": {
      "must": [
        {
          "range": {
            "@timestamp": {
              "gte": "now-1h",
              "lte": "now"
            }
          }
        },
        {
          "term": {
            "service.name": "myapp"
          }
        },
        {
          "term": {
            "severity": "ERROR"
          }
        }
      ]
    }
  },
  "sort": [
    {
      "@timestamp": {
        "order": "desc"
      }
    }
  ],
  "size": 100
}
```

### 3.2 Go Elasticsearch 客户端

```go
import (
    "github.com/elastic/go-elasticsearch/v8"
    "github.com/elastic/go-elasticsearch/v8/esapi"
)

type ESClient struct {
    client *elasticsearch.Client
    index  string
}

func NewESClient(addresses []string, index string) (*ESClient, error) {
    cfg := elasticsearch.Config{
        Addresses: addresses,
    }
    
    client, err := elasticsearch.NewClient(cfg)
    if err != nil {
        return nil, err
    }
    
    return &ESClient{
        client: client,
        index:  index,
    }, nil
}

// Search 执行搜索
func (c *ESClient) Search(ctx context.Context, query map[string]interface{}) ([]LogEntry, error) {
    var buf bytes.Buffer
    if err := json.NewEncoder(&buf).Encode(query); err != nil {
        return nil, err
    }
    
    res, err := c.client.Search(
        c.client.Search.WithContext(ctx),
        c.client.Search.WithIndex(c.index),
        c.client.Search.WithBody(&buf),
    )
    if err != nil {
        return nil, err
    }
    defer res.Body.Close()
    
    if res.IsError() {
        return nil, fmt.Errorf("search error: %s", res.String())
    }
    
    var result struct {
        Hits struct {
            Hits []struct {
                Source LogEntry `json:"_source"`
            } `json:"hits"`
        } `json:"hits"`
    }
    
    if err := json.NewDecoder(res.Body).Decode(&result); err != nil {
        return nil, err
    }
    
    var entries []LogEntry
    for _, hit := range result.Hits.Hits {
        entries = append(entries, hit.Source)
    }
    
    return entries, nil
}

// SearchByTraceID 按 Trace ID 查询
func (c *ESClient) SearchByTraceID(ctx context.Context, traceID string) ([]LogEntry, error) {
    query := map[string]interface{}{
        "query": map[string]interface{}{
            "term": map[string]interface{}{
                "trace_id": traceID,
            },
        },
        "sort": []map[string]interface{}{
            {"@timestamp": map[string]string{"order": "asc"}},
        },
        "size": 10000,
    }
    
    return c.Search(ctx, query)
}

// AggregateErrors 聚合错误统计
func (c *ESClient) AggregateErrors(ctx context.Context, interval string) (map[string]int64, error) {
    query := map[string]interface{}{
        "size": 0,
        "query": map[string]interface{}{
            "bool": map[string]interface{}{
                "must": []map[string]interface{}{
                    {
                        "range": map[string]interface{}{
                            "@timestamp": map[string]string{
                                "gte": "now-1d",
                            },
                        },
                    },
                    {
                        "term": map[string]interface{}{
                            "severity": "ERROR",
                        },
                    },
                },
            },
        },
        "aggs": map[string]interface{}{
            "errors_over_time": map[string]interface{}{
                "date_histogram": map[string]interface{}{
                    "field":    "@timestamp",
                    "interval": interval,
                },
                "aggs": map[string]interface{}{
                    "by_service": map[string]interface{}{
                        "terms": map[string]interface{}{
                            "field": "service.name",
                        },
                    },
                },
            },
        },
    }
    
    var buf bytes.Buffer
    json.NewEncoder(&buf).Encode(query)
    
    res, err := c.client.Search(
        c.client.Search.WithContext(ctx),
        c.client.Search.WithIndex(c.index),
        c.client.Search.WithBody(&buf),
    )
    if err != nil {
        return nil, err
    }
    defer res.Body.Close()
    
    // 解析聚合结果
    var result struct {
        Aggregations struct {
            ErrorsOverTime struct {
                Buckets []struct {
                    Key      string `json:"key_as_string"`
                    DocCount int64  `json:"doc_count"`
                } `json:"buckets"`
            } `json:"errors_over_time"`
        } `json:"aggregations"`
    }
    
    json.NewDecoder(res.Body).Decode(&result)
    
    counts := make(map[string]int64)
    for _, bucket := range result.Aggregations.ErrorsOverTime.Buckets {
        counts[bucket.Key] = bucket.DocCount
    }
    
    return counts, nil
}
```

---

## 4. Go 查询客户端

### 4.1 统一查询接口

```go
// LogQueryClient 统一的日志查询接口
type LogQueryClient interface {
    Query(ctx context.Context, req QueryRequest) ([]LogEntry, error)
    QueryByTraceID(ctx context.Context, traceID string, timeRange TimeRange) ([]LogEntry, error)
    Aggregate(ctx context.Context, req AggregateRequest) (AggregateResult, error)
}

type QueryRequest struct {
    TimeRange   TimeRange
    Labels      map[string]string
    Query       string
    Limit       int
    OrderBy     string
    Ascending   bool
}

type TimeRange struct {
    Start time.Time
    End   time.Time
}

type AggregateRequest struct {
    TimeRange TimeRange
    Metric    string
    GroupBy   []string
    Interval  string
}

type AggregateResult struct {
    Buckets []Bucket
}

type Bucket struct {
    Key   string
    Count int64
    Value float64
}
```

### 4.2 Loki 实现

```go
type LokiQueryClient struct {
    client *LokiClient
}

func (c *LokiQueryClient) Query(ctx context.Context, req QueryRequest) ([]LogEntry, error) {
    // 构建 LogQL
    query := buildLogQL(req)
    
    result, err := c.client.Query(ctx, query, req.TimeRange.Start, req.TimeRange.End)
    if err != nil {
        return nil, err
    }
    
    return parseLogQLResult(result), nil
}

func buildLogQL(req QueryRequest) string {
    // 构建标签选择器
    var labels []string
    for k, v := range req.Labels {
        labels = append(labels, fmt.Sprintf(`%s="%s"`, k, v))
    }
    
    query := "{" + strings.Join(labels, ",") + "}"
    
    // 添加过滤
    if req.Query != "" {
        query += fmt.Sprintf(` |= "%s"`, req.Query)
    }
    
    // 添加 JSON 解析
    query += " | json"
    
    return query
}
```

### 4.3 查询缓存

```go
import (
    "github.com/patrickmn/go-cache"
)

type CachedQueryClient struct {
    client LogQueryClient
    cache  *cache.Cache
}

func NewCachedQueryClient(client LogQueryClient) *CachedQueryClient {
    return &CachedQueryClient{
        client: client,
        cache:  cache.New(5*time.Minute, 10*time.Minute),
    }
}

func (c *CachedQueryClient) Query(ctx context.Context, req QueryRequest) ([]LogEntry, error) {
    // 生成缓存键
    key := generateCacheKey(req)
    
    // 检查缓存
    if cached, found := c.cache.Get(key); found {
        return cached.([]LogEntry), nil
    }
    
    // 执行查询
    entries, err := c.client.Query(ctx, req)
    if err != nil {
        return nil, err
    }
    
    // 存入缓存
    c.cache.Set(key, entries, cache.DefaultExpiration)
    
    return entries, nil
}

func generateCacheKey(req QueryRequest) string {
    h := sha256.New()
    json.NewEncoder(h).Encode(req)
    return fmt.Sprintf("%x", h.Sum(nil))
}
```

---

## 5. 高级查询模式

### 5.1 分页查询

```go
type PagedQueryRequest struct {
    QueryRequest
    Page     int
    PageSize int
}

type PagedResult struct {
    Entries    []LogEntry
    TotalCount int
    TotalPages int
    Page       int
}

func (c *LokiQueryClient) PagedQuery(ctx context.Context, req PagedQueryRequest) (*PagedResult, error) {
    // 第一步：获取总数
    countQuery := buildCountQuery(req.QueryRequest)
    countResult, err := c.client.Query(ctx, countQuery, req.TimeRange.Start, req.TimeRange.End)
    if err != nil {
        return nil, err
    }
    
    totalCount := len(countResult.Data.Result)
    totalPages := (totalCount + req.PageSize - 1) / req.PageSize
    
    // 第二步：获取当前页数据
    offset := (req.Page - 1) * req.PageSize
    query := buildLogQL(req.QueryRequest) + fmt.Sprintf(" | limit %d | offset %d", req.PageSize, offset)
    
    result, err := c.client.Query(ctx, query, req.TimeRange.Start, req.TimeRange.End)
    if err != nil {
        return nil, err
    }
    
    return &PagedResult{
        Entries:    parseLogQLResult(result),
        TotalCount: totalCount,
        TotalPages: totalPages,
        Page:       req.Page,
    }, nil
}
```

### 5.2 实时查询（Tail）

```go
// TailLogs 实时追踪日志
func (c *LokiClient) TailLogs(ctx context.Context, query string, callback func(LogEntry)) error {
    u, _ := url.Parse(c.baseURL + "/loki/api/v1/tail")
    
    params := url.Values{}
    params.Set("query", query)
    params.Set("limit", "100")
    
    u.RawQuery = params.Encode()
    
    req, err := http.NewRequestWithContext(ctx, "GET", u.String(), nil)
    if err != nil {
        return err
    }
    
    req.Header.Set("Accept", "application/json")
    
    resp, err := c.client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    // 读取流式响应
    scanner := bufio.NewScanner(resp.Body)
    for scanner.Scan() {
        line := scanner.Text()
        
        var entry LogEntry
        if err := json.Unmarshal([]byte(line), &entry); err != nil {
            continue
        }
        
        callback(entry)
    }
    
    return scanner.Err()
}

// 使用示例
func main() {
    client := NewLokiClient("http://localhost:3100")
    
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
    defer cancel()
    
    err := client.TailLogs(ctx, `{service_name="myapp"} | json | level="ERROR"`, func(entry LogEntry) {
        fmt.Printf("[%s] %s: %s\n", entry.Timestamp, entry.Level, entry.Message)
    })
    
    if err != nil {
        log.Fatal(err)
    }
}
```

---

## 6. 性能优化

### 6.1 批量查询

```go
// BatchQuery 批量查询多个 Trace ID
func (c *LokiQueryClient) BatchQueryByTraceIDs(ctx context.Context, traceIDs []string, timeRange TimeRange) (map[string][]LogEntry, error) {
    results := make(map[string][]LogEntry)
    var mu sync.Mutex
    
    // 使用 errgroup 并发查询
    g, ctx := errgroup.WithContext(ctx)
    sem := make(chan struct{}, 10) // 限制并发数
    
    for _, traceID := range traceIDs {
        traceID := traceID // 捕获变量
        
        g.Go(func() error {
            sem <- struct{}{}        // 获取信号量
            defer func() { <-sem }() // 释放信号量
            
            entries, err := c.QueryByTraceID(ctx, traceID, timeRange)
            if err != nil {
                return err
            }
            
            mu.Lock()
            results[traceID] = entries
            mu.Unlock()
            
            return nil
        })
    }
    
    if err := g.Wait(); err != nil {
        return nil, err
    }
    
    return results, nil
}
```

### 6.2 查询优化

```go
// OptimizedQuery 优化的查询
func (c *LokiQueryClient) OptimizedQuery(ctx context.Context, req QueryRequest) ([]LogEntry, error) {
    // 1. 限制时间范围
    if req.TimeRange.End.Sub(req.TimeRange.Start) > 24*time.Hour {
        return nil, fmt.Errorf("time range too large, max 24 hours")
    }
    
    // 2. 限制结果数量
    if req.Limit == 0 || req.Limit > 5000 {
        req.Limit = 5000
    }
    
    // 3. 使用索引标签
    if len(req.Labels) == 0 {
        return nil, fmt.Errorf("at least one label required")
    }
    
    // 4. 执行查询
    return c.Query(ctx, req)
}
```

---

## 7. 完整示例

### 7.1 日志查询服务

```go
package main

import (
    "context"
    "encoding/json"
    "net/http"
    "time"
)

type LogQueryService struct {
    lokiClient *LokiClient
    esClient   *ESClient
}

func NewLogQueryService(lokiURL string, esAddresses []string) *LogQueryService {
    return &LogQueryService{
        lokiClient: NewLokiClient(lokiURL),
        esClient:   NewESClient(esAddresses, "logs-*"),
    }
}

// HTTP 处理器：按 Trace ID 查询
func (s *LogQueryService) HandleQueryByTraceID(w http.ResponseWriter, r *http.Request) {
    traceID := r.URL.Query().Get("trace_id")
    if traceID == "" {
        http.Error(w, "trace_id required", http.StatusBadRequest)
        return
    }
    
    start := time.Now().Add(-1 * time.Hour)
    end := time.Now()
    
    entries, err := s.lokiClient.QueryByTraceID(r.Context(), traceID, start, end)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]interface{}{
        "trace_id": traceID,
        "count":    len(entries),
        "logs":     entries,
    })
}

// HTTP 处理器：搜索日志
func (s *LogQueryService) HandleSearch(w http.ResponseWriter, r *http.Request) {
    var req QueryRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    entries, err := s.esClient.Search(r.Context(), buildESQuery(req))
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]interface{}{
        "count": len(entries),
        "logs":  entries,
    })
}

func main() {
    service := NewLogQueryService(
        "http://localhost:3100",
        []string{"http://localhost:9200"},
    )
    
    http.HandleFunc("/api/logs/trace", service.HandleQueryByTraceID)
    http.HandleFunc("/api/logs/search", service.HandleSearch)
    
    log.Printf("Log query service started on :8080")
    http.ListenAndServe(":8080", nil)
}
```

---

## 8. 参考资料

1. **Loki Documentation**  
   <https://grafana.com/docs/loki/>

2. **LogQL**  
   <https://grafana.com/docs/loki/latest/logql/>

3. **Elasticsearch Query DSL**  
   <https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html>

4. **Go Elasticsearch Client**  
   <https://github.com/elastic/go-elasticsearch>

---

**文档版本**: v1.0.0  
**最后更新**: 2025-10-09  
**Go 版本**: 1.25.1  
**OpenTelemetry**: v1.32.0
