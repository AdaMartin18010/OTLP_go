# 网络与连接追踪属性完整指南

> **文档版本**: v2.0.0  
> **最后更新**: 2025-10-09  
> **OpenTelemetry 版本**: v1.32.0  
> **Go 版本**: 1.25.1

## 目录

- [网络与连接追踪属性完整指南](#网络与连接追踪属性完整指南)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 网络语义约定](#11-网络语义约定)
    - [1.2 追踪层次](#12-追踪层次)
  - [2. 核心属性](#2-核心属性)
    - [2.1 网络传输属性](#21-网络传输属性)
    - [2.2 网络对端属性](#22-网络对端属性)
    - [2.3 网络连接属性](#23-网络连接属性)
  - [3. TCP 连接追踪](#3-tcp-连接追踪)
    - [3.1 基础 TCP 追踪](#31-基础-tcp-追踪)
    - [3.2 TCP 监听器追踪](#32-tcp-监听器追踪)
  - [4. UDP 通信追踪](#4-udp-通信追踪)
    - [4.1 UDP 客户端](#41-udp-客户端)
  - [5. TLS/SSL 追踪](#5-tlsssl-追踪)
    - [5.1 TLS 客户端](#51-tls-客户端)
    - [5.2 证书验证追踪](#52-证书验证追踪)
  - [6. DNS 解析追踪](#6-dns-解析追踪)
    - [6.1 DNS 查询追踪](#61-dns-查询追踪)
  - [7. 连接池追踪](#7-连接池追踪)
    - [7.1 通用连接池](#71-通用连接池)
  - [8. 网络性能监控](#8-网络性能监控)
    - [8.1 带宽监控](#81-带宽监控)
    - [8.2 延迟监控](#82-延迟监控)
  - [9. 完整实现](#9-完整实现)
  - [10. 最佳实践](#10-最佳实践)
    - [10.1 超时控制](#101-超时控制)
    - [10.2 连接健康检查](#102-连接健康检查)
    - [10.3 错误分类](#103-错误分类)
  - [总结](#总结)

---

## 1. 概述

### 1.1 网络语义约定

网络追踪记录底层网络连接和数据传输的详细信息。

**关键特征**:

- **Span Kind**: 通常为 `SPAN_KIND_INTERNAL`
- **命名规范**: `{network.protocol.name} {operation}`
- **示例**: `tcp connect`, `dns resolve`, `tls handshake`

### 1.2 追踪层次

```text
Application Layer (HTTP/gRPC)
         ↓
Transport Layer (TCP/UDP)
         ↓
 Network Layer (IP)
         ↓
   Link Layer
```

---

## 2. 核心属性

### 2.1 网络传输属性

| 属性 | 类型 | 示例 | 描述 |
|------|------|------|------|
| `network.transport` | string | `tcp`, `udp` | 传输协议 |
| `network.protocol.name` | string | `http`, `amqp` | 应用层协议名称 |
| `network.protocol.version` | string | `1.1`, `2` | 协议版本 |

### 2.2 网络对端属性

| 属性 | 类型 | 示例 | 描述 |
|------|------|------|------|
| `network.peer.address` | string | `192.168.1.10` | 对端 IP 地址 |
| `network.peer.port` | int | `8080` | 对端端口 |
| `network.local.address` | string | `10.0.0.5` | 本地 IP 地址 |
| `network.local.port` | int | `54321` | 本地端口 |

### 2.3 网络连接属性

| 属性 | 类型 | 示例 | 描述 |
|------|------|------|------|
| `network.connection.type` | string | `wifi`, `ethernet` | 连接类型 |
| `network.connection.subtype` | string | `LTE`, `5G` | 连接子类型 |
| `network.io.direction` | string | `transmit`, `receive` | IO 方向 |

---

## 3. TCP 连接追踪

### 3.1 基础 TCP 追踪

```go
package nettracing

import (
    "context"
    "net"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// TracedTCPDialer 包装 TCP 连接并提供追踪
type TracedTCPDialer struct {
    dialer *net.Dialer
    tracer trace.Tracer
}

// NewTracedTCPDialer 创建带追踪的 TCP 拨号器
func NewTracedTCPDialer() *TracedTCPDialer {
    return &TracedTCPDialer{
        dialer: &net.Dialer{
            Timeout:   30 * time.Second,
            KeepAlive: 30 * time.Second,
        },
        tracer: otel.Tracer("tcp-dialer"),
    }
}

// DialContext 建立 TCP 连接并追踪
func (d *TracedTCPDialer) DialContext(ctx context.Context, network, address string) (net.Conn, error) {
    ctx, span := d.tracer.Start(ctx, "tcp connect",
        trace.WithSpanKind(trace.SpanKindInternal),
        trace.WithAttributes(
            attribute.String("network.transport", "tcp"),
            attribute.String("server.address", address),
        ),
    )
    defer span.End()

    // 记录连接开始时间
    startTime := time.Now()
    span.AddEvent("connect_start")

    // 建立连接
    conn, err := d.dialer.DialContext(ctx, network, address)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return nil, err
    }

    // 记录连接完成
    duration := time.Since(startTime)
    span.AddEvent("connect_done", trace.WithAttributes(
        attribute.String("duration", duration.String()),
    ))

    // 提取本地和远程地址
    localAddr := conn.LocalAddr().(*net.TCPAddr)
    remoteAddr := conn.RemoteAddr().(*net.TCPAddr)

    span.SetAttributes(
        attribute.String("network.local.address", localAddr.IP.String()),
        attribute.Int("network.local.port", localAddr.Port),
        attribute.String("network.peer.address", remoteAddr.IP.String()),
        attribute.Int("network.peer.port", remoteAddr.Port),
    )

    span.SetStatus(codes.Ok, "")

    // 返回包装的连接
    return &tracedConn{
        Conn:   conn,
        tracer: d.tracer,
    }, nil
}

// tracedConn 包装 net.Conn 并追踪读写操作
type tracedConn struct {
    net.Conn
    tracer     trace.Tracer
    bytesRead  int64
    bytesWrite int64
}

func (c *tracedConn) Read(b []byte) (n int, err error) {
    n, err = c.Conn.Read(b)
    c.bytesRead += int64(n)
    return
}

func (c *tracedConn) Write(b []byte) (n int, err error) {
    n, err = c.Conn.Write(b)
    c.bytesWrite += int64(n)
    return
}

func (c *tracedConn) Close() error {
    // 创建关闭 Span
    ctx, span := c.tracer.Start(context.Background(), "tcp close",
        trace.WithSpanKind(trace.SpanKindInternal),
        trace.WithAttributes(
            attribute.String("network.transport", "tcp"),
            attribute.Int64("network.bytes_read", c.bytesRead),
            attribute.Int64("network.bytes_write", c.bytesWrite),
        ),
    )
    defer span.End()

    err := c.Conn.Close()
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }

    span.SetStatus(codes.Ok, "")
    return nil
}
```

### 3.2 TCP 监听器追踪

```go
// TracedTCPListener 包装 TCP 监听器并追踪
type TracedTCPListener struct {
    listener net.Listener
    tracer   trace.Tracer
}

// NewTracedTCPListener 创建带追踪的 TCP 监听器
func NewTracedTCPListener(address string) (*TracedTCPListener, error) {
    listener, err := net.Listen("tcp", address)
    if err != nil {
        return nil, err
    }

    return &TracedTCPListener{
        listener: listener,
        tracer:   otel.Tracer("tcp-listener"),
    }, nil
}

// Accept 接受连接并追踪
func (l *TracedTCPListener) Accept() (net.Conn, error) {
    ctx, span := l.tracer.Start(context.Background(), "tcp accept",
        trace.WithSpanKind(trace.SpanKindInternal),
        trace.WithAttributes(
            attribute.String("network.transport", "tcp"),
        ),
    )
    defer span.End()

    conn, err := l.listener.Accept()
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return nil, err
    }

    // 记录客户端信息
    remoteAddr := conn.RemoteAddr().(*net.TCPAddr)
    span.SetAttributes(
        attribute.String("client.address", remoteAddr.IP.String()),
        attribute.Int("client.port", remoteAddr.Port),
    )

    span.SetStatus(codes.Ok, "")

    return &tracedConn{
        Conn:   conn,
        tracer: l.tracer,
    }, nil
}

func (l *TracedTCPListener) Close() error {
    return l.listener.Close()
}

func (l *TracedTCPListener) Addr() net.Addr {
    return l.listener.Addr()
}
```

---

## 4. UDP 通信追踪

### 4.1 UDP 客户端

```go
// TracedUDPConn 包装 UDP 连接并追踪
type TracedUDPConn struct {
    conn   *net.UDPConn
    tracer trace.Tracer
}

// NewTracedUDPConn 创建带追踪的 UDP 连接
func NewTracedUDPConn(address string) (*TracedUDPConn, error) {
    addr, err := net.ResolveUDPAddr("udp", address)
    if err != nil {
        return nil, err
    }

    conn, err := net.DialUDP("udp", nil, addr)
    if err != nil {
        return nil, err
    }

    return &TracedUDPConn{
        conn:   conn,
        tracer: otel.Tracer("udp-client"),
    }, nil
}

// Write 发送 UDP 数据并追踪
func (c *TracedUDPConn) Write(ctx context.Context, data []byte) (int, error) {
    ctx, span := c.tracer.Start(ctx, "udp send",
        trace.WithSpanKind(trace.SpanKindInternal),
        trace.WithAttributes(
            attribute.String("network.transport", "udp"),
            attribute.Int("network.io.bytes", len(data)),
            attribute.String("network.io.direction", "transmit"),
        ),
    )
    defer span.End()

    n, err := c.conn.Write(data)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return n, err
    }

    span.SetStatus(codes.Ok, "")
    return n, nil
}

// Read 接收 UDP 数据并追踪
func (c *TracedUDPConn) Read(ctx context.Context, buffer []byte) (int, error) {
    ctx, span := c.tracer.Start(ctx, "udp receive",
        trace.WithSpanKind(trace.SpanKindInternal),
        trace.WithAttributes(
            attribute.String("network.transport", "udp"),
            attribute.String("network.io.direction", "receive"),
        ),
    )
    defer span.End()

    n, err := c.conn.Read(buffer)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return n, err
    }

    span.SetAttributes(
        attribute.Int("network.io.bytes", n),
    )

    span.SetStatus(codes.Ok, "")
    return n, nil
}

func (c *TracedUDPConn) Close() error {
    return c.conn.Close()
}
```

---

## 5. TLS/SSL 追踪

### 5.1 TLS 客户端

```go
import (
    "crypto/tls"
    "crypto/x509"
)

// TracedTLSDialer 包装 TLS 连接并追踪
type TracedTLSDialer struct {
    config *tls.Config
    tracer trace.Tracer
}

// NewTracedTLSDialer 创建带追踪的 TLS 拨号器
func NewTracedTLSDialer(config *tls.Config) *TracedTLSDialer {
    if config == nil {
        config = &tls.Config{}
    }

    return &TracedTLSDialer{
        config: config,
        tracer: otel.Tracer("tls-dialer"),
    }
}

// DialContext 建立 TLS 连接并追踪
func (d *TracedTLSDialer) DialContext(ctx context.Context, network, address string) (*tls.Conn, error) {
    ctx, span := d.tracer.Start(ctx, "tls connect",
        trace.WithSpanKind(trace.SpanKindInternal),
        trace.WithAttributes(
            attribute.String("network.transport", "tcp"),
            attribute.String("network.protocol.name", "tls"),
            attribute.String("server.address", address),
        ),
    )
    defer span.End()

    // 建立 TCP 连接
    tcpDialer := NewTracedTCPDialer()
    conn, err := tcpDialer.DialContext(ctx, network, address)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return nil, err
    }

    // TLS 握手
    span.AddEvent("tls_handshake_start")
    startTime := time.Now()

    tlsConn := tls.Client(conn, d.config)
    if err := tlsConn.HandshakeContext(ctx); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        conn.Close()
        return nil, err
    }

    // 记录 TLS 信息
    state := tlsConn.ConnectionState()
    span.AddEvent("tls_handshake_done", trace.WithAttributes(
        attribute.String("duration", time.Since(startTime).String()),
    ))

    span.SetAttributes(
        attribute.String("tls.version", tlsVersionName(state.Version)),
        attribute.String("tls.cipher_suite", tls.CipherSuiteName(state.CipherSuite)),
        attribute.Bool("tls.resumed", state.DidResume),
        attribute.String("tls.server_name", state.ServerName),
    )

    // 记录证书信息
    if len(state.PeerCertificates) > 0 {
        cert := state.PeerCertificates[0]
        span.SetAttributes(
            attribute.String("tls.peer.subject", cert.Subject.String()),
            attribute.String("tls.peer.issuer", cert.Issuer.String()),
            attribute.String("tls.peer.not_before", cert.NotBefore.Format(time.RFC3339)),
            attribute.String("tls.peer.not_after", cert.NotAfter.Format(time.RFC3339)),
        )
    }

    span.SetStatus(codes.Ok, "")
    return tlsConn, nil
}

func tlsVersionName(version uint16) string {
    switch version {
    case tls.VersionTLS10:
        return "1.0"
    case tls.VersionTLS11:
        return "1.1"
    case tls.VersionTLS12:
        return "1.2"
    case tls.VersionTLS13:
        return "1.3"
    default:
        return fmt.Sprintf("unknown(0x%04x)", version)
    }
}
```

### 5.2 证书验证追踪

```go
// VerifyCertificate 验证证书并追踪
func VerifyCertificate(ctx context.Context, cert *x509.Certificate, opts x509.VerifyOptions) error {
    tracer := otel.Tracer("tls-verify")
    
    ctx, span := tracer.Start(ctx, "tls certificate_verify",
        trace.WithSpanKind(trace.SpanKindInternal),
        trace.WithAttributes(
            attribute.String("tls.peer.subject", cert.Subject.String()),
            attribute.String("tls.peer.issuer", cert.Issuer.String()),
        ),
    )
    defer span.End()

    chains, err := cert.Verify(opts)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }

    span.SetAttributes(
        attribute.Int("tls.certificate_chain.length", len(chains)),
    )

    span.SetStatus(codes.Ok, "")
    return nil
}
```

---

## 6. DNS 解析追踪

### 6.1 DNS 查询追踪

```go
// TracedResolver 包装 DNS 解析器并追踪
type TracedResolver struct {
    resolver *net.Resolver
    tracer   trace.Tracer
}

// NewTracedResolver 创建带追踪的 DNS 解析器
func NewTracedResolver() *TracedResolver {
    return &TracedResolver{
        resolver: net.DefaultResolver,
        tracer:   otel.Tracer("dns-resolver"),
    }
}

// LookupHost 查询主机并追踪
func (r *TracedResolver) LookupHost(ctx context.Context, host string) ([]string, error) {
    ctx, span := r.tracer.Start(ctx, "dns lookup",
        trace.WithSpanKind(trace.SpanKindInternal),
        trace.WithAttributes(
            attribute.String("dns.query.name", host),
            attribute.String("dns.query.type", "A"),
        ),
    )
    defer span.End()

    startTime := time.Now()
    span.AddEvent("dns_query_start")

    addrs, err := r.resolver.LookupHost(ctx, host)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return nil, err
    }

    span.AddEvent("dns_query_done", trace.WithAttributes(
        attribute.String("duration", time.Since(startTime).String()),
    ))

    span.SetAttributes(
        attribute.StringSlice("dns.answers", addrs),
        attribute.Int("dns.answer_count", len(addrs)),
    )

    span.SetStatus(codes.Ok, "")
    return addrs, nil
}

// LookupIP 查询 IP 地址并追踪
func (r *TracedResolver) LookupIP(ctx context.Context, network, host string) ([]net.IP, error) {
    ctx, span := r.tracer.Start(ctx, "dns lookup_ip",
        trace.WithSpanKind(trace.SpanKindInternal),
        trace.WithAttributes(
            attribute.String("dns.query.name", host),
            attribute.String("network.type", network),
        ),
    )
    defer span.End()

    ips, err := r.resolver.LookupIP(ctx, network, host)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return nil, err
    }

    ipStrings := make([]string, len(ips))
    for i, ip := range ips {
        ipStrings[i] = ip.String()
    }

    span.SetAttributes(
        attribute.StringSlice("dns.answers", ipStrings),
        attribute.Int("dns.answer_count", len(ips)),
    )

    span.SetStatus(codes.Ok, "")
    return ips, nil
}

// LookupCNAME 查询 CNAME 记录并追踪
func (r *TracedResolver) LookupCNAME(ctx context.Context, host string) (string, error) {
    ctx, span := r.tracer.Start(ctx, "dns lookup_cname",
        trace.WithSpanKind(trace.SpanKindInternal),
        trace.WithAttributes(
            attribute.String("dns.query.name", host),
            attribute.String("dns.query.type", "CNAME"),
        ),
    )
    defer span.End()

    cname, err := r.resolver.LookupCNAME(ctx, host)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return "", err
    }

    span.SetAttributes(
        attribute.String("dns.cname", cname),
    )

    span.SetStatus(codes.Ok, "")
    return cname, nil
}
```

---

## 7. 连接池追踪

### 7.1 通用连接池

```go
// TracedConnPool 通用连接池
type TracedConnPool struct {
    pool   chan net.Conn
    dialer *TracedTCPDialer
    tracer trace.Tracer
    
    // 指标
    totalConns   int
    activeConns  int
    idleConns    int
    waitCount    int
    mu           sync.Mutex
}

// NewTracedConnPool 创建连接池
func NewTracedConnPool(size int, dialer *TracedTCPDialer) *TracedConnPool {
    return &TracedConnPool{
        pool:   make(chan net.Conn, size),
        dialer: dialer,
        tracer: otel.Tracer("conn-pool"),
    }
}

// Get 从连接池获取连接
func (p *TracedConnPool) Get(ctx context.Context, network, address string) (net.Conn, error) {
    ctx, span := p.tracer.Start(ctx, "conn_pool get",
        trace.WithSpanKind(trace.SpanKindInternal),
    )
    defer span.End()

    p.mu.Lock()
    p.waitCount++
    p.mu.Unlock()

    select {
    case conn := <-p.pool:
        // 从池中获取连接
        p.mu.Lock()
        p.idleConns--
        p.activeConns++
        p.mu.Unlock()

        span.AddEvent("conn_reused")
        span.SetAttributes(
            attribute.Bool("conn.reused", true),
            attribute.Int("pool.idle_conns", p.idleConns),
        )
        
        span.SetStatus(codes.Ok, "")
        return conn, nil

    case <-ctx.Done():
        span.RecordError(ctx.Err())
        span.SetStatus(codes.Error, "context cancelled")
        return nil, ctx.Err()

    default:
        // 创建新连接
        span.AddEvent("conn_create")
        conn, err := p.dialer.DialContext(ctx, network, address)
        if err != nil {
            span.RecordError(err)
            span.SetStatus(codes.Error, err.Error())
            return nil, err
        }

        p.mu.Lock()
        p.totalConns++
        p.activeConns++
        p.mu.Unlock()

        span.SetAttributes(
            attribute.Bool("conn.reused", false),
            attribute.Int("pool.total_conns", p.totalConns),
        )

        span.SetStatus(codes.Ok, "")
        return conn, nil
    }
}

// Put 归还连接到池
func (p *TracedConnPool) Put(conn net.Conn) error {
    ctx, span := p.tracer.Start(context.Background(), "conn_pool put",
        trace.WithSpanKind(trace.SpanKindInternal),
    )
    defer span.End()

    select {
    case p.pool <- conn:
        p.mu.Lock()
        p.activeConns--
        p.idleConns++
        p.mu.Unlock()

        span.SetAttributes(
            attribute.Int("pool.idle_conns", p.idleConns),
        )
        
        span.SetStatus(codes.Ok, "")
        return nil

    default:
        // 池已满,关闭连接
        span.AddEvent("conn_closed_pool_full")
        p.mu.Lock()
        p.activeConns--
        p.totalConns--
        p.mu.Unlock()

        span.SetStatus(codes.Ok, "")
        return conn.Close()
    }
}

// Stats 获取连接池统计信息
func (p *TracedConnPool) Stats() (total, active, idle, wait int) {
    p.mu.Lock()
    defer p.mu.Unlock()
    return p.totalConns, p.activeConns, p.idleConns, p.waitCount
}
```

---

## 8. 网络性能监控

### 8.1 带宽监控

```go
// BandwidthMonitor 监控网络带宽
type BandwidthMonitor struct {
    bytesReceived metric.Int64Counter
    bytesSent     metric.Int64Counter
    throughput    metric.Float64ObservableGauge
    
    totalReceived int64
    totalSent     int64
    startTime     time.Time
    mu            sync.Mutex
}

// NewBandwidthMonitor 创建带宽监控器
func NewBandwidthMonitor() *BandwidthMonitor {
    meter := otel.Meter("network-bandwidth")

    received, _ := meter.Int64Counter("network.io.bytes.received",
        metric.WithDescription("Total bytes received"),
        metric.WithUnit("By"),
    )

    sent, _ := meter.Int64Counter("network.io.bytes.sent",
        metric.WithDescription("Total bytes sent"),
        metric.WithUnit("By"),
    )

    m := &BandwidthMonitor{
        bytesReceived: received,
        bytesSent:     sent,
        startTime:     time.Now(),
    }

    throughput, _ := meter.Float64ObservableGauge("network.throughput",
        metric.WithDescription("Network throughput"),
        metric.WithUnit("MBps"),
    )

    meter.RegisterCallback(func(ctx context.Context, o metric.Observer) error {
        m.mu.Lock()
        defer m.mu.Unlock()

        elapsed := time.Since(m.startTime).Seconds()
        if elapsed > 0 {
            mbps := float64(m.totalReceived+m.totalSent) / elapsed / 1024 / 1024
            o.ObserveFloat64(throughput, mbps)
        }

        return nil
    }, throughput)

    m.throughput = throughput

    return m
}

// RecordReceived 记录接收的字节数
func (m *BandwidthMonitor) RecordReceived(ctx context.Context, bytes int64) {
    m.bytesReceived.Add(ctx, bytes)
    
    m.mu.Lock()
    m.totalReceived += bytes
    m.mu.Unlock()
}

// RecordSent 记录发送的字节数
func (m *BandwidthMonitor) RecordSent(ctx context.Context, bytes int64) {
    m.bytesSent.Add(ctx, bytes)
    
    m.mu.Lock()
    m.totalSent += bytes
    m.mu.Unlock()
}
```

### 8.2 延迟监控

```go
// LatencyMonitor 监控网络延迟
type LatencyMonitor struct {
    latency metric.Float64Histogram
}

// NewLatencyMonitor 创建延迟监控器
func NewLatencyMonitor() *LatencyMonitor {
    meter := otel.Meter("network-latency")

    latency, _ := meter.Float64Histogram("network.latency",
        metric.WithDescription("Network request latency"),
        metric.WithUnit("ms"),
    )

    return &LatencyMonitor{
        latency: latency,
    }
}

// Record 记录延迟
func (m *LatencyMonitor) Record(ctx context.Context, duration time.Duration) {
    m.latency.Record(ctx, duration.Seconds()*1000)
}

// Measure 测量操作延迟
func (m *LatencyMonitor) Measure(ctx context.Context, operation func() error) error {
    start := time.Now()
    err := operation()
    duration := time.Since(start)
    
    m.Record(ctx, duration)
    return err
}
```

---

## 9. 完整实现

```go
package main

import (
    "context"
    "fmt"
    "log"
    "net"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

func main() {
    // 初始化追踪
    tp := initTracer()
    defer tp.Shutdown(context.Background())

    // 示例 1: TCP 连接
    if err := tcpExample(); err != nil {
        log.Printf("TCP example error: %v", err)
    }

    // 示例 2: DNS 解析
    if err := dnsExample(); err != nil {
        log.Printf("DNS example error: %v", err)
    }

    // 示例 3: UDP 通信
    if err := udpExample(); err != nil {
        log.Printf("UDP example error: %v", err)
    }
}

func tcpExample() error {
    ctx := context.Background()
    
    dialer := NewTracedTCPDialer()
    conn, err := dialer.DialContext(ctx, "tcp", "www.google.com:80")
    if err != nil {
        return err
    }
    defer conn.Close()

    // 发送 HTTP 请求
    request := "GET / HTTP/1.1\r\nHost: www.google.com\r\n\r\n"
    _, err = conn.Write([]byte(request))
    if err != nil {
        return err
    }

    // 读取响应
    buffer := make([]byte, 4096)
    _, err = conn.Read(buffer)
    if err != nil {
        return err
    }

    log.Println("TCP connection successful")
    return nil
}

func dnsExample() error {
    ctx := context.Background()
    
    resolver := NewTracedResolver()
    addrs, err := resolver.LookupHost(ctx, "www.google.com")
    if err != nil {
        return err
    }

    log.Printf("DNS resolution successful: %v", addrs)
    return nil
}

func udpExample() error {
    ctx := context.Background()
    
    // 注意: 这里仅作示例,实际需要有 UDP 服务器
    conn, err := NewTracedUDPConn("localhost:8080")
    if err != nil {
        return fmt.Errorf("failed to create UDP connection: %w", err)
    }
    defer conn.Close()

    // 发送数据
    _, err = conn.Write(ctx, []byte("Hello UDP"))
    if err != nil {
        return err
    }

    log.Println("UDP send successful")
    return nil
}

func initTracer() *sdktrace.TracerProvider {
    exporter, _ := otlptracegrpc.New(context.Background(),
        otlptracegrpc.WithEndpoint("localhost:4317"),
        otlptracegrpc.WithInsecure(),
    )

    resource := resource.NewWithAttributes(
        semconv.SchemaURL,
        semconv.ServiceName("network-app"),
        semconv.ServiceVersion("1.0.0"),
    )

    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter),
        sdktrace.WithResource(resource),
    )

    otel.SetTracerProvider(tp)
    return tp
}
```

---

## 10. 最佳实践

### 10.1 超时控制

```go
// DialWithTimeout 带超时的连接
func DialWithTimeout(ctx context.Context, network, address string, timeout time.Duration) (net.Conn, error) {
    ctx, cancel := context.WithTimeout(ctx, timeout)
    defer cancel()

    dialer := NewTracedTCPDialer()
    conn, err := dialer.DialContext(ctx, network, address)
    if err != nil {
        if ctx.Err() == context.DeadlineExceeded {
            return nil, fmt.Errorf("connection timeout after %v", timeout)
        }
        return nil, err
    }

    return conn, nil
}
```

### 10.2 连接健康检查

```go
// HealthChecker 连接健康检查器
type HealthChecker struct {
    tracer trace.Tracer
}

// CheckConnection 检查连接健康状态
func (h *HealthChecker) CheckConnection(ctx context.Context, conn net.Conn) error {
    ctx, span := h.tracer.Start(ctx, "conn health_check",
        trace.WithSpanKind(trace.SpanKindInternal),
    )
    defer span.End()

    // 设置短超时
    conn.SetDeadline(time.Now().Add(1 * time.Second))
    defer conn.SetDeadline(time.Time{})

    // 尝试写入少量数据
    _, err := conn.Write([]byte{})
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "connection unhealthy")
        return err
    }

    span.SetStatus(codes.Ok, "connection healthy")
    return nil
}
```

### 10.3 错误分类

```go
// ClassifyNetworkError 分类网络错误
func ClassifyNetworkError(err error) string {
    if err == nil {
        return "none"
    }

    switch {
    case errors.Is(err, context.DeadlineExceeded):
        return "timeout"
    case errors.Is(err, net.ErrClosed):
        return "closed"
    default:
        if netErr, ok := err.(net.Error); ok {
            if netErr.Timeout() {
                return "timeout"
            }
            if netErr.Temporary() {
                return "temporary"
            }
        }
        return "unknown"
    }
}
```

---

## 总结

✅ **核心属性**: `network.transport`, `network.peer.address`, `network.peer.port`  
✅ **TCP 追踪**: 连接、监听、读写操作  
✅ **UDP 追踪**: 数据报发送和接收  
✅ **TLS/SSL**: 握手、证书验证  
✅ **DNS 解析**: 主机名查询、IP 查询、CNAME 查询  
✅ **连接池**: 连接复用、统计信息  
✅ **性能监控**: 带宽、延迟、吞吐量  
✅ **最佳实践**: 超时控制、健康检查、错误分类

**Phase 2.2 完成!** - 所有 Trace 属性文档已创建!
