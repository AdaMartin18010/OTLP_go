# 数据库追踪属性完整指南

> **文档版本**: v2.0.0  
> **最后更新**: 2025-10-09  
> **OpenTelemetry 版本**: v1.32.0  
> **Go 版本**: 1.25.1

## 目录

- [数据库追踪属性完整指南](#数据库追踪属性完整指南)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 数据库语义约定](#11-数据库语义约定)
    - [1.2 支持的数据库类型](#12-支持的数据库类型)
  - [2. 核心属性](#2-核心属性)
    - [2.1 必需属性](#21-必需属性)
    - [2.2 推荐属性](#22-推荐属性)
    - [2.3 SQL 特定属性](#23-sql-特定属性)
    - [2.4 NoSQL 特定属性](#24-nosql-特定属性)
  - [3. SQL 数据库](#3-sql-数据库)
    - [3.1 PostgreSQL](#31-postgresql)
    - [3.2 MySQL](#32-mysql)
    - [3.3 使用示例](#33-使用示例)
  - [4. NoSQL 数据库](#4-nosql-数据库)
    - [4.1 Redis](#41-redis)
    - [4.2 MongoDB](#42-mongodb)
    - [4.3 Cassandra](#43-cassandra)
  - [5. database/sql 集成](#5-databasesql-集成)
    - [5.1 使用 otelsql](#51-使用-otelsql)
  - [6. ORM 集成](#6-orm-集成)
    - [6.1 GORM v2](#61-gorm-v2)
    - [6.2 ent](#62-ent)
    - [6.3 sqlc](#63-sqlc)
  - [7. 连接池追踪](#7-连接池追踪)
    - [7.1 监控连接池](#71-监控连接池)
  - [8. 事务追踪](#8-事务追踪)
    - [8.1 手动事务](#81-手动事务)
  - [9. 完整实现](#9-完整实现)
  - [10. 最佳实践](#10-最佳实践)
    - [10.1 SQL 清理](#101-sql-清理)
    - [10.2 慢查询检测](#102-慢查询检测)
    - [10.3 连接池配置](#103-连接池配置)
  - [总结](#总结)

---

## 1. 概述

### 1.1 数据库语义约定

数据库追踪记录应用与数据库之间的交互,包括 SQL 和 NoSQL 数据库。

**关键特征**:

- **Span Kind**: `SPAN_KIND_CLIENT`
- **命名规范**: `{db.operation} {db.name}.{db.sql.table}`
- **示例**: `SELECT users.user`, `INSERT orders.order`

### 1.2 支持的数据库类型

| 类型 | `db.system` | 示例 |
|------|-------------|------|
| **关系型** | `postgresql`, `mysql`, `mssql`, `oracle` | PostgreSQL, MySQL |
| **NoSQL 文档** | `mongodb`, `couchdb` | MongoDB |
| **NoSQL 键值** | `redis`, `memcached` | Redis |
| **NoSQL 列式** | `cassandra`, `hbase` | Cassandra |
| **NoSQL 图** | `neo4j` | Neo4j |

---

## 2. 核心属性

### 2.1 必需属性

| 属性 | 类型 | 示例 | 描述 |
|------|------|------|------|
| `db.system` | string | `postgresql` | 数据库系统标识符 |

### 2.2 推荐属性

| 属性 | 类型 | 示例 | 描述 |
|------|------|------|------|
| `db.name` | string | `mydb` | 数据库名称 |
| `db.operation` | string | `SELECT`, `INSERT` | 数据库操作 |
| `server.address` | string | `db.example.com` | 数据库服务器地址 |
| `server.port` | int | `5432` | 数据库服务器端口 |
| `db.user` | string | `dbuser` | 数据库用户名 |

### 2.3 SQL 特定属性

| 属性 | 类型 | 示例 | 描述 |
|------|------|------|------|
| `db.sql.table` | string | `users` | SQL 表名 |
| `db.statement` | string | `SELECT * FROM users WHERE id = ?` | SQL 语句 (已清理) |

### 2.4 NoSQL 特定属性

| 属性 | 类型 | 示例 | 描述 |
|------|------|------|------|
| `db.mongodb.collection` | string | `users` | MongoDB 集合 |
| `db.redis.database_index` | int | `0` | Redis 数据库索引 |
| `db.cassandra.keyspace` | string | `mykeyspace` | Cassandra 键空间 |

---

## 3. SQL 数据库

### 3.1 PostgreSQL

```go
package dbtracing

import (
    "context"
    "database/sql"

    _ "github.com/lib/pq"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/semconv/v1.24.0"
    "go.opentelemetry.io/otel/trace"
)

// TracedDB 包装 *sql.DB 并提供自动追踪
type TracedDB struct {
    db     *sql.DB
    tracer trace.Tracer
    system string
}

// NewTracedPostgresDB 创建带追踪的 PostgreSQL 连接
func NewTracedPostgresDB(dsn string) (*TracedDB, error) {
    db, err := sql.Open("postgres", dsn)
    if err != nil {
        return nil, err
    }

    return &TracedDB{
        db:     db,
        tracer: otel.Tracer("database"),
        system: "postgresql",
    }, nil
}

// QueryContext 执行查询并追踪
func (tdb *TracedDB) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
    ctx, span := tdb.tracer.Start(ctx, "SELECT",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            semconv.DBSystemKey.String(tdb.system),
            semconv.DBStatement(sanitizeSQL(query)),
        ),
    )
    defer span.End()

    rows, err := tdb.db.QueryContext(ctx, query, args...)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return nil, err
    }

    span.SetStatus(codes.Ok, "")
    return rows, nil
}

// ExecContext 执行语句并追踪
func (tdb *TracedDB) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
    operation := extractOperation(query)
    ctx, span := tdb.tracer.Start(ctx, operation,
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            semconv.DBSystemKey.String(tdb.system),
            semconv.DBStatement(sanitizeSQL(query)),
        ),
    )
    defer span.End()

    result, err := tdb.db.ExecContext(ctx, query, args...)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return nil, err
    }

    // 记录受影响的行数
    if rowsAffected, err := result.RowsAffected(); err == nil {
        span.SetAttributes(attribute.Int64("db.rows_affected", rowsAffected))
    }

    span.SetStatus(codes.Ok, "")
    return result, nil
}

// sanitizeSQL 清理 SQL 语句中的敏感信息
func sanitizeSQL(query string) string {
    // 移除参数值,保留 ? 占位符
    // 实际实现应该更复杂,这里仅作示例
    return query
}

// extractOperation 从 SQL 语句中提取操作类型
func extractOperation(query string) string {
    query = strings.ToUpper(strings.TrimSpace(query))
    operations := []string{"SELECT", "INSERT", "UPDATE", "DELETE", "CREATE", "ALTER", "DROP"}
    
    for _, op := range operations {
        if strings.HasPrefix(query, op) {
            return op
        }
    }
    
    return "QUERY"
}
```

### 3.2 MySQL

```go
import _ "github.com/go-sql-driver/mysql"

func NewTracedMySQLDB(dsn string) (*TracedDB, error) {
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        return nil, err
    }

    return &TracedDB{
        db:     db,
        tracer: otel.Tracer("database"),
        system: "mysql",
    }, nil
}
```

### 3.3 使用示例

```go
func main() {
    // 初始化追踪
    tp := initTracer()
    defer tp.Shutdown(context.Background())

    // 创建数据库连接
    db, _ := NewTracedPostgresDB("postgres://user:pass@localhost/mydb?sslmode=disable")
    defer db.Close()

    // 查询
    ctx := context.Background()
    rows, err := db.QueryContext(ctx, "SELECT id, name FROM users WHERE age > $1", 18)
    if err != nil {
        log.Fatal(err)
    }
    defer rows.Close()

    for rows.Next() {
        var id int
        var name string
        rows.Scan(&id, &name)
        log.Printf("User: %d - %s", id, name)
    }
}
```

---

## 4. NoSQL 数据库

### 4.1 Redis

```go
import (
    "github.com/redis/go-redis/v9"
    "go.opentelemetry.io/contrib/instrumentation/github.com/redis/go-redis/v9/redisotel"
)

// NewTracedRedisClient 创建带追踪的 Redis 客户端
func NewTracedRedisClient(addr string) *redis.Client {
    client := redis.NewClient(&redis.Options{
        Addr: addr,
    })

    // 启用追踪钩子
    if err := redisotel.InstrumentTracing(client); err != nil {
        log.Fatal(err)
    }

    return client
}

// 使用示例
func ExampleRedis(ctx context.Context) {
    client := NewTracedRedisClient("localhost:6379")
    defer client.Close()

    // 操作自动追踪
    client.Set(ctx, "key", "value", 0)
    val, _ := client.Get(ctx, "key").Result()
    log.Println(val)
}
```

### 4.2 MongoDB

```go
import (
    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
    "go.opentelemetry.io/contrib/instrumentation/go.mongodb.org/mongo-driver/mongo/otelmongo"
)

// NewTracedMongoClient 创建带追踪的 MongoDB 客户端
func NewTracedMongoClient(uri string) (*mongo.Client, error) {
    opts := options.Client().
        ApplyURI(uri).
        SetMonitor(otelmongo.NewMonitor())

    client, err := mongo.Connect(context.Background(), opts)
    if err != nil {
        return nil, err
    }

    return client, nil
}

// 使用示例
func ExampleMongo(ctx context.Context) {
    client, _ := NewTracedMongoClient("mongodb://localhost:27017")
    defer client.Disconnect(ctx)

    collection := client.Database("mydb").Collection("users")

    // 插入文档 (自动追踪)
    result, _ := collection.InsertOne(ctx, bson.M{
        "name": "Alice",
        "age":  30,
    })
    log.Printf("Inserted ID: %v", result.InsertedID)

    // 查询文档 (自动追踪)
    var user bson.M
    collection.FindOne(ctx, bson.M{"name": "Alice"}).Decode(&user)
    log.Printf("User: %v", user)
}
```

### 4.3 Cassandra

```go
import (
    "github.com/gocql/gocql"
    "go.opentelemetry.io/contrib/instrumentation/github.com/gocql/gocql/otelgocql"
)

// NewTracedCassandraSession 创建带追踪的 Cassandra 会话
func NewTracedCassandraSession(hosts []string, keyspace string) (*gocql.Session, error) {
    cluster := gocql.NewCluster(hosts...)
    cluster.Keyspace = keyspace

    // 添加追踪观察器
    cluster.QueryObserver = otelgocql.NewQueryObserver()

    session, err := cluster.CreateSession()
    if err != nil {
        return nil, err
    }

    return session, nil
}

// 使用示例
func ExampleCassandra(ctx context.Context) {
    session, _ := NewTracedCassandraSession([]string{"localhost"}, "mykeyspace")
    defer session.Close()

    // 查询 (自动追踪)
    var name string
    var age int
    if err := session.Query("SELECT name, age FROM users WHERE id = ?", 1).
        WithContext(ctx).
        Scan(&name, &age); err != nil {
        log.Fatal(err)
    }

    log.Printf("User: %s, Age: %d", name, age)
}
```

---

## 5. database/sql 集成

### 5.1 使用 otelsql

```go
import (
    "database/sql"

    _ "github.com/lib/pq"
    "go.opentelemetry.io/contrib/instrumentation/database/sql/otelsql"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// NewOTelTracedDB 使用 otelsql 包装数据库连接
func NewOTelTracedDB(driverName, dsn string) (*sql.DB, error) {
    // 注册带追踪的驱动
    driverName, err := otelsql.Register(driverName,
        otelsql.WithAttributes(
            semconv.DBSystemPostgreSQL,
        ),
    )
    if err != nil {
        return nil, err
    }

    // 打开连接
    db, err := sql.Open(driverName, dsn)
    if err != nil {
        return nil, err
    }

    // 记录连接池指标
    if err := otelsql.RecordStats(db); err != nil {
        return nil, err
    }

    return db, nil
}

// 使用示例
func main() {
    db, _ := NewOTelTracedDB("postgres", "postgres://user:pass@localhost/mydb")
    defer db.Close()

    // 所有操作自动追踪
    rows, _ := db.QueryContext(context.Background(), "SELECT * FROM users")
    defer rows.Close()
}
```

---

## 6. ORM 集成

### 6.1 GORM v2

```go
import (
    "gorm.io/driver/postgres"
    "gorm.io/gorm"
    "go.opentelemetry.io/contrib/instrumentation/gorm.io/gorm/otelgorm"
)

// NewTracedGORMDB 创建带追踪的 GORM 数据库连接
func NewTracedGORMDB(dsn string) (*gorm.DB, error) {
    db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
    if err != nil {
        return nil, err
    }

    // 注册追踪插件
    if err := db.Use(otelgorm.NewPlugin()); err != nil {
        return nil, err
    }

    return db, nil
}

// 使用示例
type User struct {
    ID   uint
    Name string
    Age  int
}

func ExampleGORM(ctx context.Context) {
    db, _ := NewTracedGORMDB("postgres://user:pass@localhost/mydb")

    // 查询 (自动追踪)
    var user User
    db.WithContext(ctx).First(&user, 1)
    log.Printf("User: %+v", user)

    // 创建 (自动追踪)
    db.WithContext(ctx).Create(&User{Name: "Bob", Age: 25})

    // 更新 (自动追踪)
    db.WithContext(ctx).Model(&user).Update("Age", 26)

    // 删除 (自动追踪)
    db.WithContext(ctx).Delete(&user)
}
```

### 6.2 ent

```go
import (
    "entgo.io/ent/dialect"
    "entgo.io/ent/dialect/sql"
    "go.opentelemetry.io/otel/trace"
)

// NewTracedEntClient 创建带追踪的 ent 客户端
func NewTracedEntClient(dsn string) (*ent.Client, error) {
    drv, err := sql.Open(dialect.Postgres, dsn)
    if err != nil {
        return nil, err
    }

    // 添加追踪钩子
    client := ent.NewClient(ent.Driver(drv))
    client.Use(entTracingHook())

    return client, nil
}

// entTracingHook 为 ent 创建追踪钩子
func entTracingHook() ent.Hook {
    tracer := otel.Tracer("ent")

    return func(next ent.Mutator) ent.Mutator {
        return ent.MutateFunc(func(ctx context.Context, m ent.Mutation) (ent.Value, error) {
            operation := m.Op().String()
            table := m.Type()

            ctx, span := tracer.Start(ctx, operation+" "+table,
                trace.WithSpanKind(trace.SpanKindClient),
                trace.WithAttributes(
                    semconv.DBSystemPostgreSQL,
                    attribute.String("db.operation", operation),
                    semconv.DBSQLTable(table),
                ),
            )
            defer span.End()

            v, err := next.Mutate(ctx, m)
            if err != nil {
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
                return nil, err
            }

            span.SetStatus(codes.Ok, "")
            return v, nil
        })
    }
}
```

### 6.3 sqlc

```go
// sqlc 生成的查询函数包装
type TracedQueries struct {
    *db.Queries
    tracer trace.Tracer
}

func NewTracedQueries(db *sql.DB) *TracedQueries {
    return &TracedQueries{
        Queries: db.New(db),
        tracer:  otel.Tracer("sqlc"),
    }
}

func (q *TracedQueries) GetUser(ctx context.Context, id int32) (db.User, error) {
    ctx, span := q.tracer.Start(ctx, "SELECT users",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            semconv.DBSystemPostgreSQL,
            semconv.DBStatement("SELECT * FROM users WHERE id = $1"),
        ),
    )
    defer span.End()

    user, err := q.Queries.GetUser(ctx, id)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return db.User{}, err
    }

    span.SetStatus(codes.Ok, "")
    return user, nil
}
```

---

## 7. 连接池追踪

### 7.1 监控连接池

```go
import "go.opentelemetry.io/otel/metric"

// DatabasePoolMetrics 数据库连接池指标
type DatabasePoolMetrics struct {
    openConns  metric.Int64ObservableGauge
    idleConns  metric.Int64ObservableGauge
    waitCount  metric.Int64ObservableCounter
    waitDuration metric.Float64ObservableCounter
}

// NewDatabasePoolMetrics 创建连接池指标
func NewDatabasePoolMetrics(db *sql.DB) (*DatabasePoolMetrics, error) {
    meter := otel.Meter("database-pool")

    openConns, _ := meter.Int64ObservableGauge("db.pool.connections.open",
        metric.WithDescription("Number of open connections"),
    )

    idleConns, _ := meter.Int64ObservableGauge("db.pool.connections.idle",
        metric.WithDescription("Number of idle connections"),
    )

    waitCount, _ := meter.Int64ObservableCounter("db.pool.connections.wait_count",
        metric.WithDescription("Total number of connections waited for"),
    )

    waitDuration, _ := meter.Float64ObservableCounter("db.pool.connections.wait_duration",
        metric.WithDescription("Total time waited for connections"),
        metric.WithUnit("ms"),
    )

    // 注册回调
    meter.RegisterCallback(func(ctx context.Context, o metric.Observer) error {
        stats := db.Stats()
        
        o.ObserveInt64(openConns, int64(stats.OpenConnections))
        o.ObserveInt64(idleConns, int64(stats.Idle))
        o.ObserveInt64(waitCount, stats.WaitCount)
        o.ObserveFloat64(waitDuration, stats.WaitDuration.Seconds()*1000)
        
        return nil
    }, openConns, idleConns, waitCount, waitDuration)

    return &DatabasePoolMetrics{
        openConns:    openConns,
        idleConns:    idleConns,
        waitCount:    waitCount,
        waitDuration: waitDuration,
    }, nil
}
```

---

## 8. 事务追踪

### 8.1 手动事务

```go
// TracedTx 包装 *sql.Tx 并追踪
type TracedTx struct {
    tx     *sql.Tx
    tracer trace.Tracer
    span   trace.Span
}

// BeginTx 开始事务并追踪
func (tdb *TracedDB) BeginTx(ctx context.Context, opts *sql.TxOptions) (*TracedTx, error) {
    ctx, span := tdb.tracer.Start(ctx, "TRANSACTION",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            semconv.DBSystemKey.String(tdb.system),
        ),
    )

    tx, err := tdb.db.BeginTx(ctx, opts)
    if err != nil {
        span.RecordError(err)
        span.End()
        return nil, err
    }

    return &TracedTx{
        tx:     tx,
        tracer: tdb.tracer,
        span:   span,
    }, nil
}

// Commit 提交事务
func (ttx *TracedTx) Commit() error {
    defer ttx.span.End()
    
    ttx.span.AddEvent("COMMIT")
    err := ttx.tx.Commit()
    
    if err != nil {
        ttx.span.RecordError(err)
        ttx.span.SetStatus(codes.Error, err.Error())
        return err
    }

    ttx.span.SetStatus(codes.Ok, "")
    return nil
}

// Rollback 回滚事务
func (ttx *TracedTx) Rollback() error {
    defer ttx.span.End()
    
    ttx.span.AddEvent("ROLLBACK")
    err := ttx.tx.Rollback()
    
    if err != nil {
        ttx.span.RecordError(err)
        ttx.span.SetStatus(codes.Error, err.Error())
        return err
    }

    ttx.span.SetStatus(codes.Ok, "")
    return nil
}

// ExecContext 在事务中执行语句
func (ttx *TracedTx) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
    operation := extractOperation(query)
    _, span := ttx.tracer.Start(ctx, operation,
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            semconv.DBStatement(sanitizeSQL(query)),
        ),
    )
    defer span.End()

    result, err := ttx.tx.ExecContext(ctx, query, args...)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return nil, err
    }

    span.SetStatus(codes.Ok, "")
    return result, nil
}

// 使用示例
func ExampleTransaction(ctx context.Context, db *TracedDB) error {
    tx, err := db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }

    defer func() {
        if p := recover(); p != nil {
            tx.Rollback()
            panic(p)
        } else if err != nil {
            tx.Rollback()
        } else {
            err = tx.Commit()
        }
    }()

    // 在事务中执行操作
    _, err = tx.ExecContext(ctx, "INSERT INTO users (name) VALUES ($1)", "Alice")
    if err != nil {
        return err
    }

    _, err = tx.ExecContext(ctx, "UPDATE accounts SET balance = balance - 100 WHERE user_id = $1", 1)
    if err != nil {
        return err
    }

    return nil
}
```

---

## 9. 完整实现

```go
package main

import (
    "context"
    "database/sql"
    "log"

    _ "github.com/lib/pq"
    "go.opentelemetry.io/contrib/instrumentation/database/sql/otelsql"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

func main() {
    // 初始化追踪
    tp := initTracer()
    defer tp.Shutdown(context.Background())

    // 创建数据库连接
    db, err := NewOTelTracedDB("postgres", 
        "postgres://user:pass@localhost:5432/mydb?sslmode=disable")
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()

    // 使用数据库
    ctx := context.Background()
    if err := queryUsers(ctx, db); err != nil {
        log.Fatal(err)
    }
}

func queryUsers(ctx context.Context, db *sql.DB) error {
    rows, err := db.QueryContext(ctx, "SELECT id, name, email FROM users WHERE age > $1", 18)
    if err != nil {
        return err
    }
    defer rows.Close()

    for rows.Next() {
        var id int
        var name, email string
        if err := rows.Scan(&id, &name, &email); err != nil {
            return err
        }
        log.Printf("User: %d - %s <%s>", id, name, email)
    }

    return rows.Err()
}

func initTracer() *sdktrace.TracerProvider {
    exporter, _ := otlptracegrpc.New(context.Background(),
        otlptracegrpc.WithEndpoint("localhost:4317"),
        otlptracegrpc.WithInsecure(),
    )

    resource := resource.NewWithAttributes(
        semconv.SchemaURL,
        semconv.ServiceName("db-app"),
        semconv.ServiceVersion("1.0.0"),
    )

    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter),
        sdktrace.WithResource(resource),
    )

    otel.SetTracerProvider(tp)
    return tp
}
```

---

## 10. 最佳实践

### 10.1 SQL 清理

```go
// SanitizeSQL 清理 SQL 语句
func SanitizeSQL(query string) string {
    // 1. 移除字符串字面量
    re := regexp.MustCompile(`'[^']*'`)
    query = re.ReplaceAllString(query, "?")

    // 2. 移除数字字面量
    re = regexp.MustCompile(`\b\d+\b`)
    query = re.ReplaceAllString(query, "?")

    // 3. 规范化空白字符
    query = strings.Join(strings.Fields(query), " ")

    return query
}
```

### 10.2 慢查询检测

```go
// SlowQueryInterceptor 检测慢查询
func SlowQueryInterceptor(threshold time.Duration) func(context.Context, string, ...interface{}) func() {
    return func(ctx context.Context, query string, args ...interface{}) func() {
        start := time.Now()
        span := trace.SpanFromContext(ctx)

        return func() {
            duration := time.Since(start)
            
            if duration > threshold {
                span.AddEvent("slow_query", trace.WithAttributes(
                    attribute.String("query", sanitizeSQL(query)),
                    attribute.String("duration", duration.String()),
                ))
            }
        }
    }
}
```

### 10.3 连接池配置

```go
func ConfigurePool(db *sql.DB) {
    // 最大打开连接数
    db.SetMaxOpenConns(25)
    
    // 最大空闲连接数
    db.SetMaxIdleConns(5)
    
    // 连接最大生命周期
    db.SetConnMaxLifetime(5 * time.Minute)
    
    // 连接最大空闲时间
    db.SetConnMaxIdleTime(10 * time.Minute)
}
```

---

## 总结

✅ **核心属性**: `db.system`, `db.name`, `db.operation`, `db.statement`  
✅ **SQL 支持**: PostgreSQL, MySQL, SQLite  
✅ **NoSQL 支持**: Redis, MongoDB, Cassandra  
✅ **ORM 集成**: GORM, ent, sqlc  
✅ **高级功能**: 连接池监控、事务追踪、慢查询检测  
✅ **最佳实践**: SQL 清理、性能监控、资源管理

**下一步**: 参见 `05_消息队列.md` 了解消息队列追踪。
