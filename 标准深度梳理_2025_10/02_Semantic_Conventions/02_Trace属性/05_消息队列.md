# 消息队列追踪属性完整指南

> **文档版本**: v2.0.0  
> **最后更新**: 2025-10-09  
> **OpenTelemetry 版本**: v1.32.0  
> **Go 版本**: 1.25.1

## 目录

- [消息队列追踪属性完整指南](#消息队列追踪属性完整指南)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 消息队列语义约定](#11-消息队列语义约定)
    - [1.2 Span 关系](#12-span-关系)
  - [2. 核心属性](#2-核心属性)
    - [2.1 必需属性](#21-必需属性)
    - [2.2 推荐属性](#22-推荐属性)
    - [2.3 Kafka 特定属性](#23-kafka-特定属性)
    - [2.4 RabbitMQ 特定属性](#24-rabbitmq-特定属性)
    - [2.5 NATS 特定属性](#25-nats-特定属性)
  - [3. Kafka 集成](#3-kafka-集成)
    - [3.1 Kafka 生产者](#31-kafka-生产者)
    - [3.2 Kafka 消费者](#32-kafka-消费者)
    - [3.3 使用示例](#33-使用示例)
  - [4. RabbitMQ 集成](#4-rabbitmq-集成)
    - [4.1 RabbitMQ 生产者](#41-rabbitmq-生产者)
    - [4.2 RabbitMQ 消费者](#42-rabbitmq-消费者)
  - [5. NATS 集成](#5-nats-集成)
    - [5.1 NATS 生产者](#51-nats-生产者)
    - [5.2 NATS 消费者](#52-nats-消费者)
  - [6. 生产者追踪](#6-生产者追踪)
    - [6.1 批量发送](#61-批量发送)
  - [7. 消费者追踪](#7-消费者追踪)
    - [7.1 并发消费](#71-并发消费)
  - [8. 批量处理](#8-批量处理)
    - [8.1 批量消费](#81-批量消费)
  - [9. 完整实现](#9-完整实现)
  - [10. 最佳实践](#10-最佳实践)
    - [10.1 错误重试](#101-错误重试)
    - [10.2 死信队列](#102-死信队列)
    - [10.3 性能监控](#103-性能监控)
  - [总结](#总结)

---

## 1. 概述

### 1.1 消息队列语义约定

消息队列追踪记录生产者和消费者之间的异步通信。

**关键特征**:

- **生产者 Span Kind**: `SPAN_KIND_PRODUCER`
- **消费者 Span Kind**: `SPAN_KIND_CONSUMER`
- **命名规范**: `{messaging.operation} {messaging.destination.name}`
- **示例**: `publish my-topic`, `receive my-queue`

### 1.2 Span 关系

```text
[Producer Span] --> [Message in Queue] --> [Consumer Span]
     (PRODUCER)                              (CONSUMER)
```

消费者 Span 通过 **Trace Context Propagation** 成为生产者 Span 的子 Span。

---

## 2. 核心属性

### 2.1 必需属性

| 属性 | 类型 | 示例 | 描述 |
|------|------|------|------|
| `messaging.system` | string | `kafka`, `rabbitmq`, `nats` | 消息系统标识符 |
| `messaging.destination.name` | string | `my-topic` | 目标名称 (主题/队列) |
| `messaging.operation` | string | `publish`, `receive`, `process` | 操作类型 |

### 2.2 推荐属性

| 属性 | 类型 | 示例 | 描述 |
|------|------|------|------|
| `messaging.message.id` | string | `msg-123` | 消息 ID |
| `messaging.message.payload_size_bytes` | int | `1024` | 消息大小 (字节) |
| `server.address` | string | `kafka.example.com` | 消息代理地址 |
| `server.port` | int | `9092` | 消息代理端口 |

### 2.3 Kafka 特定属性

| 属性 | 类型 | 示例 | 描述 |
|------|------|------|------|
| `messaging.kafka.destination.partition` | int | `0` | 分区 ID |
| `messaging.kafka.message.offset` | int | `12345` | 消息偏移量 |
| `messaging.kafka.message.key` | string | `user-123` | 消息键 |
| `messaging.kafka.consumer.group` | string | `my-group` | 消费者组 |

### 2.4 RabbitMQ 特定属性

| 属性 | 类型 | 示例 | 描述 |
|------|------|------|------|
| `messaging.rabbitmq.destination.routing_key` | string | `user.created` | 路由键 |
| `messaging.rabbitmq.message.delivery_tag` | int | `1` | 投递标签 |

### 2.5 NATS 特定属性

| 属性 | 类型 | 示例 | 描述 |
|------|------|------|------|
| `messaging.nats.subject` | string | `user.events` | NATS 主题 |

---

## 3. Kafka 集成

### 3.1 Kafka 生产者

```go
package messaging

import (
    "context"

    "github.com/IBM/sarama"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/semconv/v1.24.0"
    "go.opentelemetry.io/otel/trace"
)

// TracedKafkaProducer 包装 Kafka 生产者并提供追踪
type TracedKafkaProducer struct {
    producer   sarama.SyncProducer
    tracer     trace.Tracer
    propagator propagation.TextMapPropagator
}

// NewTracedKafkaProducer 创建带追踪的 Kafka 生产者
func NewTracedKafkaProducer(brokers []string) (*TracedKafkaProducer, error) {
    config := sarama.NewConfig()
    config.Producer.Return.Successes = true

    producer, err := sarama.NewSyncProducer(brokers, config)
    if err != nil {
        return nil, err
    }

    return &TracedKafkaProducer{
        producer:   producer,
        tracer:     otel.Tracer("kafka-producer"),
        propagator: otel.GetTextMapPropagator(),
    }, nil
}

// SendMessage 发送消息并追踪
func (p *TracedKafkaProducer) SendMessage(ctx context.Context, topic string, key, value []byte) error {
    // 创建生产者 Span
    ctx, span := p.tracer.Start(ctx, "publish "+topic,
        trace.WithSpanKind(trace.SpanKindProducer),
        trace.WithAttributes(
            semconv.MessagingSystemKey.String("kafka"),
            semconv.MessagingDestinationName(topic),
            semconv.MessagingOperationKey.String("publish"),
            attribute.Int("messaging.message.payload_size_bytes", len(value)),
        ),
    )
    defer span.End()

    // 创建消息
    msg := &sarama.ProducerMessage{
        Topic: topic,
        Key:   sarama.ByteEncoder(key),
        Value: sarama.ByteEncoder(value),
    }

    // 注入追踪上下文到消息头
    if msg.Headers == nil {
        msg.Headers = []sarama.RecordHeader{}
    }
    p.propagator.Inject(ctx, &kafkaHeaderCarrier{headers: &msg.Headers})

    // 发送消息
    partition, offset, err := p.producer.SendMessage(msg)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }

    // 记录分区和偏移量
    span.SetAttributes(
        attribute.Int("messaging.kafka.destination.partition", int(partition)),
        attribute.Int64("messaging.kafka.message.offset", offset),
    )

    span.SetStatus(codes.Ok, "")
    return nil
}

// kafkaHeaderCarrier 用于在 Kafka 消息头中传播追踪上下文
type kafkaHeaderCarrier struct {
    headers *[]sarama.RecordHeader
}

func (c *kafkaHeaderCarrier) Get(key string) string {
    for _, h := range *c.headers {
        if string(h.Key) == key {
            return string(h.Value)
        }
    }
    return ""
}

func (c *kafkaHeaderCarrier) Set(key, value string) {
    *c.headers = append(*c.headers, sarama.RecordHeader{
        Key:   []byte(key),
        Value: []byte(value),
    })
}

func (c *kafkaHeaderCarrier) Keys() []string {
    keys := make([]string, len(*c.headers))
    for i, h := range *c.headers {
        keys[i] = string(h.Key)
    }
    return keys
}

// Close 关闭生产者
func (p *TracedKafkaProducer) Close() error {
    return p.producer.Close()
}
```

### 3.2 Kafka 消费者

```go
// TracedKafkaConsumer 包装 Kafka 消费者并提供追踪
type TracedKafkaConsumer struct {
    consumer   sarama.ConsumerGroup
    tracer     trace.Tracer
    propagator propagation.TextMapPropagator
}

// NewTracedKafkaConsumer 创建带追踪的 Kafka 消费者
func NewTracedKafkaConsumer(brokers []string, group string) (*TracedKafkaConsumer, error) {
    config := sarama.NewConfig()
    config.Consumer.Return.Errors = true

    consumer, err := sarama.NewConsumerGroup(brokers, group, config)
    if err != nil {
        return nil, err
    }

    return &TracedKafkaConsumer{
        consumer:   consumer,
        tracer:     otel.Tracer("kafka-consumer"),
        propagator: otel.GetTextMapPropagator(),
    }, nil
}

// Consume 消费消息并追踪
func (c *TracedKafkaConsumer) Consume(ctx context.Context, topics []string, handler func(context.Context, *sarama.ConsumerMessage) error) error {
    consumerHandler := &tracedConsumerGroupHandler{
        tracer:     c.tracer,
        propagator: c.propagator,
        handler:    handler,
    }

    return c.consumer.Consume(ctx, topics, consumerHandler)
}

// tracedConsumerGroupHandler 实现 sarama.ConsumerGroupHandler
type tracedConsumerGroupHandler struct {
    tracer     trace.Tracer
    propagator propagation.TextMapPropagator
    handler    func(context.Context, *sarama.ConsumerMessage) error
}

func (h *tracedConsumerGroupHandler) Setup(sarama.ConsumerGroupSession) error {
    return nil
}

func (h *tracedConsumerGroupHandler) Cleanup(sarama.ConsumerGroupSession) error {
    return nil
}

func (h *tracedConsumerGroupHandler) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
    for msg := range claim.Messages() {
        // 从消息头提取追踪上下文
        ctx := h.propagator.Extract(context.Background(), &kafkaHeaderCarrier{headers: &msg.Headers})

        // 创建消费者 Span
        ctx, span := h.tracer.Start(ctx, "receive "+msg.Topic,
            trace.WithSpanKind(trace.SpanKindConsumer),
            trace.WithAttributes(
                semconv.MessagingSystemKey.String("kafka"),
                semconv.MessagingDestinationName(msg.Topic),
                semconv.MessagingOperationKey.String("receive"),
                attribute.Int("messaging.kafka.destination.partition", int(msg.Partition)),
                attribute.Int64("messaging.kafka.message.offset", msg.Offset),
                attribute.Int("messaging.message.payload_size_bytes", len(msg.Value)),
            ),
        )

        // 调用处理器
        err := h.handler(ctx, msg)
        if err != nil {
            span.RecordError(err)
            span.SetStatus(codes.Error, err.Error())
        } else {
            span.SetStatus(codes.Ok, "")
            session.MarkMessage(msg, "")
        }

        span.End()
    }

    return nil
}

// Close 关闭消费者
func (c *TracedKafkaConsumer) Close() error {
    return c.consumer.Close()
}
```

### 3.3 使用示例

```go
func main() {
    tp := initTracer()
    defer tp.Shutdown(context.Background())

    // 生产者
    producer, _ := NewTracedKafkaProducer([]string{"localhost:9092"})
    defer producer.Close()

    ctx := context.Background()
    producer.SendMessage(ctx, "my-topic", []byte("key1"), []byte("Hello Kafka"))

    // 消费者
    consumer, _ := NewTracedKafkaConsumer([]string{"localhost:9092"}, "my-group")
    defer consumer.Close()

    consumer.Consume(ctx, []string{"my-topic"}, func(ctx context.Context, msg *sarama.ConsumerMessage) error {
        log.Printf("Received: %s", string(msg.Value))
        return nil
    })
}
```

---

## 4. RabbitMQ 集成

### 4.1 RabbitMQ 生产者

```go
import (
    amqp "github.com/rabbitmq/amqp091-go"
)

// TracedRabbitMQProducer 包装 RabbitMQ 生产者并提供追踪
type TracedRabbitMQProducer struct {
    channel    *amqp.Channel
    tracer     trace.Tracer
    propagator propagation.TextMapPropagator
}

// NewTracedRabbitMQProducer 创建带追踪的 RabbitMQ 生产者
func NewTracedRabbitMQProducer(conn *amqp.Connection) (*TracedRabbitMQProducer, error) {
    channel, err := conn.Channel()
    if err != nil {
        return nil, err
    }

    return &TracedRabbitMQProducer{
        channel:    channel,
        tracer:     otel.Tracer("rabbitmq-producer"),
        propagator: otel.GetTextMapPropagator(),
    }, nil
}

// Publish 发布消息并追踪
func (p *TracedRabbitMQProducer) Publish(ctx context.Context, exchange, routingKey string, body []byte) error {
    ctx, span := p.tracer.Start(ctx, "publish "+exchange,
        trace.WithSpanKind(trace.SpanKindProducer),
        trace.WithAttributes(
            semconv.MessagingSystemKey.String("rabbitmq"),
            semconv.MessagingDestinationName(exchange),
            semconv.MessagingOperationKey.String("publish"),
            attribute.String("messaging.rabbitmq.destination.routing_key", routingKey),
            attribute.Int("messaging.message.payload_size_bytes", len(body)),
        ),
    )
    defer span.End()

    // 创建消息
    msg := amqp.Publishing{
        ContentType: "text/plain",
        Body:        body,
        Headers:     amqp.Table{},
    }

    // 注入追踪上下文到消息头
    p.propagator.Inject(ctx, &rabbitMQHeaderCarrier{headers: &msg.Headers})

    // 发布消息
    err := p.channel.PublishWithContext(ctx, exchange, routingKey, false, false, msg)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }

    span.SetStatus(codes.Ok, "")
    return nil
}

// rabbitMQHeaderCarrier 用于在 RabbitMQ 消息头中传播追踪上下文
type rabbitMQHeaderCarrier struct {
    headers *amqp.Table
}

func (c *rabbitMQHeaderCarrier) Get(key string) string {
    if val, ok := (*c.headers)[key]; ok {
        if str, ok := val.(string); ok {
            return str
        }
    }
    return ""
}

func (c *rabbitMQHeaderCarrier) Set(key, value string) {
    (*c.headers)[key] = value
}

func (c *rabbitMQHeaderCarrier) Keys() []string {
    keys := make([]string, 0, len(*c.headers))
    for k := range *c.headers {
        keys = append(keys, k)
    }
    return keys
}
```

### 4.2 RabbitMQ 消费者

```go
// TracedRabbitMQConsumer 包装 RabbitMQ 消费者并提供追踪
type TracedRabbitMQConsumer struct {
    channel    *amqp.Channel
    tracer     trace.Tracer
    propagator propagation.TextMapPropagator
}

// NewTracedRabbitMQConsumer 创建带追踪的 RabbitMQ 消费者
func NewTracedRabbitMQConsumer(conn *amqp.Connection) (*TracedRabbitMQConsumer, error) {
    channel, err := conn.Channel()
    if err != nil {
        return nil, err
    }

    return &TracedRabbitMQConsumer{
        channel:    channel,
        tracer:     otel.Tracer("rabbitmq-consumer"),
        propagator: otel.GetTextMapPropagator(),
    }, nil
}

// Consume 消费消息并追踪
func (c *TracedRabbitMQConsumer) Consume(ctx context.Context, queue string, handler func(context.Context, amqp.Delivery) error) error {
    msgs, err := c.channel.Consume(queue, "", false, false, false, false, nil)
    if err != nil {
        return err
    }

    for msg := range msgs {
        // 从消息头提取追踪上下文
        msgCtx := c.propagator.Extract(context.Background(), &rabbitMQHeaderCarrier{headers: &msg.Headers})

        // 创建消费者 Span
        msgCtx, span := c.tracer.Start(msgCtx, "receive "+queue,
            trace.WithSpanKind(trace.SpanKindConsumer),
            trace.WithAttributes(
                semconv.MessagingSystemKey.String("rabbitmq"),
                semconv.MessagingDestinationName(queue),
                semconv.MessagingOperationKey.String("receive"),
                attribute.Int64("messaging.rabbitmq.message.delivery_tag", int64(msg.DeliveryTag)),
                attribute.Int("messaging.message.payload_size_bytes", len(msg.Body)),
            ),
        )

        // 调用处理器
        err := handler(msgCtx, msg)
        if err != nil {
            span.RecordError(err)
            span.SetStatus(codes.Error, err.Error())
            msg.Nack(false, true) // 拒绝并重新入队
        } else {
            span.SetStatus(codes.Ok, "")
            msg.Ack(false)
        }

        span.End()

        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
        }
    }

    return nil
}
```

---

## 5. NATS 集成

### 5.1 NATS 生产者

```go
import (
    "github.com/nats-io/nats.go"
)

// TracedNATSProducer 包装 NATS 发布者并提供追踪
type TracedNATSProducer struct {
    conn       *nats.Conn
    tracer     trace.Tracer
    propagator propagation.TextMapPropagator
}

// NewTracedNATSProducer 创建带追踪的 NATS 发布者
func NewTracedNATSProducer(url string) (*TracedNATSProducer, error) {
    conn, err := nats.Connect(url)
    if err != nil {
        return nil, err
    }

    return &TracedNATSProducer{
        conn:       conn,
        tracer:     otel.Tracer("nats-producer"),
        propagator: otel.GetTextMapPropagator(),
    }, nil
}

// Publish 发布消息并追踪
func (p *TracedNATSProducer) Publish(ctx context.Context, subject string, data []byte) error {
    ctx, span := p.tracer.Start(ctx, "publish "+subject,
        trace.WithSpanKind(trace.SpanKindProducer),
        trace.WithAttributes(
            semconv.MessagingSystemKey.String("nats"),
            semconv.MessagingDestinationName(subject),
            semconv.MessagingOperationKey.String("publish"),
            attribute.String("messaging.nats.subject", subject),
            attribute.Int("messaging.message.payload_size_bytes", len(data)),
        ),
    )
    defer span.End()

    // 创建消息
    msg := &nats.Msg{
        Subject: subject,
        Data:    data,
        Header:  nats.Header{},
    }

    // 注入追踪上下文到消息头
    p.propagator.Inject(ctx, &natsHeaderCarrier{header: &msg.Header})

    // 发布消息
    err := p.conn.PublishMsg(msg)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }

    span.SetStatus(codes.Ok, "")
    return nil
}

// natsHeaderCarrier 用于在 NATS 消息头中传播追踪上下文
type natsHeaderCarrier struct {
    header *nats.Header
}

func (c *natsHeaderCarrier) Get(key string) string {
    return c.header.Get(key)
}

func (c *natsHeaderCarrier) Set(key, value string) {
    c.header.Set(key, value)
}

func (c *natsHeaderCarrier) Keys() []string {
    keys := make([]string, 0, len(*c.header))
    for k := range *c.header {
        keys = append(keys, k)
    }
    return keys
}
```

### 5.2 NATS 消费者

```go
// TracedNATSConsumer 包装 NATS 订阅者并提供追踪
type TracedNATSConsumer struct {
    conn       *nats.Conn
    tracer     trace.Tracer
    propagator propagation.TextMapPropagator
}

// NewTracedNATSConsumer 创建带追踪的 NATS 订阅者
func NewTracedNATSConsumer(url string) (*TracedNATSConsumer, error) {
    conn, err := nats.Connect(url)
    if err != nil {
        return nil, err
    }

    return &TracedNATSConsumer{
        conn:       conn,
        tracer:     otel.Tracer("nats-consumer"),
        propagator: otel.GetTextMapPropagator(),
    }, nil
}

// Subscribe 订阅主题并追踪
func (c *TracedNATSConsumer) Subscribe(subject string, handler func(context.Context, *nats.Msg) error) (*nats.Subscription, error) {
    return c.conn.Subscribe(subject, func(msg *nats.Msg) {
        // 从消息头提取追踪上下文
        ctx := c.propagator.Extract(context.Background(), &natsHeaderCarrier{header: &msg.Header})

        // 创建消费者 Span
        ctx, span := c.tracer.Start(ctx, "receive "+subject,
            trace.WithSpanKind(trace.SpanKindConsumer),
            trace.WithAttributes(
                semconv.MessagingSystemKey.String("nats"),
                semconv.MessagingDestinationName(subject),
                semconv.MessagingOperationKey.String("receive"),
                attribute.String("messaging.nats.subject", subject),
                attribute.Int("messaging.message.payload_size_bytes", len(msg.Data)),
            ),
        )
        defer span.End()

        // 调用处理器
        err := handler(ctx, msg)
        if err != nil {
            span.RecordError(err)
            span.SetStatus(codes.Error, err.Error())
        } else {
            span.SetStatus(codes.Ok, "")
        }
    })
}
```

---

## 6. 生产者追踪

### 6.1 批量发送

```go
// BatchSendMessages 批量发送消息并追踪
func (p *TracedKafkaProducer) BatchSendMessages(ctx context.Context, topic string, messages [][]byte) error {
    ctx, span := p.tracer.Start(ctx, "batch_publish "+topic,
        trace.WithSpanKind(trace.SpanKindProducer),
        trace.WithAttributes(
            semconv.MessagingSystemKey.String("kafka"),
            semconv.MessagingDestinationName(topic),
            attribute.Int("messaging.batch.message_count", len(messages)),
        ),
    )
    defer span.End()

    var totalSize int
    for i, msg := range messages {
        err := p.SendMessage(ctx, topic, nil, msg)
        if err != nil {
            span.AddEvent("message_failed", trace.WithAttributes(
                attribute.Int("message.index", i),
            ))
            return err
        }
        totalSize += len(msg)
    }

    span.SetAttributes(
        attribute.Int("messaging.batch.total_size_bytes", totalSize),
    )

    span.SetStatus(codes.Ok, "")
    return nil
}
```

---

## 7. 消费者追踪

### 7.1 并发消费

```go
// ConcurrentConsume 并发消费消息
func (c *TracedKafkaConsumer) ConcurrentConsume(ctx context.Context, topics []string, 
    handler func(context.Context, *sarama.ConsumerMessage) error, workers int) error {

    sem := make(chan struct{}, workers)

    consumerHandler := &concurrentConsumerGroupHandler{
        tracer:     c.tracer,
        propagator: c.propagator,
        handler:    handler,
        sem:        sem,
    }

    return c.consumer.Consume(ctx, topics, consumerHandler)
}

type concurrentConsumerGroupHandler struct {
    tracer     trace.Tracer
    propagator propagation.TextMapPropagator
    handler    func(context.Context, *sarama.ConsumerMessage) error
    sem        chan struct{}
}

func (h *concurrentConsumerGroupHandler) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
    for msg := range claim.Messages() {
        h.sem <- struct{}{} // 获取信号量

        go func(msg *sarama.ConsumerMessage) {
            defer func() { <-h.sem }() // 释放信号量

            ctx := h.propagator.Extract(context.Background(), &kafkaHeaderCarrier{headers: &msg.Headers})
            ctx, span := h.tracer.Start(ctx, "process "+msg.Topic,
                trace.WithSpanKind(trace.SpanKindConsumer),
            )
            defer span.End()

            if err := h.handler(ctx, msg); err != nil {
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
            } else {
                span.SetStatus(codes.Ok, "")
                session.MarkMessage(msg, "")
            }
        }(msg)
    }

    return nil
}
```

---

## 8. 批量处理

### 8.1 批量消费

```go
// BatchConsume 批量消费消息
func (c *TracedKafkaConsumer) BatchConsume(ctx context.Context, topics []string, 
    batchSize int, handler func(context.Context, []*sarama.ConsumerMessage) error) error {

    batchHandler := &batchConsumerGroupHandler{
        tracer:     c.tracer,
        propagator: c.propagator,
        handler:    handler,
        batchSize:  batchSize,
    }

    return c.consumer.Consume(ctx, topics, batchHandler)
}

type batchConsumerGroupHandler struct {
    tracer     trace.Tracer
    propagator propagation.TextMapPropagator
    handler    func(context.Context, []*sarama.ConsumerMessage) error
    batchSize  int
}

func (h *batchConsumerGroupHandler) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
    batch := make([]*sarama.ConsumerMessage, 0, h.batchSize)

    for msg := range claim.Messages() {
        batch = append(batch, msg)

        if len(batch) >= h.batchSize {
            if err := h.processBatch(session, batch); err != nil {
                return err
            }
            batch = batch[:0]
        }
    }

    // 处理剩余消息
    if len(batch) > 0 {
        return h.processBatch(session, batch)
    }

    return nil
}

func (h *batchConsumerGroupHandler) processBatch(session sarama.ConsumerGroupSession, batch []*sarama.ConsumerMessage) error {
    if len(batch) == 0 {
        return nil
    }

    // 从第一条消息提取上下文
    ctx := h.propagator.Extract(context.Background(), &kafkaHeaderCarrier{headers: &batch[0].Headers})

    ctx, span := h.tracer.Start(ctx, "batch_process "+batch[0].Topic,
        trace.WithSpanKind(trace.SpanKindConsumer),
        trace.WithAttributes(
            semconv.MessagingSystemKey.String("kafka"),
            attribute.Int("messaging.batch.message_count", len(batch)),
        ),
    )
    defer span.End()

    err := h.handler(ctx, batch)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }

    // 标记所有消息为已处理
    for _, msg := range batch {
        session.MarkMessage(msg, "")
    }

    span.SetStatus(codes.Ok, "")
    return nil
}
```

---

## 9. 完整实现

```go
package main

import (
    "context"
    "log"

    "github.com/IBM/sarama"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

func main() {
    // 初始化追踪
    tp := initTracer()
    defer tp.Shutdown(context.Background())

    // 启动生产者
    go runProducer()

    // 启动消费者
    runConsumer()
}

func runProducer() {
    producer, err := NewTracedKafkaProducer([]string{"localhost:9092"})
    if err != nil {
        log.Fatal(err)
    }
    defer producer.Close()

    ctx := context.Background()
    for i := 0; i < 10; i++ {
        err := producer.SendMessage(ctx, "my-topic", nil, []byte(fmt.Sprintf("Message %d", i)))
        if err != nil {
            log.Printf("Send error: %v", err)
        } else {
            log.Printf("Sent message %d", i)
        }
        time.Sleep(1 * time.Second)
    }
}

func runConsumer() {
    consumer, err := NewTracedKafkaConsumer([]string{"localhost:9092"}, "my-group")
    if err != nil {
        log.Fatal(err)
    }
    defer consumer.Close()

    ctx := context.Background()
    consumer.Consume(ctx, []string{"my-topic"}, func(ctx context.Context, msg *sarama.ConsumerMessage) error {
        log.Printf("Received: %s (offset: %d)", string(msg.Value), msg.Offset)
        
        // 模拟业务处理
        time.Sleep(100 * time.Millisecond)
        
        return nil
    })
}

func initTracer() *sdktrace.TracerProvider {
    exporter, _ := otlptracegrpc.New(context.Background(),
        otlptracegrpc.WithEndpoint("localhost:4317"),
        otlptracegrpc.WithInsecure(),
    )

    resource := resource.NewWithAttributes(
        semconv.SchemaURL,
        semconv.ServiceName("messaging-app"),
        semconv.ServiceVersion("1.0.0"),
    )

    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter),
        sdktrace.WithResource(resource),
    )

    otel.SetTracerProvider(tp)
    return tp
}
```

---

## 10. 最佳实践

### 10.1 错误重试

```go
// RetryableConsumer 支持重试的消费者
type RetryableConsumer struct {
    consumer   *TracedKafkaConsumer
    maxRetries int
    backoff    time.Duration
}

func (c *RetryableConsumer) ConsumeWithRetry(ctx context.Context, topics []string,
    handler func(context.Context, *sarama.ConsumerMessage) error) error {

    return c.consumer.Consume(ctx, topics, func(ctx context.Context, msg *sarama.ConsumerMessage) error {
        span := trace.SpanFromContext(ctx)
        
        var lastErr error
        for attempt := 0; attempt <= c.maxRetries; attempt++ {
            if attempt > 0 {
                span.AddEvent("retry_attempt", trace.WithAttributes(
                    attribute.Int("attempt", attempt),
                ))
                time.Sleep(c.backoff * time.Duration(attempt))
            }

            err := handler(ctx, msg)
            if err == nil {
                span.SetAttributes(attribute.Int("retry.count", attempt))
                return nil
            }

            lastErr = err
        }

        return lastErr
    })
}
```

### 10.2 死信队列

```go
// DeadLetterProducer 死信队列生产者
type DeadLetterProducer struct {
    producer *TracedKafkaProducer
    dlqTopic string
}

func (p *DeadLetterProducer) SendToDeadLetter(ctx context.Context, msg *sarama.ConsumerMessage, err error) error {
    span := trace.SpanFromContext(ctx)
    span.AddEvent("send_to_dead_letter", trace.WithAttributes(
        attribute.String("original_topic", msg.Topic),
        attribute.String("error", err.Error()),
    ))

    return p.producer.SendMessage(ctx, p.dlqTopic, msg.Key, msg.Value)
}
```

### 10.3 性能监控

```go
// MessagingMetrics 消息队列指标
type MessagingMetrics struct {
    messagesProduced metric.Int64Counter
    messagesConsumed metric.Int64Counter
    processingTime   metric.Float64Histogram
}

func NewMessagingMetrics() *MessagingMetrics {
    meter := otel.Meter("messaging")

    produced, _ := meter.Int64Counter("messaging.messages.produced")
    consumed, _ := meter.Int64Counter("messaging.messages.consumed")
    processingTime, _ := meter.Float64Histogram("messaging.processing.duration",
        metric.WithUnit("ms"),
    )

    return &MessagingMetrics{
        messagesProduced: produced,
        messagesConsumed: consumed,
        processingTime:   processingTime,
    }
}
```

---

## 总结

✅ **核心属性**: `messaging.system`, `messaging.destination.name`, `messaging.operation`  
✅ **Kafka**: 生产者、消费者、批量处理  
✅ **RabbitMQ**: 发布、订阅、确认机制  
✅ **NATS**: 发布-订阅模式  
✅ **高级功能**: 并发消费、批量处理、死信队列  
✅ **最佳实践**: 错误重试、性能监控、追踪上下文传播

**下一步**: 参见 `06_网络与连接.md` 了解网络层追踪。
