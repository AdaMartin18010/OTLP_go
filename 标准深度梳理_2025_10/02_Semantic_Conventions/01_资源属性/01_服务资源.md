# 服务资源属性 (Service Resource Attributes)

> **文档版本**: v1.0.0  
> **OpenTelemetry 版本**: v1.32.0  
> **语义约定版本**: v1.28.0  
> **最后更新**: 2025年10月9日

---

## 📋 目录

- [服务资源属性 (Service Resource Attributes)](#服务资源属性-service-resource-attributes)
  - [📋 目录](#-目录)
  - [概述](#概述)
    - [服务资源的定义](#服务资源的定义)
    - [为什么需要服务资源属性?](#为什么需要服务资源属性)
  - [核心属性](#核心属性)
    - [1. 必需属性](#1-必需属性)
    - [2. 推荐属性](#2-推荐属性)
    - [3. 完整属性列表](#3-完整属性列表)
  - [属性详解](#属性详解)
    - [1. service.name (必需)](#1-servicename-必需)
    - [2. service.namespace](#2-servicenamespace)
    - [3. service.version](#3-serviceversion)
    - [4. service.instance.id](#4-serviceinstanceid)
  - [Go 实现](#go-实现)
    - [1. 基础实现](#1-基础实现)
    - [2. 从环境变量配置](#2-从环境变量配置)
    - [3. Kubernetes 集成](#3-kubernetes-集成)
  - [最佳实践](#最佳实践)
    - [1. 服务命名规范](#1-服务命名规范)
    - [2. 版本管理](#2-版本管理)
    - [3. 实例 ID 生成](#3-实例-id-生成)
  - [常见问题](#常见问题)
    - [Q1: service.name 和应用程序名称的区别?](#q1-servicename-和应用程序名称的区别)
    - [Q2: 是否必须设置 service.namespace?](#q2-是否必须设置-servicenamespace)
    - [Q3: service.instance.id 应该如何保持稳定?](#q3-serviceinstanceid-应该如何保持稳定)
    - [Q4: 如何处理服务名称变更?](#q4-如何处理服务名称变更)
  - [参考资源](#参考资源)
    - [官方文档](#官方文档)
    - [相关规范](#相关规范)

---

## 概述

### 服务资源的定义

**形式化定义**:

```text
Service = (ServiceName, ServiceNamespace, ServiceVersion, ServiceInstanceId)

其中:
- ServiceName: 服务逻辑名称 (必需)
- ServiceNamespace: 服务命名空间 (可选)
- ServiceVersion: 服务版本号 (推荐)
- ServiceInstanceId: 服务实例唯一标识 (推荐)
```

### 为什么需要服务资源属性?

```text
1. 服务识别
   - 在分布式系统中唯一标识服务
   - 区分不同服务的遥测数据

2. 版本管理
   - 跟踪不同版本的行为
   - 支持金丝雀发布和 A/B 测试

3. 实例管理
   - 识别特定服务实例
   - 故障定位和负载分析

4. 组织管理
   - 通过命名空间组织服务
   - 支持多租户架构
```

---

## 核心属性

### 1. 必需属性

| 属性名 | 类型 | 描述 | 示例 |
|-------|------|------|------|
| `service.name` | string | 服务的逻辑名称 | `order-service` |

### 2. 推荐属性

| 属性名 | 类型 | 描述 | 示例 |
|-------|------|------|------|
| `service.namespace` | string | 服务命名空间 | `production` |
| `service.version` | string | 服务版本 | `1.2.3` |
| `service.instance.id` | string | 服务实例 ID | `order-service-7b9f8c-xyz12` |

### 3. 完整属性列表

| 属性名 | 类型 | 必需性 | 描述 |
|-------|------|--------|------|
| `service.name` | string | **必需** | 服务逻辑名称 |
| `service.namespace` | string | 推荐 | 服务命名空间 |
| `service.version` | string | 推荐 | 服务版本 |
| `service.instance.id` | string | 推荐 | 服务实例唯一标识符 |

---

## 属性详解

### 1. service.name (必需)

**定义**: 服务的逻辑名称,用于在分布式系统中唯一标识服务。

**命名规范**:

```text
✅ 推荐:
  - 使用 kebab-case: order-service, user-api
  - 使用 snake_case: order_service, user_api
  - 简短且描述性: payment, auth, billing
  
❌ 避免:
  - 包含环境信息: order-service-prod
  - 包含版本信息: order-service-v2
  - 包含实例信息: order-service-instance-1
  - 过长的名称: order-management-microservice-api
```

**示例**:

```go
// 好的命名
service.name = "order-service"
service.name = "user-api"
service.name = "payment-gateway"

// 不好的命名
service.name = "order-service-production-v2-instance-1"  // 太长且包含环境/版本信息
service.name = "srv1"                                    // 太短且不描述性
```

### 2. service.namespace

**定义**: 服务命名空间,用于组织和隔离服务。

**使用场景**:

```text
1. 环境隔离:
   - production
   - staging
   - development

2. 团队隔离:
   - team-alpha
   - team-beta
   - team-charlie

3. 租户隔离:
   - tenant-1
   - tenant-2
   - customer-xyz

4. 区域隔离:
   - us-east
   - eu-west
   - asia-pacific
```

**命名建议**:

```text
环境命名空间:
  production, staging, development, test

团队命名空间:
  team-<name>, org-<name>

租户命名空间:
  tenant-<id>, customer-<name>

混合命名空间 (用点分隔):
  production.us-east
  staging.team-alpha
  production.tenant-123
```

### 3. service.version

**定义**: 服务的版本号,遵循语义化版本规范。

**版本格式**:

```text
语义化版本 (Semantic Versioning):
  MAJOR.MINOR.PATCH
  
示例:
  1.0.0 - 初始发布
  1.1.0 - 新功能
  1.1.1 - Bug 修复
  2.0.0 - 破坏性变更

Git SHA (适用于持续部署):
  abcd1234
  v1.2.3-g1234567

构建版本:
  1.2.3-build.123
  1.2.3+20240101120000
```

**示例**:

```go
// 语义化版本
service.version = "1.2.3"

// Git SHA
service.version = "abc1234"

// 带元数据的版本
service.version = "1.2.3-beta.1"
service.version = "1.2.3+20240101"
```

### 4. service.instance.id

**定义**: 服务实例的唯一标识符。

**生成策略**:

```text
1. Kubernetes Pod Name:
   order-service-7b9f8c-xyz12

2. 容器 ID:
   container://abc123def456

3. 主机名 + PID:
   host-123.prod.example.com:12345

4. UUID:
   550e8400-e29b-41d4-a716-446655440000

5. 自定义格式:
   <service>-<region>-<timestamp>-<random>
   order-service-us-east-1234567890-abc
```

**示例**:

```go
// Kubernetes
service.instance.id = "order-service-7b9f8c-xyz12"

// 容器
service.instance.id = "container://abc123def456"

// 主机名 + PID
hostname, _ := os.Hostname()
pid := os.Getpid()
service.instance.id = fmt.Sprintf("%s:%d", hostname, pid)

// UUID
service.instance.id = uuid.New().String()
```

---

## Go 实现

### 1. 基础实现

```go
package main

import (
    "context"
    "fmt"
    "log"
    "os"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

func initTracer() (*sdktrace.TracerProvider, error) {
    ctx := context.Background()

    // 1. 创建 OTLP 导出器
    exporter, err := otlptracegrpc.New(ctx,
        otlptracegrpc.WithInsecure(),
        otlptracegrpc.WithEndpoint("localhost:4317"),
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create exporter: %w", err)
    }

    // 2. 创建服务资源
    res, err := resource.New(ctx,
        resource.WithAttributes(
            // 必需: 服务名称
            semconv.ServiceName("order-service"),
            
            // 推荐: 服务命名空间
            semconv.ServiceNamespace("production"),
            
            // 推荐: 服务版本
            semconv.ServiceVersion("1.2.3"),
            
            // 推荐: 服务实例 ID
            semconv.ServiceInstanceID(getInstanceID()),
        ),
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create resource: %w", err)
    }

    // 3. 创建 TracerProvider
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter),
        sdktrace.WithResource(res),
    )

    otel.SetTracerProvider(tp)
    return tp, nil
}

// getInstanceID 获取实例 ID
func getInstanceID() string {
    // 优先使用环境变量 (Kubernetes Pod Name)
    if instanceID := os.Getenv("HOSTNAME"); instanceID != "" {
        return instanceID
    }

    // 备用方案: 主机名 + PID
    hostname, _ := os.Hostname()
    pid := os.Getpid()
    return fmt.Sprintf("%s:%d", hostname, pid)
}

func main() {
    // 初始化 Tracer
    tp, err := initTracer()
    if err != nil {
        log.Fatalf("Failed to initialize tracer: %v", err)
    }
    defer func() {
        if err := tp.Shutdown(context.Background()); err != nil {
            log.Printf("Error shutting down tracer provider: %v", err)
        }
    }()

    // 创建 Tracer
    tracer := otel.Tracer("order-service")

    // 创建 Span
    ctx := context.Background()
    ctx, span := tracer.Start(ctx, "process-order")
    defer span.End()

    // 业务逻辑
    fmt.Println("Processing order...")
}
```

### 2. 从环境变量配置

```go
package config

import (
    "os"

    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// ServiceConfig 服务配置
type ServiceConfig struct {
    Name        string
    Namespace   string
    Version     string
    InstanceID  string
}

// NewServiceConfigFromEnv 从环境变量创建服务配置
func NewServiceConfigFromEnv() *ServiceConfig {
    return &ServiceConfig{
        Name:       getEnv("SERVICE_NAME", "unknown-service"),
        Namespace:  getEnv("SERVICE_NAMESPACE", ""),
        Version:    getEnv("SERVICE_VERSION", "unknown"),
        InstanceID: getEnv("SERVICE_INSTANCE_ID", getDefaultInstanceID()),
    }
}

// ToResource 转换为 Resource
func (c *ServiceConfig) ToResource(ctx context.Context) (*resource.Resource, error) {
    attrs := []attribute.KeyValue{
        semconv.ServiceName(c.Name),
    }

    if c.Namespace != "" {
        attrs = append(attrs, semconv.ServiceNamespace(c.Namespace))
    }

    if c.Version != "" {
        attrs = append(attrs, semconv.ServiceVersion(c.Version))
    }

    if c.InstanceID != "" {
        attrs = append(attrs, semconv.ServiceInstanceID(c.InstanceID))
    }

    return resource.New(ctx, resource.WithAttributes(attrs...))
}

// getEnv 获取环境变量,带默认值
func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

// getDefaultInstanceID 获取默认实例 ID
func getDefaultInstanceID() string {
    // Kubernetes Pod Name
    if hostname := os.Getenv("HOSTNAME"); hostname != "" {
        return hostname
    }

    // 容器 ID
    if containerID := os.Getenv("CONTAINER_ID"); containerID != "" {
        return containerID
    }

    // 主机名 + PID
    hostname, _ := os.Hostname()
    pid := os.Getpid()
    return fmt.Sprintf("%s:%d", hostname, pid)
}
```

### 3. Kubernetes 集成

```go
package k8s

import (
    "context"
    "fmt"
    "os"

    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// NewK8sResource 创建 Kubernetes 服务资源
func NewK8sResource(ctx context.Context, serviceName string) (*resource.Resource, error) {
    return resource.New(ctx,
        // 服务属性
        resource.WithAttributes(
            semconv.ServiceName(serviceName),
            semconv.ServiceNamespace(os.Getenv("K8S_NAMESPACE")),
            semconv.ServiceVersion(os.Getenv("APP_VERSION")),
            semconv.ServiceInstanceID(os.Getenv("HOSTNAME")), // Pod Name
        ),
        
        // Kubernetes 检测器 (自动检测 K8s 环境)
        resource.WithFromEnv(),
        resource.WithProcess(),
        resource.WithOS(),
        resource.WithContainer(),
        resource.WithHost(),
    )
}

// Kubernetes Deployment 示例
/*
apiVersion: apps/v1
kind: Deployment
metadata:
  name: order-service
spec:
  template:
    spec:
      containers:
      - name: order-service
        image: order-service:1.2.3
        env:
        # 服务属性
        - name: SERVICE_NAME
          value: "order-service"
        - name: SERVICE_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: APP_VERSION
          value: "1.2.3"
        - name: K8S_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        # Pod 信息 (HOSTNAME 自动设置为 Pod Name)
*/
```

---

## 最佳实践

### 1. 服务命名规范

```text
✅ 好的实践:

1. 使用一致的命名风格
   order-service, user-service, payment-service

2. 反映服务职责
   auth (认证), billing (计费), notification (通知)

3. 简短且描述性
   api, gateway, worker

4. 避免技术细节
   ✓ order-service
   ✗ order-service-java-springboot

❌ 避免的实践:

1. 包含环境信息
   ✗ order-service-prod

2. 包含版本信息
   ✗ order-service-v2

3. 包含实例信息
   ✗ order-service-1

4. 使用不一致的风格
   ✗ orderService, order_api, OrderSvc
```

### 2. 版本管理

```go
package version

import (
    "fmt"
    "runtime/debug"
)

// 通过 ldflags 注入版本信息
var (
    Version   = "dev"
    GitCommit = "unknown"
    BuildTime = "unknown"
)

// GetVersion 获取版本字符串
func GetVersion() string {
    if Version != "dev" {
        return Version
    }

    // 尝试从 build info 获取
    if info, ok := debug.ReadBuildInfo(); ok {
        return info.Main.Version
    }

    return "unknown"
}

// GetFullVersion 获取完整版本信息
func GetFullVersion() string {
    return fmt.Sprintf("%s (commit: %s, built: %s)", 
        GetVersion(), GitCommit, BuildTime)
}

// 构建时注入版本:
// go build -ldflags "-X main.Version=1.2.3 -X main.GitCommit=$(git rev-parse --short HEAD) -X main.BuildTime=$(date -u +%Y%m%d%H%M%S)"
```

### 3. 实例 ID 生成

```go
package instance

import (
    "crypto/rand"
    "encoding/hex"
    "fmt"
    "os"
)

// GenerateInstanceID 生成实例 ID
func GenerateInstanceID(serviceName string) string {
    // 优先级1: Kubernetes Pod Name
    if podName := os.Getenv("HOSTNAME"); podName != "" {
        return podName
    }

    // 优先级2: 容器 ID
    if containerID := os.Getenv("CONTAINER_ID"); containerID != "" {
        return fmt.Sprintf("container-%s", containerID[:12])
    }

    // 优先级3: 主机名 + PID
    hostname, _ := os.Hostname()
    pid := os.Getpid()
    
    // 添加随机后缀确保唯一性
    randomBytes := make([]byte, 4)
    rand.Read(randomBytes)
    randomSuffix := hex.EncodeToString(randomBytes)

    return fmt.Sprintf("%s-%s-%d-%s", 
        serviceName, hostname, pid, randomSuffix)
}
```

---

## 常见问题

### Q1: service.name 和应用程序名称的区别?

**A**: `service.name` 是逻辑服务名称,而应用程序名称可能包含环境或技术细节。

```text
应用程序名称: order-service-prod-v2-java
Service Name:  order-service

原因:
- service.name 用于识别服务的逻辑角色
- 环境、版本、技术栈应该用其他属性表示
- 保持 service.name 稳定,便于长期追踪
```

### Q2: 是否必须设置 service.namespace?

**A**: 不是必需的,但在以下场景强烈推荐:

```text
推荐设置的场景:
✓ 多环境部署 (dev/staging/prod)
✓ 多租户系统
✓ 多团队协作
✓ 多区域部署

可以不设置的场景:
- 单一环境
- 服务数量少
- 简单架构
```

### Q3: service.instance.id 应该如何保持稳定?

**A**: 取决于部署模式:

```text
Kubernetes:
- 使用 Pod Name (自动稳定)
- Pod 重启会改变 ID (符合预期)

虚拟机/裸机:
- 使用主机名 + 配置文件
- 手动管理实例 ID
- 重启后保持不变

容器:
- 使用容器 ID
- 容器重建会改变 ID
```

### Q4: 如何处理服务名称变更?

**A**:

```text
不推荐变更服务名称,因为会影响:
- 历史数据查询
- 监控告警规则
- 服务依赖关系

如果必须变更:
1. 创建别名映射
2. 逐步迁移
3. 保留历史数据访问
4. 更新所有相关配置
```

---

## 参考资源

### 官方文档

- [OpenTelemetry Semantic Conventions - Service](https://opentelemetry.io/docs/specs/semconv/resource/service/)
- [Resource Semantic Conventions](https://opentelemetry.io/docs/specs/semconv/resource/)

### 相关规范

- [Semantic Versioning](https://semver.org/)
- [Kubernetes Downward API](https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/)

---

**文档版本**: v1.0.0  
**最后更新**: 2025年10月9日  
**维护者**: OTLP 标准化项目组
