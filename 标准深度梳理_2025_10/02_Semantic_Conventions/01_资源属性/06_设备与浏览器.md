# 06 - è®¾å¤‡ä¸æµè§ˆå™¨èµ„æºå±æ€§ (device.*/ browser.*)

## ğŸ“‹ ç›®å½•

- [06 - è®¾å¤‡ä¸æµè§ˆå™¨èµ„æºå±æ€§ (device.*/ browser.*)](#06---è®¾å¤‡ä¸æµè§ˆå™¨èµ„æºå±æ€§-device-browser)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. è®¾å¤‡ä¸æµè§ˆå™¨å±æ€§æ¦‚è¿°](#1-è®¾å¤‡ä¸æµè§ˆå™¨å±æ€§æ¦‚è¿°)
    - [1.1 device.*vs browser.* å‘½åç©ºé—´](#11-devicevs-browser-å‘½åç©ºé—´)
    - [1.2 é€‚ç”¨åœºæ™¯](#12-é€‚ç”¨åœºæ™¯)
    - [1.3 åç«¯ vs å‰ç«¯æ£€æµ‹](#13-åç«¯-vs-å‰ç«¯æ£€æµ‹)
  - [2. è®¾å¤‡çº§åˆ«å±æ€§ (device.\*)](#2-è®¾å¤‡çº§åˆ«å±æ€§-device)
    - [2.1 device.\* æ ‡å‡†å±æ€§](#21-device-æ ‡å‡†å±æ€§)
    - [2.2 è®¾å¤‡æ ‡è¯† (ID/Model)](#22-è®¾å¤‡æ ‡è¯†-idmodel)
    - [2.3 è®¾å¤‡åˆ¶é€ å•†](#23-è®¾å¤‡åˆ¶é€ å•†)
    - [2.4 ç§»åŠ¨è®¾å¤‡ç‰¹æœ‰å±æ€§](#24-ç§»åŠ¨è®¾å¤‡ç‰¹æœ‰å±æ€§)
  - [3. æµè§ˆå™¨çº§åˆ«å±æ€§ (browser.\*)](#3-æµè§ˆå™¨çº§åˆ«å±æ€§-browser)
    - [3.1 browser.\* æ ‡å‡†å±æ€§](#31-browser-æ ‡å‡†å±æ€§)
    - [3.2 æµè§ˆå™¨æ ‡è¯† (Brand/Version)](#32-æµè§ˆå™¨æ ‡è¯†-brandversion)
    - [3.3 æµè§ˆå™¨è¯­è¨€å’Œå¹³å°](#33-æµè§ˆå™¨è¯­è¨€å’Œå¹³å°)
    - [3.4 ç”¨æˆ·ä»£ç† (User-Agent)](#34-ç”¨æˆ·ä»£ç†-user-agent)
  - [4. Go åç«¯å®ç° - User-Agent è§£æ](#4-go-åç«¯å®ç°---user-agent-è§£æ)
    - [4.1 åŸºç¡€ User-Agent è§£æ](#41-åŸºç¡€-user-agent-è§£æ)
    - [4.2 ä½¿ç”¨ ua-parser åº“](#42-ä½¿ç”¨-ua-parser-åº“)
    - [4.3 è®¾å¤‡ç±»å‹æ£€æµ‹](#43-è®¾å¤‡ç±»å‹æ£€æµ‹)
    - [4.4 æµè§ˆå™¨ç‰¹æ€§æ£€æµ‹](#44-æµè§ˆå™¨ç‰¹æ€§æ£€æµ‹)
  - [5. Go åç«¯å®ç° - HTTP Headers æå–](#5-go-åç«¯å®ç°---http-headers-æå–)
    - [5.1 æ ‡å‡† HTTP Headers](#51-æ ‡å‡†-http-headers)
    - [5.2 Client Hints API](#52-client-hints-api)
    - [5.3 ä¸­é—´ä»¶é›†æˆ](#53-ä¸­é—´ä»¶é›†æˆ)
    - [5.4 Context ä¼ æ’­](#54-context-ä¼ æ’­)
  - [6. å‰ç«¯ JavaScript æ£€æµ‹](#6-å‰ç«¯-javascript-æ£€æµ‹)
    - [6.1 æµè§ˆå™¨ä¿¡æ¯è·å–](#61-æµè§ˆå™¨ä¿¡æ¯è·å–)
    - [6.2 è®¾å¤‡ä¿¡æ¯è·å–](#62-è®¾å¤‡ä¿¡æ¯è·å–)
    - [6.3 å±å¹•ä¿¡æ¯](#63-å±å¹•ä¿¡æ¯)
    - [6.4 ç½‘ç»œä¿¡æ¯](#64-ç½‘ç»œä¿¡æ¯)
  - [7. OpenTelemetry Browser SDK é›†æˆ](#7-opentelemetry-browser-sdk-é›†æˆ)
    - [7.1 Browser SDK åˆå§‹åŒ–](#71-browser-sdk-åˆå§‹åŒ–)
    - [7.2 èµ„æºæ£€æµ‹å™¨](#72-èµ„æºæ£€æµ‹å™¨)
    - [7.3 è‡ªåŠ¨æ’æ¡©](#73-è‡ªåŠ¨æ’æ¡©)
    - [7.4 å‰åç«¯å…³è”](#74-å‰åç«¯å…³è”)
  - [9. å®Œæ•´ç¤ºä¾‹](#9-å®Œæ•´ç¤ºä¾‹)
    - [9.1 Go HTTP æœåŠ¡å™¨](#91-go-http-æœåŠ¡å™¨)
    - [9.2 å‰ç«¯ SPA åº”ç”¨](#92-å‰ç«¯-spa-åº”ç”¨)
    - [9.3 å…¨æ ˆè¿½è¸ª](#93-å…¨æ ˆè¿½è¸ª)
  - [10. æœ€ä½³å®è·µ](#10-æœ€ä½³å®è·µ)
    - [10.1 éšç§è€ƒè™‘](#101-éšç§è€ƒè™‘)
    - [10.2 æ€§èƒ½ä¼˜åŒ–](#102-æ€§èƒ½ä¼˜åŒ–)
    - [10.3 å‡†ç¡®æ€§ä¿è¯](#103-å‡†ç¡®æ€§ä¿è¯)
    - [10.4 è·¨å¹³å°å…¼å®¹æ€§](#104-è·¨å¹³å°å…¼å®¹æ€§)
  - [11. å¸¸è§é—®é¢˜ (FAQ)](#11-å¸¸è§é—®é¢˜-faq)
    - [Q1: User-Agent è§£æå‡†ç¡®æ€§å¦‚ä½•?](#q1-user-agent-è§£æå‡†ç¡®æ€§å¦‚ä½•)
    - [Q2: Client Hints å…¼å®¹æ€§å¦‚ä½•?](#q2-client-hints-å…¼å®¹æ€§å¦‚ä½•)
    - [Q3: å¦‚ä½•é¿å…è®¾å¤‡æŒ‡çº¹è¯†åˆ«?](#q3-å¦‚ä½•é¿å…è®¾å¤‡æŒ‡çº¹è¯†åˆ«)
    - [Q4: ç§»åŠ¨åº”ç”¨å¦‚ä½•é›†æˆ?](#q4-ç§»åŠ¨åº”ç”¨å¦‚ä½•é›†æˆ)
    - [Q5: æµè§ˆå™¨èµ„æºå±æ€§ä¼šå½±å“æ€§èƒ½å—?](#q5-æµè§ˆå™¨èµ„æºå±æ€§ä¼šå½±å“æ€§èƒ½å—)
    - [Q6: å¦‚ä½•å¤„ç†çˆ¬è™«å’Œæœºå™¨äºº?](#q6-å¦‚ä½•å¤„ç†çˆ¬è™«å’Œæœºå™¨äºº)
    - [Q7: device.model.name å¦‚ä½•è·å–ç²¾ç¡®å€¼?](#q7-devicemodelname-å¦‚ä½•è·å–ç²¾ç¡®å€¼)
    - [Q8: å¦‚ä½•å…³è”å‰åç«¯ Traces?](#q8-å¦‚ä½•å…³è”å‰åç«¯-traces)
    - [Q9: æµè§ˆå™¨ç‰ˆæœ¬å˜åŒ–å¦‚ä½•è¿½è¸ª?](#q9-æµè§ˆå™¨ç‰ˆæœ¬å˜åŒ–å¦‚ä½•è¿½è¸ª)
    - [Q10: å¦‚ä½•æµ‹è¯•èµ„æºæ£€æµ‹é€»è¾‘?](#q10-å¦‚ä½•æµ‹è¯•èµ„æºæ£€æµ‹é€»è¾‘)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## 1. è®¾å¤‡ä¸æµè§ˆå™¨å±æ€§æ¦‚è¿°

### 1.1 device.*vs browser.* å‘½åç©ºé—´

**æ ¸å¿ƒæ¦‚å¿µ**:

- `device.*`: ç‰©ç†è®¾å¤‡å±æ€§ (æ‰‹æœºã€å¹³æ¿ã€æ¡Œé¢)
- `browser.*`: æµè§ˆå™¨è½¯ä»¶å±æ€§ (Chromeã€Safariã€Firefox)

**å‘½åç©ºé—´å¯¹æ¯”**:

| å‘½åç©ºé—´ | ä½œç”¨åŸŸ | ä¸»è¦ç”¨é€” | ç¤ºä¾‹ |
|----------|--------|----------|------|
| `device.*` | ç¡¬ä»¶è®¾å¤‡ | ç§»åŠ¨åº”ç”¨ã€å“åº”å¼ Web | `device.model.name`, `device.manufacturer` |
| `browser.*` | æµè§ˆå™¨è½¯ä»¶ | Web åº”ç”¨ã€å‰ç«¯è¿½è¸ª | `browser.brand`, `browser.version` |

### 1.2 é€‚ç”¨åœºæ™¯

**è®¾å¤‡å±æ€§é€‚ç”¨åœºæ™¯**:

- ç§»åŠ¨åº”ç”¨ (iOS/Android)
- å“åº”å¼ Web åº”ç”¨
- PWA (Progressive Web App)
- è·¨è®¾å¤‡ç”¨æˆ·ä½“éªŒåˆ†æ

**æµè§ˆå™¨å±æ€§é€‚ç”¨åœºæ™¯**:

- Web åº”ç”¨å‰ç«¯è¿½è¸ª
- æµè§ˆå™¨å…¼å®¹æ€§åˆ†æ
- ç”¨æˆ·è¡Œä¸ºåˆ†æ
- A/B æµ‹è¯•

### 1.3 åç«¯ vs å‰ç«¯æ£€æµ‹

**æ£€æµ‹æ–¹å¼å¯¹æ¯”**:

| æ–¹æ³• | ä½ç½® | å‡†ç¡®æ€§ | æ€§èƒ½ | éšç§ |
|------|------|--------|------|------|
| User-Agent è§£æ | åç«¯ | ä¸­ç­‰ | é«˜ | è¾ƒå¥½ |
| Client Hints | åç«¯ | é«˜ | é«˜ | å¥½ |
| JavaScript API | å‰ç«¯ | æœ€é«˜ | ä¸­ | è¾ƒå·® |
| åŸç”Ÿ SDK | ç§»åŠ¨ç«¯ | æœ€é«˜ | é«˜ | å¥½ |

**æœ€ä½³å®è·µ**:

- **Web åº”ç”¨**: ä¼˜å…ˆä½¿ç”¨ Client Hints,å¤‡é€‰ User-Agent
- **SPA/PWA**: å‰ç«¯ JavaScript æ£€æµ‹
- **ç§»åŠ¨åº”ç”¨**: ä½¿ç”¨åŸç”Ÿ SDK

---

## 2. è®¾å¤‡çº§åˆ«å±æ€§ (device.*)

### 2.1 device.* æ ‡å‡†å±æ€§

**æ ‡å‡†å±æ€§æ¸…å•**:

| å±æ€§å | ç±»å‹ | å¿…éœ€ | æè¿° | ç¤ºä¾‹ |
|--------|------|------|------|------|
| `device.id` | string | å¯é€‰ | è®¾å¤‡å”¯ä¸€ ID | `2c54a1e3-8f4c-4d5e-9a1b-7c8d9e0f1a2b` |
| `device.model.name` | string | æ¨è | è®¾å¤‡å‹å·åç§° | `iPhone14,2` |
| `device.model.identifier` | string | å¯é€‰ | è®¾å¤‡å‹å·æ ‡è¯†ç¬¦ | `iPhone 13 Pro` |
| `device.manufacturer` | string | æ¨è | è®¾å¤‡åˆ¶é€ å•† | `Apple` |

**æ³¨æ„äº‹é¡¹**:

- `device.id` æ¶‰åŠéšç§,éœ€éµå®ˆ GDPR/CCPA ç­‰æ³•è§„
- ç§»åŠ¨è®¾å¤‡å»ºè®®ä½¿ç”¨å¹¿å‘Š ID (IDFA/GAID)
- Web æµè§ˆå™¨æ— æ³•ç›´æ¥è·å–ç¡¬ä»¶è®¾å¤‡ ID

### 2.2 è®¾å¤‡æ ‡è¯† (ID/Model)

**device.id è·å–ç­–ç•¥**:

```go
package deviceresource

import (
    "crypto/sha256"
    "encoding/hex"
    "os"
    
    "go.opentelemetry.io/otel/attribute"
    semconv "go.opentelemetry.io/otel/semconv/v1.28.0"
)

// GetDeviceID è·å–è®¾å¤‡ ID (éœ€è€ƒè™‘éšç§åˆè§„)
func GetDeviceID() (string, error) {
    // ä¼˜å…ˆä»ç¯å¢ƒå˜é‡ (ç§»åŠ¨åº”ç”¨åœºæ™¯)
    if deviceID := os.Getenv("DEVICE_ID"); deviceID != "" {
        return deviceID, nil
    }
    
    // Web åœºæ™¯: ä¸åº”ç›´æ¥è·å–è®¾å¤‡ ID
    // å»ºè®®ä½¿ç”¨ Session ID æˆ–åŒ¿ååŒ–çš„ç”¨æˆ· ID
    
    return "", fmt.Errorf("device ID not available")
}

// GenerateAnonymousDeviceID ç”ŸæˆåŒ¿åè®¾å¤‡ ID
func GenerateAnonymousDeviceID(userAgent string, ipAddress string) string {
    // åŸºäº User-Agent å’Œ IP ç”Ÿæˆç¨³å®šçš„åŒ¿å ID
    // æ³¨æ„: è¿™ä¸æ˜¯çœŸå®çš„è®¾å¤‡ ID,ä»…ç”¨äºä¼šè¯å…³è”
    
    data := fmt.Sprintf("%s|%s", userAgent, ipAddress)
    hash := sha256.Sum256([]byte(data))
    return hex.EncodeToString(hash[:16])
}

// DeviceIDAttribute è¿”å›è®¾å¤‡ ID å±æ€§
func DeviceIDAttribute() (attribute.KeyValue, error) {
    deviceID, err := GetDeviceID()
    if err != nil {
        return attribute.KeyValue{}, err
    }
    
    return semconv.DeviceID(deviceID), nil
}
```

**device.model.name è§£æ**:

```go
// GetDeviceModel ä» User-Agent è§£æè®¾å¤‡å‹å·
func GetDeviceModel(userAgent string) *DeviceModel {
    // æ£€æµ‹ç§»åŠ¨è®¾å¤‡
    if strings.Contains(userAgent, "iPhone") {
        return parseAppleDevice(userAgent)
    }
    
    if strings.Contains(userAgent, "Android") {
        return parseAndroidDevice(userAgent)
    }
    
    // æ¡Œé¢è®¾å¤‡
    return &DeviceModel{
        Name:       "Desktop",
        Identifier: "Unknown",
    }
}

type DeviceModel struct {
    Name       string
    Identifier string
}

func parseAppleDevice(ua string) *DeviceModel {
    // ç¤ºä¾‹: Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) ...
    
    if strings.Contains(ua, "iPhone") {
        return &DeviceModel{
            Name:       "iPhone",
            Identifier: extractiOSModel(ua),
        }
    }
    
    if strings.Contains(ua, "iPad") {
        return &DeviceModel{
            Name:       "iPad",
            Identifier: "iPad",
        }
    }
    
    return &DeviceModel{Name: "Apple Device"}
}

func extractiOSModel(ua string) string {
    // ä» User-Agent æå– iOS ç‰ˆæœ¬
    re := regexp.MustCompile(`CPU iPhone OS ([\d_]+)`)
    matches := re.FindStringSubmatch(ua)
    if len(matches) > 1 {
        version := strings.ReplaceAll(matches[1], "_", ".")
        return fmt.Sprintf("iPhone iOS %s", version)
    }
    return "iPhone"
}

func parseAndroidDevice(ua string) *DeviceModel {
    // ç¤ºä¾‹: Mozilla/5.0 (Linux; Android 11; Pixel 5) ...
    
    re := regexp.MustCompile(`Android ([\d.]+); ([^)]+)`)
    matches := re.FindStringSubmatch(ua)
    
    if len(matches) > 2 {
        androidVersion := matches[1]
        deviceName := matches[2]
        
        return &DeviceModel{
            Name:       deviceName,
            Identifier: fmt.Sprintf("Android %s", androidVersion),
        }
    }
    
    return &DeviceModel{Name: "Android Device"}
}
```

### 2.3 è®¾å¤‡åˆ¶é€ å•†

**device.manufacturer æ£€æµ‹**:

```go
// GetDeviceManufacturer è·å–è®¾å¤‡åˆ¶é€ å•†
func GetDeviceManufacturer(userAgent string) string {
    ua := strings.ToLower(userAgent)
    
    manufacturers := map[string][]string{
        "Apple":   {"iphone", "ipad", "macintosh"},
        "Samsung": {"samsung", "sm-", "galaxy"},
        "Google":  {"pixel"},
        "Huawei":  {"huawei"},
        "Xiaomi":  {"xiaomi", "redmi", "mi "},
        "OnePlus": {"oneplus"},
        "LG":      {"lg-"},
        "Sony":    {"sony"},
        "Motorola": {"motorola", "moto"},
        "Nokia":   {"nokia"},
    }
    
    for manufacturer, patterns := range manufacturers {
        for _, pattern := range patterns {
            if strings.Contains(ua, pattern) {
                return manufacturer
            }
        }
    }
    
    return "Unknown"
}

// DeviceManufacturerAttribute è¿”å›è®¾å¤‡åˆ¶é€ å•†å±æ€§
func DeviceManufacturerAttribute(userAgent string) attribute.KeyValue {
    manufacturer := GetDeviceManufacturer(userAgent)
    return semconv.DeviceManufacturer(manufacturer)
}
```

### 2.4 ç§»åŠ¨è®¾å¤‡ç‰¹æœ‰å±æ€§

**æ‰©å±•å±æ€§** (éæ ‡å‡†,ä½†æœ‰ç”¨):

```go
// MobileDeviceInfo ç§»åŠ¨è®¾å¤‡æ‰©å±•ä¿¡æ¯
type MobileDeviceInfo struct {
    IsTablet     bool
    IsMobile     bool
    IsDesktop    bool
    ScreenWidth  int
    ScreenHeight int
    PixelRatio   float64
}

// DetectDeviceType æ£€æµ‹è®¾å¤‡ç±»å‹
func DetectDeviceType(userAgent string) string {
    ua := strings.ToLower(userAgent)
    
    // å¹³æ¿æ£€æµ‹
    if strings.Contains(ua, "ipad") ||
       (strings.Contains(ua, "android") && !strings.Contains(ua, "mobile")) {
        return "tablet"
    }
    
    // æ‰‹æœºæ£€æµ‹
    if strings.Contains(ua, "mobile") ||
       strings.Contains(ua, "iphone") ||
       strings.Contains(ua, "android") {
        return "mobile"
    }
    
    // é»˜è®¤æ¡Œé¢
    return "desktop"
}

// IsMobileDevice æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡
func IsMobileDevice(userAgent string) bool {
    deviceType := DetectDeviceType(userAgent)
    return deviceType == "mobile" || deviceType == "tablet"
}
```

---

## 3. æµè§ˆå™¨çº§åˆ«å±æ€§ (browser.*)

### 3.1 browser.* æ ‡å‡†å±æ€§

**æ ‡å‡†å±æ€§æ¸…å•**:

| å±æ€§å | ç±»å‹ | å¿…éœ€ | æè¿° | ç¤ºä¾‹ |
|--------|------|------|------|------|
| `browser.brand` | string | æ¨è | æµè§ˆå™¨å“ç‰Œ | `Chrome` |
| `browser.version` | string | æ¨è | æµè§ˆå™¨ç‰ˆæœ¬ | `96.0.4664.110` |
| `browser.language` | string | å¯é€‰ | æµè§ˆå™¨è¯­è¨€ | `en-US` |
| `browser.platform` | string | å¯é€‰ | æµè§ˆå™¨å¹³å° | `Win32`, `MacIntel` |

**ä¸ user_agent.* çš„å…³ç³»**:

- `browser.*` æ˜¯ç»“æ„åŒ–çš„ã€è§£æåçš„å±æ€§
- `user_agent.original` æ˜¯åŸå§‹çš„ User-Agent å­—ç¬¦ä¸²

### 3.2 æµè§ˆå™¨æ ‡è¯† (Brand/Version)

**browser.brand è§£æ**:

```go
package browserresource

import (
    "regexp"
    "strings"
    
    "go.opentelemetry.io/otel/attribute"
    semconv "go.opentelemetry.io/otel/semconv/v1.28.0"
)

// GetBrowserInfo ä» User-Agent è§£ææµè§ˆå™¨ä¿¡æ¯
func GetBrowserInfo(userAgent string) *BrowserInfo {
    ua := strings.ToLower(userAgent)
    
    // æ£€æµ‹é¡ºåºå¾ˆé‡è¦ (Chrome åŒ…å« Safari å­—ç¬¦ä¸²)
    browsers := []struct {
        name    string
        pattern string
    }{
        {"Edge", `edg/([\d.]+)`},
        {"Chrome", `chrome/([\d.]+)`},
        {"Safari", `version/([\d.]+).*safari`},
        {"Firefox", `firefox/([\d.]+)`},
        {"Opera", `opr/([\d.]+)`},
        {"IE", `msie ([\d.]+)`},
        {"IE", `trident/.*rv:([\d.]+)`},
    }
    
    for _, browser := range browsers {
        re := regexp.MustCompile(browser.pattern)
        if matches := re.FindStringSubmatch(ua); len(matches) > 1 {
            return &BrowserInfo{
                Brand:   browser.name,
                Version: matches[1],
            }
        }
    }
    
    return &BrowserInfo{
        Brand:   "Unknown",
        Version: "Unknown",
    }
}

type BrowserInfo struct {
    Brand    string
    Version  string
    Language string
    Platform string
}

// BrowserBrandAttribute è¿”å›æµè§ˆå™¨å“ç‰Œå±æ€§
func BrowserBrandAttribute(userAgent string) attribute.KeyValue {
    info := GetBrowserInfo(userAgent)
    return semconv.BrowserBrand(info.Brand)
}

// BrowserVersionAttribute è¿”å›æµè§ˆå™¨ç‰ˆæœ¬å±æ€§
func BrowserVersionAttribute(userAgent string) attribute.KeyValue {
    info := GetBrowserInfo(userAgent)
    return semconv.BrowserVersion(info.Version)
}
```

### 3.3 æµè§ˆå™¨è¯­è¨€å’Œå¹³å°

**ä» HTTP Headers æå–**:

```go
// GetBrowserLanguage ä» Accept-Language Header è·å–è¯­è¨€
func GetBrowserLanguage(acceptLanguage string) string {
    if acceptLanguage == "" {
        return ""
    }
    
    // è§£æ: en-US,en;q=0.9,zh-CN;q=0.8
    languages := strings.Split(acceptLanguage, ",")
    if len(languages) > 0 {
        // å–ç¬¬ä¸€ä¸ªè¯­è¨€ (ä¼˜å…ˆçº§æœ€é«˜)
        lang := strings.Split(languages[0], ";")[0]
        return strings.TrimSpace(lang)
    }
    
    return ""
}

// GetBrowserPlatform ä» User-Agent è§£æå¹³å°
func GetBrowserPlatform(userAgent string) string {
    ua := strings.ToLower(userAgent)
    
    platforms := map[string][]string{
        "Win32":    {"windows nt"},
        "MacIntel": {"macintosh", "mac os x"},
        "Linux":    {"linux"},
        "Android":  {"android"},
        "iOS":      {"iphone", "ipad"},
    }
    
    for platform, patterns := range platforms {
        for _, pattern := range patterns {
            if strings.Contains(ua, pattern) {
                return platform
            }
        }
    }
    
    return "Unknown"
}

// BrowserLanguageAttribute è¿”å›æµè§ˆå™¨è¯­è¨€å±æ€§
func BrowserLanguageAttribute(acceptLanguage string) attribute.KeyValue {
    lang := GetBrowserLanguage(acceptLanguage)
    return semconv.BrowserLanguage(lang)
}

// BrowserPlatformAttribute è¿”å›æµè§ˆå™¨å¹³å°å±æ€§
func BrowserPlatformAttribute(userAgent string) attribute.KeyValue {
    platform := GetBrowserPlatform(userAgent)
    return semconv.BrowserPlatform(platform)
}
```

### 3.4 ç”¨æˆ·ä»£ç† (User-Agent)

**user_agent.original å­˜å‚¨**:

```go
// UserAgentOriginalAttribute è¿”å›åŸå§‹ User-Agent å±æ€§
func UserAgentOriginalAttribute(userAgent string) attribute.KeyValue {
    return semconv.UserAgentOriginal(userAgent)
}

// å®Œæ•´çš„æµè§ˆå™¨èµ„æºå±æ€§
func BrowserAttributes(userAgent, acceptLanguage string) []attribute.KeyValue {
    attrs := []attribute.KeyValue{
        UserAgentOriginalAttribute(userAgent),
        BrowserBrandAttribute(userAgent),
        BrowserVersionAttribute(userAgent),
        BrowserPlatformAttribute(userAgent),
    }
    
    if acceptLanguage != "" {
        attrs = append(attrs, BrowserLanguageAttribute(acceptLanguage))
    }
    
    return attrs
}
```

---

## 4. Go åç«¯å®ç° - User-Agent è§£æ

### 4.1 åŸºç¡€ User-Agent è§£æ

**æ‰‹åŠ¨è§£æå®ç°**:

```go
package useragent

import (
    "regexp"
    "strings"
)

// UserAgentParser User-Agent è§£æå™¨
type UserAgentParser struct {
    ua string
}

func NewUserAgentParser(ua string) *UserAgentParser {
    return &UserAgentParser{ua: ua}
}

// Parse è§£æ User-Agent
func (p *UserAgentParser) Parse() *ParsedUserAgent {
    return &ParsedUserAgent{
        Browser:      p.parseBrowser(),
        Device:       p.parseDevice(),
        OS:           p.parseOS(),
        OriginalUA:   p.ua,
    }
}

type ParsedUserAgent struct {
    Browser    *BrowserInfo
    Device     *DeviceInfo
    OS         *OSInfo
    OriginalUA string
}

type BrowserInfo struct {
    Name    string
    Version string
}

type DeviceInfo struct {
    Type         string // mobile, tablet, desktop
    Manufacturer string
    Model        string
}

type OSInfo struct {
    Name    string
    Version string
}

func (p *UserAgentParser) parseBrowser() *BrowserInfo {
    ua := strings.ToLower(p.ua)
    
    // Chrome
    if re := regexp.MustCompile(`chrome/([\d.]+)`); re.MatchString(ua) {
        matches := re.FindStringSubmatch(ua)
        return &BrowserInfo{Name: "Chrome", Version: matches[1]}
    }
    
    // Firefox
    if re := regexp.MustCompile(`firefox/([\d.]+)`); re.MatchString(ua) {
        matches := re.FindStringSubmatch(ua)
        return &BrowserInfo{Name: "Firefox", Version: matches[1]}
    }
    
    // Safari
    if re := regexp.MustCompile(`version/([\d.]+).*safari`); re.MatchString(ua) {
        matches := re.FindStringSubmatch(ua)
        return &BrowserInfo{Name: "Safari", Version: matches[1]}
    }
    
    return &BrowserInfo{Name: "Unknown", Version: "Unknown"}
}

func (p *UserAgentParser) parseDevice() *DeviceInfo {
    ua := strings.ToLower(p.ua)
    
    device := &DeviceInfo{
        Type: "desktop", // é»˜è®¤
    }
    
    // ç§»åŠ¨è®¾å¤‡
    if strings.Contains(ua, "mobile") || strings.Contains(ua, "iphone") {
        device.Type = "mobile"
    }
    
    // å¹³æ¿
    if strings.Contains(ua, "ipad") || 
       (strings.Contains(ua, "android") && !strings.Contains(ua, "mobile")) {
        device.Type = "tablet"
    }
    
    // åˆ¶é€ å•†
    if strings.Contains(ua, "iphone") || strings.Contains(ua, "ipad") {
        device.Manufacturer = "Apple"
    } else if strings.Contains(ua, "samsung") {
        device.Manufacturer = "Samsung"
    }
    
    return device
}

func (p *UserAgentParser) parseOS() *OSInfo {
    ua := strings.ToLower(p.ua)
    
    // Windows
    if strings.Contains(ua, "windows nt") {
        re := regexp.MustCompile(`windows nt ([\d.]+)`)
        matches := re.FindStringSubmatch(ua)
        if len(matches) > 1 {
            return &OSInfo{Name: "Windows", Version: matches[1]}
        }
        return &OSInfo{Name: "Windows", Version: "Unknown"}
    }
    
    // macOS
    if strings.Contains(ua, "mac os x") {
        re := regexp.MustCompile(`mac os x ([\d_]+)`)
        matches := re.FindStringSubmatch(ua)
        if len(matches) > 1 {
            version := strings.ReplaceAll(matches[1], "_", ".")
            return &OSInfo{Name: "macOS", Version: version}
        }
        return &OSInfo{Name: "macOS", Version: "Unknown"}
    }
    
    // Linux
    if strings.Contains(ua, "linux") {
        return &OSInfo{Name: "Linux", Version: "Unknown"}
    }
    
    // iOS
    if strings.Contains(ua, "iphone") || strings.Contains(ua, "ipad") {
        re := regexp.MustCompile(`cpu (?:iphone )?os ([\d_]+)`)
        matches := re.FindStringSubmatch(ua)
        if len(matches) > 1 {
            version := strings.ReplaceAll(matches[1], "_", ".")
            return &OSInfo{Name: "iOS", Version: version}
        }
        return &OSInfo{Name: "iOS", Version: "Unknown"}
    }
    
    // Android
    if strings.Contains(ua, "android") {
        re := regexp.MustCompile(`android ([\d.]+)`)
        matches := re.FindStringSubmatch(ua)
        if len(matches) > 1 {
            return &OSInfo{Name: "Android", Version: matches[1]}
        }
        return &OSInfo{Name: "Android", Version: "Unknown"}
    }
    
    return &OSInfo{Name: "Unknown", Version: "Unknown"}
}
```

### 4.2 ä½¿ç”¨ ua-parser åº“

**æ¨èåº“: github.com/ua-parser/uap-go**:

```go
package useragent

import (
    uaparser "github.com/ua-parser/uap-go/uaparser"
)

// ParseWithLibrary ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“è§£æ User-Agent
func ParseWithLibrary(userAgent string) (*ParsedUserAgent, error) {
    parser := uaparser.NewFromSaved()
    
    client := parser.Parse(userAgent)
    
    return &ParsedUserAgent{
        Browser: &BrowserInfo{
            Name:    client.UserAgent.Family,
            Version: formatVersion(client.UserAgent),
        },
        Device: &DeviceInfo{
            Type:         normalizeDeviceType(client.Device.Family),
            Manufacturer: client.Device.Brand,
            Model:        client.Device.Model,
        },
        OS: &OSInfo{
            Name:    client.Os.Family,
            Version: formatVersion(client.Os),
        },
        OriginalUA: userAgent,
    }, nil
}

func formatVersion(v interface{}) string {
    // å®ç°ç‰ˆæœ¬å·æ ¼å¼åŒ–
    // ...
    return "1.0.0"
}

func normalizeDeviceType(family string) string {
    family = strings.ToLower(family)
    
    switch family {
    case "smartphone", "mobile phone":
        return "mobile"
    case "tablet":
        return "tablet"
    default:
        return "desktop"
    }
}
```

**go.mod ä¾èµ–**:

```go
module myapp

go 1.25

require (
    github.com/ua-parser/uap-go v0.0.0-20211112212520-00c877edfe0f
    go.opentelemetry.io/otel v1.32.0
    go.opentelemetry.io/otel/sdk v1.32.0
)
```

### 4.3 è®¾å¤‡ç±»å‹æ£€æµ‹

**è¯¦ç»†è®¾å¤‡åˆ†ç±»**:

```go
// DeviceCategory è®¾å¤‡åˆ†ç±»
type DeviceCategory struct {
    Type      string // mobile, tablet, desktop, tv, wearable, console
    IsMobile  bool
    IsTablet  bool
    IsDesktop bool
    IsBot     bool
}

// ClassifyDevice åˆ†ç±»è®¾å¤‡
func ClassifyDevice(ua string) *DeviceCategory {
    parser := NewUserAgentParser(ua)
    parsed := parser.Parse()
    
    category := &DeviceCategory{
        Type: parsed.Device.Type,
    }
    
    switch category.Type {
    case "mobile":
        category.IsMobile = true
    case "tablet":
        category.IsTablet = true
    case "desktop":
        category.IsDesktop = true
    }
    
    // Bot æ£€æµ‹
    if isBot(ua) {
        category.IsBot = true
    }
    
    return category
}

func isBot(ua string) bool {
    ua = strings.ToLower(ua)
    
    botPatterns := []string{
        "bot", "crawler", "spider", "scraper",
        "googlebot", "bingbot", "slurp", "duckduckbot",
        "baiduspider", "yandexbot",
    }
    
    for _, pattern := range botPatterns {
        if strings.Contains(ua, pattern) {
            return true
        }
    }
    
    return false
}
```

### 4.4 æµè§ˆå™¨ç‰¹æ€§æ£€æµ‹

**æµè§ˆå™¨èƒ½åŠ›æ£€æµ‹** (åŸºäºç‰ˆæœ¬):

```go
// BrowserCapabilities æµè§ˆå™¨èƒ½åŠ›
type BrowserCapabilities struct {
    SupportsWebGL      bool
    SupportsWebWorkers bool
    SupportsWebSockets bool
    SupportsHTTP2      bool
    SupportsWebAssembly bool
}

// DetectCapabilities æ£€æµ‹æµè§ˆå™¨èƒ½åŠ›
func DetectCapabilities(browser *BrowserInfo) *BrowserCapabilities {
    caps := &BrowserCapabilities{}
    
    // åŸºäºæµè§ˆå™¨å’Œç‰ˆæœ¬æ£€æµ‹ç‰¹æ€§æ”¯æŒ
    switch browser.Name {
    case "Chrome":
        if compareVersion(browser.Version, "90.0") >= 0 {
            caps.SupportsWebGL = true
            caps.SupportsWebWorkers = true
            caps.SupportsWebSockets = true
            caps.SupportsHTTP2 = true
            caps.SupportsWebAssembly = true
        }
    case "Firefox":
        if compareVersion(browser.Version, "78.0") >= 0 {
            caps.SupportsWebGL = true
            caps.SupportsWebWorkers = true
            caps.SupportsWebSockets = true
            caps.SupportsHTTP2 = true
            caps.SupportsWebAssembly = true
        }
    case "Safari":
        if compareVersion(browser.Version, "14.0") >= 0 {
            caps.SupportsWebGL = true
            caps.SupportsWebWorkers = true
            caps.SupportsWebSockets = true
            caps.SupportsHTTP2 = true
            caps.SupportsWebAssembly = true
        }
    }
    
    return caps
}

func compareVersion(v1, v2 string) int {
    // å®ç°ç‰ˆæœ¬å·æ¯”è¾ƒé€»è¾‘
    // ...
    return 0
}
```

---

## 5. Go åç«¯å®ç° - HTTP Headers æå–

### 5.1 æ ‡å‡† HTTP Headers

**æå–èµ„æºç›¸å…³ Headers**:

```go
package httpresource

import (
    "net/http"
    
    "go.opentelemetry.io/otel/attribute"
    semconv "go.opentelemetry.io/otel/semconv/v1.28.0"
)

// ExtractResourceFromHeaders ä» HTTP Headers æå–èµ„æºå±æ€§
func ExtractResourceFromHeaders(headers http.Header) []attribute.KeyValue {
    attrs := []attribute.KeyValue{}
    
    // User-Agent
    if ua := headers.Get("User-Agent"); ua != "" {
        attrs = append(attrs, semconv.UserAgentOriginal(ua))
        
        // è§£ææµè§ˆå™¨ä¿¡æ¯
        browserInfo := browserresource.GetBrowserInfo(ua)
        attrs = append(attrs,
            semconv.BrowserBrand(browserInfo.Brand),
            semconv.BrowserVersion(browserInfo.Version),
        )
    }
    
    // Accept-Language
    if lang := headers.Get("Accept-Language"); lang != "" {
        language := browserresource.GetBrowserLanguage(lang)
        attrs = append(attrs, semconv.BrowserLanguage(language))
    }
    
    // Sec-CH-UA (Client Hints)
    if chUA := headers.Get("Sec-CH-UA"); chUA != "" {
        attrs = append(attrs, attribute.String("browser.user_agent_hint", chUA))
    }
    
    return attrs
}
```

### 5.2 Client Hints API

**User-Agent Client Hints (UA-CH)**:

```go
// ClientHints Client Hints ä¿¡æ¯
type ClientHints struct {
    Brands       []Brand
    Mobile       bool
    Platform     string
    PlatformVersion string
    Architecture string
    Bitness      string
    Model        string
}

type Brand struct {
    Brand   string
    Version string
}

// ParseClientHints è§£æ Client Hints Headers
func ParseClientHints(headers http.Header) *ClientHints {
    ch := &ClientHints{}
    
    // Sec-CH-UA: "Chromium";v="96", "Google Chrome";v="96"
    if secUA := headers.Get("Sec-CH-UA"); secUA != "" {
        ch.Brands = parseSecCHUA(secUA)
    }
    
    // Sec-CH-UA-Mobile: ?1
    if mobile := headers.Get("Sec-CH-UA-Mobile"); mobile == "?1" {
        ch.Mobile = true
    }
    
    // Sec-CH-UA-Platform: "Windows"
    ch.Platform = headers.Get("Sec-CH-UA-Platform")
    
    // Sec-CH-UA-Platform-Version: "14.0.0"
    ch.PlatformVersion = headers.Get("Sec-CH-UA-Platform-Version")
    
    // Sec-CH-UA-Arch: "x86"
    ch.Architecture = headers.Get("Sec-CH-UA-Arch")
    
    // Sec-CH-UA-Bitness: "64"
    ch.Bitness = headers.Get("Sec-CH-UA-Bitness")
    
    // Sec-CH-UA-Model: "Pixel 5"
    ch.Model = headers.Get("Sec-CH-UA-Model")
    
    return ch
}

func parseSecCHUA(secUA string) []Brand {
    // è§£æ: "Chromium";v="96", "Google Chrome";v="96"
    brands := []Brand{}
    
    parts := strings.Split(secUA, ",")
    for _, part := range parts {
        part = strings.TrimSpace(part)
        
        // æå–å“ç‰Œå’Œç‰ˆæœ¬
        brandRe := regexp.MustCompile(`"([^"]+)";v="([^"]+)"`)
        matches := brandRe.FindStringSubmatch(part)
        
        if len(matches) == 3 {
            brands = append(brands, Brand{
                Brand:   matches[1],
                Version: matches[2],
            })
        }
    }
    
    return brands
}

// ClientHintsAttributes è¿”å› Client Hints å±æ€§
func ClientHintsAttributes(ch *ClientHints) []attribute.KeyValue {
    attrs := []attribute.KeyValue{}
    
    if len(ch.Brands) > 0 {
        // ä½¿ç”¨ç¬¬ä¸€ä¸ªå“ç‰Œ (é€šå¸¸æ˜¯ä¸»æµè§ˆå™¨)
        attrs = append(attrs,
            semconv.BrowserBrand(ch.Brands[0].Brand),
            semconv.BrowserVersion(ch.Brands[0].Version),
        )
    }
    
    if ch.Mobile {
        attrs = append(attrs, attribute.String("device.type", "mobile"))
    }
    
    if ch.Platform != "" {
        attrs = append(attrs, semconv.BrowserPlatform(ch.Platform))
    }
    
    if ch.Model != "" {
        attrs = append(attrs, semconv.DeviceModelName(ch.Model))
    }
    
    return attrs
}
```

**å¯ç”¨ Client Hints** (æœåŠ¡å™¨å“åº”):

```go
// EnableClientHints åœ¨å“åº”ä¸­å¯ç”¨ Client Hints
func EnableClientHints(w http.ResponseWriter) {
    // è¯·æ±‚å®¢æˆ·ç«¯å‘é€é«˜ç†µ Client Hints
    w.Header().Set("Accept-CH", "Sec-CH-UA, Sec-CH-UA-Mobile, Sec-CH-UA-Platform, Sec-CH-UA-Model")
    
    // æŒä¹…åŒ– Client Hints (å¯é€‰)
    w.Header().Set("Critical-CH", "Sec-CH-UA-Mobile")
}
```

### 5.3 ä¸­é—´ä»¶é›†æˆ

**HTTP ä¸­é—´ä»¶è‡ªåŠ¨æå–èµ„æºå±æ€§**:

```go
package middleware

import (
    "context"
    "net/http"
    
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// ResourceDetectionMiddleware èµ„æºæ£€æµ‹ä¸­é—´ä»¶
func ResourceDetectionMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // å¯ç”¨ Client Hints
        httpresource.EnableClientHints(w)
        
        // æå–èµ„æºå±æ€§
        attrs := httpresource.ExtractResourceFromHeaders(r.Header)
        
        // æ·»åŠ åˆ° Span
        span := trace.SpanFromContext(r.Context())
        span.SetAttributes(attrs...)
        
        // ä¹Ÿå¯ä»¥æ·»åŠ åˆ° Context ä¾›åç»­ä½¿ç”¨
        ctx := context.WithValue(r.Context(), "resource.attrs", attrs)
        
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}
```

### 5.4 Context ä¼ æ’­

**å°†èµ„æºå±æ€§ä¼ æ’­åˆ°æ•´ä¸ªè¯·æ±‚é“¾**:

```go
// ResourceContextKey Context Key ç±»å‹
type ResourceContextKey string

const (
    BrowserInfoKey   ResourceContextKey = "resource.browser"
    DeviceInfoKey    ResourceContextKey = "resource.device"
    ClientHintsKey   ResourceContextKey = "resource.client_hints"
)

// AttachResourceToContext å°†èµ„æºä¿¡æ¯é™„åŠ åˆ° Context
func AttachResourceToContext(ctx context.Context, r *http.Request) context.Context {
    // è§£æ User-Agent
    if ua := r.Header.Get("User-Agent"); ua != "" {
        parser := useragent.NewUserAgentParser(ua)
        parsed := parser.Parse()
        
        ctx = context.WithValue(ctx, BrowserInfoKey, parsed.Browser)
        ctx = context.WithValue(ctx, DeviceInfoKey, parsed.Device)
    }
    
    // è§£æ Client Hints
    ch := httpresource.ParseClientHints(r.Header)
    ctx = context.WithValue(ctx, ClientHintsKey, ch)
    
    return ctx
}

// GetBrowserInfoFromContext ä» Context è·å–æµè§ˆå™¨ä¿¡æ¯
func GetBrowserInfoFromContext(ctx context.Context) *useragent.BrowserInfo {
    if info, ok := ctx.Value(BrowserInfoKey).(*useragent.BrowserInfo); ok {
        return info
    }
    return nil
}
```

---

## 6. å‰ç«¯ JavaScript æ£€æµ‹

### 6.1 æµè§ˆå™¨ä¿¡æ¯è·å–

**JavaScript å®ç°**:

```javascript
// browser-detector.js

class BrowserDetector {
    constructor() {
        this.navigator = window.navigator;
        this.userAgent = this.navigator.userAgent;
    }
    
    getBrowserInfo() {
        return {
            brand: this.getBrand(),
            version: this.getVersion(),
            language: this.navigator.language,
            platform: this.navigator.platform,
            userAgent: this.userAgent,
            // User-Agent Client Hints (å¦‚æœå¯ç”¨)
            userAgentData: this.navigator.userAgentData || null,
        };
    }
    
    getBrand() {
        const ua = this.userAgent.toLowerCase();
        
        if (ua.includes('edg/')) return 'Edge';
        if (ua.includes('chrome/')) return 'Chrome';
        if (ua.includes('firefox/')) return 'Firefox';
        if (ua.includes('safari/') && !ua.includes('chrome')) return 'Safari';
        if (ua.includes('opr/')) return 'Opera';
        
        return 'Unknown';
    }
    
    getVersion() {
        const brand = this.getBrand();
        const ua = this.userAgent;
        
        let match;
        switch (brand) {
            case 'Edge':
                match = ua.match(/Edg\/([\d.]+)/);
                break;
            case 'Chrome':
                match = ua.match(/Chrome\/([\d.]+)/);
                break;
            case 'Firefox':
                match = ua.match(/Firefox\/([\d.]+)/);
                break;
            case 'Safari':
                match = ua.match(/Version\/([\d.]+)/);
                break;
            case 'Opera':
                match = ua.match(/OPR\/([\d.]+)/);
                break;
        }
        
        return match ? match[1] : 'Unknown';
    }
    
    // User-Agent Client Hints API (ç°ä»£æµè§ˆå™¨)
    async getHighEntropyValues() {
        if (!this.navigator.userAgentData) {
            return null;
        }
        
        try {
            return await this.navigator.userAgentData.getHighEntropyValues([
                'architecture',
                'bitness',
                'model',
                'platformVersion',
                'uaFullVersion',
            ]);
        } catch (error) {
            console.error('Failed to get high entropy values:', error);
            return null;
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const detector = new BrowserDetector();
const browserInfo = detector.getBrowserInfo();
console.log('Browser Info:', browserInfo);

// å¼‚æ­¥è·å–é«˜ç†µå€¼
detector.getHighEntropyValues().then(highEntropy => {
    console.log('High Entropy Values:', highEntropy);
});
```

### 6.2 è®¾å¤‡ä¿¡æ¯è·å–

**JavaScript è®¾å¤‡æ£€æµ‹**:

```javascript
// device-detector.js

class DeviceDetector {
    constructor() {
        this.navigator = window.navigator;
        this.userAgent = this.navigator.userAgent;
    }
    
    getDeviceInfo() {
        return {
            type: this.getDeviceType(),
            isMobile: this.isMobile(),
            isTablet: this.isTablet(),
            isDesktop: this.isDesktop(),
            touchSupport: this.hasTouchSupport(),
            // å±å¹•ä¿¡æ¯
            screen: this.getScreenInfo(),
            // ç½‘ç»œä¿¡æ¯
            network: this.getNetworkInfo(),
        };
    }
    
    getDeviceType() {
        if (this.isTablet()) return 'tablet';
        if (this.isMobile()) return 'mobile';
        return 'desktop';
    }
    
    isMobile() {
        const ua = this.userAgent.toLowerCase();
        return /mobile|iphone|ipod|android.*mobile/.test(ua);
    }
    
    isTablet() {
        const ua = this.userAgent.toLowerCase();
        return /ipad|android(?!.*mobile)/.test(ua);
    }
    
    isDesktop() {
        return !this.isMobile() && !this.isTablet();
    }
    
    hasTouchSupport() {
        return (
            'ontouchstart' in window ||
            navigator.maxTouchPoints > 0 ||
            navigator.msMaxTouchPoints > 0
        );
    }
    
    getScreenInfo() {
        return {
            width: window.screen.width,
            height: window.screen.height,
            availWidth: window.screen.availWidth,
            availHeight: window.screen.availHeight,
            colorDepth: window.screen.colorDepth,
            pixelDepth: window.screen.pixelDepth,
            orientation: this.getOrientation(),
            pixelRatio: window.devicePixelRatio || 1,
        };
    }
    
    getOrientation() {
        if (window.screen.orientation) {
            return window.screen.orientation.type;
        }
        
        // Fallback
        return window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
    }
    
    getNetworkInfo() {
        if (!navigator.connection) {
            return null;
        }
        
        const conn = navigator.connection;
        return {
            effectiveType: conn.effectiveType, // '4g', '3g', '2g', 'slow-2g'
            downlink: conn.downlink, // Mbps
            rtt: conn.rtt, // ms
            saveData: conn.saveData, // boolean
        };
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const deviceDetector = new DeviceDetector();
const deviceInfo = deviceDetector.getDeviceInfo();
console.log('Device Info:', deviceInfo);
```

### 6.3 å±å¹•ä¿¡æ¯

**è¯¦ç»†å±å¹•å±æ€§**:

```javascript
// screen-info.js

function getScreenInfo() {
    return {
        // ç‰©ç†å°ºå¯¸
        screen: {
            width: window.screen.width,
            height: window.screen.height,
        },
        
        // å¯ç”¨å°ºå¯¸ (æ’é™¤ä»»åŠ¡æ ç­‰)
        availableScreen: {
            width: window.screen.availWidth,
            height: window.screen.availHeight,
        },
        
        // è§†å£å°ºå¯¸
        viewport: {
            width: window.innerWidth,
            height: window.innerHeight,
        },
        
        // åƒç´ æ¯”
        pixelRatio: window.devicePixelRatio || 1,
        
        // é¢œè‰²æ·±åº¦
        colorDepth: window.screen.colorDepth,
        pixelDepth: window.screen.pixelDepth,
        
        // æ–¹å‘
        orientation: getScreenOrientation(),
    };
}

function getScreenOrientation() {
    if (window.screen.orientation) {
        return {
            type: window.screen.orientation.type,
            angle: window.screen.orientation.angle,
        };
    }
    
    // Fallback
    return {
        type: window.innerWidth > window.innerHeight ? 'landscape' : 'portrait',
        angle: 0,
    };
}
```

### 6.4 ç½‘ç»œä¿¡æ¯

**Network Information API**:

```javascript
// network-info.js

function getNetworkInfo() {
    if (!navigator.connection) {
        return {
            supported: false,
            message: 'Network Information API not supported',
        };
    }
    
    const conn = navigator.connection;
    
    return {
        supported: true,
        
        // æœ‰æ•ˆç±»å‹: '4g', '3g', '2g', 'slow-2g'
        effectiveType: conn.effectiveType,
        
        // ä¸‹è¡Œé€Ÿåº¦ (Mbps)
        downlink: conn.downlink,
        
        // å¾€è¿”æ—¶é—´ (ms)
        rtt: conn.rtt,
        
        // èŠ‚çœæ•°æ®æ¨¡å¼
        saveData: conn.saveData,
        
        // è¿æ¥ç±»å‹: 'bluetooth', 'cellular', 'ethernet', 'wifi', 'other', 'unknown'
        type: conn.type || 'unknown',
    };
}

// ç›‘å¬ç½‘ç»œå˜åŒ–
function monitorNetworkChanges(callback) {
    if (!navigator.connection) {
        console.warn('Network Information API not supported');
        return () => {}; // è¿”å›ç©ºçš„æ¸…ç†å‡½æ•°
    }
    
    const conn = navigator.connection;
    
    const handler = () => {
        callback(getNetworkInfo());
    };
    
    conn.addEventListener('change', handler);
    
    // è¿”å›æ¸…ç†å‡½æ•°
    return () => {
        conn.removeEventListener('change', handler);
    };
}

// ä½¿ç”¨ç¤ºä¾‹
const networkInfo = getNetworkInfo();
console.log('Network Info:', networkInfo);

// ç›‘å¬ç½‘ç»œå˜åŒ–
const cleanup = monitorNetworkChanges((info) => {
    console.log('Network changed:', info);
});

// æ¸…ç†ç›‘å¬å™¨
// cleanup();
```

---

## 7. OpenTelemetry Browser SDK é›†æˆ

### 7.1 Browser SDK åˆå§‹åŒ–

**å®‰è£…ä¾èµ–**:

```bash
npm install --save \
  @opentelemetry/api \
  @opentelemetry/sdk-trace-web \
  @opentelemetry/instrumentation \
  @opentelemetry/instrumentation-fetch \
  @opentelemetry/instrumentation-document-load \
  @opentelemetry/instrumentation-user-interaction \
  @opentelemetry/exporter-trace-otlp-http \
  @opentelemetry/resources \
  @opentelemetry/semantic-conventions
```

**åˆå§‹åŒ–ä»£ç **:

```javascript
// otel-init.js

import { WebTracerProvider } from '@opentelemetry/sdk-trace-web';
import { BatchSpanProcessor } from '@opentelemetry/sdk-trace-base';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
import { Resource } from '@opentelemetry/resources';
import { ATTR_SERVICE_NAME, ATTR_SERVICE_VERSION } from '@opentelemetry/semantic-conventions';
import { registerInstrumentations } from '@opentelemetry/instrumentation';
import { FetchInstrumentation } from '@opentelemetry/instrumentation-fetch';
import { DocumentLoadInstrumentation } from '@opentelemetry/instrumentation-document-load';
import { UserInteractionInstrumentation } from '@opentelemetry/instrumentation-user-interaction';

// è‡ªå®šä¹‰èµ„æºæ£€æµ‹
import { BrowserResourceDetector } from './resource-detector';

function initializeOpenTelemetry() {
    // 1. åˆ›å»ºèµ„æº
    const resource = Resource.default().merge(
        new Resource({
            [ATTR_SERVICE_NAME]: 'my-web-app',
            [ATTR_SERVICE_VERSION]: '1.0.0',
        })
    );
    
    // 2. æ£€æµ‹æµè§ˆå™¨å’Œè®¾å¤‡èµ„æº
    const browserDetector = new BrowserResourceDetector();
    const detectedResource = browserDetector.detect();
    const finalResource = resource.merge(detectedResource);
    
    // 3. åˆ›å»º TracerProvider
    const provider = new WebTracerProvider({
        resource: finalResource,
    });
    
    // 4. é…ç½® Exporter
    const exporter = new OTLPTraceExporter({
        url: 'http://localhost:4318/v1/traces', // OTLP HTTP endpoint
    });
    
    // 5. æ·»åŠ  Span Processor
    provider.addSpanProcessor(new BatchSpanProcessor(exporter));
    
    // 6. æ³¨å†Œ Provider
    provider.register();
    
    // 7. æ³¨å†Œè‡ªåŠ¨æ’æ¡©
    registerInstrumentations({
        instrumentations: [
            new FetchInstrumentation(),
            new DocumentLoadInstrumentation(),
            new UserInteractionInstrumentation(),
        ],
    });
    
    console.log('OpenTelemetry initialized');
}

// åˆå§‹åŒ–
initializeOpenTelemetry();
```

### 7.2 èµ„æºæ£€æµ‹å™¨

**è‡ªå®šä¹‰æµè§ˆå™¨èµ„æºæ£€æµ‹å™¨**:

```javascript
// resource-detector.js

import { Resource } from '@opentelemetry/resources';
import { 
    ATTR_BROWSER_BRAND, 
    ATTR_BROWSER_VERSION,
    ATTR_BROWSER_LANGUAGE,
    ATTR_BROWSER_PLATFORM,
    ATTR_DEVICE_MODEL_NAME,
    ATTR_USER_AGENT_ORIGINAL,
} from '@opentelemetry/semantic-conventions';

export class BrowserResourceDetector {
    detect() {
        const attrs = {};
        
        // User-Agent
        attrs[ATTR_USER_AGENT_ORIGINAL] = navigator.userAgent;
        
        // æµè§ˆå™¨ä¿¡æ¯
        const browserInfo = this.detectBrowser();
        attrs[ATTR_BROWSER_BRAND] = browserInfo.brand;
        attrs[ATTR_BROWSER_VERSION] = browserInfo.version;
        attrs[ATTR_BROWSER_LANGUAGE] = navigator.language;
        attrs[ATTR_BROWSER_PLATFORM] = navigator.platform;
        
        // è®¾å¤‡ä¿¡æ¯
        const deviceInfo = this.detectDevice();
        attrs['device.type'] = deviceInfo.type;
        
        if (deviceInfo.model) {
            attrs[ATTR_DEVICE_MODEL_NAME] = deviceInfo.model;
        }
        
        // å±å¹•ä¿¡æ¯
        attrs['screen.width'] = window.screen.width;
        attrs['screen.height'] = window.screen.height;
        attrs['screen.pixel_ratio'] = window.devicePixelRatio || 1;
        
        // ç½‘ç»œä¿¡æ¯ (å¦‚æœå¯ç”¨)
        if (navigator.connection) {
            attrs['network.effective_type'] = navigator.connection.effectiveType;
        }
        
        return new Resource(attrs);
    }
    
    detectBrowser() {
        const ua = navigator.userAgent.toLowerCase();
        
        if (ua.includes('edg/')) {
            const match = ua.match(/edg\/([\d.]+)/);
            return { brand: 'Edge', version: match ? match[1] : 'unknown' };
        }
        
        if (ua.includes('chrome/')) {
            const match = ua.match(/chrome\/([\d.]+)/);
            return { brand: 'Chrome', version: match ? match[1] : 'unknown' };
        }
        
        if (ua.includes('firefox/')) {
            const match = ua.match(/firefox\/([\d.]+)/);
            return { brand: 'Firefox', version: match ? match[1] : 'unknown' };
        }
        
        if (ua.includes('safari/') && !ua.includes('chrome')) {
            const match = ua.match(/version\/([\d.]+)/);
            return { brand: 'Safari', version: match ? match[1] : 'unknown' };
        }
        
        return { brand: 'Unknown', version: 'unknown' };
    }
    
    detectDevice() {
        const ua = navigator.userAgent.toLowerCase();
        
        const isMobile = /mobile|iphone|ipod|android.*mobile/.test(ua);
        const isTablet = /ipad|android(?!.*mobile)/.test(ua);
        
        let type = 'desktop';
        if (isTablet) type = 'tablet';
        else if (isMobile) type = 'mobile';
        
        // å°è¯•æå–è®¾å¤‡å‹å·
        let model = null;
        if (navigator.userAgentData) {
            model = navigator.userAgentData.mobile ? 'Mobile Device' : 'Desktop';
        }
        
        return { type, model };
    }
}
```

### 7.3 è‡ªåŠ¨æ’æ¡©

**é…ç½®è‡ªåŠ¨æ’æ¡©**:

```javascript
// instrumentation-config.js

import { FetchInstrumentation } from '@opentelemetry/instrumentation-fetch';
import { DocumentLoadInstrumentation } from '@opentelemetry/instrumentation-document-load';
import { UserInteractionInstrumentation } from '@opentelemetry/instrumentation-user-interaction';

export function getInstrumentations() {
    return [
        // Fetch API æ’æ¡©
        new FetchInstrumentation({
            propagateTraceHeaderCorsUrls: [
                /^https:\/\/api\.example\.com\/.*/,
            ],
            clearTimingResources: true,
        }),
        
        // æ–‡æ¡£åŠ è½½æ’æ¡©
        new DocumentLoadInstrumentation(),
        
        // ç”¨æˆ·äº¤äº’æ’æ¡© (ç‚¹å‡»ã€é”®ç›˜ç­‰)
        new UserInteractionInstrumentation({
            eventNames: ['click', 'submit'],
        }),
    ];
}
```

### 7.4 å‰åç«¯å…³è”

**Trace Context ä¼ æ’­**:

```javascript
// å‰ç«¯å‘èµ·è¯·æ±‚æ—¶,è‡ªåŠ¨ä¼ æ’­ Trace Context

// ä½¿ç”¨ Fetch (è‡ªåŠ¨æ’æ¡©)
fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => console.log(data));

// åç«¯æ¥æ”¶åˆ°çš„ Headers:
// traceparent: 00-trace-id-span-id-01
// tracestate: ...
```

**Go åç«¯æ¥æ”¶**:

```go
import (
    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
)

// HTTP Handler è‡ªåŠ¨æå– Trace Context
handler := otelhttp.NewHandler(
    http.HandlerFunc(myHandler),
    "my-api",
)

http.ListenAndServe(":8080", handler)
```

---

## 9. å®Œæ•´ç¤ºä¾‹

### 9.1 Go HTTP æœåŠ¡å™¨

**main.go**:

```go
package main

import (
    "context"
    "log"
    "net/http"
    
    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.28.0"
    
    "myapp/middleware"
)

func main() {
    ctx := context.Background()
    
    // åˆå§‹åŒ– TracerProvider
    tp, err := initTracerProvider(ctx)
    if err != nil {
        log.Fatal(err)
    }
    defer tp.Shutdown(ctx)
    
    otel.SetTracerProvider(tp)
    
    // é…ç½®è·¯ç”±
    mux := http.NewServeMux()
    mux.HandleFunc("/api/data", handleData)
    
    // åº”ç”¨ä¸­é—´ä»¶
    handler := middleware.ResourceDetectionMiddleware(mux)
    handler = otelhttp.NewHandler(handler, "my-api")
    
    log.Println("Server starting on :8080")
    http.ListenAndServe(":8080", handler)
}

func handleData(w http.ResponseWriter, r *http.Request) {
    // ä¸šåŠ¡é€»è¾‘
    w.Header().Set("Content-Type", "application/json")
    w.Write([]byte(`{"status":"ok"}`))
}

func initTracerProvider(ctx context.Context) (*sdktrace.TracerProvider, error) {
    res := resource.NewWithAttributes(
        semconv.SchemaURL,
        semconv.ServiceName("my-api"),
        semconv.ServiceVersion("1.0.0"),
    )
    
    exporter, err := otlptracegrpc.New(
        ctx,
        otlptracegrpc.WithEndpoint("localhost:4317"),
        otlptracegrpc.WithInsecure(),
    )
    if err != nil {
        return nil, err
    }
    
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithResource(res),
        sdktrace.WithBatcher(exporter),
    )
    
    return tp, nil
}
```

### 9.2 å‰ç«¯ SPA åº”ç”¨

**index.html**:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Web App</title>
</head>
<body>
    <h1>My Web App</h1>
    <button id="fetch-data">Fetch Data</button>
    <div id="result"></div>
    
    <script type="module" src="/src/main.js"></script>
</body>
</html>
```

**src/main.js**:

```javascript
// main.js

import './otel-init.js';
import { trace } from '@opentelemetry/api';

const tracer = trace.getTracer('my-web-app');

document.getElementById('fetch-data').addEventListener('click', async () => {
    const span = tracer.startSpan('fetch-data-button-click');
    
    try {
        const response = await fetch('http://localhost:8080/api/data');
        const data = await response.json();
        
        document.getElementById('result').textContent = JSON.stringify(data);
        
        span.setStatus({ code: 0 }); // OK
    } catch (error) {
        span.recordException(error);
        span.setStatus({ code: 2, message: error.message }); // ERROR
    } finally {
        span.end();
    }
});
```

### 9.3 å…¨æ ˆè¿½è¸ª

**å®Œæ•´è¿½è¸ªæµç¨‹**:

```mermaid
sequenceDiagram
    participant Browser
    participant GoBackend
    participant OTELCollector
    participant Jaeger
    
    Browser->>Browser: åˆå§‹åŒ– Browser SDK
    Browser->>Browser: æ£€æµ‹æµè§ˆå™¨/è®¾å¤‡èµ„æº
    Browser->>GoBackend: HTTP Request + traceparent
    GoBackend->>GoBackend: æå– User-Agent
    GoBackend->>GoBackend: è§£ææµè§ˆå™¨/è®¾å¤‡ä¿¡æ¯
    GoBackend->>GoBackend: å¤„ç†ä¸šåŠ¡é€»è¾‘
    GoBackend->>OTELCollector: Export Spans
    Browser->>OTELCollector: Export Spans
    OTELCollector->>Jaeger: Forward Traces
```

---

## 10. æœ€ä½³å®è·µ

### 10.1 éšç§è€ƒè™‘

**GDPR/CCPA åˆè§„**:

```go
// åŒ¿ååŒ–æ•æ„Ÿä¿¡æ¯
func anonymizeUserAgent(ua string) string {
    // ç§»é™¤å¯èƒ½è¯†åˆ«ä¸ªäººçš„ä¿¡æ¯
    // ä¿ç•™è®¾å¤‡ç±»å‹å’Œæµè§ˆå™¨ä¿¡æ¯,ä½†ç§»é™¤ç²¾ç¡®ç‰ˆæœ¬å·
    
    parser := useragent.NewUserAgentParser(ua)
    parsed := parser.Parse()
    
    return fmt.Sprintf("%s/%s %s",
        parsed.Browser.Name,
        majorVersion(parsed.Browser.Version),
        parsed.Device.Type,
    )
}

func majorVersion(version string) string {
    parts := strings.Split(version, ".")
    if len(parts) > 0 {
        return parts[0] + ".x"
    }
    return "x"
}
```

### 10.2 æ€§èƒ½ä¼˜åŒ–

**ç¼“å­˜è§£æç»“æœ**:

```go
var (
    uaCache   = make(map[string]*useragent.ParsedUserAgent)
    cacheMu   sync.RWMutex
    cacheSize = 1000
)

func parseUserAgentCached(ua string) *useragent.ParsedUserAgent {
    // è¯»ç¼“å­˜
    cacheMu.RLock()
    if parsed, ok := uaCache[ua]; ok {
        cacheMu.RUnlock()
        return parsed
    }
    cacheMu.RUnlock()
    
    // è§£æ
    parser := useragent.NewUserAgentParser(ua)
    parsed := parser.Parse()
    
    // å†™ç¼“å­˜
    cacheMu.Lock()
    if len(uaCache) >= cacheSize {
        // ç®€å•çš„ LRU: æ¸…ç©ºç¼“å­˜
        uaCache = make(map[string]*useragent.ParsedUserAgent)
    }
    uaCache[ua] = parsed
    cacheMu.Unlock()
    
    return parsed
}
```

### 10.3 å‡†ç¡®æ€§ä¿è¯

**å®šæœŸæ›´æ–° User-Agent è§„åˆ™**:

```bash
# ä½¿ç”¨ ua-parser å¹¶å®šæœŸæ›´æ–°è§„åˆ™æ–‡ä»¶
go get -u github.com/ua-parser/uap-go/uaparser
```

### 10.4 è·¨å¹³å°å…¼å®¹æ€§

**Feature Detection over Browser Detection**:

```javascript
// âŒ ä¸æ¨è: åŸºäºæµè§ˆå™¨åˆ¤æ–­ç‰¹æ€§
if (browserInfo.brand === 'Chrome') {
    // ä½¿ç”¨ Chrome ç‰¹æœ‰åŠŸèƒ½
}

// âœ… æ¨è: åŸºäºç‰¹æ€§æ£€æµ‹
if ('serviceWorker' in navigator) {
    // ä½¿ç”¨ Service Worker
}
```

---

## 11. å¸¸è§é—®é¢˜ (FAQ)

### Q1: User-Agent è§£æå‡†ç¡®æ€§å¦‚ä½•?

**A**: User-Agent è§£æå‡†ç¡®æ€§çº¦ 90-95%ã€‚å»ºè®®:

1. ä½¿ç”¨æˆç†Ÿçš„è§£æåº“ (ua-parser)
2. ç»“åˆ Client Hints API
3. å®šæœŸæ›´æ–°è§£æè§„åˆ™

### Q2: Client Hints å…¼å®¹æ€§å¦‚ä½•?

**A**: Client Hints ç›®å‰æ”¯æŒ Chrome 89+, Edge 89+ã€‚å»ºè®®:

- ä¼˜å…ˆä½¿ç”¨ Client Hints
- Fallback åˆ° User-Agent è§£æ
- æ£€æµ‹ `navigator.userAgentData` å¯ç”¨æ€§

### Q3: å¦‚ä½•é¿å…è®¾å¤‡æŒ‡çº¹è¯†åˆ«?

**A**:

1. ä¸æ”¶é›† `device.id`
2. å¯¹ User-Agent è¿›è¡ŒåŒ¿ååŒ–
3. éµå®ˆ DNT (Do Not Track) è¯·æ±‚
4. æä¾›éšç§è®¾ç½®é€‰é¡¹

### Q4: ç§»åŠ¨åº”ç”¨å¦‚ä½•é›†æˆ?

**A**:

- **iOS**: ä½¿ç”¨ OpenTelemetry Swift SDK
- **Android**: ä½¿ç”¨ OpenTelemetry Android SDK
- **React Native**: ä½¿ç”¨ @opentelemetry/react-native
- **Flutter**: ä½¿ç”¨ opentelemetry_dart

### Q5: æµè§ˆå™¨èµ„æºå±æ€§ä¼šå½±å“æ€§èƒ½å—?

**A**: å½±å“æå° (<1ms):

- èµ„æºæ£€æµ‹é€šå¸¸åœ¨åº”ç”¨å¯åŠ¨æ—¶æ‰§è¡Œä¸€æ¬¡
- ä½¿ç”¨ç¼“å­˜é¿å…é‡å¤æ£€æµ‹
- Browser SDK å¼‚æ­¥å¯¼å‡º Spans

### Q6: å¦‚ä½•å¤„ç†çˆ¬è™«å’Œæœºå™¨äºº?

**A**:

```go
func isBot(ua string) bool {
    ua = strings.ToLower(ua)
    botPatterns := []string{"bot", "crawler", "spider"}
    for _, pattern := range botPatterns {
        if strings.Contains(ua, pattern) {
            return true
        }
    }
    return false
}
```

### Q7: device.model.name å¦‚ä½•è·å–ç²¾ç¡®å€¼?

**A**:

- **å‰ç«¯**: ä½¿ç”¨ Client Hints `Sec-CH-UA-Model` (éœ€ç”¨æˆ·æˆæƒ)
- **åç«¯**: ä» User-Agent è§£æ (ä¸å¤Ÿç²¾ç¡®)
- **ç§»åŠ¨åº”ç”¨**: ä½¿ç”¨åŸç”Ÿ API

### Q8: å¦‚ä½•å…³è”å‰åç«¯ Traces?

**A**:

1. å‰ç«¯ Browser SDK è‡ªåŠ¨åœ¨ Fetch/XHR è¯·æ±‚ä¸­æ³¨å…¥ `traceparent` Header
2. åç«¯ä½¿ç”¨ `otelhttp` ä¸­é—´ä»¶è‡ªåŠ¨æå– Trace Context
3. ç¡®ä¿å‰åç«¯ä½¿ç”¨ç›¸åŒçš„ OTLP Collector

### Q9: æµè§ˆå™¨ç‰ˆæœ¬å˜åŒ–å¦‚ä½•è¿½è¸ª?

**A**:

- åœ¨èµ„æºå±æ€§ä¸­è®°å½• `browser.version`
- ä½¿ç”¨ Metrics ç»Ÿè®¡ä¸åŒç‰ˆæœ¬çš„ä½¿ç”¨ç‡
- è®¾ç½®å‘Šè­¦æ£€æµ‹ç‰ˆæœ¬åˆ†å¸ƒå¼‚å¸¸

### Q10: å¦‚ä½•æµ‹è¯•èµ„æºæ£€æµ‹é€»è¾‘?

**A**:

```go
func TestUserAgentParsing(t *testing.T) {
    testCases := []struct {
        ua       string
        expected string
    }{
        {
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36",
            "Chrome",
        },
        // æ›´å¤šæµ‹è¯•ç”¨ä¾‹...
    }
    
    for _, tc := range testCases {
        parsed := ParseUserAgent(tc.ua)
        assert.Equal(t, tc.expected, parsed.Browser.Name)
    }
}
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **OpenTelemetry Semantic Conventions**:
   - Browser: <https://opentelemetry.io/docs/specs/semconv/resource/browser/>
   - Device: <https://opentelemetry.io/docs/specs/semconv/resource/device/>
   - User-Agent: <https://opentelemetry.io/docs/specs/semconv/resource/user-agent/>

2. **OpenTelemetry Browser SDK**:
   - Documentation: <https://opentelemetry.io/docs/instrumentation/js/>
   - GitHub: <https://github.com/open-telemetry/opentelemetry-js>

3. **User-Agent è§£æåº“**:
   - uap-go: <https://github.com/ua-parser/uap-go>
   - ua-parser-js: <https://github.com/faisalman/ua-parser-js>

4. **Web APIs**:
   - User-Agent Client Hints: <https://wicg.github.io/ua-client-hints/>
   - Network Information API: <https://developer.mozilla.org/en-US/docs/Web/API/Network_Information_API>

5. **ç›¸å…³æ–‡æ¡£**:
   - [01_æœåŠ¡èµ„æº.md](./01_æœåŠ¡èµ„æº.md) - Service å±æ€§
   - [05_ä¸»æœºä¸è¿›ç¨‹.md](./05_ä¸»æœºä¸è¿›ç¨‹.md) - Host å’Œ Process å±æ€§

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0  
**æœ€åæ›´æ–°**: 2025-10-09  
**OpenTelemetry ç‰ˆæœ¬**: 1.32.0+  
**Semantic Conventions ç‰ˆæœ¬**: 1.28.0+
