# 05 - ä¸»æœºä¸è¿›ç¨‹èµ„æºå±æ€§ (host.*/ process.*)

## ğŸ“‹ ç›®å½•

- [05 - ä¸»æœºä¸è¿›ç¨‹èµ„æºå±æ€§ (host.*/ process.*)](#05---ä¸»æœºä¸è¿›ç¨‹èµ„æºå±æ€§-host-process)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. ä¸»æœºä¸è¿›ç¨‹å±æ€§æ¦‚è¿°](#1-ä¸»æœºä¸è¿›ç¨‹å±æ€§æ¦‚è¿°)
    - [1.1 host.*vs process.* å‘½åç©ºé—´](#11-hostvs-process-å‘½åç©ºé—´)
    - [1.2 å±æ€§å±‚çº§å…³ç³»](#12-å±æ€§å±‚çº§å…³ç³»)
    - [1.3 æ£€æµ‹ç­–ç•¥](#13-æ£€æµ‹ç­–ç•¥)
  - [2. ä¸»æœºçº§åˆ«å±æ€§ (host.\*)](#2-ä¸»æœºçº§åˆ«å±æ€§-host)
    - [2.1 host.\* æ ‡å‡†å±æ€§](#21-host-æ ‡å‡†å±æ€§)
    - [2.2 ä¸»æœºæ ‡è¯† (ID/Name)](#22-ä¸»æœºæ ‡è¯†-idname)
    - [2.3 ä¸»æœºæ¶æ„ (Arch/Type)](#23-ä¸»æœºæ¶æ„-archtype)
    - [2.4 ä¸»æœºé•œåƒ (Image)](#24-ä¸»æœºé•œåƒ-image)
  - [3. æ“ä½œç³»ç»Ÿå±æ€§ (os.\*)](#3-æ“ä½œç³»ç»Ÿå±æ€§-os)
    - [3.1 os.\* æ ‡å‡†å±æ€§](#31-os-æ ‡å‡†å±æ€§)
    - [3.2 OS ç±»å‹å’Œç‰ˆæœ¬](#32-os-ç±»å‹å’Œç‰ˆæœ¬)
    - [3.3 OS æ„å»ºä¿¡æ¯](#33-os-æ„å»ºä¿¡æ¯)
    - [3.4 è·¨å¹³å°å…¼å®¹æ€§](#34-è·¨å¹³å°å…¼å®¹æ€§)
  - [6. Go å®ç° - OS æ£€æµ‹å™¨](#6-go-å®ç°---os-æ£€æµ‹å™¨)
    - [6.2 Linux ç³»ç»Ÿæ£€æµ‹](#62-linux-ç³»ç»Ÿæ£€æµ‹)
    - [6.3 Windows ç³»ç»Ÿæ£€æµ‹](#63-windows-ç³»ç»Ÿæ£€æµ‹)
    - [6.4 macOS ç³»ç»Ÿæ£€æµ‹](#64-macos-ç³»ç»Ÿæ£€æµ‹)
  - [7. Go å®ç° - Process æ£€æµ‹å™¨](#7-go-å®ç°---process-æ£€æµ‹å™¨)
    - [7.1 åŸºç¡€è¿›ç¨‹æ£€æµ‹](#71-åŸºç¡€è¿›ç¨‹æ£€æµ‹)
    - [7.2 è¿›ç¨‹å¯æ‰§è¡Œæ–‡ä»¶è·¯å¾„](#72-è¿›ç¨‹å¯æ‰§è¡Œæ–‡ä»¶è·¯å¾„)
    - [7.3 è¿›ç¨‹å‘½ä»¤è¡Œå‚æ•°](#73-è¿›ç¨‹å‘½ä»¤è¡Œå‚æ•°)
    - [7.4 è¿›ç¨‹æ‰€æœ‰è€…æ£€æµ‹](#74-è¿›ç¨‹æ‰€æœ‰è€…æ£€æµ‹)
    - [7.5 è¿›ç¨‹è¿è¡Œæ—¶æ£€æµ‹](#75-è¿›ç¨‹è¿è¡Œæ—¶æ£€æµ‹)
  - [8. å®¹å™¨ç¯å¢ƒç‰¹æ®Šå¤„ç†](#8-å®¹å™¨ç¯å¢ƒç‰¹æ®Šå¤„ç†)
    - [8.1 å®¹å™¨ vs ä¸»æœº](#81-å®¹å™¨-vs-ä¸»æœº)
    - [8.2 Docker å®¹å™¨æ£€æµ‹](#82-docker-å®¹å™¨æ£€æµ‹)
    - [8.3 Kubernetes Pod æ£€æµ‹](#83-kubernetes-pod-æ£€æµ‹)
    - [8.4 å®¹å™¨ ID æå–](#84-å®¹å™¨-id-æå–)
  - [9. å®Œæ•´ç¤ºä¾‹](#9-å®Œæ•´ç¤ºä¾‹)
    - [9.1 ç»Ÿä¸€èµ„æºæ£€æµ‹å™¨](#91-ç»Ÿä¸€èµ„æºæ£€æµ‹å™¨)
    - [9.2 ç”Ÿäº§ç¯å¢ƒé…ç½®](#92-ç”Ÿäº§ç¯å¢ƒé…ç½®)
    - [9.3 ç›‘æ§å’Œè¯Šæ–­](#93-ç›‘æ§å’Œè¯Šæ–­)
  - [10. æœ€ä½³å®è·µ](#10-æœ€ä½³å®è·µ)
    - [10.1 æ€§èƒ½ä¼˜åŒ–](#101-æ€§èƒ½ä¼˜åŒ–)
    - [10.2 é”™è¯¯å¤„ç†](#102-é”™è¯¯å¤„ç†)
    - [10.3 å®‰å…¨è€ƒè™‘](#103-å®‰å…¨è€ƒè™‘)
    - [10.4 è·¨å¹³å°æ”¯æŒ](#104-è·¨å¹³å°æ”¯æŒ)
  - [11. å¸¸è§é—®é¢˜ (FAQ)](#11-å¸¸è§é—®é¢˜-faq)
    - [Q1: host.name å’Œ host.id å¿…é¡»éƒ½è®¾ç½®å—?](#q1-hostname-å’Œ-hostid-å¿…é¡»éƒ½è®¾ç½®å—)
    - [Q2: å¦‚ä½•åœ¨å®¹å™¨ä¸­è·å–å®¿ä¸»æœºä¿¡æ¯?](#q2-å¦‚ä½•åœ¨å®¹å™¨ä¸­è·å–å®¿ä¸»æœºä¿¡æ¯)
    - [Q3: process.command\_line ä¼šæ³„éœ²æ•æ„Ÿä¿¡æ¯å—?](#q3-processcommand_line-ä¼šæ³„éœ²æ•æ„Ÿä¿¡æ¯å—)
    - [Q4: å¦‚ä½•å¤„ç†å¤šä¸ªè¿›ç¨‹å®ä¾‹?](#q4-å¦‚ä½•å¤„ç†å¤šä¸ªè¿›ç¨‹å®ä¾‹)
    - [Q5: ä¸ºä»€ä¹ˆ host.id åœ¨å®¹å™¨ä¸­æ¯æ¬¡éƒ½ä¸åŒ?](#q5-ä¸ºä»€ä¹ˆ-hostid-åœ¨å®¹å™¨ä¸­æ¯æ¬¡éƒ½ä¸åŒ)
    - [Q6: å¦‚ä½•æ£€æµ‹è™šæ‹ŸåŒ–ç±»å‹ (KVM/VMware/Xen)?](#q6-å¦‚ä½•æ£€æµ‹è™šæ‹ŸåŒ–ç±»å‹-kvmvmwarexen)
    - [Q7: Windows ä¸Šå¦‚ä½•è·å– machine GUID?](#q7-windows-ä¸Šå¦‚ä½•è·å–-machine-guid)
    - [Q8: macOS ä¸Šå¦‚ä½•è·å–ç¨³å®šçš„ host.id?](#q8-macos-ä¸Šå¦‚ä½•è·å–ç¨³å®šçš„-hostid)
    - [Q9: å¦‚ä½•æœ€å°åŒ–èµ„æºæ£€æµ‹çš„æ€§èƒ½å½±å“?](#q9-å¦‚ä½•æœ€å°åŒ–èµ„æºæ£€æµ‹çš„æ€§èƒ½å½±å“)
    - [Q10: è·¨å¹³å°å…¼å®¹æ€§å¦‚ä½•ä¿è¯?](#q10-è·¨å¹³å°å…¼å®¹æ€§å¦‚ä½•ä¿è¯)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## 1. ä¸»æœºä¸è¿›ç¨‹å±æ€§æ¦‚è¿°

### 1.1 host.*vs process.* å‘½åç©ºé—´

**æ ¸å¿ƒæ¦‚å¿µ**:

- `host.*`: ç‰©ç†æˆ–è™šæ‹Ÿæœºçº§åˆ«çš„å±æ€§ (ç¡¬ä»¶ã€OS)
- `os.*`: æ“ä½œç³»ç»Ÿå±æ€§ (é€šå¸¸ä½œä¸º host çš„å­å±æ€§)
- `process.*`: è¿›ç¨‹çº§åˆ«çš„å±æ€§ (PIDã€å‘½ä»¤è¡Œã€æ‰€æœ‰è€…)

**å‘½åç©ºé—´å¯¹æ¯”**:

| å‘½åç©ºé—´ | ä½œç”¨åŸŸ | ç”Ÿå‘½å‘¨æœŸ | ç¤ºä¾‹ |
|----------|--------|----------|------|
| `host.*` | ä¸»æœºçº§ | ä¸»æœºå¯åŠ¨åˆ°å…³é—­ | `host.name`, `host.id` |
| `os.*` | OS çº§ | OS å®‰è£…åˆ°é‡è£… | `os.type`, `os.version` |
| `process.*` | è¿›ç¨‹çº§ | è¿›ç¨‹å¯åŠ¨åˆ°é€€å‡º | `process.pid`, `process.command` |

### 1.2 å±æ€§å±‚çº§å…³ç³»

```mermaid
graph TD
    A[host.name / host.id] --> B[os.type / os.version]
    B --> C[process.pid]
    C --> D[process.command]
    C --> E[process.runtime.name]
    
    style A fill:#e1f5ff
    style B fill:#fff4e1
    style C fill:#ffe1f5
```

**å±‚çº§è¯´æ˜**:

1. **ä¸»æœºå±‚**: æœ€åº•å±‚ç¡¬ä»¶/è™šæ‹Ÿæœº
2. **OS å±‚**: æ“ä½œç³»ç»Ÿ
3. **è¿›ç¨‹å±‚**: åº”ç”¨è¿›ç¨‹

### 1.3 æ£€æµ‹ç­–ç•¥

**æ£€æµ‹ä¼˜å…ˆçº§**:

```go
type DetectionSource string

const (
    // 1. ç¯å¢ƒå˜é‡ (æœ€å¿«)
    SourceEnvVar DetectionSource = "env"
    
    // 2. ç³»ç»Ÿè°ƒç”¨ (ä¸­ç­‰æ€§èƒ½)
    SourceSyscall DetectionSource = "syscall"
    
    // 3. æ–‡ä»¶ç³»ç»Ÿè¯»å– (è¾ƒæ…¢)
    SourceFS DetectionSource = "fs"
    
    // 4. å¤–éƒ¨å‘½ä»¤æ‰§è¡Œ (æœ€æ…¢)
    SourceExec DetectionSource = "exec"
)
```

**æœ€ä½³å®è·µ**:

- **ä¼˜å…ˆä½¿ç”¨ Go æ ‡å‡†åº“**: `runtime.GOOS`, `runtime.GOARCH`, `os.Hostname()`
- **ç¼“å­˜æ£€æµ‹ç»“æœ**: ä¸»æœºå’Œ OS ä¿¡æ¯å¾ˆå°‘å˜åŒ–
- **é¿å…æ‰§è¡Œå¤–éƒ¨å‘½ä»¤**: æ€§èƒ½å·®ä¸”ä¸å¯ç§»æ¤

---

## 2. ä¸»æœºçº§åˆ«å±æ€§ (host.*)

### 2.1 host.* æ ‡å‡†å±æ€§

**æ ‡å‡†å±æ€§æ¸…å•**:

| å±æ€§å | ç±»å‹ | å¿…éœ€ | æè¿° | ç¤ºä¾‹ |
|--------|------|------|------|------|
| `host.name` | string | âœ… | ä¸»æœºå | `web-server-01.example.com` |
| `host.id` | string | æ¨è | ä¸»æœºå”¯ä¸€ ID | `2c54a1e3-8f4c-4d5e-9a1b-7c8d9e0f1a2b` |
| `host.type` | string | å¯é€‰ | ä¸»æœºç±»å‹ | `physical`, `virtual`, `container` |
| `host.arch` | string | æ¨è | CPU æ¶æ„ | `amd64`, `arm64` |
| `host.image.name` | string | å¯é€‰ | ä¸»æœºé•œåƒåç§° | `ubuntu-20.04-lts` |
| `host.image.id` | string | å¯é€‰ | ä¸»æœºé•œåƒ ID | `ami-0c55b159cbfafe1f0` |
| `host.image.version` | string | å¯é€‰ | ä¸»æœºé•œåƒç‰ˆæœ¬ | `20.04.3` |

**å±æ€§å…³ç³»**:

- `host.name` + `host.id` ç»„åˆå”¯ä¸€æ ‡è¯†ä¸»æœº
- `host.arch` æè¿°ç¡¬ä»¶æ¶æ„
- `host.image.*` åœ¨äº‘ç¯å¢ƒä¸­ç‰¹åˆ«é‡è¦

### 2.2 ä¸»æœºæ ‡è¯† (ID/Name)

**host.name è·å–**:

```go
package hostresource

import (
    "os"
    "strings"
    
    "go.opentelemetry.io/otel/attribute"
    semconv "go.opentelemetry.io/otel/semconv/v1.28.0"
)

// GetHostName è·å–ä¸»æœºå
func GetHostName() (string, error) {
    // ä¼˜å…ˆä»ç¯å¢ƒå˜é‡
    if hostname := os.Getenv("HOSTNAME"); hostname != "" {
        return hostname, nil
    }
    
    // ä½¿ç”¨ os.Hostname()
    hostname, err := os.Hostname()
    if err != nil {
        return "", err
    }
    
    // æ ‡å‡†åŒ–: è½¬æ¢ä¸ºå°å†™,å»é™¤åŸŸååç¼€
    hostname = strings.ToLower(hostname)
    
    return hostname, nil
}

// HostNameAttribute è¿”å›ä¸»æœºåå±æ€§
func HostNameAttribute() (attribute.KeyValue, error) {
    hostname, err := GetHostName()
    if err != nil {
        return attribute.KeyValue{}, err
    }
    
    return semconv.HostName(hostname), nil
}
```

**host.id ç”Ÿæˆç­–ç•¥**:

```go
package hostresource

import (
    "crypto/sha256"
    "encoding/hex"
    "fmt"
    "io"
    "os"
    "runtime"
    "strings"
    
    "go.opentelemetry.io/otel/attribute"
    semconv "go.opentelemetry.io/otel/semconv/v1.28.0"
)

// GetHostID è·å–ä¸»æœºå”¯ä¸€ ID
func GetHostID() (string, error) {
    // ä¼˜å…ˆä»ç¯å¢ƒå˜é‡
    if hostID := os.Getenv("HOST_ID"); hostID != "" {
        return hostID, nil
    }
    
    // å¹³å°ç‰¹å®šçš„ Host ID
    switch runtime.GOOS {
    case "linux":
        return getLinuxHostID()
    case "darwin":
        return getDarwinHostID()
    case "windows":
        return getWindowsHostID()
    default:
        // Fallback: åŸºäºä¸»æœºåç”Ÿæˆç¨³å®šçš„ ID
        return generateHostIDFromName()
    }
}

// getLinuxHostID ä» /etc/machine-id æˆ– /var/lib/dbus/machine-id è¯»å–
func getLinuxHostID() (string, error) {
    paths := []string{
        "/etc/machine-id",
        "/var/lib/dbus/machine-id",
    }
    
    for _, path := range paths {
        data, err := os.ReadFile(path)
        if err == nil {
            id := strings.TrimSpace(string(data))
            if id != "" {
                return id, nil
            }
        }
    }
    
    return "", fmt.Errorf("machine-id not found")
}

// getDarwinHostID ä» ioreg è·å– IOPlatformUUID
func getDarwinHostID() (string, error) {
    // æ–¹å¼1: ä»ç¯å¢ƒå˜é‡ (æ¨èåœ¨å®¹å™¨ä¸­è®¾ç½®)
    if uuid := os.Getenv("MACOS_PLATFORM_UUID"); uuid != "" {
        return uuid, nil
    }
    
    // æ–¹å¼2: ä»æ–‡ä»¶ (å¦‚æœå·²ç¼“å­˜)
    data, err := os.ReadFile("/var/db/.SystemSerialNumber")
    if err == nil {
        return strings.TrimSpace(string(data)), nil
    }
    
    // æ–¹å¼3: Fallback
    return generateHostIDFromName()
}

// getWindowsHostID ä»æ³¨å†Œè¡¨è·å– MachineGuid
func getWindowsHostID() (string, error) {
    // æ–¹å¼1: ä»ç¯å¢ƒå˜é‡
    if guid := os.Getenv("MACHINE_GUID"); guid != "" {
        return guid, nil
    }
    
    // æ–¹å¼2: Fallback (Windows æ³¨å†Œè¡¨è¯»å–éœ€è¦ golang.org/x/sys/windows)
    // è¿™é‡Œä½¿ç”¨ç®€åŒ–çš„ fallback
    return generateHostIDFromName()
}

// generateHostIDFromName åŸºäºä¸»æœºåç”Ÿæˆç¨³å®šçš„ ID (fallback)
func generateHostIDFromName() (string, error) {
    hostname, err := GetHostName()
    if err != nil {
        return "", err
    }
    
    // ä½¿ç”¨ SHA-256 ç”Ÿæˆç¨³å®šçš„ UUID
    hash := sha256.Sum256([]byte(hostname))
    return hex.EncodeToString(hash[:16]), nil // 128-bit UUID
}

// HostIDAttribute è¿”å›ä¸»æœº ID å±æ€§
func HostIDAttribute() (attribute.KeyValue, error) {
    hostID, err := GetHostID()
    if err != nil {
        return attribute.KeyValue{}, err
    }
    
    return semconv.HostID(hostID), nil
}
```

### 2.3 ä¸»æœºæ¶æ„ (Arch/Type)

**host.arch æ£€æµ‹**:

```go
package hostresource

import (
    "runtime"
    
    "go.opentelemetry.io/otel/attribute"
    semconv "go.opentelemetry.io/otel/semconv/v1.28.0"
)

// GetHostArch è·å– CPU æ¶æ„
func GetHostArch() string {
    return runtime.GOARCH
}

// HostArchAttribute è¿”å›ä¸»æœºæ¶æ„å±æ€§
func HostArchAttribute() attribute.KeyValue {
    return semconv.HostArch(GetHostArch())
}

// æ ‡å‡†æ¶æ„å€¼:
// - amd64 (x86-64)
// - arm64 (ARM 64-bit)
// - arm (ARM 32-bit)
// - 386 (x86 32-bit)
// - ppc64le (PowerPC 64-bit LE)
// - s390x (IBM System z)
```

**host.type æ£€æµ‹**:

```go
// GetHostType æ£€æµ‹ä¸»æœºç±»å‹
func GetHostType() string {
    // æ£€æµ‹å®¹å™¨ç¯å¢ƒ
    if isRunningInContainer() {
        return "container"
    }
    
    // æ£€æµ‹è™šæ‹ŸåŒ–
    if isVirtualMachine() {
        return "virtual"
    }
    
    return "physical"
}

// isRunningInContainer æ£€æµ‹æ˜¯å¦åœ¨å®¹å™¨ä¸­è¿è¡Œ
func isRunningInContainer() bool {
    // Docker å®¹å™¨æ ‡è¯†
    if _, err := os.Stat("/.dockerenv"); err == nil {
        return true
    }
    
    // Kubernetes Pod æ ‡è¯†
    if os.Getenv("KUBERNETES_SERVICE_HOST") != "" {
        return true
    }
    
    // cgroup æ£€æµ‹ (Linux)
    if runtime.GOOS == "linux" {
        data, err := os.ReadFile("/proc/1/cgroup")
        if err == nil && (strings.Contains(string(data), "docker") ||
            strings.Contains(string(data), "kubepods")) {
            return true
        }
    }
    
    return false
}

// isVirtualMachine æ£€æµ‹æ˜¯å¦åœ¨è™šæ‹Ÿæœºä¸­è¿è¡Œ
func isVirtualMachine() bool {
    switch runtime.GOOS {
    case "linux":
        return isLinuxVM()
    case "darwin":
        // macOS é€šå¸¸åœ¨è™šæ‹Ÿæœºä¸­è¿è¡Œè¾ƒå°‘è§
        return false
    case "windows":
        return isWindowsVM()
    default:
        return false
    }
}

func isLinuxVM() bool {
    // æ£€æµ‹ /sys/class/dmi/id/product_name
    data, err := os.ReadFile("/sys/class/dmi/id/product_name")
    if err == nil {
        product := strings.ToLower(string(data))
        vmIndicators := []string{"virtualbox", "vmware", "qemu", "kvm", "xen"}
        for _, indicator := range vmIndicators {
            if strings.Contains(product, indicator) {
                return true
            }
        }
    }
    
    return false
}

func isWindowsVM() bool {
    // Windows è™šæ‹ŸåŒ–æ£€æµ‹éœ€è¦ WMI æŸ¥è¯¢
    // ç®€åŒ–å®ç°: æ£€æŸ¥ç¯å¢ƒå˜é‡
    return os.Getenv("VM_VENDOR") != ""
}

// HostTypeAttribute è¿”å›ä¸»æœºç±»å‹å±æ€§
func HostTypeAttribute() attribute.KeyValue {
    return semconv.HostType(GetHostType())
}
```

### 2.4 ä¸»æœºé•œåƒ (Image)

**é€‚ç”¨åœºæ™¯**: äº‘ç¯å¢ƒ (AWS EC2, GCE, Azure VM)

```go
package hostresource

import (
    "encoding/json"
    "io"
    "net/http"
    "os"
    "time"
    
    "go.opentelemetry.io/otel/attribute"
    semconv "go.opentelemetry.io/otel/semconv/v1.28.0"
)

// GetHostImage è·å–ä¸»æœºé•œåƒä¿¡æ¯
func GetHostImage() (*HostImage, error) {
    // ä¼˜å…ˆä»ç¯å¢ƒå˜é‡
    if imageName := os.Getenv("HOST_IMAGE_NAME"); imageName != "" {
        return &HostImage{
            Name:    imageName,
            ID:      os.Getenv("HOST_IMAGE_ID"),
            Version: os.Getenv("HOST_IMAGE_VERSION"),
        }, nil
    }
    
    // äº‘å¹³å° Metadata API
    if isAWSEC2() {
        return getAWSImageInfo()
    }
    
    if isGCE() {
        return getGCEImageInfo()
    }
    
    if isAzureVM() {
        return getAzureImageInfo()
    }
    
    return nil, fmt.Errorf("host image not available")
}

type HostImage struct {
    Name    string
    ID      string
    Version string
}

func isAWSEC2() bool {
    return os.Getenv("AWS_EXECUTION_ENV") != "" || isMetadataAvailable("http://169.254.169.254/latest/meta-data/")
}

func getAWSImageInfo() (*HostImage, error) {
    // AWS EC2 Metadata API
    amiID, err := fetchMetadata("http://169.254.169.254/latest/meta-data/ami-id")
    if err != nil {
        return nil, err
    }
    
    return &HostImage{
        ID: amiID,
        // Name å’Œ Version éœ€è¦ä» EC2 Tags æˆ– ImageDescription è·å–
    }, nil
}

func isGCE() bool {
    return isMetadataAvailable("http://metadata.google.internal")
}

func getGCEImageInfo() (*HostImage, error) {
    // GCE Metadata API
    imageName, err := fetchMetadata("http://metadata.google.internal/computeMetadata/v1/instance/image")
    if err != nil {
        return nil, err
    }
    
    return &HostImage{
        Name: imageName,
    }, nil
}

func isAzureVM() bool {
    return isMetadataAvailable("http://169.254.169.254/metadata/instance")
}

func getAzureImageInfo() (*HostImage, error) {
    // Azure VM Metadata API
    resp, err := http.Get("http://169.254.169.254/metadata/instance/compute?api-version=2021-02-01")
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    var metadata struct {
        ImageReference struct {
            ID        string `json:"id"`
            Publisher string `json:"publisher"`
            Offer     string `json:"offer"`
            Sku       string `json:"sku"`
            Version   string `json:"version"`
        } `json:"imageReference"`
    }
    
    if err := json.NewDecoder(resp.Body).Decode(&metadata); err != nil {
        return nil, err
    }
    
    return &HostImage{
        Name:    fmt.Sprintf("%s:%s:%s", metadata.ImageReference.Publisher, metadata.ImageReference.Offer, metadata.ImageReference.Sku),
        ID:      metadata.ImageReference.ID,
        Version: metadata.ImageReference.Version,
    }, nil
}

func isMetadataAvailable(endpoint string) bool {
    client := &http.Client{Timeout: 1 * time.Second}
    resp, err := client.Get(endpoint)
    if err != nil {
        return false
    }
    defer resp.Body.Close()
    return resp.StatusCode == http.StatusOK
}

func fetchMetadata(url string) (string, error) {
    client := &http.Client{Timeout: 2 * time.Second}
    resp, err := client.Get(url)
    if err != nil {
        return "", err
    }
    defer resp.Body.Close()
    
    data, err := io.ReadAll(resp.Body)
    if err != nil {
        return "", err
    }
    
    return strings.TrimSpace(string(data)), nil
}

// HostImageAttributes è¿”å›ä¸»æœºé•œåƒå±æ€§
func HostImageAttributes() []attribute.KeyValue {
    image, err := GetHostImage()
    if err != nil {
        return nil
    }
    
    attrs := []attribute.KeyValue{}
    
    if image.Name != "" {
        attrs = append(attrs, semconv.HostImageName(image.Name))
    }
    
    if image.ID != "" {
        attrs = append(attrs, semconv.HostImageID(image.ID))
    }
    
    if image.Version != "" {
        attrs = append(attrs, semconv.HostImageVersion(image.Version))
    }
    
    return attrs
}
```

---

## 3. æ“ä½œç³»ç»Ÿå±æ€§ (os.*)

### 3.1 os.* æ ‡å‡†å±æ€§

**æ ‡å‡†å±æ€§æ¸…å•**:

| å±æ€§å | ç±»å‹ | å¿…éœ€ | æè¿° | ç¤ºä¾‹ |
|--------|------|------|------|------|
| `os.type` | string | âœ… | OS ç±»å‹ | `linux`, `windows`, `darwin` |
| `os.description` | string | æ¨è | OS å®Œæ•´æè¿° | `Ubuntu 20.04.3 LTS` |
| `os.name` | string | å¯é€‰ | OS åç§° | `Ubuntu` |
| `os.version` | string | æ¨è | OS ç‰ˆæœ¬ | `20.04` |
| `os.build_id` | string | å¯é€‰ | OS æ„å»º ID | `#62-Ubuntu SMP Tue Nov 22` |

### 3.2 OS ç±»å‹å’Œç‰ˆæœ¬

**os.type æ£€æµ‹**:

```go
package osresource

import (
    "runtime"
    
    "go.opentelemetry.io/otel/attribute"
    semconv "go.opentelemetry.io/otel/semconv/v1.28.0"
)

// GetOSType è·å– OS ç±»å‹
func GetOSType() string {
    return runtime.GOOS
}

// OSTypeAttribute è¿”å› OS ç±»å‹å±æ€§
func OSTypeAttribute() attribute.KeyValue {
    return semconv.OSType(GetOSType())
}

// æ ‡å‡† OS ç±»å‹å€¼:
// - linux
// - windows
// - darwin (macOS)
// - freebsd
// - netbsd
// - openbsd
// - dragonfly
// - solaris
// - aix
```

**os.version æ£€æµ‹ (è·¨å¹³å°)**:

```go
package osresource

import (
    "fmt"
    "os"
    "runtime"
    "strings"
    
    "go.opentelemetry.io/otel/attribute"
    semconv "go.opentelemetry.io/otel/semconv/v1.28.0"
)

// GetOSVersion è·å– OS ç‰ˆæœ¬
func GetOSVersion() (string, error) {
    switch runtime.GOOS {
    case "linux":
        return getLinuxVersion()
    case "darwin":
        return getDarwinVersion()
    case "windows":
        return getWindowsVersion()
    default:
        return "", fmt.Errorf("unsupported OS: %s", runtime.GOOS)
    }
}

// OSVersionAttribute è¿”å› OS ç‰ˆæœ¬å±æ€§
func OSVersionAttribute() (attribute.KeyValue, error) {
    version, err := GetOSVersion()
    if err != nil {
        return attribute.KeyValue{}, err
    }
    
    return semconv.OSVersion(version), nil
}
```

### 3.3 OS æ„å»ºä¿¡æ¯

**os.description æ£€æµ‹**:

```go
// GetOSDescription è·å– OS å®Œæ•´æè¿°
func GetOSDescription() (string, error) {
    switch runtime.GOOS {
    case "linux":
        return getLinuxDescription()
    case "darwin":
        return getDarwinDescription()
    case "windows":
        return getWindowsDescription()
    default:
        return fmt.Sprintf("%s %s", runtime.GOOS, runtime.GOARCH), nil
    }
}

// OSDescriptionAttribute è¿”å› OS æè¿°å±æ€§
func OSDescriptionAttribute() (attribute.KeyValue, error) {
    description, err := GetOSDescription()
    if err != nil {
        return attribute.KeyValue{}, err
    }
    
    return semconv.OSDescription(description), nil
}
```

### 3.4 è·¨å¹³å°å…¼å®¹æ€§

**ç»Ÿä¸€çš„ OS ä¿¡æ¯ç»“æ„**:

```go
// OSInfo æ“ä½œç³»ç»Ÿä¿¡æ¯
type OSInfo struct {
    Type        string // linux, windows, darwin
    Name        string // Ubuntu, Windows Server, macOS
    Version     string // 20.04, 10.0.19044, 12.3
    Description string // å®Œæ•´æè¿°
    BuildID     string // æ„å»º ID
}

// GetOSInfo è·å–å®Œæ•´çš„ OS ä¿¡æ¯
func GetOSInfo() (*OSInfo, error) {
    info := &OSInfo{
        Type: runtime.GOOS,
    }
    
    switch runtime.GOOS {
    case "linux":
        return getLinuxOSInfo()
    case "darwin":
        return getDarwinOSInfo()
    case "windows":
        return getWindowsOSInfo()
    default:
        return info, nil
    }
}

// OSAttributes è¿”å›æ‰€æœ‰ OS å±æ€§
func OSAttributes() ([]attribute.KeyValue, error) {
    info, err := GetOSInfo()
    if err != nil {
        return nil, err
    }
    
    attrs := []attribute.KeyValue{
        semconv.OSType(info.Type),
    }
    
    if info.Name != "" {
        attrs = append(attrs, semconv.OSName(info.Name))
    }
    
    if info.Version != "" {
        attrs = append(attrs, semconv.OSVersion(info.Version))
    }
    
    if info.Description != "" {
        attrs = append(attrs, semconv.OSDescription(info.Description))
    }
    
    if info.BuildID != "" {
        attrs = append(attrs, semconv.OSBuildID(info.BuildID))
    }
    
    return attrs, nil
}
```

---

## 6. Go å®ç° - OS æ£€æµ‹å™¨

### 6.2 Linux ç³»ç»Ÿæ£€æµ‹

**ä» /etc/os-release è¯»å–**:

```go
package osresource

import (
    "bufio"
    "os"
    "strings"
)

// getLinuxOSInfo è·å– Linux ç³»ç»Ÿä¿¡æ¯
func getLinuxOSInfo() (*OSInfo, error) {
    info := &OSInfo{
        Type: "linux",
    }
    
    // è§£æ /etc/os-release
    osRelease, err := parseOSRelease("/etc/os-release")
    if err != nil {
        // Fallback: /usr/lib/os-release
        osRelease, err = parseOSRelease("/usr/lib/os-release")
        if err != nil {
            return info, nil
        }
    }
    
    info.Name = osRelease["NAME"]
    info.Version = osRelease["VERSION_ID"]
    info.Description = osRelease["PRETTY_NAME"]
    info.BuildID = osRelease["BUILD_ID"]
    
    return info, nil
}

// parseOSRelease è§£æ os-release æ–‡ä»¶
func parseOSRelease(path string) (map[string]string, error) {
    file, err := os.Open(path)
    if err != nil {
        return nil, err
    }
    defer file.Close()
    
    result := make(map[string]string)
    scanner := bufio.NewScanner(file)
    
    for scanner.Scan() {
        line := scanner.Text()
        
        // è·³è¿‡æ³¨é‡Šå’Œç©ºè¡Œ
        if strings.HasPrefix(line, "#") || line == "" {
            continue
        }
        
        // è§£æ KEY=VALUE
        parts := strings.SplitN(line, "=", 2)
        if len(parts) != 2 {
            continue
        }
        
        key := parts[0]
        value := strings.Trim(parts[1], `"`)
        
        result[key] = value
    }
    
    return result, scanner.Err()
}

// getLinuxVersion è·å– Linux å†…æ ¸ç‰ˆæœ¬
func getLinuxVersion() (string, error) {
    data, err := os.ReadFile("/proc/version")
    if err != nil {
        return "", err
    }
    
    // è§£æ: Linux version 5.10.0-14-amd64 ...
    versionStr := string(data)
    if strings.HasPrefix(versionStr, "Linux version ") {
        parts := strings.Fields(versionStr)
        if len(parts) >= 3 {
            return parts[2], nil
        }
    }
    
    return "", fmt.Errorf("failed to parse kernel version")
}

// getLinuxDescription è·å– Linux å®Œæ•´æè¿°
func getLinuxDescription() (string, error) {
    osRelease, err := parseOSRelease("/etc/os-release")
    if err != nil {
        return "", err
    }
    
    if prettyName, ok := osRelease["PRETTY_NAME"]; ok {
        return prettyName, nil
    }
    
    return fmt.Sprintf("%s %s", osRelease["NAME"], osRelease["VERSION"]), nil
}
```

### 6.3 Windows ç³»ç»Ÿæ£€æµ‹

**ä½¿ç”¨ golang.org/x/sys/windows**:

```go
//go:build windows

package osresource

import (
    "fmt"
    "unsafe"
    
    "golang.org/x/sys/windows"
)

// getWindowsOSInfo è·å– Windows ç³»ç»Ÿä¿¡æ¯
func getWindowsOSInfo() (*OSInfo, error) {
    info := &OSInfo{
        Type: "windows",
    }
    
    // è·å– Windows ç‰ˆæœ¬
    version := windows.RtlGetVersion()
    
    info.Version = fmt.Sprintf("%d.%d.%d",
        version.MajorVersion,
        version.MinorVersion,
        version.BuildNumber,
    )
    
    // è·å– Windows åç§°
    info.Name = getWindowsProductName()
    
    // å®Œæ•´æè¿°
    info.Description = fmt.Sprintf("%s (Build %d)",
        info.Name,
        version.BuildNumber,
    )
    
    return info, nil
}

// getWindowsProductName è·å– Windows äº§å“åç§°
func getWindowsProductName() string {
    // ä»æ³¨å†Œè¡¨è¯»å–
    // HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProductName
    
    k, err := windows.RegOpenKeyEx(
        windows.HKEY_LOCAL_MACHINE,
        windows.StringToUTF16Ptr(`SOFTWARE\Microsoft\Windows NT\CurrentVersion`),
        0,
        windows.KEY_READ,
    )
    if err != nil {
        return "Windows"
    }
    defer windows.RegCloseKey(k)
    
    var productName [256]uint16
    size := uint32(len(productName) * 2)
    
    err = windows.RegQueryValueEx(
        k,
        windows.StringToUTF16Ptr("ProductName"),
        nil,
        nil,
        (*byte)(unsafe.Pointer(&productName[0])),
        &size,
    )
    if err != nil {
        return "Windows"
    }
    
    return windows.UTF16ToString(productName[:])
}

// getWindowsVersion è·å– Windows ç‰ˆæœ¬å­—ç¬¦ä¸²
func getWindowsVersion() (string, error) {
    version := windows.RtlGetVersion()
    return fmt.Sprintf("%d.%d.%d",
        version.MajorVersion,
        version.MinorVersion,
        version.BuildNumber,
    ), nil
}

// getWindowsDescription è·å– Windows å®Œæ•´æè¿°
func getWindowsDescription() (string, error) {
    info, err := getWindowsOSInfo()
    if err != nil {
        return "", err
    }
    return info.Description, nil
}
```

### 6.4 macOS ç³»ç»Ÿæ£€æµ‹

**ä½¿ç”¨ sw_vers å‘½ä»¤** (æˆ–è§£æç³»ç»Ÿæ–‡ä»¶):

```go
//go:build darwin

package osresource

import (
    "bytes"
    "os/exec"
    "strings"
)

// getDarwinOSInfo è·å– macOS ç³»ç»Ÿä¿¡æ¯
func getDarwinOSInfo() (*OSInfo, error) {
    info := &OSInfo{
        Type: "darwin",
        Name: "macOS",
    }
    
    // ä½¿ç”¨ sw_vers è·å–ç‰ˆæœ¬ä¿¡æ¯
    version, err := execSWVers("ProductVersion")
    if err == nil {
        info.Version = version
    }
    
    build, err := execSWVers("BuildVersion")
    if err == nil {
        info.BuildID = build
    }
    
    // å®Œæ•´æè¿°
    if info.Version != "" {
        info.Description = fmt.Sprintf("macOS %s (Build %s)", info.Version, info.BuildID)
    }
    
    return info, nil
}

// execSWVers æ‰§è¡Œ sw_vers å‘½ä»¤
func execSWVers(key string) (string, error) {
    cmd := exec.Command("sw_vers", "-"+key)
    var out bytes.Buffer
    cmd.Stdout = &out
    
    if err := cmd.Run(); err != nil {
        return "", err
    }
    
    return strings.TrimSpace(out.String()), nil
}

// getDarwinVersion è·å– macOS ç‰ˆæœ¬
func getDarwinVersion() (string, error) {
    return execSWVers("ProductVersion")
}

// getDarwinDescription è·å– macOS å®Œæ•´æè¿°
func getDarwinDescription() (string, error) {
    info, err := getDarwinOSInfo()
    if err != nil {
        return "", err
    }
    return info.Description, nil
}
```

---

## 7. Go å®ç° - Process æ£€æµ‹å™¨

### 7.1 åŸºç¡€è¿›ç¨‹æ£€æµ‹

**process.pid å’Œ process.parent_pid**:

```go
package processresource

import (
    "os"
    
    "go.opentelemetry.io/otel/attribute"
    semconv "go.opentelemetry.io/otel/semconv/v1.28.0"
)

// GetProcessPID è·å–å½“å‰è¿›ç¨‹ PID
func GetProcessPID() int {
    return os.Getpid()
}

// GetParentPID è·å–çˆ¶è¿›ç¨‹ PID
func GetParentPID() int {
    return os.Getppid()
}

// ProcessPIDAttribute è¿”å›è¿›ç¨‹ PID å±æ€§
func ProcessPIDAttribute() attribute.KeyValue {
    return semconv.ProcessPID(GetProcessPID())
}

// ProcessParentPIDAttribute è¿”å›çˆ¶è¿›ç¨‹ PID å±æ€§
func ProcessParentPIDAttribute() attribute.KeyValue {
    return semconv.ProcessParentPID(GetParentPID())
}
```

### 7.2 è¿›ç¨‹å¯æ‰§è¡Œæ–‡ä»¶è·¯å¾„

**process.executable.path å’Œ process.executable.name**:

```go
package processresource

import (
    "os"
    "path/filepath"
    
    "go.opentelemetry.io/otel/attribute"
    semconv "go.opentelemetry.io/otel/semconv/v1.28.0"
)

// GetExecutablePath è·å–å¯æ‰§è¡Œæ–‡ä»¶è·¯å¾„
func GetExecutablePath() (string, error) {
    return os.Executable()
}

// GetExecutableName è·å–å¯æ‰§è¡Œæ–‡ä»¶åç§°
func GetExecutableName() (string, error) {
    exePath, err := os.Executable()
    if err != nil {
        return "", err
    }
    
    return filepath.Base(exePath), nil
}

// ProcessExecutablePathAttribute è¿”å›å¯æ‰§è¡Œæ–‡ä»¶è·¯å¾„å±æ€§
func ProcessExecutablePathAttribute() (attribute.KeyValue, error) {
    exePath, err := GetExecutablePath()
    if err != nil {
        return attribute.KeyValue{}, err
    }
    
    return semconv.ProcessExecutablePath(exePath), nil
}

// ProcessExecutableNameAttribute è¿”å›å¯æ‰§è¡Œæ–‡ä»¶åç§°å±æ€§
func ProcessExecutableNameAttribute() (attribute.KeyValue, error) {
    exeName, err := GetExecutableName()
    if err != nil {
        return attribute.KeyValue{}, err
    }
    
    return semconv.ProcessExecutableName(exeName), nil
}
```

### 7.3 è¿›ç¨‹å‘½ä»¤è¡Œå‚æ•°

**process.command å’Œ process.command_line**:

```go
package processresource

import (
    "os"
    "strings"
    
    "go.opentelemetry.io/otel/attribute"
    semconv "go.opentelemetry.io/otel/semconv/v1.28.0"
)

// GetProcessCommand è·å–è¿›ç¨‹å‘½ä»¤ (ä¸å«å‚æ•°)
func GetProcessCommand() (string, error) {
    return GetExecutablePath()
}

// GetProcessCommandLine è·å–å®Œæ•´å‘½ä»¤è¡Œ (å«å‚æ•°)
func GetProcessCommandLine() string {
    args := os.Args
    return strings.Join(args, " ")
}

// GetProcessCommandArgs è·å–å‘½ä»¤è¡Œå‚æ•°åˆ—è¡¨
func GetProcessCommandArgs() []string {
    if len(os.Args) > 1 {
        return os.Args[1:]
    }
    return []string{}
}

// ProcessCommandAttribute è¿”å›è¿›ç¨‹å‘½ä»¤å±æ€§
func ProcessCommandAttribute() (attribute.KeyValue, error) {
    command, err := GetProcessCommand()
    if err != nil {
        return attribute.KeyValue{}, err
    }
    
    return semconv.ProcessCommand(command), nil
}

// ProcessCommandLineAttribute è¿”å›å®Œæ•´å‘½ä»¤è¡Œå±æ€§
func ProcessCommandLineAttribute() attribute.KeyValue {
    return semconv.ProcessCommandLine(GetProcessCommandLine())
}

// ProcessCommandArgsAttribute è¿”å›å‘½ä»¤è¡Œå‚æ•°å±æ€§
func ProcessCommandArgsAttribute() attribute.KeyValue {
    args := GetProcessCommandArgs()
    return semconv.ProcessCommandArgs(args...)
}
```

### 7.4 è¿›ç¨‹æ‰€æœ‰è€…æ£€æµ‹

**process.owner å’Œ process.user.***:

```go
package processresource

import (
    "os/user"
    "strconv"
    
    "go.opentelemetry.io/otel/attribute"
    semconv "go.opentelemetry.io/otel/semconv/v1.28.0"
)

// GetProcessOwner è·å–è¿›ç¨‹æ‰€æœ‰è€…ä¿¡æ¯
func GetProcessOwner() (*ProcessOwner, error) {
    currentUser, err := user.Current()
    if err != nil {
        return nil, err
    }
    
    uid, _ := strconv.Atoi(currentUser.Uid)
    gid, _ := strconv.Atoi(currentUser.Gid)
    
    return &ProcessOwner{
        Username: currentUser.Username,
        UID:      uid,
        GID:      gid,
    }, nil
}

type ProcessOwner struct {
    Username string
    UID      int
    GID      int
}

// ProcessOwnerAttribute è¿”å›è¿›ç¨‹æ‰€æœ‰è€…å±æ€§
func ProcessOwnerAttribute() (attribute.KeyValue, error) {
    owner, err := GetProcessOwner()
    if err != nil {
        return attribute.KeyValue{}, err
    }
    
    return semconv.ProcessOwner(owner.Username), nil
}
```

### 7.5 è¿›ç¨‹è¿è¡Œæ—¶æ£€æµ‹

**process.runtime.*** (Go ç‰¹å®š):

```go
package processresource

import (
    "runtime"
    
    "go.opentelemetry.io/otel/attribute"
    semconv "go.opentelemetry.io/otel/semconv/v1.28.0"
)

// GetProcessRuntimeInfo è·å–è¿›ç¨‹è¿è¡Œæ—¶ä¿¡æ¯
func GetProcessRuntimeInfo() *ProcessRuntime {
    return &ProcessRuntime{
        Name:        "go",
        Version:     runtime.Version(),
        Description: runtime.Compiler + " " + runtime.Version(),
    }
}

type ProcessRuntime struct {
    Name        string
    Version     string
    Description string
}

// ProcessRuntimeAttributes è¿”å›è¿è¡Œæ—¶å±æ€§
func ProcessRuntimeAttributes() []attribute.KeyValue {
    rt := GetProcessRuntimeInfo()
    
    return []attribute.KeyValue{
        semconv.ProcessRuntimeName(rt.Name),
        semconv.ProcessRuntimeVersion(rt.Version),
        semconv.ProcessRuntimeDescription(rt.Description),
    }
}
```

---

## 8. å®¹å™¨ç¯å¢ƒç‰¹æ®Šå¤„ç†

### 8.1 å®¹å™¨ vs ä¸»æœº

**åŒºåˆ†å®¹å™¨å’Œä¸»æœºå±æ€§**:

```go
package containerresource

import (
    "os"
    "runtime"
    "strings"
)

// IsRunningInContainer æ£€æµ‹æ˜¯å¦åœ¨å®¹å™¨ä¸­è¿è¡Œ
func IsRunningInContainer() bool {
    // Docker
    if _, err := os.Stat("/.dockerenv"); err == nil {
        return true
    }
    
    // Kubernetes
    if os.Getenv("KUBERNETES_SERVICE_HOST") != "" {
        return true
    }
    
    // cgroup æ£€æµ‹ (Linux)
    if runtime.GOOS == "linux" {
        if data, err := os.ReadFile("/proc/1/cgroup"); err == nil {
            content := string(data)
            return strings.Contains(content, "docker") ||
                   strings.Contains(content, "kubepods") ||
                   strings.Contains(content, "containerd")
        }
    }
    
    return false
}

// GetContainerType è·å–å®¹å™¨ç±»å‹
func GetContainerType() string {
    if _, err := os.Stat("/.dockerenv"); err == nil {
        return "docker"
    }
    
    if os.Getenv("KUBERNETES_SERVICE_HOST") != "" {
        return "kubernetes"
    }
    
    if runtime.GOOS == "linux" {
        if data, err := os.ReadFile("/proc/1/cgroup"); err == nil {
            content := string(data)
            if strings.Contains(content, "docker") {
                return "docker"
            }
            if strings.Contains(content, "kubepods") {
                return "kubernetes"
            }
            if strings.Contains(content, "containerd") {
                return "containerd"
            }
        }
    }
    
    return ""
}
```

### 8.2 Docker å®¹å™¨æ£€æµ‹

**container.id æå–**:

```go
// GetDockerContainerID è·å– Docker å®¹å™¨ ID
func GetDockerContainerID() (string, error) {
    // æ–¹å¼1: ä»ç¯å¢ƒå˜é‡
    if containerID := os.Getenv("HOSTNAME"); containerID != "" {
        // Docker é»˜è®¤å°†å®¹å™¨ ID å‰ç¼€ä½œä¸º hostname
        return containerID, nil
    }
    
    // æ–¹å¼2: ä» cgroup æå–
    if runtime.GOOS == "linux" {
        return extractContainerIDFromCGroup()
    }
    
    return "", fmt.Errorf("container ID not found")
}

// extractContainerIDFromCGroup ä» cgroup æå–å®¹å™¨ ID
func extractContainerIDFromCGroup() (string, error) {
    data, err := os.ReadFile("/proc/self/cgroup")
    if err != nil {
        return "", err
    }
    
    lines := strings.Split(string(data), "\n")
    for _, line := range lines {
        // æ ¼å¼: 12:pids:/docker/<container-id>
        if strings.Contains(line, "docker") {
            parts := strings.Split(line, "/")
            if len(parts) > 0 {
                containerID := parts[len(parts)-1]
                if len(containerID) == 64 { // Docker å®¹å™¨ ID æ˜¯ 64 å­—ç¬¦
                    return containerID, nil
                }
            }
        }
    }
    
    return "", fmt.Errorf("container ID not found in cgroup")
}
```

### 8.3 Kubernetes Pod æ£€æµ‹

**å·²åœ¨ 04_Kubernetesèµ„æº.md ä¸­è¯¦ç»†è¯´æ˜**:

### 8.4 å®¹å™¨ ID æå–

**ç»Ÿä¸€çš„å®¹å™¨ ID æå–**:

```go
// GetContainerID è·å–å®¹å™¨ ID (è‡ªåŠ¨æ£€æµ‹å®¹å™¨ç±»å‹)
func GetContainerID() (string, error) {
    containerType := GetContainerType()
    
    switch containerType {
    case "docker":
        return GetDockerContainerID()
    case "kubernetes":
        // Kubernetes ä½¿ç”¨ Pod UID
        if podUID := os.Getenv("K8S_POD_UID"); podUID != "" {
            return podUID, nil
        }
        return "", fmt.Errorf("k8s pod uid not found")
    case "containerd":
        return extractContainerIDFromCGroup()
    default:
        return "", fmt.Errorf("not running in container")
    }
}
```

---

## 9. å®Œæ•´ç¤ºä¾‹

### 9.1 ç»Ÿä¸€èµ„æºæ£€æµ‹å™¨

**main.go**:

```go
package main

import (
    "context"
    "log"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.28.0"
    
    "myapp/containerresource"
    "myapp/hostresource"
    "myapp/osresource"
    "myapp/processresource"
)

func main() {
    ctx := context.Background()
    
    // æ£€æµ‹æ‰€æœ‰èµ„æº
    res, err := detectAllResources(ctx)
    if err != nil {
        log.Fatalf("Failed to detect resources: %v", err)
    }
    
    // åˆå§‹åŒ– TracerProvider
    tp, err := initTracerProvider(ctx, res)
    if err != nil {
        log.Fatalf("Failed to initialize tracer provider: %v", err)
    }
    defer tp.Shutdown(ctx)
    
    otel.SetTracerProvider(tp)
    
    log.Println("Application started with full resource detection")
}

func detectAllResources(ctx context.Context) (*resource.Resource, error) {
    // 1. æœåŠ¡ä¿¡æ¯
    serviceRes := resource.NewWithAttributes(
        semconv.SchemaURL,
        semconv.ServiceName("my-app"),
        semconv.ServiceVersion("1.0.0"),
    )
    
    // 2. ä¸»æœºä¿¡æ¯
    hostAttrs := []attribute.KeyValue{}
    
    if attr, err := hostresource.HostNameAttribute(); err == nil {
        hostAttrs = append(hostAttrs, attr)
    }
    
    if attr, err := hostresource.HostIDAttribute(); err == nil {
        hostAttrs = append(hostAttrs, attr)
    }
    
    hostAttrs = append(hostAttrs, hostresource.HostArchAttribute())
    hostAttrs = append(hostAttrs, hostresource.HostTypeAttribute())
    
    hostRes := resource.NewWithAttributes(semconv.SchemaURL, hostAttrs...)
    
    // 3. OS ä¿¡æ¯
    osAttrs, _ := osresource.OSAttributes()
    osRes := resource.NewWithAttributes(semconv.SchemaURL, osAttrs...)
    
    // 4. è¿›ç¨‹ä¿¡æ¯
    processAttrs := []attribute.KeyValue{
        processresource.ProcessPIDAttribute(),
        processresource.ProcessParentPIDAttribute(),
    }
    
    if attr, err := processresource.ProcessExecutablePathAttribute(); err == nil {
        processAttrs = append(processAttrs, attr)
    }
    
    if attr, err := processresource.ProcessExecutableNameAttribute(); err == nil {
        processAttrs = append(processAttrs, attr)
    }
    
    processAttrs = append(processAttrs, processresource.ProcessCommandLineAttribute())
    processAttrs = append(processAttrs, processresource.ProcessRuntimeAttributes()...)
    
    processRes := resource.NewWithAttributes(semconv.SchemaURL, processAttrs...)
    
    // 5. å®¹å™¨ä¿¡æ¯ (å¦‚æœåœ¨å®¹å™¨ä¸­è¿è¡Œ)
    var containerRes *resource.Resource
    if containerresource.IsRunningInContainer() {
        if containerID, err := containerresource.GetContainerID(); err == nil {
            containerRes = resource.NewWithAttributes(
                semconv.SchemaURL,
                semconv.ContainerID(containerID),
            )
        }
    }
    
    // åˆå¹¶æ‰€æœ‰èµ„æº
    resources := []*resource.Resource{serviceRes, hostRes, osRes, processRes}
    if containerRes != nil {
        resources = append(resources, containerRes)
    }
    
    return resource.Merge(resources[0], resources[1:]...)
}

func initTracerProvider(ctx context.Context, res *resource.Resource) (*sdktrace.TracerProvider, error) {
    exporter, err := otlptracegrpc.New(
        ctx,
        otlptracegrpc.WithEndpoint("otel-collector:4317"),
        otlptracegrpc.WithInsecure(),
    )
    if err != nil {
        return nil, err
    }
    
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithResource(res),
        sdktrace.WithBatcher(exporter),
    )
    
    return tp, nil
}
```

### 9.2 ç”Ÿäº§ç¯å¢ƒé…ç½®

**ç¯å¢ƒå˜é‡æ³¨å…¥**:

```bash
# Kubernetes Deployment
env:
# ä¸»æœºä¿¡æ¯
- name: HOST_ID
  value: "550e8400-e29b-41d4-a716-446655440000"
- name: HOST_IMAGE_NAME
  value: "ubuntu-20.04-lts"

# OS ä¿¡æ¯ (å¯é€‰,é€šå¸¸è‡ªåŠ¨æ£€æµ‹)
- name: OS_TYPE
  value: "linux"
- name: OS_VERSION
  value: "20.04"

# è¿›ç¨‹ä¿¡æ¯ (å¯é€‰)
- name: PROCESS_OWNER
  value: "app-user"
```

### 9.3 ç›‘æ§å’Œè¯Šæ–­

**èµ„æºå±æ€§æŸ¥è¯¢ç¤ºä¾‹** (Jaeger/Grafana):

```promql
# Jaeger Trace Query
service.name="my-app" AND host.name="web-server-01"

# Grafana Dashboard
{service_name="my-app", host_type="container", os_type="linux"}
```

---

## 10. æœ€ä½³å®è·µ

### 10.1 æ€§èƒ½ä¼˜åŒ–

**ç¼“å­˜èµ„æºæ£€æµ‹ç»“æœ**:

```go
var (
    cachedResource *resource.Resource
    cacheOnce      sync.Once
)

func GetCachedResource(ctx context.Context) *resource.Resource {
    cacheOnce.Do(func() {
        cachedResource, _ = detectAllResources(ctx)
    })
    return cachedResource
}
```

### 10.2 é”™è¯¯å¤„ç†

**ä¼˜é›…é™çº§**:

```go
func detectWithFallback(ctx context.Context) *resource.Resource {
    res, err := detectAllResources(ctx)
    if err != nil {
        log.Printf("Warning: resource detection failed: %v", err)
        // ä½¿ç”¨æœ€å°èµ„æºé›†
        return resource.NewWithAttributes(
            semconv.SchemaURL,
            semconv.ServiceName("unknown-service"),
        )
    }
    return res
}
```

### 10.3 å®‰å…¨è€ƒè™‘

**é¿å…æ³„éœ²æ•æ„Ÿä¿¡æ¯**:

```go
// è¿‡æ»¤å‘½ä»¤è¡Œå‚æ•°ä¸­çš„æ•æ„Ÿä¿¡æ¯
func SanitizeCommandLine(cmdLine string) string {
    // ç§»é™¤å¯†ç ã€token ç­‰
    patterns := []string{
        `--password=[^\s]+`,
        `--token=[^\s]+`,
        `--secret=[^\s]+`,
    }
    
    sanitized := cmdLine
    for _, pattern := range patterns {
        re := regexp.MustCompile(pattern)
        sanitized = re.ReplaceAllString(sanitized, "$1=***")
    }
    
    return sanitized
}
```

### 10.4 è·¨å¹³å°æ”¯æŒ

**æ„å»ºæ ‡ç­¾**:

```go
//go:build !windows
// +build !windows

package hostresource

// Unix-specific implementation
```

```go
//go:build windows
// +build windows

package hostresource

// Windows-specific implementation
```

---

## 11. å¸¸è§é—®é¢˜ (FAQ)

### Q1: host.name å’Œ host.id å¿…é¡»éƒ½è®¾ç½®å—?

**A**: `host.name` æ˜¯å¿…éœ€çš„,`host.id` æ˜¯æ¨èçš„ã€‚`host.id` ç”¨äºå”¯ä¸€æ ‡è¯†ä¸»æœº,åœ¨ä¸»æœºåå¯èƒ½é‡å¤çš„ç¯å¢ƒä¸­ç‰¹åˆ«é‡è¦ã€‚

### Q2: å¦‚ä½•åœ¨å®¹å™¨ä¸­è·å–å®¿ä¸»æœºä¿¡æ¯?

**A**: å®¹å™¨ä¸­é€šå¸¸åªèƒ½è·å–å®¹å™¨è‡ªèº«çš„ä¿¡æ¯ã€‚å¦‚æœéœ€è¦å®¿ä¸»æœºä¿¡æ¯,å¯ä»¥:

1. é€šè¿‡ Downward API æ³¨å…¥ç¯å¢ƒå˜é‡
2. æŒ‚è½½å®¿ä¸»æœºçš„ `/etc/machine-id` (åªè¯»)
3. ä½¿ç”¨ K8s Node Affinity è·å–èŠ‚ç‚¹ä¿¡æ¯

### Q3: process.command_line ä¼šæ³„éœ²æ•æ„Ÿä¿¡æ¯å—?

**A**: æ˜¯çš„,å‘½ä»¤è¡Œå‚æ•°å¯èƒ½åŒ…å«å¯†ç ã€token ç­‰æ•æ„Ÿä¿¡æ¯ã€‚å»ºè®®:

1. ä½¿ç”¨é…ç½®æ–‡ä»¶æˆ–ç¯å¢ƒå˜é‡ä¼ é€’æ•æ„Ÿä¿¡æ¯
2. å¯¹ `process.command_line` è¿›è¡Œè„±æ•å¤„ç†
3. åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ç¦ç”¨ `process.command_line` å±æ€§

### Q4: å¦‚ä½•å¤„ç†å¤šä¸ªè¿›ç¨‹å®ä¾‹?

**A**: ä½¿ç”¨ `process.pid` å’Œ `service.instance.id` ç»„åˆå”¯ä¸€æ ‡è¯†:

```go
semconv.ServiceInstanceID(fmt.Sprintf("%s-%d", hostname, os.Getpid()))
```

### Q5: ä¸ºä»€ä¹ˆ host.id åœ¨å®¹å™¨ä¸­æ¯æ¬¡éƒ½ä¸åŒ?

**A**: å®¹å™¨çš„ "ä¸»æœº" æ˜¯å®¹å™¨æœ¬èº«,æ¯æ¬¡é‡å¯å®¹å™¨ ID ä¼šå˜åŒ–ã€‚è§£å†³æ–¹æ¡ˆ:

1. ä½¿ç”¨ `container.id` è€Œä¸æ˜¯ `host.id`
2. åœ¨ K8s ä¸­ä½¿ç”¨ `k8s.pod.uid`
3. æ³¨å…¥ç¨³å®šçš„ `HOST_ID` ç¯å¢ƒå˜é‡

### Q6: å¦‚ä½•æ£€æµ‹è™šæ‹ŸåŒ–ç±»å‹ (KVM/VMware/Xen)?

**A**: Linux ç³»ç»Ÿå¯ä»¥ä» `/sys/class/dmi/id/product_name` æˆ–ä½¿ç”¨ `systemd-detect-virt` å‘½ä»¤ã€‚

### Q7: Windows ä¸Šå¦‚ä½•è·å– machine GUID?

**A**: ä»æ³¨å†Œè¡¨ `HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Cryptography\MachineGuid` è¯»å–,éœ€è¦ä½¿ç”¨ `golang.org/x/sys/windows`ã€‚

### Q8: macOS ä¸Šå¦‚ä½•è·å–ç¨³å®šçš„ host.id?

**A**: ä½¿ç”¨ `ioreg -rd1 -c IOPlatformExpertDevice | grep IOPlatformUUID` æˆ–ä» `/Library/Preferences/SystemConfiguration/preferences.plist` è¯»å–ã€‚

### Q9: å¦‚ä½•æœ€å°åŒ–èµ„æºæ£€æµ‹çš„æ€§èƒ½å½±å“?

**A**:

1. ä½¿ç”¨ `sync.Once` ç¼“å­˜æ£€æµ‹ç»“æœ
2. é¿å…æ‰§è¡Œå¤–éƒ¨å‘½ä»¤
3. ä½¿ç”¨ Go æ ‡å‡†åº“è€Œéæ–‡ä»¶ç³»ç»Ÿè¯»å–
4. å¹¶è¡Œæ£€æµ‹ç‹¬ç«‹çš„èµ„æºé¡¹

### Q10: è·¨å¹³å°å…¼å®¹æ€§å¦‚ä½•ä¿è¯?

**A**:

1. ä½¿ç”¨æ„å»ºæ ‡ç­¾ (`//go:build`) åˆ†ç¦»å¹³å°ç‰¹å®šä»£ç 
2. æä¾› fallback å®ç°
3. ä¼˜å…ˆä½¿ç”¨ Go æ ‡å‡†åº“ (`runtime`, `os`)
4. æµ‹è¯•è¦†ç›– Linux/Windows/macOS

---

## ğŸ“š å‚è€ƒèµ„æº

1. **OpenTelemetry Semantic Conventions**:
   - Host: <https://opentelemetry.io/docs/specs/semconv/resource/host/>
   - OS: <https://opentelemetry.io/docs/specs/semconv/resource/os/>
   - Process: <https://opentelemetry.io/docs/specs/semconv/resource/process/>

2. **Go æ ‡å‡†åº“**:
   - `runtime` package: <https://pkg.go.dev/runtime>
   - `os` package: <https://pkg.go.dev/os>
   - `os/user` package: <https://pkg.go.dev/os/user>

3. **å¹³å°ç‰¹å®š**:
   - golang.org/x/sys/windows: <https://pkg.go.dev/golang.org/x/sys/windows>
   - golang.org/x/sys/unix: <https://pkg.go.dev/golang.org/x/sys/unix>

4. **ç›¸å…³æ–‡æ¡£**:
   - [01_æœåŠ¡èµ„æº.md](./01_æœåŠ¡èµ„æº.md) - Service å±æ€§
   - [04_Kubernetesèµ„æº.md](./04_Kubernetesèµ„æº.md) - K8s å®¹å™¨ç¯å¢ƒ

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0  
**æœ€åæ›´æ–°**: 2025-10-09  
**OpenTelemetry ç‰ˆæœ¬**: 1.32.0+  
**Semantic Conventions ç‰ˆæœ¬**: 1.28.0+
