# Baggage ä¼ æ’­æœºåˆ¶

## ğŸ“‹ ç›®å½•

- [Baggage ä¼ æ’­æœºåˆ¶](#baggage-ä¼ æ’­æœºåˆ¶)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
  - [W3C Baggage è§„èŒƒ](#w3c-baggage-è§„èŒƒ)
    - [1. å¤´éƒ¨æ ¼å¼](#1-å¤´éƒ¨æ ¼å¼)
    - [2. ç¼–ç è§„åˆ™](#2-ç¼–ç è§„åˆ™)
  - [ä¼ æ’­å™¨ç±»å‹](#ä¼ æ’­å™¨ç±»å‹)
    - [1. HTTP ä¼ æ’­](#1-http-ä¼ æ’­)
    - [2. gRPC ä¼ æ’­](#2-grpc-ä¼ æ’­)
    - [3. æ¶ˆæ¯é˜Ÿåˆ—ä¼ æ’­](#3-æ¶ˆæ¯é˜Ÿåˆ—ä¼ æ’­)
  - [Go 1.25.1 å®ç°](#go-1251-å®ç°)
    - [1. åŸºæœ¬ä¼ æ’­](#1-åŸºæœ¬ä¼ æ’­)
    - [2. ç»„åˆä¼ æ’­å™¨](#2-ç»„åˆä¼ æ’­å™¨)
    - [3. è‡ªå®šä¹‰ä¼ æ’­å™¨](#3-è‡ªå®šä¹‰ä¼ æ’­å™¨)
  - [Context ä¼ é€’](#context-ä¼ é€’)
    - [1. æœåŠ¡å†…ä¼ é€’](#1-æœåŠ¡å†…ä¼ é€’)
    - [2. è·¨æœåŠ¡ä¼ é€’](#2-è·¨æœåŠ¡ä¼ é€’)
  - [ä¼ æ’­ç­–ç•¥](#ä¼ æ’­ç­–ç•¥)
    - [1. é€‰æ‹©æ€§ä¼ æ’­](#1-é€‰æ‹©æ€§ä¼ æ’­)
    - [2. æ¡ä»¶ä¼ æ’­](#2-æ¡ä»¶ä¼ æ’­)
  - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
  - [å‚è€ƒèµ„æº](#å‚è€ƒèµ„æº)

---

## æ¦‚è¿°

**Baggage ä¼ æ’­æœºåˆ¶** ç¡®ä¿é”®å€¼å¯¹åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿçš„æœåŠ¡è¾¹ç•Œé—´è‡ªåŠ¨ä¼ é€’ã€‚

```text
Service A (è®¾ç½® Baggage)
    â†“ HTTP/gRPC (è‡ªåŠ¨ä¼ æ’­)
Service B (è¯»å– Baggage)
    â†“ HTTP/gRPC (ç»§ç»­ä¼ æ’­)
Service C (è¯»å– Baggage)
```

---

## W3C Baggage è§„èŒƒ

### 1. å¤´éƒ¨æ ¼å¼

W3C Baggage é€šè¿‡ HTTP å¤´ä¼ æ’­ï¼š

```http
baggage: key1=value1,key2=value2;metadata2

ç¤ºä¾‹:
baggage: user.id=12345,tenant.id=acme-corp;propagate=true
```

**æ ¼å¼è§„åˆ™**:
```text
baggage: <member>[,<member>]*

member: <key>=<value>[;<metadata>]

key: token (åªå…è®¸ a-z, 0-9, -, _)
value: URL-encoded string
metadata: property[;property]*
property: token[=token]
```

### 2. ç¼–ç è§„åˆ™

```go
import "net/url"

// ç¼–ç å€¼
func EncodeValue(value string) string {
    return url.QueryEscape(value)
}

// è§£ç å€¼
func DecodeValue(encoded string) (string, error) {
    return url.QueryUnescape(encoded)
}

// ç¤ºä¾‹
original := "user@example.com"
encoded := EncodeValue(original)  // "user%40example.com"
decoded, _ := DecodeValue(encoded) // "user@example.com"
```

---

## ä¼ æ’­å™¨ç±»å‹

### 1. HTTP ä¼ æ’­

```go
package main

import (
    "context"
    "net/http"
    "go.opentelemetry.io/otel/propagation"
)

var propagator = propagation.NewCompositeTextMapPropagator(
    propagation.TraceContext{},
    propagation.Baggage{},
)

// HTTP æœåŠ¡å™¨ï¼šæå– Baggage
func HTTPHandler(w http.ResponseWriter, r *http.Request) {
    // ä» HTTP å¤´æå–
    ctx := propagator.Extract(r.Context(), propagation.HeaderCarrier(r.Header))
    
    // ä½¿ç”¨ Context å¤„ç†è¯·æ±‚
    handleRequest(ctx)
}

// HTTP å®¢æˆ·ç«¯ï¼šæ³¨å…¥ Baggage
func MakeHTTPRequest(ctx context.Context, url string) error {
    req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
    
    // æ³¨å…¥åˆ° HTTP å¤´
    propagator.Inject(ctx, propagation.HeaderCarrier(req.Header))
    
    _, err := http.DefaultClient.Do(req)
    return err
}
```

### 2. gRPC ä¼ æ’­

```go
package main

import (
    "context"
    "google.golang.org/grpc"
    "google.golang.org/grpc/metadata"
    "go.opentelemetry.io/otel/propagation"
)

// gRPC å…ƒæ•°æ®è½½ä½“
type metadataSupplier struct {
    metadata *metadata.MD
}

func (s *metadataSupplier) Get(key string) string {
    values := s.metadata.Get(key)
    if len(values) == 0 {
        return ""
    }
    return values[0]
}

func (s *metadataSupplier) Set(key, value string) {
    s.metadata.Set(key, value)
}

func (s *metadataSupplier) Keys() []string {
    keys := make([]string, 0, len(*s.metadata))
    for k := range *s.metadata {
        keys = append(keys, k)
    }
    return keys
}

// gRPC æœåŠ¡å™¨æ‹¦æˆªå™¨ï¼šæå– Baggage
func UnaryServerInterceptor(
    ctx context.Context,
    req interface{},
    info *grpc.UnaryServerInfo,
    handler grpc.UnaryHandler,
) (interface{}, error) {
    md, ok := metadata.FromIncomingContext(ctx)
    if ok {
        carrier := &metadataSupplier{metadata: &md}
        ctx = propagator.Extract(ctx, carrier)
    }
    
    return handler(ctx, req)
}

// gRPC å®¢æˆ·ç«¯æ‹¦æˆªå™¨ï¼šæ³¨å…¥ Baggage
func UnaryClientInterceptor(
    ctx context.Context,
    method string,
    req, reply interface{},
    cc *grpc.ClientConn,
    invoker grpc.UnaryInvoker,
    opts ...grpc.CallOption,
) error {
    md := metadata.New(nil)
    carrier := &metadataSupplier{metadata: &md}
    propagator.Inject(ctx, carrier)
    
    ctx = metadata.NewOutgoingContext(ctx, md)
    return invoker(ctx, method, req, reply, cc, opts...)
}
```

### 3. æ¶ˆæ¯é˜Ÿåˆ—ä¼ æ’­

```go
package kafka

import (
    "context"
    "github.com/segmentio/kafka-go"
    "go.opentelemetry.io/otel/propagation"
)

// Kafka æ¶ˆæ¯å¤´è½½ä½“
type kafkaHeadersCarrier []kafka.Header

func (c kafkaHeadersCarrier) Get(key string) string {
    for _, h := range c {
        if h.Key == key {
            return string(h.Value)
        }
    }
    return ""
}

func (c *kafkaHeadersCarrier) Set(key, value string) {
    *c = append(*c, kafka.Header{
        Key:   key,
        Value: []byte(value),
    })
}

func (c kafkaHeadersCarrier) Keys() []string {
    keys := make([]string, 0, len(c))
    for _, h := range c {
        keys = append(keys, h.Key)
    }
    return keys
}

// ç”Ÿäº§è€…ï¼šæ³¨å…¥ Baggage
func ProduceMessage(ctx context.Context, topic string, value []byte) error {
    msg := kafka.Message{
        Topic: topic,
        Value: value,
    }
    
    carrier := kafkaHeadersCarrier(msg.Headers)
    propagator.Inject(ctx, &carrier)
    msg.Headers = []kafka.Header(carrier)
    
    return producer.WriteMessages(ctx, msg)
}

// æ¶ˆè´¹è€…ï¼šæå– Baggage
func ConsumeMessage(msg kafka.Message) context.Context {
    carrier := kafkaHeadersCarrier(msg.Headers)
    return propagator.Extract(context.Background(), carrier)
}
```

---

## Go 1.25.1 å®ç°

### 1. åŸºæœ¬ä¼ æ’­

```go
package main

import (
    "context"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/baggage"
)

// è®¾ç½®å…¨å±€ä¼ æ’­å™¨
func InitPropagator() {
    propagator := propagation.NewCompositeTextMapPropagator(
        propagation.TraceContext{},  // W3C Trace Context
        propagation.Baggage{},       // W3C Baggage
    )
    
    otel.SetTextMapPropagator(propagator)
}

// ä½¿ç”¨å…¨å±€ä¼ æ’­å™¨
func PropagateContext(ctx context.Context, carrier propagation.TextMapCarrier) {
    otel.GetTextMapPropagator().Inject(ctx, carrier)
}

func ExtractContext(ctx context.Context, carrier propagation.TextMapCarrier) context.Context {
    return otel.GetTextMapPropagator().Extract(ctx, carrier)
}
```

### 2. ç»„åˆä¼ æ’­å™¨

```go
package main

import (
    "go.opentelemetry.io/otel/propagation"
)

// ç»„åˆå¤šä¸ªä¼ æ’­å™¨
func CreateCompositePropagator() propagation.TextMapPropagator {
    return propagation.NewCompositeTextMapPropagator(
        // OpenTelemetry æ ‡å‡†
        propagation.TraceContext{},
        propagation.Baggage{},
        
        // å¯é€‰ï¼šJaeger å…¼å®¹
        // jaeger.Jaeger{},
        
        // å¯é€‰ï¼šB3 æ ¼å¼ (Zipkin)
        // b3.New(),
    )
}

// åªä¼ æ’­ Baggageï¼ˆä¸ä¼ æ’­è¿½è¸ªä¿¡æ¯ï¼‰
func BaggageOnlyPropagator() propagation.TextMapPropagator {
    return propagation.Baggage{}
}
```

### 3. è‡ªå®šä¹‰ä¼ æ’­å™¨

```go
package custom

import (
    "context"
    "go.opentelemetry.io/otel/baggage"
    "go.opentelemetry.io/otel/propagation"
)

// CustomPropagator è‡ªå®šä¹‰ä¼ æ’­å™¨
type CustomPropagator struct{}

func (cp CustomPropagator) Inject(ctx context.Context, carrier propagation.TextMapCarrier) {
    bag := baggage.FromContext(ctx)
    
    // è‡ªå®šä¹‰å¤´éƒ¨åç§°
    carrier.Set("X-Custom-Baggage", bag.String())
}

func (cp CustomPropagator) Extract(ctx context.Context, carrier propagation.TextMapCarrier) context.Context {
    baggageStr := carrier.Get("X-Custom-Baggage")
    if baggageStr == "" {
        return ctx
    }
    
    bag, err := baggage.Parse(baggageStr)
    if err != nil {
        return ctx
    }
    
    return baggage.ContextWithBaggage(ctx, bag)
}

func (cp CustomPropagator) Fields() []string {
    return []string{"X-Custom-Baggage"}
}
```

---

## Context ä¼ é€’

### 1. æœåŠ¡å†…ä¼ é€’

```go
package main

import (
    "context"
    "go.opentelemetry.io/otel/baggage"
)

// åœ¨åŒä¸€æœåŠ¡å†…ï¼ŒBaggage é€šè¿‡ Context ä¼ é€’
func HandleRequest(ctx context.Context) {
    // åœ¨å…¥å£è®¾ç½® Baggage
    ctx = SetUserContext(ctx, "12345")
    
    // ä¼ é€’ç»™ä¸šåŠ¡é€»è¾‘
    processOrder(ctx)
}

func processOrder(ctx context.Context) {
    // å¯ä»¥è¯»å– Baggage
    userID := GetUserID(ctx)
    
    // ç»§ç»­ä¼ é€’
    validateOrder(ctx)
    saveOrder(ctx)
}

func validateOrder(ctx context.Context) {
    // ä»ç„¶å¯ä»¥è¯»å–
    userID := GetUserID(ctx)
    log.Printf("Validating order for user: %s", userID)
}

// è¾…åŠ©å‡½æ•°
func SetUserContext(ctx context.Context, userID string) context.Context {
    member, _ := baggage.NewMember("user.id", userID)
    bag, _ := baggage.FromContext(ctx).SetMember(member)
    return baggage.ContextWithBaggage(ctx, bag)
}

func GetUserID(ctx context.Context) string {
    return baggage.FromContext(ctx).Member("user.id").Value()
}
```

### 2. è·¨æœåŠ¡ä¼ é€’

```go
package main

// Service A â†’ Service B â†’ Service C
// å®Œæ•´çš„ä¼ æ’­é“¾

// Service A: è®¾ç½® Baggage å¹¶è°ƒç”¨ Service B
func ServiceA(ctx context.Context) {
    // è®¾ç½® Baggage
    member, _ := baggage.NewMember("request.id", "req-123")
    bag, _ := baggage.FromContext(ctx).SetMember(member)
    ctx = baggage.ContextWithBaggage(ctx, bag)
    
    // è°ƒç”¨ Service B (è‡ªåŠ¨ä¼ æ’­)
    CallServiceB(ctx)
}

func CallServiceB(ctx context.Context) error {
    req, _ := http.NewRequestWithContext(ctx, "GET", "http://service-b/api", nil)
    
    // æ³¨å…¥ Baggage
    propagator.Inject(ctx, propagation.HeaderCarrier(req.Header))
    
    _, err := http.DefaultClient.Do(req)
    return err
}

// Service B: æ¥æ”¶ Baggage å¹¶è°ƒç”¨ Service C
func ServiceBHandler(w http.ResponseWriter, r *http.Request) {
    // æå– Baggage
    ctx := propagator.Extract(r.Context(), propagation.HeaderCarrier(r.Header))
    
    // å¯ä»¥è¯»å–
    requestID := baggage.FromContext(ctx).Member("request.id").Value()
    log.Printf("Service B processing request: %s", requestID)
    
    // è°ƒç”¨ Service C (ç»§ç»­ä¼ æ’­)
    CallServiceC(ctx)
}

// Service C: æ¥æ”¶ Baggage
func ServiceCHandler(w http.ResponseWriter, r *http.Request) {
    ctx := propagator.Extract(r.Context(), propagation.HeaderCarrier(r.Header))
    
    // ä»ç„¶å¯ä»¥è¯»å–
    requestID := baggage.FromContext(ctx).Member("request.id").Value()
    log.Printf("Service C processing request: %s", requestID)
}
```

---

## ä¼ æ’­ç­–ç•¥

### 1. é€‰æ‹©æ€§ä¼ æ’­

```go
package propagation

import (
    "context"
    "go.opentelemetry.io/otel/baggage"
)

// åªä¼ æ’­ç‰¹å®šé”®
func PropagateSelectedKeys(ctx context.Context, allowedKeys []string) context.Context {
    bag := baggage.FromContext(ctx)
    
    members := make([]baggage.Member, 0)
    for _, member := range bag.Members() {
        if contains(allowedKeys, member.Key()) {
            members = append(members, member)
        }
    }
    
    newBag, _ := baggage.New(members...)
    return baggage.ContextWithBaggage(ctx, newBag)
}

// æ’é™¤ç‰¹å®šé”®
func ExcludeKeys(ctx context.Context, excludedKeys []string) context.Context {
    bag := baggage.FromContext(ctx)
    
    members := make([]baggage.Member, 0)
    for _, member := range bag.Members() {
        if !contains(excludedKeys, member.Key()) {
            members = append(members, member)
        }
    }
    
    newBag, _ := baggage.New(members...)
    return baggage.ContextWithBaggage(ctx, newBag)
}

func contains(slice []string, item string) bool {
    for _, s := range slice {
        if s == item {
            return true
        }
    }
    return false
}
```

### 2. æ¡ä»¶ä¼ æ’­

```go
// æ ¹æ® Metadata å†³å®šæ˜¯å¦ä¼ æ’­
func ConditionalPropagate(ctx context.Context) context.Context {
    bag := baggage.FromContext(ctx)
    
    members := make([]baggage.Member, 0)
    for _, member := range bag.Members() {
        // æ£€æŸ¥ metadata ä¸­çš„ propagate æ ‡å¿—
        if shouldPropagate(member) {
            members = append(members, member)
        }
    }
    
    newBag, _ := baggage.New(members...)
    return baggage.ContextWithBaggage(ctx, newBag)
}

func shouldPropagate(member baggage.Member) bool {
    // è§£æ metadata
    metadata := member.Properties()
    for _, prop := range metadata {
        if prop.Key() == "propagate" && prop.Value() == "false" {
            return false
        }
    }
    return true
}
```

---

## æ€§èƒ½ä¼˜åŒ–

```go
// 1. ç¼“å­˜ä¼ æ’­å™¨
var globalPropagator = propagation.NewCompositeTextMapPropagator(
    propagation.TraceContext{},
    propagation.Baggage{},
)

// 2. æ± åŒ–è½½ä½“
var headerCarrierPool = sync.Pool{
    New: func() interface{} {
        return make(propagation.MapCarrier)
    },
}

func GetCarrier() propagation.MapCarrier {
    return headerCarrierPool.Get().(propagation.MapCarrier)
}

func PutCarrier(carrier propagation.MapCarrier) {
    for k := range carrier {
        delete(carrier, k)
    }
    headerCarrierPool.Put(carrier)
}

// 3. é™åˆ¶ Baggage å¤§å°
func LimitBaggageSize(ctx context.Context, maxSize int) context.Context {
    bag := baggage.FromContext(ctx)
    
    totalSize := 0
    members := make([]baggage.Member, 0)
    
    for _, member := range bag.Members() {
        memberSize := len(member.Key()) + len(member.Value())
        if totalSize+memberSize <= maxSize {
            members = append(members, member)
            totalSize += memberSize
        }
    }
    
    newBag, _ := baggage.New(members...)
    return baggage.ContextWithBaggage(ctx, newBag)
}
```

---

## æœ€ä½³å®è·µ

```go
// âœ… æ­£ç¡®ï¼šåœ¨åº”ç”¨å¯åŠ¨æ—¶è®¾ç½®å…¨å±€ä¼ æ’­å™¨
func main() {
    otel.SetTextMapPropagator(
        propagation.NewCompositeTextMapPropagator(
            propagation.TraceContext{},
            propagation.Baggage{},
        ),
    )
}

// âœ… æ­£ç¡®ï¼šä½¿ç”¨ä¸­é—´ä»¶è‡ªåŠ¨ä¼ æ’­
app.Use(BaggageMiddleware)

// âŒ é”™è¯¯ï¼šæ‰‹åŠ¨åœ¨æ¯ä¸ªè¯·æ±‚ä¸­ä¼ æ’­
func handler(w http.ResponseWriter, r *http.Request) {
    // ä¸è¦è¿™æ ·åšï¼Œä½¿ç”¨ä¸­é—´ä»¶
    propagator.Extract(...)
    propagator.Inject(...)
}

// âœ… æ­£ç¡®ï¼šé™åˆ¶ Baggage å¤§å°
ctx = LimitBaggageSize(ctx, 4096)

// âŒ é”™è¯¯ï¼šæ— é™åˆ¶æ·»åŠ æ•°æ®
for i := 0; i < 1000; i++ {
    member, _ := baggage.NewMember(fmt.Sprintf("key%d", i), "value")
    bag, _ = bag.SetMember(member)
}

// âœ… æ­£ç¡®ï¼šåªä¼ æ’­å¿…è¦ä¿¡æ¯
allowedKeys := []string{"user.id", "tenant.id"}
ctx = PropagateSelectedKeys(ctx, allowedKeys)

// âŒ é”™è¯¯ï¼šä¼ æ’­æ‰€æœ‰ä¿¡æ¯ï¼ˆå¯èƒ½åŒ…å«æ•æ„Ÿæ•°æ®ï¼‰
// ç›´æ¥ä¼ æ’­æ•´ä¸ª Baggage
```

---

## å‚è€ƒèµ„æº

- [W3C Baggage Specification](https://www.w3.org/TR/baggage/)
- [OpenTelemetry Propagators](https://opentelemetry.io/docs/specs/otel/context/api-propagators/)
- [Go SDK Propagation Package](https://pkg.go.dev/go.opentelemetry.io/otel/propagation)
- [01_Baggageå®šä¹‰.md](./01_Baggageå®šä¹‰.md)
- [03_å½¢å¼åŒ–å®šä¹‰.md](./03_å½¢å¼åŒ–å®šä¹‰.md)

---

**ğŸ‰ æ­å–œï¼ä½ å·²ç»æŒæ¡äº† Baggage çš„ä¼ æ’­æœºåˆ¶ï¼**

ç°åœ¨ä½ å¯ä»¥ï¼š
- âœ… ç†è§£ W3C Baggage è§„èŒƒ
- âœ… å®ç° HTTP/gRPC/æ¶ˆæ¯é˜Ÿåˆ—ä¼ æ’­
- âœ… ä½¿ç”¨ç»„åˆä¼ æ’­å™¨
- âœ… å®ç°é€‰æ‹©æ€§å’Œæ¡ä»¶ä¼ æ’­

