# Baggage 传播机制

## 📋 目录

- [Baggage 传播机制](#baggage-传播机制)
  - [📋 目录](#-目录)
  - [概述](#概述)
  - [W3C Baggage 规范](#w3c-baggage-规范)
    - [1. 头部格式](#1-头部格式)
    - [2. 编码规则](#2-编码规则)
  - [传播器类型](#传播器类型)
    - [1. HTTP 传播](#1-http-传播)
    - [2. gRPC 传播](#2-grpc-传播)
    - [3. 消息队列传播](#3-消息队列传播)
  - [Go 1.25.1 实现](#go-1251-实现)
    - [1. 基本传播](#1-基本传播)
    - [2. 组合传播器](#2-组合传播器)
    - [3. 自定义传播器](#3-自定义传播器)
  - [Context 传递](#context-传递)
    - [1. 服务内传递](#1-服务内传递)
    - [2. 跨服务传递](#2-跨服务传递)
  - [传播策略](#传播策略)
    - [1. 选择性传播](#1-选择性传播)
    - [2. 条件传播](#2-条件传播)
  - [性能优化](#性能优化)
  - [最佳实践](#最佳实践)
  - [参考资源](#参考资源)

---

## 概述

**Baggage 传播机制** 确保键值对在分布式系统的服务边界间自动传递。

```text
Service A (设置 Baggage)
    ↓ HTTP/gRPC (自动传播)
Service B (读取 Baggage)
    ↓ HTTP/gRPC (继续传播)
Service C (读取 Baggage)
```

---

## W3C Baggage 规范

### 1. 头部格式

W3C Baggage 通过 HTTP 头传播：

```http
baggage: key1=value1,key2=value2;metadata2

示例:
baggage: user.id=12345,tenant.id=acme-corp;propagate=true
```

**格式规则**:
```text
baggage: <member>[,<member>]*

member: <key>=<value>[;<metadata>]

key: token (只允许 a-z, 0-9, -, _)
value: URL-encoded string
metadata: property[;property]*
property: token[=token]
```

### 2. 编码规则

```go
import "net/url"

// 编码值
func EncodeValue(value string) string {
    return url.QueryEscape(value)
}

// 解码值
func DecodeValue(encoded string) (string, error) {
    return url.QueryUnescape(encoded)
}

// 示例
original := "user@example.com"
encoded := EncodeValue(original)  // "user%40example.com"
decoded, _ := DecodeValue(encoded) // "user@example.com"
```

---

## 传播器类型

### 1. HTTP 传播

```go
package main

import (
    "context"
    "net/http"
    "go.opentelemetry.io/otel/propagation"
)

var propagator = propagation.NewCompositeTextMapPropagator(
    propagation.TraceContext{},
    propagation.Baggage{},
)

// HTTP 服务器：提取 Baggage
func HTTPHandler(w http.ResponseWriter, r *http.Request) {
    // 从 HTTP 头提取
    ctx := propagator.Extract(r.Context(), propagation.HeaderCarrier(r.Header))
    
    // 使用 Context 处理请求
    handleRequest(ctx)
}

// HTTP 客户端：注入 Baggage
func MakeHTTPRequest(ctx context.Context, url string) error {
    req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
    
    // 注入到 HTTP 头
    propagator.Inject(ctx, propagation.HeaderCarrier(req.Header))
    
    _, err := http.DefaultClient.Do(req)
    return err
}
```

### 2. gRPC 传播

```go
package main

import (
    "context"
    "google.golang.org/grpc"
    "google.golang.org/grpc/metadata"
    "go.opentelemetry.io/otel/propagation"
)

// gRPC 元数据载体
type metadataSupplier struct {
    metadata *metadata.MD
}

func (s *metadataSupplier) Get(key string) string {
    values := s.metadata.Get(key)
    if len(values) == 0 {
        return ""
    }
    return values[0]
}

func (s *metadataSupplier) Set(key, value string) {
    s.metadata.Set(key, value)
}

func (s *metadataSupplier) Keys() []string {
    keys := make([]string, 0, len(*s.metadata))
    for k := range *s.metadata {
        keys = append(keys, k)
    }
    return keys
}

// gRPC 服务器拦截器：提取 Baggage
func UnaryServerInterceptor(
    ctx context.Context,
    req interface{},
    info *grpc.UnaryServerInfo,
    handler grpc.UnaryHandler,
) (interface{}, error) {
    md, ok := metadata.FromIncomingContext(ctx)
    if ok {
        carrier := &metadataSupplier{metadata: &md}
        ctx = propagator.Extract(ctx, carrier)
    }
    
    return handler(ctx, req)
}

// gRPC 客户端拦截器：注入 Baggage
func UnaryClientInterceptor(
    ctx context.Context,
    method string,
    req, reply interface{},
    cc *grpc.ClientConn,
    invoker grpc.UnaryInvoker,
    opts ...grpc.CallOption,
) error {
    md := metadata.New(nil)
    carrier := &metadataSupplier{metadata: &md}
    propagator.Inject(ctx, carrier)
    
    ctx = metadata.NewOutgoingContext(ctx, md)
    return invoker(ctx, method, req, reply, cc, opts...)
}
```

### 3. 消息队列传播

```go
package kafka

import (
    "context"
    "github.com/segmentio/kafka-go"
    "go.opentelemetry.io/otel/propagation"
)

// Kafka 消息头载体
type kafkaHeadersCarrier []kafka.Header

func (c kafkaHeadersCarrier) Get(key string) string {
    for _, h := range c {
        if h.Key == key {
            return string(h.Value)
        }
    }
    return ""
}

func (c *kafkaHeadersCarrier) Set(key, value string) {
    *c = append(*c, kafka.Header{
        Key:   key,
        Value: []byte(value),
    })
}

func (c kafkaHeadersCarrier) Keys() []string {
    keys := make([]string, 0, len(c))
    for _, h := range c {
        keys = append(keys, h.Key)
    }
    return keys
}

// 生产者：注入 Baggage
func ProduceMessage(ctx context.Context, topic string, value []byte) error {
    msg := kafka.Message{
        Topic: topic,
        Value: value,
    }
    
    carrier := kafkaHeadersCarrier(msg.Headers)
    propagator.Inject(ctx, &carrier)
    msg.Headers = []kafka.Header(carrier)
    
    return producer.WriteMessages(ctx, msg)
}

// 消费者：提取 Baggage
func ConsumeMessage(msg kafka.Message) context.Context {
    carrier := kafkaHeadersCarrier(msg.Headers)
    return propagator.Extract(context.Background(), carrier)
}
```

---

## Go 1.25.1 实现

### 1. 基本传播

```go
package main

import (
    "context"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/baggage"
)

// 设置全局传播器
func InitPropagator() {
    propagator := propagation.NewCompositeTextMapPropagator(
        propagation.TraceContext{},  // W3C Trace Context
        propagation.Baggage{},       // W3C Baggage
    )
    
    otel.SetTextMapPropagator(propagator)
}

// 使用全局传播器
func PropagateContext(ctx context.Context, carrier propagation.TextMapCarrier) {
    otel.GetTextMapPropagator().Inject(ctx, carrier)
}

func ExtractContext(ctx context.Context, carrier propagation.TextMapCarrier) context.Context {
    return otel.GetTextMapPropagator().Extract(ctx, carrier)
}
```

### 2. 组合传播器

```go
package main

import (
    "go.opentelemetry.io/otel/propagation"
)

// 组合多个传播器
func CreateCompositePropagator() propagation.TextMapPropagator {
    return propagation.NewCompositeTextMapPropagator(
        // OpenTelemetry 标准
        propagation.TraceContext{},
        propagation.Baggage{},
        
        // 可选：Jaeger 兼容
        // jaeger.Jaeger{},
        
        // 可选：B3 格式 (Zipkin)
        // b3.New(),
    )
}

// 只传播 Baggage（不传播追踪信息）
func BaggageOnlyPropagator() propagation.TextMapPropagator {
    return propagation.Baggage{}
}
```

### 3. 自定义传播器

```go
package custom

import (
    "context"
    "go.opentelemetry.io/otel/baggage"
    "go.opentelemetry.io/otel/propagation"
)

// CustomPropagator 自定义传播器
type CustomPropagator struct{}

func (cp CustomPropagator) Inject(ctx context.Context, carrier propagation.TextMapCarrier) {
    bag := baggage.FromContext(ctx)
    
    // 自定义头部名称
    carrier.Set("X-Custom-Baggage", bag.String())
}

func (cp CustomPropagator) Extract(ctx context.Context, carrier propagation.TextMapCarrier) context.Context {
    baggageStr := carrier.Get("X-Custom-Baggage")
    if baggageStr == "" {
        return ctx
    }
    
    bag, err := baggage.Parse(baggageStr)
    if err != nil {
        return ctx
    }
    
    return baggage.ContextWithBaggage(ctx, bag)
}

func (cp CustomPropagator) Fields() []string {
    return []string{"X-Custom-Baggage"}
}
```

---

## Context 传递

### 1. 服务内传递

```go
package main

import (
    "context"
    "go.opentelemetry.io/otel/baggage"
)

// 在同一服务内，Baggage 通过 Context 传递
func HandleRequest(ctx context.Context) {
    // 在入口设置 Baggage
    ctx = SetUserContext(ctx, "12345")
    
    // 传递给业务逻辑
    processOrder(ctx)
}

func processOrder(ctx context.Context) {
    // 可以读取 Baggage
    userID := GetUserID(ctx)
    
    // 继续传递
    validateOrder(ctx)
    saveOrder(ctx)
}

func validateOrder(ctx context.Context) {
    // 仍然可以读取
    userID := GetUserID(ctx)
    log.Printf("Validating order for user: %s", userID)
}

// 辅助函数
func SetUserContext(ctx context.Context, userID string) context.Context {
    member, _ := baggage.NewMember("user.id", userID)
    bag, _ := baggage.FromContext(ctx).SetMember(member)
    return baggage.ContextWithBaggage(ctx, bag)
}

func GetUserID(ctx context.Context) string {
    return baggage.FromContext(ctx).Member("user.id").Value()
}
```

### 2. 跨服务传递

```go
package main

// Service A → Service B → Service C
// 完整的传播链

// Service A: 设置 Baggage 并调用 Service B
func ServiceA(ctx context.Context) {
    // 设置 Baggage
    member, _ := baggage.NewMember("request.id", "req-123")
    bag, _ := baggage.FromContext(ctx).SetMember(member)
    ctx = baggage.ContextWithBaggage(ctx, bag)
    
    // 调用 Service B (自动传播)
    CallServiceB(ctx)
}

func CallServiceB(ctx context.Context) error {
    req, _ := http.NewRequestWithContext(ctx, "GET", "http://service-b/api", nil)
    
    // 注入 Baggage
    propagator.Inject(ctx, propagation.HeaderCarrier(req.Header))
    
    _, err := http.DefaultClient.Do(req)
    return err
}

// Service B: 接收 Baggage 并调用 Service C
func ServiceBHandler(w http.ResponseWriter, r *http.Request) {
    // 提取 Baggage
    ctx := propagator.Extract(r.Context(), propagation.HeaderCarrier(r.Header))
    
    // 可以读取
    requestID := baggage.FromContext(ctx).Member("request.id").Value()
    log.Printf("Service B processing request: %s", requestID)
    
    // 调用 Service C (继续传播)
    CallServiceC(ctx)
}

// Service C: 接收 Baggage
func ServiceCHandler(w http.ResponseWriter, r *http.Request) {
    ctx := propagator.Extract(r.Context(), propagation.HeaderCarrier(r.Header))
    
    // 仍然可以读取
    requestID := baggage.FromContext(ctx).Member("request.id").Value()
    log.Printf("Service C processing request: %s", requestID)
}
```

---

## 传播策略

### 1. 选择性传播

```go
package propagation

import (
    "context"
    "go.opentelemetry.io/otel/baggage"
)

// 只传播特定键
func PropagateSelectedKeys(ctx context.Context, allowedKeys []string) context.Context {
    bag := baggage.FromContext(ctx)
    
    members := make([]baggage.Member, 0)
    for _, member := range bag.Members() {
        if contains(allowedKeys, member.Key()) {
            members = append(members, member)
        }
    }
    
    newBag, _ := baggage.New(members...)
    return baggage.ContextWithBaggage(ctx, newBag)
}

// 排除特定键
func ExcludeKeys(ctx context.Context, excludedKeys []string) context.Context {
    bag := baggage.FromContext(ctx)
    
    members := make([]baggage.Member, 0)
    for _, member := range bag.Members() {
        if !contains(excludedKeys, member.Key()) {
            members = append(members, member)
        }
    }
    
    newBag, _ := baggage.New(members...)
    return baggage.ContextWithBaggage(ctx, newBag)
}

func contains(slice []string, item string) bool {
    for _, s := range slice {
        if s == item {
            return true
        }
    }
    return false
}
```

### 2. 条件传播

```go
// 根据 Metadata 决定是否传播
func ConditionalPropagate(ctx context.Context) context.Context {
    bag := baggage.FromContext(ctx)
    
    members := make([]baggage.Member, 0)
    for _, member := range bag.Members() {
        // 检查 metadata 中的 propagate 标志
        if shouldPropagate(member) {
            members = append(members, member)
        }
    }
    
    newBag, _ := baggage.New(members...)
    return baggage.ContextWithBaggage(ctx, newBag)
}

func shouldPropagate(member baggage.Member) bool {
    // 解析 metadata
    metadata := member.Properties()
    for _, prop := range metadata {
        if prop.Key() == "propagate" && prop.Value() == "false" {
            return false
        }
    }
    return true
}
```

---

## 性能优化

```go
// 1. 缓存传播器
var globalPropagator = propagation.NewCompositeTextMapPropagator(
    propagation.TraceContext{},
    propagation.Baggage{},
)

// 2. 池化载体
var headerCarrierPool = sync.Pool{
    New: func() interface{} {
        return make(propagation.MapCarrier)
    },
}

func GetCarrier() propagation.MapCarrier {
    return headerCarrierPool.Get().(propagation.MapCarrier)
}

func PutCarrier(carrier propagation.MapCarrier) {
    for k := range carrier {
        delete(carrier, k)
    }
    headerCarrierPool.Put(carrier)
}

// 3. 限制 Baggage 大小
func LimitBaggageSize(ctx context.Context, maxSize int) context.Context {
    bag := baggage.FromContext(ctx)
    
    totalSize := 0
    members := make([]baggage.Member, 0)
    
    for _, member := range bag.Members() {
        memberSize := len(member.Key()) + len(member.Value())
        if totalSize+memberSize <= maxSize {
            members = append(members, member)
            totalSize += memberSize
        }
    }
    
    newBag, _ := baggage.New(members...)
    return baggage.ContextWithBaggage(ctx, newBag)
}
```

---

## 最佳实践

```go
// ✅ 正确：在应用启动时设置全局传播器
func main() {
    otel.SetTextMapPropagator(
        propagation.NewCompositeTextMapPropagator(
            propagation.TraceContext{},
            propagation.Baggage{},
        ),
    )
}

// ✅ 正确：使用中间件自动传播
app.Use(BaggageMiddleware)

// ❌ 错误：手动在每个请求中传播
func handler(w http.ResponseWriter, r *http.Request) {
    // 不要这样做，使用中间件
    propagator.Extract(...)
    propagator.Inject(...)
}

// ✅ 正确：限制 Baggage 大小
ctx = LimitBaggageSize(ctx, 4096)

// ❌ 错误：无限制添加数据
for i := 0; i < 1000; i++ {
    member, _ := baggage.NewMember(fmt.Sprintf("key%d", i), "value")
    bag, _ = bag.SetMember(member)
}

// ✅ 正确：只传播必要信息
allowedKeys := []string{"user.id", "tenant.id"}
ctx = PropagateSelectedKeys(ctx, allowedKeys)

// ❌ 错误：传播所有信息（可能包含敏感数据）
// 直接传播整个 Baggage
```

---

## 参考资源

- [W3C Baggage Specification](https://www.w3.org/TR/baggage/)
- [OpenTelemetry Propagators](https://opentelemetry.io/docs/specs/otel/context/api-propagators/)
- [Go SDK Propagation Package](https://pkg.go.dev/go.opentelemetry.io/otel/propagation)
- [01_Baggage定义.md](./01_Baggage定义.md)
- [03_形式化定义.md](./03_形式化定义.md)

---

**🎉 恭喜！你已经掌握了 Baggage 的传播机制！**

现在你可以：
- ✅ 理解 W3C Baggage 规范
- ✅ 实现 HTTP/gRPC/消息队列传播
- ✅ 使用组合传播器
- ✅ 实现选择性和条件传播

