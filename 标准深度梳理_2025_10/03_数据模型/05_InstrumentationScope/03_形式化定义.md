# InstrumentationScope 形式化定义

## 📋 目录

- [InstrumentationScope 形式化定义](#instrumentationscope-形式化定义)
  - [📋 目录](#-目录)
  - [概述](#概述)
  - [基本定义](#基本定义)
    - [1. InstrumentationScope 定义](#1-instrumentationscope-定义)
    - [2. Scope 标识定义](#2-scope-标识定义)
    - [3. Attributes 定义](#3-attributes-定义)
  - [InstrumentationScope 的形式化](#instrumentationscope-的形式化)
    - [1. 完整定义](#1-完整定义)
    - [2. 有效性条件](#2-有效性条件)
  - [Scope 操作的形式化](#scope-操作的形式化)
    - [1. 相等操作](#1-相等操作)
    - [2. 匹配操作](#2-匹配操作)
  - [不变量](#不变量)
    - [1. Scope 不变量](#1-scope-不变量)
    - [2. 唯一性不变量](#2-唯一性不变量)
  - [正确性证明](#正确性证明)
    - [1. 相等关系](#1-相等关系)
    - [2. 唯一性](#2-唯一性)
  - [性能分析](#性能分析)
    - [1. 时间复杂度](#1-时间复杂度)
    - [2. 空间复杂度](#2-空间复杂度)
  - [TLA+ 规范](#tla-规范)
  - [Go 实现验证](#go-实现验证)
  - [参考资源](#参考资源)

---

## 概述

本文档提供 OpenTelemetry InstrumentationScope 数据模型的形式化定义，包括数学模型、正确性证明和性能分析。

---

## 基本定义

### 1. InstrumentationScope 定义

**定义 1.1 (InstrumentationScope)**:

InstrumentationScope 是一个四元组：

\[
S = (N, V, A, D)
\]

其中：

- \( N \in \text{String} \): Name (必需)
- \( V \in \text{String} \cup \{\emptyset\} \): Version (可选)
- \( A \subseteq \mathbb{K} \times \mathbb{V} \): Attributes (可选)
- \( D \in \mathbb{N} \): DroppedAttributesCount

### 2. Scope 标识定义

**定义 1.2 (Scope Identity)**:

Scope 的标识定义为：

\[
\text{ID}(S) = \begin{cases}
N & \text{if } V = \emptyset \\
N \oplus V & \text{if } V \neq \emptyset
\end{cases}
\]

其中 \( \oplus \) 表示字符串连接操作（通常用 "@" 分隔）。

**示例**:
\[
\begin{aligned}
\text{ID}(("myapp", \emptyset, \emptyset, 0)) &= "myapp" \\
\text{ID}(("myapp", "1.0.0", \emptyset, 0)) &= "myapp@1.0.0"
\end{aligned}
\]

### 3. Attributes 定义

**定义 1.3 (Attributes)**:

Attributes 是一个有限映射：

\[
A: \mathbb{K} \rightharpoonup \mathbb{V}
\]

其中：

- \( \mathbb{K} = \text{String} \) (键空间)
- \( \mathbb{V} = \text{String} \mid \text{Int} \mid \text{Float} \mid \text{Bool} \) (值空间)
- \( \rightharpoonup \) 表示部分函数

---

## InstrumentationScope 的形式化

### 1. 完整定义

**定义 2.1 (InstrumentationScope 集合)**:

InstrumentationScope 的集合定义为：

\[
\mathcal{S} = \{(N, V, A, D) \mid \text{Valid}(N, V, A, D)\}
\]

### 2. 有效性条件

**定义 2.2 (Valid)**:

InstrumentationScope 有效当且仅当：

\[
\begin{aligned}
\text{Valid}(S) \iff & \ N \neq \emptyset \\
& \land \text{ValidName}(N) \\
& \land (V = \emptyset \lor \text{ValidVersion}(V)) \\
& \land |A| \leq \text{MaxAttributes} \\
& \land \forall (k, v) \in A: k \neq \emptyset \\
& \land D = \max(0, \text{OriginalCount}(A) - |A|)
\end{aligned}
\]

**条件说明**:

1. Name 非空
2. Name 符合命名规范
3. Version 为空或符合版本规范
4. Attributes 数量不超过限制
5. 所有属性键非空
6. DroppedAttributesCount 正确

**定义 2.3 (ValidName)**:

有效的 Name 满足：

\[
\text{ValidName}(N) \iff N \in [\text{a-z}][\text{a-z0-9}\_./]^*
\]

即：小写字母开头，后跟小写字母、数字、下划线、点号或斜杠。

**定义 2.4 (ValidVersion)**:

有效的 Version 满足语义化版本规范：

\[
\text{ValidVersion}(V) \iff V \in \text{SemVer}
\]

其中 \( \text{SemVer} = \text{MAJOR}.\text{MINOR}.\text{PATCH}[-\text{PRERELEASE}] \)

---

## Scope 操作的形式化

### 1. 相等操作

**定义 3.1 (Scope Equality)**:

两个 Scope 相等当且仅当名称和版本相同：

\[
S_1 = S_2 \iff N_1 = N_2 \land V_1 = V_2
\]

**注意**: Attributes 不影响 Scope 的相等性。

### 2. 匹配操作

**定义 3.2 (Scope Matching)**:

Scope 匹配给定名称：

\[
\text{Matches}(S, n) \iff N = n
\]

**定义 3.3 (Prefix Matching)**:

Scope 名称以给定前缀开头：

\[
\text{MatchesPrefix}(S, p) \iff \exists s \in \Sigma^*: N = p \oplus s
\]

---

## 不变量

### 1. Scope 不变量

**不变量 4.1 (Name 非空)**:

\[
\forall S \in \mathcal{S}: N \neq \emptyset
\]

**不变量 4.2 (Name 有效性)**:

\[
\forall S \in \mathcal{S}: \text{ValidName}(N)
\]

**不变量 4.3 (Version 有效性)**:

\[
\forall S \in \mathcal{S}: V = \emptyset \lor \text{ValidVersion}(V)
\]

**不变量 4.4 (Attributes 数量)**:

\[
\forall S \in \mathcal{S}: |A| \leq \text{MaxAttributes}
\]

**不变量 4.5 (DroppedAttributesCount 一致性)**:

\[
\forall S \in \mathcal{S}: D = \text{OriginalCount}(A) - |A|
\]

### 2. 唯一性不变量

**不变量 4.6 (ID 唯一性)**:

在同一 Provider 中，每个 \( \text{ID}(S) \) 唯一对应一个 Scope：

\[
\forall S_1, S_2 \in \mathcal{S}: \text{ID}(S_1) = \text{ID}(S_2) \Rightarrow S_1 = S_2
\]

---

## 正确性证明

### 1. 相等关系

**定理 5.1 (相等关系的性质)**:

Scope 的相等关系是等价关系：

**自反性**:
\[
\forall S: S = S
\]

**证明**: 显然 \( N = N \land V = V \)。∎

**对称性**:
\[
S_1 = S_2 \Rightarrow S_2 = S_1
\]

**证明**: 如果 \( N_1 = N_2 \land V_1 = V_2 \)，则 \( N_2 = N_1 \land V_2 = V_1 \)。∎

**传递性**:
\[
S_1 = S_2 \land S_2 = S_3 \Rightarrow S_1 = S_3
\]

**证明**:
\[
\begin{aligned}
& N_1 = N_2 \land V_1 = V_2 \\
& N_2 = N_3 \land V_2 = V_3 \\
\Rightarrow & N_1 = N_3 \land V_1 = V_3
\end{aligned}
\]
∎

### 2. 唯一性

**定理 5.2 (ID 唯一性)**:

如果两个 Scope 的 ID 相同，则它们相等：

\[
\text{ID}(S_1) = \text{ID}(S_2) \Rightarrow S_1 = S_2
\]

**证明**:

**情况 1**: \( V_1 = V_2 = \emptyset \)

\[
\text{ID}(S_1) = N_1, \text{ID}(S_2) = N_2
\]

如果 \( N_1 = N_2 \)，则 \( S_1 = S_2 \)。

**情况 2**: \( V_1 \neq \emptyset \land V_2 \neq \emptyset \)

\[
\text{ID}(S_1) = N_1 \oplus V_1, \text{ID}(S_2) = N_2 \oplus V_2
\]

如果 \( N_1 \oplus V_1 = N_2 \oplus V_2 \)，由于 \( \oplus \) 是单射，则 \( N_1 = N_2 \land V_1 = V_2 \)，因此 \( S_1 = S_2 \)。

**情况 3**: \( V_1 = \emptyset \land V_2 \neq \emptyset \) (或反之)

\[
\text{ID}(S_1) = N_1, \text{ID}(S_2) = N_2 \oplus V_2
\]

由于格式不同，\( N_1 \neq N_2 \oplus V_2 \)（假设没有 "@" 符号冲突）。

因此，ID 唯一性成立。∎

---

## 性能分析

### 1. 时间复杂度

**定理 6.1 (Scope 创建复杂度)**:

创建 InstrumentationScope 的时间复杂度为：

\[
T_{\text{create}}(n) = O(n)
\]

其中 \( n = |A| \) 是属性数量。

**证明**:

```text
创建 Scope:
  设置 Name, Version:  O(1)
  复制 Attributes:     O(n)
  
总复杂度: O(n)  ✓
```

**定理 6.2 (Scope 相等比较复杂度)**:

比较两个 Scope 是否相等的时间复杂度为：

\[
T_{\text{equal}}(m_1, m_2) = O(m_1 + m_2)
\]

其中 \( m_1 = |N_1| + |V_1| \), \( m_2 = |N_2| + |V_2| \)。

**证明**:

```text
相等比较:
  比较 Name:    O(m₁)
  比较 Version: O(m₂)
  
总复杂度: O(m₁ + m₂)  ✓
```

**定理 6.3 (ID 生成复杂度)**:

生成 Scope ID 的时间复杂度为：

\[
T_{\text{id}}(m) = O(m)
\]

其中 \( m = |N| + |V| \)。

### 2. 空间复杂度

**定理 6.4 (Scope 空间复杂度)**:

InstrumentationScope 的空间复杂度为：

\[
S_{\text{Scope}}(m, n) = O(m + n)
\]

其中：

- \( m = |N| + |V| \): Name 和 Version 的总长度
- \( n = |A| \): Attributes 数量

**证明**:

```text
Scope 存储:
  Name, Version:  O(m)
  Attributes:     O(n)
  DroppedCount:   O(1)
  
总空间: O(m + n)  ✓
```

---

## TLA+ 规范

```tla
------------------------ MODULE InstrumentationScope ------------------------
EXTENDS Naturals, Sequences, Strings, TLC

CONSTANTS MaxAttributes

VARIABLES 
    scopes,         \* Scope 集合
    nextID          \* 下一个 ID

TypeInvariant ==
    /\ scopes \in Seq([
        name: STRING,
        version: STRING,
        attributes: [STRING -> STRING],
        droppedAttributesCount: Nat
    ])
    /\ nextID \in Nat

Init ==
    /\ scopes = <<>>
    /\ nextID = 0

\* 创建 Scope
CreateScope(name, version, attrs) ==
    /\ name /= ""
    /\ Cardinality(DOMAIN attrs) <= MaxAttributes
    /\ nextID' = nextID + 1
    /\ scopes' = Append(scopes, [
        name |-> name,
        version |-> version,
        attributes |-> attrs,
        droppedAttributesCount |-> 0
    ])

\* 生成 Scope ID
ScopeID(scope) ==
    IF scope.version = ""
    THEN scope.name
    ELSE scope.name \o "@" \o scope.version

\* 不变量：Name 非空
NameNonEmpty ==
    \A i \in DOMAIN scopes:
        scopes[i].name /= ""

\* 不变量：Attributes 数量限制
AttributesLimit ==
    \A i \in DOMAIN scopes:
        Cardinality(DOMAIN scopes[i].attributes) <= MaxAttributes

\* 不变量：ID 唯一性
IDUniqueness ==
    \A i, j \in DOMAIN scopes:
        i /= j => ScopeID(scopes[i]) /= ScopeID(scopes[j])

Spec == Init /\ [][CreateScope]_<<scopes, nextID>>

THEOREM Spec => []TypeInvariant
THEOREM Spec => []NameNonEmpty
THEOREM Spec => []AttributesLimit
THEOREM Spec => []IDUniqueness
============================================================================
```

---

## Go 实现验证

```go
package instrumentation

import (
    "testing"
    "go.opentelemetry.io/otel/attribute"
)

// TestScopeEquality 验证相等关系
func TestScopeEquality(t *testing.T) {
    s1 := NewScope("myapp", "1.0.0")
    s2 := NewScope("myapp", "1.0.0")
    s3 := NewScope("myapp", "2.0.0")
    
    // 自反性
    if !s1.Equal(s1) {
        t.Error("自反性失败")
    }
    
    // 对称性
    if s1.Equal(s2) != s2.Equal(s1) {
        t.Error("对称性失败")
    }
    
    // 传递性
    if s1.Equal(s2) && s2.Equal(s1) && !s1.Equal(s2) {
        t.Error("传递性失败")
    }
    
    // 不同版本不相等
    if s1.Equal(s3) {
        t.Error("不同版本应该不相等")
    }
}

// TestScopeIDUniqueness 验证 ID 唯一性
func TestScopeIDUniqueness(t *testing.T) {
    s1 := NewScope("myapp", "1.0.0")
    s2 := NewScope("myapp", "1.0.0")
    s3 := NewScope("myapp", "2.0.0")
    
    // 相同 Scope，相同 ID
    if s1.UniqueID() != s2.UniqueID() {
        t.Error("相同 Scope 应该有相同 ID")
    }
    
    // 不同 Scope，不同 ID
    if s1.UniqueID() == s3.UniqueID() {
        t.Error("不同 Scope 应该有不同 ID")
    }
}

// TestScopeImmutability 验证不可变性
func TestScopeImmutability(t *testing.T) {
    attrs := []attribute.KeyValue{
        attribute.String("key", "value"),
    }
    
    scope := NewScope("myapp", "1.0.0", attrs...)
    originalID := scope.UniqueID()
    
    // 修改原始属性不应影响 Scope
    attrs[0] = attribute.String("key", "newvalue")
    
    if scope.UniqueID() != originalID {
        t.Error("Scope 应该是不可变的")
    }
}
```

---

## 参考资源

- [OpenTelemetry InstrumentationScope Spec](https://opentelemetry.io/docs/specs/otel/glossary/#instrumentation-scope)
- [TLA+ Specification](https://lamport.azurewebsites.net/tla/tla.html)
- [01_Scope定义.md](./01_Scope定义.md)
- [02_Scope管理.md](./02_Scope管理.md)

---

**🎉 恭喜！你已经完成了 InstrumentationScope 数据模型的形式化定义！**

本文档提供了：

- ✅ 完整的数学定义
- ✅ 严格的不变量分析
- ✅ 正确性证明
- ✅ 性能复杂度分析
- ✅ TLA+ 形式化规范
- ✅ Go 实现验证

**Phase 3.5: InstrumentationScope 数据模型 全部完成！** 🎊
