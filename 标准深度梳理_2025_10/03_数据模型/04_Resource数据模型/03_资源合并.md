# 资源合并

## 📋 目录

- [资源合并](#资源合并)
  - [📋 目录](#-目录)
  - [概述](#概述)
  - [合并规则](#合并规则)
  - [合并策略](#合并策略)
    - [1. 左优先合并](#1-左优先合并)
    - [2. 右优先合并](#2-右优先合并)
    - [3. 条件合并](#3-条件合并)
  - [冲突解决](#冲突解决)
  - [Go 1.25.1 实现](#go-1251-实现)
    - [1. 基本合并](#1-基本合并)
    - [2. 多资源合并](#2-多资源合并)
    - [3. 条件合并](#3-条件合并-1)
    - [4. 自定义合并策略](#4-自定义合并策略)
  - [合并优先级](#合并优先级)
  - [最佳实践](#最佳实践)
  - [常见场景](#常见场景)
  - [参考资源](#参考资源)

---

## 概述

**资源合并** 是将多个 Resource 的属性组合成单个 Resource 的过程。

```text
Resource1 + Resource2 -> MergedResource

用途:
✅ 组合多个检测器的结果
✅ 覆盖默认配置
✅ 添加自定义属性
✅ 分层配置管理
```

---

## 合并规则

OpenTelemetry Resource 合并的基本规则：

```text
1. 不可变性: Resource 本身不可变
2. 非破坏性: 合并创建新的 Resource
3. 属性唯一: 同一键只保留一个值
4. 默认策略: 后者覆盖前者 (右优先)
```

---

## 合并策略

### 1. 左优先合并

第一个 Resource 的属性优先：

```go
// resource.Merge(r1, r2) - r1 优先
merged, err := resource.Merge(r1, r2)

// 如果 r1 和 r2 都有 "service.name":
// 结果使用 r1 的值
```

### 2. 右优先合并

第二个 Resource 的属性优先：

```go
// 通过交换参数实现右优先
merged, err := resource.Merge(r2, r1)

// 现在 r2 的值会覆盖 r1
```

### 3. 条件合并

基于条件选择性合并：

```go
// 只有当 r1 不存在某个键时，才使用 r2 的值
if !r1.HasAttribute("service.version") {
    merged, _ = resource.Merge(r1, r2)
}
```

---

## 冲突解决

处理属性冲突的策略：

```text
冲突类型:
1. 键冲突: 相同的键，不同的值
2. 类型冲突: 相同的键，不同的类型

解决方案:
✅ 默认: 使用第一个 Resource 的值 (左优先)
✅ 显式配置优先: 手动设置 > 自动检测
✅ 环境特定: 生产环境 > 默认配置
```

---

## Go 1.25.1 实现

### 1. 基本合并

```go
package main

import (
    "context"
    "log"
    
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

func BasicMerge() {
    ctx := context.Background()
    
    // Resource 1: 服务信息
    r1, _ := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName("api-gateway"),
            semconv.ServiceVersion("1.0.0"),
        ),
    )
    
    // Resource 2: 部署信息
    r2, _ := resource.New(ctx,
        resource.WithAttributes(
            semconv.DeploymentEnvironment("production"),
            semconv.ServiceVersion("2.0.0"), // 冲突！
        ),
    )
    
    // 合并 (r1 优先)
    merged, err := resource.Merge(r1, r2)
    if err != nil {
        log.Fatal(err)
    }
    
    // 结果:
    // service.name = "api-gateway" (from r1)
    // service.version = "1.0.0"    (from r1, 冲突优先)
    // deployment.environment = "production" (from r2)
    
    for _, attr := range merged.Attributes() {
        log.Printf("%s = %v", attr.Key, attr.Value)
    }
}
```

### 2. 多资源合并

```go
package main

import (
    "context"
    
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// MergeMultiple 合并多个 Resource
func MergeMultiple(resources ...*resource.Resource) (*resource.Resource, error) {
    if len(resources) == 0 {
        return resource.Empty(), nil
    }
    
    result := resources[0]
    for i := 1; i < len(resources); i++ {
        merged, err := resource.Merge(result, resources[i])
        if err != nil {
            return nil, err
        }
        result = merged
    }
    
    return result, nil
}

// 使用示例
func main() {
    ctx := context.Background()
    
    // 创建多个 Resource
    r1, _ := resource.New(ctx,
        resource.WithAttributes(semconv.ServiceName("api-gateway")),
    )
    
    r2, _ := resource.New(ctx,
        resource.WithHost(),
    )
    
    r3, _ := resource.New(ctx,
        resource.WithProcess(),
    )
    
    r4, _ := resource.New(ctx,
        resource.WithAttributes(
            semconv.DeploymentEnvironment("production"),
        ),
    )
    
    // 合并所有 Resource
    merged, err := MergeMultiple(r1, r2, r3, r4)
    if err != nil {
        log.Fatal(err)
    }
    
    log.Printf("Merged resource: %v", merged.Attributes())
}
```

### 3. 条件合并

```go
package main

import (
    "context"
    
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/sdk/resource"
)

// ConditionalMerge 条件合并
func ConditionalMerge(base, override *resource.Resource, condition func(attribute.KeyValue) bool) (*resource.Resource, error) {
    ctx := context.Background()
    
    // 从 override 中筛选满足条件的属性
    var attrs []attribute.KeyValue
    for _, attr := range override.Attributes() {
        if condition(attr) {
            attrs = append(attrs, attr)
        }
    }
    
    // 创建过滤后的 Resource
    filtered, err := resource.New(ctx,
        resource.WithAttributes(attrs...),
    )
    if err != nil {
        return nil, err
    }
    
    // 合并
    return resource.Merge(base, filtered)
}

// 使用示例
func main() {
    ctx := context.Background()
    
    base, _ := resource.New(ctx,
        resource.WithAttributes(
            attribute.String("service.name", "api-gateway"),
            attribute.String("service.version", "1.0.0"),
        ),
    )
    
    override, _ := resource.New(ctx,
        resource.WithAttributes(
            attribute.String("service.version", "2.0.0"),
            attribute.String("deployment.environment", "production"),
        ),
    )
    
    // 只合并以 "deployment." 开头的属性
    merged, _ := ConditionalMerge(base, override, func(kv attribute.KeyValue) bool {
        return strings.HasPrefix(string(kv.Key), "deployment.")
    })
    
    // 结果:
    // service.name = "api-gateway"
    // service.version = "1.0.0"  (未被覆盖)
    // deployment.environment = "production"
    
    log.Printf("Merged: %v", merged.Attributes())
}
```

### 4. 自定义合并策略

```go
package main

import (
    "context"
    
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/sdk/resource"
)

// MergeStrategy 合并策略
type MergeStrategy int

const (
    LeftPriority  MergeStrategy = iota // 左优先 (默认)
    RightPriority                       // 右优先
    VersionAware                        // 版本感知
)

// MergeWithStrategy 使用指定策略合并
func MergeWithStrategy(r1, r2 *resource.Resource, strategy MergeStrategy) (*resource.Resource, error) {
    switch strategy {
    case LeftPriority:
        return resource.Merge(r1, r2)
        
    case RightPriority:
        return resource.Merge(r2, r1)
        
    case VersionAware:
        return versionAwareMerge(r1, r2)
        
    default:
        return resource.Merge(r1, r2)
    }
}

// versionAwareMerge 版本感知合并
func versionAwareMerge(r1, r2 *resource.Resource) (*resource.Resource, error) {
    ctx := context.Background()
    
    // 从两个 Resource 中选择属性
    attrs := make([]attribute.KeyValue, 0)
    
    // 对于 service.version，选择较新的版本
    v1 := getVersion(r1)
    v2 := getVersion(r2)
    
    if compareVersion(v1, v2) >= 0 {
        attrs = append(attrs, attribute.String("service.version", v1))
    } else {
        attrs = append(attrs, attribute.String("service.version", v2))
    }
    
    // 合并其他属性
    for _, attr := range r1.Attributes() {
        if attr.Key != "service.version" {
            attrs = append(attrs, attr)
        }
    }
    
    for _, attr := range r2.Attributes() {
        if attr.Key != "service.version" && !hasKey(attrs, attr.Key) {
            attrs = append(attrs, attr)
        }
    }
    
    return resource.NewWithAttributes(semconv.SchemaURL, attrs...), nil
}

func getVersion(r *resource.Resource) string {
    for _, attr := range r.Attributes() {
        if attr.Key == "service.version" {
            return attr.Value.AsString()
        }
    }
    return "0.0.0"
}

func compareVersion(v1, v2 string) int {
    // 简化的版本比较
    if v1 == v2 {
        return 0
    }
    if v1 > v2 {
        return 1
    }
    return -1
}

func hasKey(attrs []attribute.KeyValue, key attribute.Key) bool {
    for _, attr := range attrs {
        if attr.Key == key {
            return true
        }
    }
    return false
}

// 使用示例
func main() {
    ctx := context.Background()
    
    r1, _ := resource.New(ctx,
        resource.WithAttributes(
            attribute.String("service.name", "api-gateway"),
            attribute.String("service.version", "1.0.0"),
        ),
    )
    
    r2, _ := resource.New(ctx,
        resource.WithAttributes(
            attribute.String("service.version", "2.0.0"),
            attribute.String("deployment.environment", "production"),
        ),
    )
    
    // 左优先 (默认)
    m1, _ := MergeWithStrategy(r1, r2, LeftPriority)
    // service.version = "1.0.0"
    
    // 右优先
    m2, _ := MergeWithStrategy(r1, r2, RightPriority)
    // service.version = "2.0.0"
    
    // 版本感知 (选择较新版本)
    m3, _ := MergeWithStrategy(r1, r2, VersionAware)
    // service.version = "2.0.0" (自动选择较新)
    
    log.Printf("Left: %v", m1.Attributes())
    log.Printf("Right: %v", m2.Attributes())
    log.Printf("Version-aware: %v", m3.Attributes())
}
```

---

## 合并优先级

实际应用中的合并优先级：

```go
package main

import (
    "context"
    
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

func CreateResourceWithPriority(ctx context.Context, serviceName string) (*resource.Resource, error) {
    // 优先级 1: 默认配置 (最低)
    defaults, _ := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName(serviceName),
            semconv.ServiceVersion("0.0.0"),
            semconv.DeploymentEnvironment("development"),
        ),
    )
    
    // 优先级 2: 自动检测
    detected, _ := resource.New(ctx,
        resource.WithHost(),
        resource.WithProcess(),
        resource.WithContainer(),
    )
    
    // 优先级 3: 环境变量
    envConfig, _ := resource.New(ctx,
        resource.WithFromEnv(),
    )
    
    // 优先级 4: 显式配置 (最高)
    explicit, _ := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceVersion("1.0.0"), // 覆盖默认
        ),
    )
    
    // 按优先级合并 (从低到高)
    step1, _ := resource.Merge(defaults, detected)
    step2, _ := resource.Merge(step1, envConfig)
    final, _ := resource.Merge(step2, explicit)
    
    return final, nil
}
```

---

## 最佳实践

### ✅ 正确的合并方式

```go
// 1. 清晰的优先级
res, _ := resource.New(ctx,
    resource.WithAttributes(semconv.ServiceName("api-gateway")), // 高优先级
    resource.WithFromEnv(),    // 中优先级
    resource.WithHost(),       // 低优先级
)

// 2. 显式覆盖
defaults, _ := resource.New(ctx, resource.WithHost())
overrides, _ := resource.New(ctx, 
    resource.WithAttributes(semconv.ServiceName("custom")))
final, _ := resource.Merge(defaults, overrides)

// 3. 分层配置
baseConfig := loadBaseConfig()
envConfig := loadEnvConfig()
merged, _ := resource.Merge(baseConfig, envConfig)
```

### ❌ 错误的合并方式

```go
// 1. 未考虑优先级
res, _ := resource.Merge(explicit, defaults) // 错误: 低优先级覆盖高优先级

// 2. 过度合并
for _, r := range manyResources {
    merged, _ = resource.Merge(merged, r) // 性能问题
}

// 3. 忽略错误
merged, _ := resource.Merge(r1, r2) // 应该检查错误
```

---

## 常见场景

### 场景 1: 多环境配置

```go
func CreateResourceForEnvironment(env string) (*resource.Resource, error) {
    ctx := context.Background()
    
    // 基础配置
    base, _ := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName("api-gateway"),
        ),
        resource.WithHost(),
        resource.WithProcess(),
    )
    
    // 环境特定配置
    var envConfig *resource.Resource
    switch env {
    case "production":
        envConfig, _ = resource.New(ctx,
            resource.WithAttributes(
                semconv.DeploymentEnvironment("production"),
                semconv.ServiceVersion("1.0.0"),
            ),
        )
    case "staging":
        envConfig, _ = resource.New(ctx,
            resource.WithAttributes(
                semconv.DeploymentEnvironment("staging"),
                semconv.ServiceVersion("0.9.0"),
            ),
        )
    default:
        envConfig, _ = resource.New(ctx,
            resource.WithAttributes(
                semconv.DeploymentEnvironment("development"),
            ),
        )
    }
    
    return resource.Merge(base, envConfig)
}
```

### 场景 2: 团队级配置

```go
func CreateResourceWithTeamConfig(serviceName, team string) (*resource.Resource, error) {
    ctx := context.Background()
    
    // 服务配置
    serviceConfig, _ := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName(serviceName),
        ),
    )
    
    // 团队配置
    teamConfig, _ := resource.New(ctx,
        resource.WithAttributes(
            attribute.String("team.name", team),
            attribute.String("team.owner", getTeamOwner(team)),
        ),
    )
    
    // 环境检测
    envDetected, _ := resource.New(ctx,
        resource.WithHost(),
        resource.WithProcess(),
    )
    
    // 合并: 服务 + 团队 + 环境
    step1, _ := resource.Merge(serviceConfig, teamConfig)
    return resource.Merge(step1, envDetected)
}
```

### 场景 3: 动态覆盖

```go
func CreateResourceWithDynamicOverride(base *resource.Resource) (*resource.Resource, error) {
    ctx := context.Background()
    
    // 从远程配置服务读取覆盖
    overrideAttrs := fetchRemoteConfig()
    
    override, _ := resource.New(ctx,
        resource.WithAttributes(overrideAttrs...),
    )
    
    return resource.Merge(base, override)
}

func fetchRemoteConfig() []attribute.KeyValue {
    // 从 Config Server/Consul/etcd 读取
    return []attribute.KeyValue{
        attribute.String("feature.flag.new_ui", "enabled"),
        attribute.String("log.level", "debug"),
    }
}
```

---

## 参考资源

- [OpenTelemetry Resource Spec](https://opentelemetry.io/docs/specs/otel/resource/sdk/)
- [Go SDK Resource Package](https://pkg.go.dev/go.opentelemetry.io/otel/sdk/resource)
- [01_Resource定义.md](./01_Resource定义.md)
- [02_资源检测.md](./02_资源检测.md)

---

**🎉 恭喜！你已经掌握了资源合并！**

现在你可以：
- ✅ 理解合并规则和策略
- ✅ 处理属性冲突
- ✅ 实现自定义合并策略
- ✅ 应用于多环境配置

