# 资源检测

## 📋 目录

- [资源检测](#资源检测)
  - [📋 目录](#-目录)
  - [概述](#概述)
  - [检测器类型](#检测器类型)
    - [1. 环境变量检测器](#1-环境变量检测器)
    - [2. 主机检测器](#2-主机检测器)
    - [3. 进程检测器](#3-进程检测器)
    - [4. 容器检测器](#4-容器检测器)
    - [5. Kubernetes 检测器](#5-kubernetes-检测器)
    - [6. 云平台检测器](#6-云平台检测器)
  - [检测器接口](#检测器接口)
  - [检测器优先级](#检测器优先级)
  - [Go 1.25.1 实现](#go-1251-实现)
    - [1. 环境变量检测](#1-环境变量检测)
    - [2. 主机信息检测](#2-主机信息检测)
    - [3. 进程信息检测](#3-进程信息检测)
    - [4. 容器环境检测](#4-容器环境检测)
    - [5. Kubernetes 检测](#5-kubernetes-检测)
    - [6. AWS 检测](#6-aws-检测)
    - [7. GCP 检测](#7-gcp-检测)
    - [8. Azure 检测](#8-azure-检测)
  - [自定义检测器](#自定义检测器)
  - [组合检测器](#组合检测器)
  - [检测器缓存](#检测器缓存)
  - [错误处理](#错误处理)
  - [最佳实践](#最佳实践)
  - [参考资源](#参考资源)

---

## 概述

**资源检测** 是自动发现和识别运行环境信息的过程，用于自动填充 Resource 属性。

```text
自动检测的好处:
✅ 减少手动配置
✅ 保证一致性
✅ 适应不同环境
✅ 简化部署
```

---

## 检测器类型

### 1. 环境变量检测器

从环境变量读取 Resource 属性：

```bash
# OpenTelemetry 标准环境变量
export OTEL_RESOURCE_ATTRIBUTES="service.name=api-gateway,service.version=1.0.0"
export OTEL_SERVICE_NAME="api-gateway"
```

### 2. 主机检测器

检测主机信息（操作系统、架构、主机名）：

```go
resource.WithHost()       // 主机名、ID
resource.WithOS()         // 操作系统类型、版本
resource.WithOSDescription() // 详细描述
```

### 3. 进程检测器

检测进程信息（PID、可执行文件、运行时）：

```go
resource.WithProcessPID()              // 进程 ID
resource.WithProcessExecutableName()   // 可执行文件名
resource.WithProcessRuntimeName()      // 运行时名称 (go)
resource.WithProcessRuntimeVersion()   // 运行时版本
```

### 4. 容器检测器

检测容器环境（Docker、Podman）：

```go
resource.WithContainer()  // container.id, container.image.name
```

### 5. Kubernetes 检测器

检测 Kubernetes 资源信息：

```go
// 从 Downward API 读取
// /var/run/secrets/kubernetes.io/serviceaccount/
```

### 6. 云平台检测器

检测云平台元数据（AWS、GCP、Azure）：

```go
// AWS: 从 EC2 Metadata Service
// GCP: 从 Metadata Server
// Azure: 从 Instance Metadata Service
```

---

## 检测器接口

OpenTelemetry Go SDK 定义的检测器接口：

```go
// Detector 检测器接口
type Detector interface {
    // Detect 检测并返回 Resource
    Detect(ctx context.Context) (*Resource, error)
}
```

---

## 检测器优先级

检测器的优先级从高到低：

```text
1. 显式配置 (WithAttributes)
2. 环境变量 (WithFromEnv)
3. 云平台检测器
4. Kubernetes 检测器
5. 容器检测器
6. 主机/进程检测器
```

---

## Go 1.25.1 实现

### 1. 环境变量检测

```go
package main

import (
    "context"
    "log"
    "os"
    
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

func EnvResourceDetector() {
    // 设置环境变量
    os.Setenv("OTEL_SERVICE_NAME", "api-gateway")
    os.Setenv("OTEL_RESOURCE_ATTRIBUTES", "deployment.environment=production,service.version=1.0.0")
    
    // 从环境变量创建 Resource
    res, err := resource.New(context.Background(),
        resource.WithFromEnv(),  // 自动读取环境变量
    )
    if err != nil {
        log.Fatal(err)
    }
    
    // 输出属性
    for _, attr := range res.Attributes() {
        log.Printf("%s = %s", attr.Key, attr.Value.AsString())
    }
}

// 支持的环境变量:
// OTEL_SERVICE_NAME                - service.name
// OTEL_RESOURCE_ATTRIBUTES         - key1=val1,key2=val2
```

### 2. 主机信息检测

```go
package main

import (
    "context"
    "log"
    "os"
    "runtime"
    
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// HostDetector 主机信息检测器
type HostDetector struct{}

func (d HostDetector) Detect(ctx context.Context) (*resource.Resource, error) {
    hostname, err := os.Hostname()
    if err != nil {
        hostname = "unknown"
    }
    
    attrs := []attribute.KeyValue{
        semconv.HostName(hostname),
        semconv.HostArch(runtime.GOARCH),
        semconv.OSType(runtime.GOOS),
    }
    
    // 在 Linux 上，尝试读取 machine-id
    if runtime.GOOS == "linux" {
        if id, err := os.ReadFile("/etc/machine-id"); err == nil {
            attrs = append(attrs, semconv.HostID(string(id)))
        }
    }
    
    return resource.NewWithAttributes(semconv.SchemaURL, attrs...), nil
}

// 使用示例
func main() {
    ctx := context.Background()
    
    // 方式 1: 使用内置检测器
    res1, _ := resource.New(ctx,
        resource.WithHost(),
        resource.WithOS(),
    )
    
    // 方式 2: 使用自定义检测器
    detector := HostDetector{}
    res2, _ := detector.Detect(ctx)
    
    log.Printf("Host: %v", res1.Attributes())
    log.Printf("Custom: %v", res2.Attributes())
}
```

### 3. 进程信息检测

```go
package main

import (
    "context"
    "os"
    "path/filepath"
    "runtime"
    
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// ProcessDetector 进程信息检测器
type ProcessDetector struct{}

func (d ProcessDetector) Detect(ctx context.Context) (*resource.Resource, error) {
    pid := os.Getpid()
    executable, _ := os.Executable()
    execName := filepath.Base(executable)
    
    attrs := []attribute.KeyValue{
        semconv.ProcessPID(pid),
        semconv.ProcessExecutableName(execName),
        semconv.ProcessExecutablePath(executable),
        semconv.ProcessRuntimeName("go"),
        semconv.ProcessRuntimeVersion(runtime.Version()),
        semconv.ProcessRuntimeDescription(runtime.Version()),
    }
    
    // 获取命令行参数
    if len(os.Args) > 0 {
        cmdline := ""
        for i, arg := range os.Args {
            if i > 0 {
                cmdline += " "
            }
            cmdline += arg
        }
        attrs = append(attrs, semconv.ProcessCommandLine(cmdline))
    }
    
    // 获取进程所有者
    if uid := os.Getuid(); uid != 0 {
        attrs = append(attrs, semconv.ProcessOwner(fmt.Sprintf("uid-%d", uid)))
    }
    
    return resource.NewWithAttributes(semconv.SchemaURL, attrs...), nil
}

// 使用示例
func main() {
    ctx := context.Background()
    
    // 使用内置检测器
    res, _ := resource.New(ctx,
        resource.WithProcess(),
    )
    
    for _, attr := range res.Attributes() {
        log.Printf("%s = %v", attr.Key, attr.Value)
    }
}
```

### 4. 容器环境检测

```go
package main

import (
    "context"
    "os"
    "strings"
    
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// ContainerDetector 容器检测器
type ContainerDetector struct{}

func (d ContainerDetector) Detect(ctx context.Context) (*resource.Resource, error) {
    var attrs []attribute.KeyValue
    
    // 方法 1: 检查 /.dockerenv 文件
    if _, err := os.Stat("/.dockerenv"); err == nil {
        // 从 cgroup 读取 container ID
        if data, err := os.ReadFile("/proc/self/cgroup"); err == nil {
            for _, line := range strings.Split(string(data), "\n") {
                if strings.Contains(line, "docker") {
                    parts := strings.Split(line, "/")
                    if len(parts) > 0 {
                        containerID := parts[len(parts)-1]
                        attrs = append(attrs, semconv.ContainerID(containerID))
                        break
                    }
                }
            }
        }
    }
    
    // 方法 2: 从环境变量读取
    if hostname, err := os.Hostname(); err == nil {
        attrs = append(attrs, semconv.ContainerName(hostname))
    }
    
    // 检测容器镜像
    if imageName := os.Getenv("CONTAINER_IMAGE"); imageName != "" {
        attrs = append(attrs, semconv.ContainerImageName(imageName))
    }
    
    if len(attrs) == 0 {
        return resource.Empty(), nil
    }
    
    return resource.NewWithAttributes(semconv.SchemaURL, attrs...), nil
}

// 使用示例
func main() {
    ctx := context.Background()
    
    // 使用内置容器检测器
    res, _ := resource.New(ctx,
        resource.WithContainer(),
    )
    
    log.Printf("Container: %v", res.Attributes())
}
```

### 5. Kubernetes 检测

```go
package main

import (
    "context"
    "os"
    
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// K8sDetector Kubernetes 检测器
type K8sDetector struct{}

func (d K8sDetector) Detect(ctx context.Context) (*resource.Resource, error) {
    var attrs []attribute.KeyValue
    
    // 从 Downward API 环境变量读取
    if podName := os.Getenv("POD_NAME"); podName != "" {
        attrs = append(attrs, semconv.K8SPodName(podName))
    }
    
    if podUID := os.Getenv("POD_UID"); podUID != "" {
        attrs = append(attrs, semconv.K8SPodUID(podUID))
    }
    
    if namespace := os.Getenv("POD_NAMESPACE"); namespace != "" {
        attrs = append(attrs, semconv.K8SNamespaceName(namespace))
    }
    
    if nodeName := os.Getenv("NODE_NAME"); nodeName != "" {
        attrs = append(attrs, semconv.K8SNodeName(nodeName))
    }
    
    if containerName := os.Getenv("CONTAINER_NAME"); containerName != "" {
        attrs = append(attrs, semconv.K8SContainerName(containerName))
    }
    
    // 从 Pod 标签读取
    if deploymentName := os.Getenv("DEPLOYMENT_NAME"); deploymentName != "" {
        attrs = append(attrs, semconv.K8SDeploymentName(deploymentName))
    }
    
    if clusterName := os.Getenv("CLUSTER_NAME"); clusterName != "" {
        attrs = append(attrs, semconv.K8SClusterName(clusterName))
    }
    
    if len(attrs) == 0 {
        return resource.Empty(), nil
    }
    
    return resource.NewWithAttributes(semconv.SchemaURL, attrs...), nil
}

// Kubernetes Deployment YAML 示例
/*
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-gateway
spec:
  template:
    spec:
      containers:
      - name: api-gateway
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_UID
          valueFrom:
            fieldRef:
              fieldPath: metadata.uid
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        - name: CONTAINER_NAME
          value: "api-gateway"
        - name: DEPLOYMENT_NAME
          value: "api-gateway"
        - name: CLUSTER_NAME
          value: "prod-cluster"
*/
```

### 6. AWS 检测

```go
package main

import (
    "context"
    "encoding/json"
    "io"
    "net/http"
    "time"
    
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// AWSDetector AWS 检测器
type AWSDetector struct {
    client *http.Client
}

func NewAWSDetector() *AWSDetector {
    return &AWSDetector{
        client: &http.Client{
            Timeout: 1 * time.Second,
        },
    }
}

type ec2Metadata struct {
    InstanceID       string `json:"instanceId"`
    InstanceType     string `json:"instanceType"`
    Region           string `json:"region"`
    AvailabilityZone string `json:"availabilityZone"`
    AccountID        string `json:"accountId"`
}

func (d *AWSDetector) Detect(ctx context.Context) (*resource.Resource, error) {
    const metadataURL = "http://169.254.169.254/latest/dynamic/instance-identity/document"
    
    req, err := http.NewRequestWithContext(ctx, "GET", metadataURL, nil)
    if err != nil {
        return resource.Empty(), err
    }
    
    resp, err := d.client.Do(req)
    if err != nil {
        return resource.Empty(), nil // 不在 AWS 环境
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return resource.Empty(), nil
    }
    
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return resource.Empty(), err
    }
    
    var metadata ec2Metadata
    if err := json.Unmarshal(body, &metadata); err != nil {
        return resource.Empty(), err
    }
    
    attrs := []attribute.KeyValue{
        semconv.CloudProvider("aws"),
        semconv.CloudPlatform("aws_ec2"),
        semconv.CloudAccountID(metadata.AccountID),
        semconv.CloudRegion(metadata.Region),
        semconv.CloudAvailabilityZone(metadata.AvailabilityZone),
        semconv.HostID(metadata.InstanceID),
        semconv.HostType(metadata.InstanceType),
    }
    
    return resource.NewWithAttributes(semconv.SchemaURL, attrs...), nil
}
```

### 7. GCP 检测

```go
package main

import (
    "context"
    "io"
    "net/http"
    "time"
    
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// GCPDetector GCP 检测器
type GCPDetector struct {
    client *http.Client
}

func NewGCPDetector() *GCPDetector {
    return &GCPDetector{
        client: &http.Client{
            Timeout: 1 * time.Second,
        },
    }
}

func (d *GCPDetector) getMetadata(ctx context.Context, path string) (string, error) {
    url := "http://metadata.google.internal/computeMetadata/v1/" + path
    
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return "", err
    }
    req.Header.Set("Metadata-Flavor", "Google")
    
    resp, err := d.client.Do(req)
    if err != nil {
        return "", err
    }
    defer resp.Body.Close()
    
    body, err := io.ReadAll(resp.Body)
    return string(body), err
}

func (d *GCPDetector) Detect(ctx context.Context) (*resource.Resource, error) {
    // 检测是否在 GCP 环境
    projectID, err := d.getMetadata(ctx, "project/project-id")
    if err != nil {
        return resource.Empty(), nil // 不在 GCP 环境
    }
    
    zone, _ := d.getMetadata(ctx, "instance/zone")
    instanceID, _ := d.getMetadata(ctx, "instance/id")
    instanceType, _ := d.getMetadata(ctx, "instance/machine-type")
    
    // 从 zone 提取 region (us-central1-a -> us-central1)
    region := zone
    if len(zone) > 2 {
        region = zone[:len(zone)-2]
    }
    
    attrs := []attribute.KeyValue{
        semconv.CloudProvider("gcp"),
        semconv.CloudPlatform("gcp_compute_engine"),
        semconv.CloudAccountID(projectID),
        semconv.CloudRegion(region),
        semconv.CloudAvailabilityZone(zone),
        semconv.HostID(instanceID),
        semconv.HostType(instanceType),
    }
    
    return resource.NewWithAttributes(semconv.SchemaURL, attrs...), nil
}
```

### 8. Azure 检测

```go
package main

import (
    "context"
    "encoding/json"
    "io"
    "net/http"
    "time"
    
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// AzureDetector Azure 检测器
type AzureDetector struct {
    client *http.Client
}

func NewAzureDetector() *AzureDetector {
    return &AzureDetector{
        client: &http.Client{
            Timeout: 1 * time.Second,
        },
    }
}

type azureMetadata struct {
    Compute struct {
        VMId             string `json:"vmId"`
        VMSize           string `json:"vmSize"`
        Location         string `json:"location"`
        ResourceGroupName string `json:"resourceGroupName"`
        SubscriptionID   string `json:"subscriptionId"`
    } `json:"compute"`
}

func (d *AzureDetector) Detect(ctx context.Context) (*resource.Resource, error) {
    const metadataURL = "http://169.254.169.254/metadata/instance?api-version=2021-02-01"
    
    req, err := http.NewRequestWithContext(ctx, "GET", metadataURL, nil)
    if err != nil {
        return resource.Empty(), err
    }
    req.Header.Set("Metadata", "true")
    
    resp, err := d.client.Do(req)
    if err != nil {
        return resource.Empty(), nil // 不在 Azure 环境
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return resource.Empty(), nil
    }
    
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return resource.Empty(), err
    }
    
    var metadata azureMetadata
    if err := json.Unmarshal(body, &metadata); err != nil {
        return resource.Empty(), err
    }
    
    attrs := []attribute.KeyValue{
        semconv.CloudProvider("azure"),
        semconv.CloudPlatform("azure_vm"),
        semconv.CloudAccountID(metadata.Compute.SubscriptionID),
        semconv.CloudRegion(metadata.Compute.Location),
        semconv.HostID(metadata.Compute.VMId),
        semconv.HostType(metadata.Compute.VMSize),
        attribute.String("azure.resource_group", metadata.Compute.ResourceGroupName),
    }
    
    return resource.NewWithAttributes(semconv.SchemaURL, attrs...), nil
}
```

---

## 自定义检测器

创建自定义检测器：

```go
package main

import (
    "context"
    "os"
    
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// CustomDetector 自定义检测器示例
type CustomDetector struct {
    teamName string
}

func NewCustomDetector(teamName string) *CustomDetector {
    return &CustomDetector{
        teamName: teamName,
    }
}

func (d *CustomDetector) Detect(ctx context.Context) (*resource.Resource, error) {
    attrs := []attribute.KeyValue{
        attribute.String("team.name", d.teamName),
    }
    
    // 从配置文件读取
    if gitCommit := os.Getenv("GIT_COMMIT"); gitCommit != "" {
        attrs = append(attrs, attribute.String("git.commit", gitCommit))
    }
    
    // 从构建时间读取
    if buildTime := os.Getenv("BUILD_TIME"); buildTime != "" {
        attrs = append(attrs, attribute.String("build.time", buildTime))
    }
    
    return resource.NewWithAttributes(semconv.SchemaURL, attrs...), nil
}

// 使用示例
func main() {
    ctx := context.Background()
    
    customDetector := NewCustomDetector("platform-team")
    
    res, _ := resource.New(ctx,
        resource.WithDetectors(customDetector),
        resource.WithHost(),
    )
    
    log.Printf("Resource: %v", res.Attributes())
}
```

---

## 组合检测器

组合多个检测器：

```go
package main

import (
    "context"
    
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

func CreateResourceWithAllDetectors(ctx context.Context, serviceName string) (*resource.Resource, error) {
    return resource.New(ctx,
        // 1. 显式配置 (最高优先级)
        resource.WithAttributes(
            semconv.ServiceName(serviceName),
        ),
        
        // 2. 环境变量
        resource.WithFromEnv(),
        
        // 3. 云平台检测
        resource.WithDetectors(
            NewAWSDetector(),
            NewGCPDetector(),
            NewAzureDetector(),
        ),
        
        // 4. Kubernetes
        resource.WithDetectors(
            &K8sDetector{},
        ),
        
        // 5. 容器
        resource.WithContainer(),
        
        // 6. 主机和进程
        resource.WithHost(),
        resource.WithOS(),
        resource.WithProcess(),
        
        // 7. 自定义检测器
        resource.WithDetectors(
            NewCustomDetector("my-team"),
        ),
    )
}
```

---

## 检测器缓存

缓存检测结果以提升性能：

```go
package main

import (
    "context"
    "sync"
    
    "go.opentelemetry.io/otel/sdk/resource"
)

// CachedDetector 带缓存的检测器
type CachedDetector struct {
    detector resource.Detector
    once     sync.Once
    result   *resource.Resource
    err      error
}

func NewCachedDetector(detector resource.Detector) *CachedDetector {
    return &CachedDetector{
        detector: detector,
    }
}

func (d *CachedDetector) Detect(ctx context.Context) (*resource.Resource, error) {
    d.once.Do(func() {
        d.result, d.err = d.detector.Detect(ctx)
    })
    return d.result, d.err
}

// 使用示例
func main() {
    ctx := context.Background()
    
    // 包装 AWS 检测器为缓存检测器
    awsDetector := NewCachedDetector(NewAWSDetector())
    
    // 多次调用只执行一次检测
    res1, _ := awsDetector.Detect(ctx)
    res2, _ := awsDetector.Detect(ctx) // 使用缓存结果
    
    log.Printf("Same: %v", res1 == res2)
}
```

---

## 错误处理

检测器错误处理最佳实践：

```go
package main

import (
    "context"
    "log"
    
    "go.opentelemetry.io/otel/sdk/resource"
)

// SafeDetector 安全的检测器包装
type SafeDetector struct {
    detector resource.Detector
    logger   *log.Logger
}

func NewSafeDetector(detector resource.Detector, logger *log.Logger) *SafeDetector {
    return &SafeDetector{
        detector: detector,
        logger:   logger,
    }
}

func (d *SafeDetector) Detect(ctx context.Context) (*resource.Resource, error) {
    res, err := d.detector.Detect(ctx)
    if err != nil {
        d.logger.Printf("Detector failed: %v", err)
        // 返回空 Resource，不中断检测流程
        return resource.Empty(), nil
    }
    return res, nil
}
```

---

## 最佳实践

```go
// ✅ 正确：组合多个检测器
res, _ := resource.New(ctx,
    resource.WithAttributes(semconv.ServiceName("api-gateway")),
    resource.WithFromEnv(),
    resource.WithHost(),
    resource.WithProcess(),
)

// ✅ 正确：设置超时
ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
defer cancel()
res, _ := resource.New(ctx, resource.WithDetectors(detector))

// ❌ 错误：阻塞过长时间
res, _ := resource.New(context.Background(),
    resource.WithDetectors(slowDetector), // 无超时控制
)

// ✅ 正确：缓存检测结果
cachedDetector := NewCachedDetector(NewAWSDetector())
res, _ := resource.New(ctx, resource.WithDetectors(cachedDetector))
```

---

## 参考资源

- [OpenTelemetry Resource Detectors](https://opentelemetry.io/docs/specs/otel/resource/sdk/)
- [Go SDK Resource Detectors](https://pkg.go.dev/go.opentelemetry.io/otel/sdk/resource)
- [01_Resource定义.md](./01_Resource定义.md)
- [03_资源合并.md](./03_资源合并.md)

---

**🎉 恭喜！你已经掌握了资源自动检测！**

现在你可以：
- ✅ 理解不同类型的检测器
- ✅ 实现自定义检测器
- ✅ 组合多个检测器
- ✅ 处理检测错误

