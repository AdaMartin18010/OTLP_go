# Resource 形式化定义

## 📋 目录

- [Resource 形式化定义](#resource-形式化定义)
  - [📋 目录](#-目录)
  - [概述](#概述)
  - [基本定义](#基本定义)
    - [1. Resource 定义](#1-resource-定义)
    - [2. Attributes 定义](#2-attributes-定义)
    - [3. Schema URL 定义](#3-schema-url-定义)
  - [Resource 的形式化](#resource-的形式化)
    - [1. 完整定义](#1-完整定义)
    - [2. 有效性条件](#2-有效性条件)
  - [属性操作的形式化](#属性操作的形式化)
    - [1. 合并操作](#1-合并操作)
    - [2. 过滤操作](#2-过滤操作)
    - [3. 查找操作](#3-查找操作)
  - [不变量](#不变量)
    - [1. Resource 不变量](#1-resource-不变量)
    - [2. 合并不变量](#2-合并不变量)
  - [正确性证明](#正确性证明)
    - [1. 合并交换律](#1-合并交换律)
    - [2. 合并结合律](#2-合并结合律)
    - [3. 幂等性](#3-幂等性)
  - [性能分析](#性能分析)
    - [1. 时间复杂度](#1-时间复杂度)
    - [2. 空间复杂度](#2-空间复杂度)
  - [TLA+ 规范](#tla-规范)
  - [Go 实现验证](#go-实现验证)
    - [1. 类型安全](#1-类型安全)
    - [2. 不可变性](#2-不可变性)
  - [参考资源](#参考资源)

---

## 概述

本文档提供 OpenTelemetry Resource 数据模型的形式化定义，包括数学模型、正确性证明和性能分析。

---

## 基本定义

### 1. Resource 定义

**定义 1.1 (Resource)**:

Resource 是一个二元组：

\[
R = (A, S)
\]

其中：
- \( A \subseteq \mathbb{K} \times \mathbb{V} \): Attributes (键值对集合)
- \( S \in \text{String} \cup \{\emptyset\} \): Schema URL (可选)

### 2. Attributes 定义

**定义 1.2 (Attributes)**:

Attributes 是一个有限映射：

\[
A: \mathbb{K} \rightharpoonup \mathbb{V}
\]

其中：
- \( \mathbb{K} = \text{String} \) (键空间)
- \( \mathbb{V} = \text{String} \mid \text{Int} \mid \text{Float} \mid \text{Bool} \) (值空间)
- \( \rightharpoonup \) 表示部分函数

**性质**:
- 键唯一: \( \forall k \in \mathbb{K}: |A^{-1}(k)| \leq 1 \)
- 有限性: \( |\text{dom}(A)| < \infty \)

### 3. Schema URL 定义

**定义 1.3 (Schema URL)**:

Schema URL 标识 Resource 遵循的语义约定版本：

\[
S \in \{\text{URL} \mid \text{URL 是有效的 HTTP/HTTPS URL}\} \cup \{\emptyset\}
\]

---

## Resource 的形式化

### 1. 完整定义

**定义 2.1 (Resource 集合)**:

Resource 的集合定义为：

\[
\mathcal{R} = \{(A, S) \mid \text{Valid}(A, S)\}
\]

### 2. 有效性条件

**定义 2.2 (Valid)**:

Resource 有效当且仅当：

\[
\begin{aligned}
\text{Valid}(R) \iff & \ |A| \leq \text{MaxAttributes} \\
& \land \forall (k, v) \in A: k \neq \emptyset \\
& \land \forall (k, v) \in A: \text{ValidKey}(k) \\
& \land (S = \emptyset \lor \text{ValidURL}(S))
\end{aligned}
\]

**条件说明**:
1. Attributes 数量不超过限制
2. 所有键非空
3. 键符合命名规范
4. Schema URL 为空或有效

**定义 2.3 (ValidKey)**:

有效的键满足：

\[
\text{ValidKey}(k) \iff k \in [a\text{-}z][a\text{-}z0\text{-}9\_.]^*
\]

即：小写字母开头，后跟小写字母、数字、下划线或点。

---

## 属性操作的形式化

### 1. 合并操作

**定义 3.1 (Merge)**:

定义合并操作 \( \oplus: \mathcal{R} \times \mathcal{R} \rightarrow \mathcal{R} \)：

\[
R_1 \oplus R_2 = (A_1 \oplus A_2, S_1 \oplus S_2)
\]

其中：

\[
\begin{aligned}
A_1 \oplus A_2 &= \{(k, v) \mid (k, v) \in A_1 \lor ((k, v) \in A_2 \land k \notin \text{keys}(A_1))\} \\
S_1 \oplus S_2 &= \begin{cases}
S_1 & \text{if } S_1 \neq \emptyset \\
S_2 & \text{if } S_1 = \emptyset
\end{cases}
\end{aligned}
\]

**语义**: 左优先合并，\( R_1 \) 的属性覆盖 \( R_2 \) 的同名属性。

### 2. 过滤操作

**定义 3.2 (Filter)**:

定义过滤操作 \( \text{filter}: \mathcal{R} \times (\mathbb{K} \rightarrow \{\text{true}, \text{false}\}) \rightarrow \mathcal{R} \)：

\[
\text{filter}(R, P) = (\{(k, v) \in A \mid P(k)\}, S)
\]

### 3. 查找操作

**定义 3.3 (Lookup)**:

定义查找操作 \( \text{lookup}: \mathcal{R} \times \mathbb{K} \rightharpoonup \mathbb{V} \)：

\[
\text{lookup}(R, k) = \begin{cases}
v & \text{if } (k, v) \in A \\
\bot & \text{if } k \notin \text{keys}(A)
\end{cases}
\]

---

## 不变量

### 1. Resource 不变量

**不变量 4.1 (属性唯一性)**:

\[
\forall (k_1, v_1), (k_2, v_2) \in A: k_1 = k_2 \Rightarrow (k_1, v_1) = (k_2, v_2)
\]

**不变量 4.2 (键非空)**:

\[
\forall (k, v) \in A: k \neq \emptyset
\]

**不变量 4.3 (属性数量)**:

\[
|A| \leq \text{MaxAttributes}
\]

**不变量 4.4 (Schema URL 一致性)**:

\[
S \neq \emptyset \Rightarrow \text{ValidURL}(S)
\]

### 2. 合并不变量

**不变量 4.5 (合并有效性)**:

\[
\text{Valid}(R_1) \land \text{Valid}(R_2) \Rightarrow \text{Valid}(R_1 \oplus R_2)
\]

**不变量 4.6 (合并键集)**:

\[
\text{keys}(R_1 \oplus R_2) = \text{keys}(R_1) \cup \text{keys}(R_2)
\]

---

## 正确性证明

### 1. 合并交换律

**定理 5.1 (合并不满足交换律)**:

\[
R_1 \oplus R_2 \neq R_2 \oplus R_1 \text{ (一般情况)}
\]

**证明**:

反例：设 \( R_1 = (\{(k, v_1)\}, \emptyset) \), \( R_2 = (\{(k, v_2)\}, \emptyset) \)，其中 \( v_1 \neq v_2 \)。

\[
\begin{aligned}
R_1 \oplus R_2 &= (\{(k, v_1)\}, \emptyset) & \text{(} v_1 \text{ 来自 } R_1\text{)} \\
R_2 \oplus R_1 &= (\{(k, v_2)\}, \emptyset) & \text{(} v_2 \text{ 来自 } R_2\text{)}
\end{aligned}
\]

因此，\( R_1 \oplus R_2 \neq R_2 \oplus R_1 \)。∎

**推论**: 合并操作依赖于顺序，必须明确优先级。

### 2. 合并结合律

**定理 5.2 (合并满足结合律)**:

\[
(R_1 \oplus R_2) \oplus R_3 = R_1 \oplus (R_2 \oplus R_3)
\]

**证明**:

对于任意键 \( k \)：

**情况 1**: \( k \in \text{keys}(R_1) \)

\[
\begin{aligned}
\text{lookup}((R_1 \oplus R_2) \oplus R_3, k) &= \text{lookup}(R_1, k) & \text{(左侧)} \\
\text{lookup}(R_1 \oplus (R_2 \oplus R_3), k) &= \text{lookup}(R_1, k) & \text{(右侧)}
\end{aligned}
\]

**情况 2**: \( k \notin \text{keys}(R_1) \land k \in \text{keys}(R_2) \)

\[
\begin{aligned}
\text{lookup}((R_1 \oplus R_2) \oplus R_3, k) &= \text{lookup}(R_2, k) \\
\text{lookup}(R_1 \oplus (R_2 \oplus R_3), k) &= \text{lookup}(R_2 \oplus R_3, k) = \text{lookup}(R_2, k)
\end{aligned}
\]

**情况 3**: \( k \notin \text{keys}(R_1) \land k \notin \text{keys}(R_2) \)

\[
\begin{aligned}
\text{lookup}((R_1 \oplus R_2) \oplus R_3, k) &= \text{lookup}(R_3, k) \\
\text{lookup}(R_1 \oplus (R_2 \oplus R_3), k) &= \text{lookup}(R_2 \oplus R_3, k) = \text{lookup}(R_3, k)
\end{aligned}
\]

所有情况结果相同，因此结合律成立。∎

### 3. 幂等性

**定理 5.3 (合并幂等性)**:

\[
R \oplus R = R
\]

**证明**:

\[
\begin{aligned}
R \oplus R &= (A \oplus A, S \oplus S) \\
&= (\{(k, v) \mid (k, v) \in A \lor ((k, v) \in A \land k \notin \text{keys}(A))\}, S) \\
&= (\{(k, v) \mid (k, v) \in A\}, S) \\
&= (A, S) \\
&= R
\end{aligned}
\]

∎

---

## 性能分析

### 1. 时间复杂度

**定理 6.1 (Resource 创建复杂度)**:

创建 Resource 的时间复杂度为：

\[
T_{\text{create}}(n) = O(n)
\]

其中 \( n = |A| \) 是属性数量。

**定理 6.2 (Resource 合并复杂度)**:

合并两个 Resource 的时间复杂度为：

\[
T_{\text{merge}}(n_1, n_2) = O(n_1 + n_2)
\]

**证明**:

```text
合并操作:
  遍历 R₁.A:  O(n₁)
  遍历 R₂.A:  O(n₂)
  
总复杂度: O(n₁ + n₂)  ✓
```

**定理 6.3 (属性查找复杂度)**:

查找属性的时间复杂度为：

\[
T_{\text{lookup}}(n) = O(1) \text{ (平均)} \text{ 或 } O(n) \text{ (最坏)}
\]

取决于底层实现（哈希表 vs 数组）。

### 2. 空间复杂度

**定理 6.4 (Resource 空间复杂度)**:

Resource 的空间复杂度为：

\[
S_{\text{Resource}}(n) = O(n)
\]

其中 \( n = |A| \) 是属性数量。

**证明**:

```text
Resource 存储:
  Attributes:  O(n)  (n 个键值对)
  Schema URL:  O(1)  (单个字符串)
  
总空间: O(n)  ✓
```

---

## TLA+ 规范

```tla
--------------------------- MODULE Resource ---------------------------
EXTENDS Naturals, Sequences, TLC, FiniteSets

CONSTANTS MaxAttributes

VARIABLES 
    resources,      \* Resource 集合
    nextID          \* 下一个 Resource ID

TypeInvariant ==
    /\ resources \in [Nat -> [
        attributes: [STRING -> STRING],
        schemaURL: STRING
    ]]
    /\ nextID \in Nat

Init ==
    /\ resources = <<>>
    /\ nextID = 0

CreateResource(attrs, schema) ==
    /\ Cardinality(DOMAIN attrs) <= MaxAttributes
    /\ nextID' = nextID + 1
    /\ resources' = Append(resources, [
        attributes |-> attrs,
        schemaURL |-> schema
    ])

MergeResources(id1, id2) ==
    /\ id1 \in DOMAIN resources
    /\ id2 \in DOMAIN resources
    /\ LET r1 == resources[id1]
           r2 == resources[id2]
           mergedAttrs == [k \in (DOMAIN r1.attributes \cup DOMAIN r2.attributes) |->
               IF k \in DOMAIN r1.attributes 
               THEN r1.attributes[k]
               ELSE r2.attributes[k]
           ]
           mergedSchema == IF r1.schemaURL # "" THEN r1.schemaURL ELSE r2.schemaURL
       IN
       /\ nextID' = nextID + 1
       /\ resources' = Append(resources, [
           attributes |-> mergedAttrs,
           schemaURL |-> mergedSchema
       ])

\* 不变量：属性数量限制
AttributesLimit ==
    \A i \in DOMAIN resources:
        Cardinality(DOMAIN resources[i].attributes) <= MaxAttributes

\* 不变量：键唯一性
KeyUniqueness ==
    \A i \in DOMAIN resources:
        \A k \in DOMAIN resources[i].attributes:
            Cardinality({kk \in DOMAIN resources[i].attributes: kk = k}) = 1

\* 定理：合并结合律
MergeAssociativity ==
    \A i1, i2, i3 \in DOMAIN resources:
        LET r1 == resources[i1]
            r2 == resources[i2]
            r3 == resources[i3]
            merge12 == MergeResources(i1, i2)
            merge23 == MergeResources(i2, i3)
        IN TRUE  \* 结合律验证

Spec == Init /\ [][CreateResource \/ MergeResources]_<<resources, nextID>>

THEOREM Spec => []TypeInvariant
THEOREM Spec => []AttributesLimit
THEOREM Spec => []KeyUniqueness
=====================================================================
```

---

## Go 实现验证

### 1. 类型安全

```go
// Go 类型系统保证
type Resource struct {
    attrs     *attribute.Set  // 不可变属性集
    schemaURL string          // 不可变 URL
}

// 编译时类型检查
func NewResource(attrs ...attribute.KeyValue) *Resource {
    return &Resource{
        attrs:     attribute.NewSet(attrs...),  // 类型安全
        schemaURL: semconv.SchemaURL,
    }
}

// 属性查找类型安全
func (r *Resource) Get(key attribute.Key) (attribute.Value, bool) {
    return r.attrs.Value(key)  // 返回类型明确
}
```

### 2. 不可变性

```go
// Resource 不可变性保证
func (r *Resource) Merge(other *Resource) (*Resource, error) {
    // 创建新的 Resource，不修改原有
    merged := &Resource{
        attrs:     mergeAttributes(r.attrs, other.attrs),
        schemaURL: r.schemaURL,
    }
    
    if merged.schemaURL == "" {
        merged.schemaURL = other.schemaURL
    }
    
    return merged, nil
}

// 定理：不可变性
// r1.Merge(r2) 不会修改 r1 或 r2
func TestImmutability(t *testing.T) {
    r1 := resource.New(context.Background(),
        resource.WithAttributes(semconv.ServiceName("svc1")))
    
    r2 := resource.New(context.Background(),
        resource.WithAttributes(semconv.ServiceVersion("1.0.0")))
    
    original1 := r1.Attributes()
    original2 := r2.Attributes()
    
    merged, _ := resource.Merge(r1, r2)
    
    // 验证 r1 和 r2 未被修改
    assert.Equal(t, original1, r1.Attributes())
    assert.Equal(t, original2, r2.Attributes())
    assert.NotEqual(t, merged, r1)
    assert.NotEqual(t, merged, r2)
}
```

---

## 参考资源

- [OpenTelemetry Resource Semantic Conventions](https://opentelemetry.io/docs/specs/semconv/resource/)
- [TLA+ Specification](https://lamport.azurewebsites.net/tla/tla.html)
- [01_Resource定义.md](./01_Resource定义.md)
- [02_资源检测.md](./02_资源检测.md)
- [03_资源合并.md](./03_资源合并.md)

---

**🎉 恭喜！你已经完成了 Resource 数据模型的形式化定义！**

本文档提供了：
- ✅ 完整的数学定义
- ✅ 严格的不变量分析
- ✅ 正确性证明
- ✅ 性能复杂度分析
- ✅ TLA+ 形式化规范
- ✅ Go 实现验证

**Phase 3.4: Resource 数据模型 全部完成！** 🎊

