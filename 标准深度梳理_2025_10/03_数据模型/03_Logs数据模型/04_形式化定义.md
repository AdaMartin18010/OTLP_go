# Logs 形式化定义

## 📋 目录

- [Logs 形式化定义](#logs-形式化定义)
  - [📋 目录](#-目录)
  - [概述](#概述)
  - [基本定义](#基本定义)
    - [1. LogRecord 定义](#1-logrecord-定义)
    - [2. 时间戳定义](#2-时间戳定义)
    - [3. SeverityNumber 定义](#3-severitynumber-定义)
    - [4. AnyValue 定义](#4-anyvalue-定义)
  - [LogRecord 的形式化](#logrecord-的形式化)
    - [1. 完整定义](#1-完整定义)
    - [2. 有效性条件](#2-有效性条件)
  - [SeverityNumber 的形式化](#severitynumber-的形式化)
    - [1. 全序关系](#1-全序关系)
    - [2. 级别映射](#2-级别映射)
  - [Body 和 Attributes 的形式化](#body-和-attributes-的形式化)
    - [1. Body 定义](#1-body-定义)
    - [2. Attributes 定义](#2-attributes-定义)
    - [3. 属性操作](#3-属性操作)
  - [不变量](#不变量)
    - [1. 时间不变量](#1-时间不变量)
    - [2. 严重性不变量](#2-严重性不变量)
    - [3. 属性不变量](#3-属性不变量)
  - [正确性证明](#正确性证明)
    - [1. 时间戳一致性](#1-时间戳一致性)
    - [2. 严重性有序性](#2-严重性有序性)
    - [3. 属性合并正确性](#3-属性合并正确性)
  - [性能分析](#性能分析)
    - [1. 时间复杂度](#1-时间复杂度)
    - [2. 空间复杂度](#2-空间复杂度)
  - [TLA+ 规范](#tla-规范)
  - [Go 实现验证](#go-实现验证)
    - [1. 类型安全](#1-类型安全)
    - [2. 并发安全](#2-并发安全)
  - [参考资源](#参考资源)

---

## 概述

本文档提供 OpenTelemetry Logs 数据模型的形式化定义，包括数学模型、正确性证明和性能分析。

---

## 基本定义

### 1. LogRecord 定义

**定义 1.1 (LogRecord)**:

LogRecord 是一个元组：

\[
LR = (T, T_{obs}, S_n, S_t, B, A, \text{TraceID}, \text{SpanID}, F)
\]

其中：

- \( T \in \mathbb{T} \): Timestamp (可选)
- \( T_{obs} \in \mathbb{T} \): ObservedTimestamp (必需)
- \( S_n \in [0, 24] \): SeverityNumber
- \( S_t \in \text{String} \): SeverityText
- \( B \in \mathbb{V} \): Body (AnyValue)
- \( A \subseteq \mathbb{K} \times \mathbb{V} \): Attributes
- \( \text{TraceID} \in \{0,1\}^{128} \): 追踪 ID
- \( \text{SpanID} \in \{0,1\}^{64} \): Span ID
- \( F \in \{0,1\}^{32} \): TraceFlags

### 2. 时间戳定义

**定义 1.2 (时间域)**:

\[
\mathbb{T} = \{t \in \mathbb{N} \mid 0 \leq t < 2^{64}\}
\]

时间戳为 Unix 纳秒 (uint64)。

**性质**:

- 单调递增 (对于同一源)
- 精度: 纳秒级

### 3. SeverityNumber 定义

**定义 1.3 (SeverityNumber)**:

\[
S_n \in \{0, 1, 2, ..., 24\}
\]

级别映射：
\[
\begin{aligned}
\text{TRACE} &\mapsto [1, 4] \\
\text{DEBUG} &\mapsto [5, 8] \\
\text{INFO} &\mapsto [9, 12] \\
\text{WARN} &\mapsto [13, 16] \\
\text{ERROR} &\mapsto [17, 20] \\
\text{FATAL} &\mapsto [21, 24]
\end{aligned}
\]

### 4. AnyValue 定义

**定义 1.4 (AnyValue)**:

AnyValue 是一个代数数据类型：

\[
\mathbb{V} = \text{String} \mid \text{Int} \mid \text{Float} \mid \text{Bool} \mid \text{Bytes} \mid \text{Array} \mid \text{KvList}
\]

其中：

- \( \text{String} \subseteq \Sigma^* \) (字符串)
- \( \text{Int} \subseteq \mathbb{Z} \) (整数)
- \( \text{Float} \subseteq \mathbb{R} \) (浮点数)
- \( \text{Bool} = \{\text{true}, \text{false}\} \) (布尔)
- \( \text{Bytes} \subseteq \{0,1\}^* \) (字节序列)
- \( \text{Array} = \mathbb{V}^* \) (数组)
- \( \text{KvList} = (\mathbb{K} \times \mathbb{V})^* \) (键值对列表)

---

## LogRecord 的形式化

### 1. 完整定义

**定义 2.1 (LogRecord 集合)**:

LogRecord 的集合定义为：

\[
\mathcal{LR} = \{(T, T_{obs}, S_n, S_t, B, A, \text{TID}, \text{SID}, F) \mid \text{Valid}(T, T_{obs}, S_n, A)\}
\]

### 2. 有效性条件

**定义 2.2 (Valid)**:

LogRecord 有效当且仅当：

\[
\begin{aligned}
\text{Valid}(LR) \iff & \ T_{obs} \neq \emptyset \\
& \land (T = \emptyset \lor T \leq T_{obs}) \\
& \land S_n \in [0, 24] \\
& \land |A| \leq \text{MaxAttributes} \\
& \land \forall (k, v) \in A: k \neq \emptyset
\end{aligned}
\]

**条件说明**:

1. ObservedTimestamp 必须存在
2. 如果 Timestamp 存在，必须 ≤ ObservedTimestamp
3. SeverityNumber 在有效范围内
4. Attributes 数量不超过限制
5. 所有属性键非空

---

## SeverityNumber 的形式化

### 1. 全序关系

**定义 3.1 (SeverityNumber 全序)**:

在 SeverityNumber 上定义全序关系 \( \leq \)：

\[
\forall s_1, s_2 \in [0, 24]: s_1 \leq s_2 \iff s_1 \text{ 的数值} \leq s_2 \text{ 的数值}
\]

**性质**:

- **自反性**: \( \forall s: s \leq s \)
- **反对称性**: \( s_1 \leq s_2 \land s_2 \leq s_1 \Rightarrow s_1 = s_2 \)
- **传递性**: \( s_1 \leq s_2 \land s_2 \leq s_3 \Rightarrow s_1 \leq s_3 \)
- **完全性**: \( \forall s_1, s_2: s_1 \leq s_2 \lor s_2 \leq s_1 \)

### 2. 级别映射

**定义 3.2 (级别映射函数)**:

定义映射函数 \( \text{Level}: [0, 24] \rightarrow \{\text{TRACE}, \text{DEBUG}, \text{INFO}, \text{WARN}, \text{ERROR}, \text{FATAL}\} \)：

\[
\text{Level}(s) = \begin{cases}
\text{TRACE} & \text{if } 1 \leq s \leq 4 \\
\text{DEBUG} & \text{if } 5 \leq s \leq 8 \\
\text{INFO} & \text{if } 9 \leq s \leq 12 \\
\text{WARN} & \text{if } 13 \leq s \leq 16 \\
\text{ERROR} & \text{if } 17 \leq s \leq 20 \\
\text{FATAL} & \text{if } 21 \leq s \leq 24 \\
\text{UNSPECIFIED} & \text{if } s = 0
\end{cases}
\]

**定理 3.1 (级别保序)**:

级别映射保持偏序关系：

\[
\forall s_1, s_2: \text{Level}(s_1) \leq \text{Level}(s_2) \Leftarrow s_1 \leq s_2
\]

---

## Body 和 Attributes 的形式化

### 1. Body 定义

**定义 4.1 (Body 有效性)**:

Body 有效当且仅当：

\[
\text{ValidBody}(B) \iff |B| \leq \text{MaxBodySize}
\]

其中 \( |B| \) 是 Body 的序列化大小。

### 2. Attributes 定义

**定义 4.2 (Attributes 集合)**:

Attributes 是键值对的有限集合：

\[
A = \{(k_1, v_1), (k_2, v_2), ..., (k_n, v_n)\}
\]

满足：

- \( \forall i \neq j: k_i \neq k_j \) (键唯一)
- \( n \leq \text{MaxAttributes} \) (数量限制)

### 3. 属性操作

**定义 4.3 (属性合并)**:

定义合并操作 \( \oplus: \mathcal{A} \times \mathcal{A} \rightarrow \mathcal{A} \)：

\[
A_1 \oplus A_2 = \{(k, v) \mid (k, v) \in A_1 \lor ((k, v) \in A_2 \land k \notin \text{keys}(A_1))\}
\]

**性质**:

- **幂等性**: \( A \oplus A = A \)
- **结合性**: \( (A_1 \oplus A_2) \oplus A_3 = A_1 \oplus (A_2 \oplus A_3) \)
- **左优先**: 如果 \( k \in \text{keys}(A_1) \cap \text{keys}(A_2) \)，则使用 \( A_1 \) 中的值

**定义 4.4 (属性过滤)**:

定义过滤操作 \( \text{filter}: \mathcal{A} \times (\mathbb{K} \rightarrow \{\text{true}, \text{false}\}) \rightarrow \mathcal{A} \)：

\[
\text{filter}(A, P) = \{(k, v) \in A \mid P(k)\}
\]

---

## 不变量

### 1. 时间不变量

**不变量 5.1 (时间有序性)**:

\[
T \neq \emptyset \Rightarrow T \leq T_{obs}
\]

即：如果 Timestamp 存在，必须早于或等于 ObservedTimestamp。

**不变量 5.2 (ObservedTimestamp 非空)**:

\[
\forall LR \in \mathcal{LR}: T_{obs} \neq \emptyset
\]

即：所有 LogRecord 必须有 ObservedTimestamp。

### 2. 严重性不变量

**不变量 5.3 (SeverityNumber 范围)**:

\[
\forall LR \in \mathcal{LR}: S_n \in [0, 24]
\]

**不变量 5.4 (SeverityText 一致性)**:

\[
S_n \neq 0 \Rightarrow S_t = \text{Level}(S_n).\text{String}()
\]

即：如果 SeverityNumber 有效，SeverityText 应该对应。

### 3. 属性不变量

**不变量 5.5 (属性键唯一性)**:

\[
\forall (k_1, v_1), (k_2, v_2) \in A: k_1 = k_2 \Rightarrow (k_1, v_1) = (k_2, v_2)
\]

**不变量 5.6 (属性数量限制)**:

\[
|A| \leq \text{MaxAttributes}
\]

**不变量 5.7 (丢弃计数一致性)**:

\[
\text{DroppedAttributesCount} = \text{原始属性数量} - |A|
\]

---

## 正确性证明

### 1. 时间戳一致性

**定理 6.1 (时间戳一致性)**:

对于任意有效的 LogRecord，如果 Timestamp 存在，则：

\[
T \leq T_{obs}
\]

**证明**:

由有效性条件 (定义 2.2)：

\[
\text{Valid}(LR) \Rightarrow (T = \emptyset \lor T \leq T_{obs})
\]

如果 \( T \neq \emptyset \)，则必有 \( T \leq T_{obs} \)。∎

### 2. 严重性有序性

**定理 6.2 (严重性过滤正确性)**:

给定最小严重性 \( S_{min} \)，过滤后的 LogRecord 集合满足：

\[
\mathcal{LR}' = \{LR \in \mathcal{LR} \mid S_n \geq S_{min}\}
\]

则：

\[
\forall LR \in \mathcal{LR}': S_n \geq S_{min}
\]

**证明**:

由集合定义，\( \mathcal{LR}' \) 仅包含满足 \( S_n \geq S_{min} \) 的 LogRecord。

因此，\( \forall LR \in \mathcal{LR}': S_n \geq S_{min} \)。∎

### 3. 属性合并正确性

**定理 6.3 (属性合并幂等性)**:

\[
\forall A: A \oplus A = A
\]

**证明**:

\[
\begin{aligned}
A \oplus A &= \{(k, v) \mid (k, v) \in A \lor ((k, v) \in A \land k \notin \text{keys}(A))\} \\
&= \{(k, v) \mid (k, v) \in A \lor \text{false}\} \\
&= \{(k, v) \mid (k, v) \in A\} \\
&= A
\end{aligned}
\]

∎

**定理 6.4 (属性合并结合性)**:

\[
(A_1 \oplus A_2) \oplus A_3 = A_1 \oplus (A_2 \oplus A_3)
\]

**证明**:

对于任意键 \( k \)：

- 如果 \( k \in \text{keys}(A_1) \)，则：
  - 左侧: \( (A_1 \oplus A_2) \oplus A_3 \) 使用 \( A_1 \) 的值
  - 右侧: \( A_1 \oplus (A_2 \oplus A_3) \) 使用 \( A_1 \) 的值
  - 结果相同

- 如果 \( k \notin \text{keys}(A_1) \land k \in \text{keys}(A_2) \)，则：
  - 左侧: 使用 \( A_2 \) 的值
  - 右侧: 使用 \( A_2 \) 的值
  - 结果相同

- 如果 \( k \notin \text{keys}(A_1) \land k \notin \text{keys}(A_2) \)，则：
  - 左侧: 使用 \( A_3 \) 的值 (如果存在)
  - 右侧: 使用 \( A_3 \) 的值 (如果存在)
  - 结果相同

因此，结合性成立。∎

---

## 性能分析

### 1. 时间复杂度

**定理 7.1 (LogRecord 创建复杂度)**:

创建 LogRecord 的时间复杂度为：

\[
T_{\text{create}}(n) = O(n)
\]

其中 \( n = |A| \) 是属性数量。

**证明**:

```text
创建 LogRecord:
  设置字段:         O(1)
  复制 Attributes:  O(n)
  
总复杂度: O(n)  ✓
```

**定理 7.2 (属性合并复杂度)**:

合并两个属性集合的时间复杂度为：

\[
T_{\text{merge}}(n_1, n_2) = O(n_1 + n_2)
\]

**证明**:

```text
属性合并:
  遍历 A₁:  O(n₁)
  遍历 A₂:  O(n₂)
  
总复杂度: O(n₁ + n₂)  ✓
```

**定理 7.3 (严重性比较复杂度)**:

比较两个 SeverityNumber 的时间复杂度为：

\[
T_{\text{compare}} = O(1)
\]

**证明**: 整数比较为常数时间操作。∎

### 2. 空间复杂度

**定理 7.4 (LogRecord 空间复杂度)**:

LogRecord 的空间复杂度为：

\[
S_{\text{LR}}(n, m) = O(n + m)
\]

其中：

- \( n = |A| \): 属性数量
- \( m = |B| \): Body 大小

**证明**:

```text
LogRecord 存储:
  固定字段:        O(1)  (Timestamp, SeverityNumber, etc.)
  Body:            O(m)
  Attributes:      O(n)
  
总空间: O(n + m)  ✓
```

---

## TLA+ 规范

```tla
--------------------------- MODULE Logs ---------------------------
EXTENDS Naturals, Sequences, TLC

CONSTANTS MaxAttributes, MaxSeverity

VARIABLES 
    logs,           \* 日志序列
    observedTime    \* 观测时间

TypeInvariant ==
    /\ logs \in Seq([
        timestamp: Nat,
        observedTimestamp: Nat,
        severityNumber: 0..MaxSeverity,
        body: STRING,
        attributes: [STRING -> STRING]
    ])
    /\ observedTime \in Nat

Init ==
    /\ logs = <<>>
    /\ observedTime = 0

AddLog(timestamp, severity, body, attrs) ==
    /\ observedTime' = observedTime + 1
    /\ logs' = Append(logs, [
        timestamp |-> timestamp,
        observedTimestamp |-> observedTime',
        severityNumber |-> severity,
        body |-> body,
        attributes |-> attrs
    ])

\* 不变量：ObservedTimestamp 递增
ObservedTimestampMonotonic ==
    \A i, j \in DOMAIN logs:
        i < j => logs[i].observedTimestamp < logs[j].observedTimestamp

\* 不变量：Timestamp <= ObservedTimestamp
TimestampConsistency ==
    \A i \in DOMAIN logs:
        logs[i].timestamp <= logs[i].observedTimestamp

\* 不变量：SeverityNumber 范围
SeverityRange ==
    \A i \in DOMAIN logs:
        logs[i].severityNumber \in 0..MaxSeverity

\* 不变量：Attributes 数量限制
AttributesLimit ==
    \A i \in DOMAIN logs:
        Cardinality(DOMAIN logs[i].attributes) <= MaxAttributes

Spec == Init /\ [][AddLog]_<<logs, observedTime>>

THEOREM Spec => []TypeInvariant
THEOREM Spec => []ObservedTimestampMonotonic
THEOREM Spec => []TimestampConsistency
THEOREM Spec => []SeverityRange
THEOREM Spec => []AttributesLimit
=====================================================================
```

---

## Go 实现验证

### 1. 类型安全

```go
// Go 类型系统保证
type LogRecord struct {
    Timestamp         time.Time  // 自动类型检查
    ObservedTimestamp time.Time  // 必需字段
    SeverityNumber    SeverityNumber // 枚举类型
    Body              *AnyValue  // 类型安全的值
    Attributes        map[string]*AnyValue // 类型安全的属性
}

// 编译时检查
func NewLogRecord() *LogRecord {
    return &LogRecord{
        ObservedTimestamp: time.Now(), // 必需字段自动设置
        Attributes:        make(map[string]*AnyValue),
    }
}
```

### 2. 并发安全

```go
// 使用互斥锁保证并发安全
type SafeLogger struct {
    records []*LogRecord
    mu      sync.RWMutex
}

func (l *SafeLogger) Add(record *LogRecord) {
    l.mu.Lock()
    defer l.mu.Unlock()
    l.records = append(l.records, record)
}

func (l *SafeLogger) GetAll() []*LogRecord {
    l.mu.RLock()
    defer l.mu.RUnlock()
    
    // 返回副本，避免并发修改
    result := make([]*LogRecord, len(l.records))
    copy(result, l.records)
    return result
}

// 定理：并发安全性
// 多个 goroutine 同时调用 Add() 和 GetAll() 不会导致数据竞争
```

---

## 参考资源

- [OpenTelemetry Logs Data Model](https://opentelemetry.io/docs/specs/otel/logs/data-model/)
- [TLA+ Specification](https://lamport.azurewebsites.net/tla/tla.html)
- [01_LogRecord结构.md](./01_LogRecord结构.md)
- [02_SeverityNumber.md](./02_SeverityNumber.md)
- [03_Body与Attributes.md](./03_Body与Attributes.md)

---

**🎉 恭喜！你已经完成了 Logs 数据模型的形式化定义！**

本文档提供了：

- ✅ 完整的数学定义
- ✅ 严格的不变量分析
- ✅ 正确性证明
- ✅ 性能复杂度分析
- ✅ TLA+ 形式化规范
- ✅ Go 实现验证

**Phase 3.3: Logs 数据模型 全部完成！** 🎊
