# æ ‡ç­¾å®Œæ•´æŒ‡å—

## ğŸ“‹ ç›®å½•

- [æ ‡ç­¾å®Œæ•´æŒ‡å—](#æ ‡ç­¾å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
    - [æ ‡ç­¾çš„é‡è¦æ€§](#æ ‡ç­¾çš„é‡è¦æ€§)
  - [Attributes (å±æ€§)](#attributes-å±æ€§)
    - [æ•°æ®ç»“æ„](#æ•°æ®ç»“æ„)
    - [å±æ€§ç±»å‹](#å±æ€§ç±»å‹)
    - [Go å®ç°](#go-å®ç°)
    - [å‘½åçº¦å®š](#å‘½åçº¦å®š)
  - [åŸºæ•°é—®é¢˜](#åŸºæ•°é—®é¢˜)
    - [ä»€ä¹ˆæ˜¯åŸºæ•°](#ä»€ä¹ˆæ˜¯åŸºæ•°)
    - [é«˜åŸºæ•°çš„å½±å“](#é«˜åŸºæ•°çš„å½±å“)
    - [åŸºæ•°æ§åˆ¶ç­–ç•¥](#åŸºæ•°æ§åˆ¶ç­–ç•¥)
    - [Go å®ç°2](#go-å®ç°2)
  - [å±æ€§ç®¡ç†](#å±æ€§ç®¡ç†)
    - [å±æ€§ç¼“å­˜](#å±æ€§ç¼“å­˜)
    - [å±æ€§æ± åŒ–](#å±æ€§æ± åŒ–)
    - [å±æ€§å»é‡](#å±æ€§å»é‡)
    - [Go å®ç°3](#go-å®ç°3)
  - [Exemplar (ç¤ºä¾‹å€¼)](#exemplar-ç¤ºä¾‹å€¼)
    - [å®šä¹‰](#å®šä¹‰)
    - [æ•°æ®ç»“æ„2](#æ•°æ®ç»“æ„2)
    - [å…³è”æœºåˆ¶](#å…³è”æœºåˆ¶)
    - [Go å®ç°4](#go-å®ç°4)
  - [Exemplar é‡‡æ ·](#exemplar-é‡‡æ ·)
    - [é‡‡æ ·ç­–ç•¥](#é‡‡æ ·ç­–ç•¥)
    - [å§‹ç»ˆé‡‡æ ·](#å§‹ç»ˆé‡‡æ ·)
    - [æ¦‚ç‡é‡‡æ ·](#æ¦‚ç‡é‡‡æ ·)
    - [å¼‚å¸¸å€¼é‡‡æ ·](#å¼‚å¸¸å€¼é‡‡æ ·)
    - [æ—¶é—´çª—å£é‡‡æ ·](#æ—¶é—´çª—å£é‡‡æ ·)
    - [Go å®ç°5](#go-å®ç°5)
  - [Metrics-Traces å…³è”](#metrics-traces-å…³è”)
    - [å…³è”åœºæ™¯](#å…³è”åœºæ™¯)
    - [å®ç°åŸç†](#å®ç°åŸç†)
    - [å¯è§†åŒ–é›†æˆ](#å¯è§†åŒ–é›†æˆ)
    - [Go å®Œæ•´å®ç°](#go-å®Œæ•´å®ç°)
  - [å±æ€§è¿‡æ»¤ä¸è½¬æ¢](#å±æ€§è¿‡æ»¤ä¸è½¬æ¢)
    - [è¿‡æ»¤ç­–ç•¥](#è¿‡æ»¤ç­–ç•¥)
    - [è½¬æ¢ç­–ç•¥](#è½¬æ¢ç­–ç•¥)
    - [Go å®ç°6](#go-å®ç°6)
  - [å±æ€§èšåˆ](#å±æ€§èšåˆ)
    - [èšåˆç»´åº¦](#èšåˆç»´åº¦)
    - [åŠ¨æ€èšåˆ](#åŠ¨æ€èšåˆ)
    - [Go å®ç°7](#go-å®ç°7)
  - [å®Œæ•´å®ç°](#å®Œæ•´å®ç°)
    - [æ ‡ç­¾ç®¡ç†ç³»ç»Ÿ](#æ ‡ç­¾ç®¡ç†ç³»ç»Ÿ)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [1. é€‰æ‹©ä½åŸºæ•°æ ‡ç­¾](#1-é€‰æ‹©ä½åŸºæ•°æ ‡ç­¾)
    - [2. æ ‡å‡†åŒ–å‘½å](#2-æ ‡å‡†åŒ–å‘½å)
    - [3. åˆç†çš„ Exemplar é‡‡æ ·](#3-åˆç†çš„-exemplar-é‡‡æ ·)
    - [4. å±æ€§å¤ç”¨](#4-å±æ€§å¤ç”¨)
  - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
    - [1. é¢„åˆ†é…](#1-é¢„åˆ†é…)
    - [2. å­—ç¬¦ä¸²å†…è”](#2-å­—ç¬¦ä¸²å†…è”)
    - [3. æ‰¹é‡æ“ä½œ](#3-æ‰¹é‡æ“ä½œ)
  - [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)
    - [Q1: å¦‚ä½•åˆ¤æ–­æ ‡ç­¾åŸºæ•°æ˜¯å¦è¿‡é«˜ï¼Ÿ](#q1-å¦‚ä½•åˆ¤æ–­æ ‡ç­¾åŸºæ•°æ˜¯å¦è¿‡é«˜)
    - [Q2: Exemplar é‡‡æ ·ç‡å¦‚ä½•è®¾ç½®ï¼Ÿ](#q2-exemplar-é‡‡æ ·ç‡å¦‚ä½•è®¾ç½®)
    - [Q3: å¦‚ä½•å¤„ç†åŠ¨æ€æ ‡ç­¾ï¼Ÿ](#q3-å¦‚ä½•å¤„ç†åŠ¨æ€æ ‡ç­¾)
    - [Q4: å±æ€§ç¼“å­˜ä¼šå ç”¨å¤šå°‘å†…å­˜ï¼Ÿ](#q4-å±æ€§ç¼“å­˜ä¼šå ç”¨å¤šå°‘å†…å­˜)
    - [Q5: å¦‚ä½•åœ¨ Grafana ä¸­ä½¿ç”¨ Exemplarï¼Ÿ](#q5-å¦‚ä½•åœ¨-grafana-ä¸­ä½¿ç”¨-exemplar)
  - [å‚è€ƒèµ„æº](#å‚è€ƒèµ„æº)
    - [å®˜æ–¹æ–‡æ¡£](#å®˜æ–¹æ–‡æ¡£)
    - [Go å®ç°8](#go-å®ç°8)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)

---

## æ¦‚è¿°

**æ ‡ç­¾ (Labels)** æ˜¯æ—¶é—´åºåˆ—çš„å…³é”®ç»´åº¦ï¼Œç”¨äºåŒºåˆ†å’Œè¿‡æ»¤ä¸åŒçš„åº¦é‡æ•°æ®ã€‚åœ¨ OpenTelemetry ä¸­ï¼Œæ ‡ç­¾ä¸»è¦é€šè¿‡ **Attributes** å’Œ **Exemplar** å®ç°ã€‚

### æ ¸å¿ƒæ¦‚å¿µ

- âœ… **Attributes**: æ•°æ®ç‚¹çš„ç»´åº¦æ ‡ç­¾
- âœ… **Exemplar**: å…³è” Metrics å’Œ Traces çš„æ¡¥æ¢
- âœ… **Cardinality**: æ ‡ç­¾ç»„åˆçš„æ•°é‡
- âœ… **Filtering**: æ ‡ç­¾è¿‡æ»¤å’Œè½¬æ¢

### æ ‡ç­¾çš„é‡è¦æ€§

```text
ä½œç”¨:
1. ç»´åº¦åŒºåˆ†: åŒºåˆ†ä¸åŒç±»å‹çš„æ•°æ®
2. è¿‡æ»¤æŸ¥è¯¢: æ”¯æŒçµæ´»çš„æŸ¥è¯¢
3. èšåˆåˆ†æ: æŒ‰ç»´åº¦èšåˆç»Ÿè®¡
4. å‘Šè­¦è§„åˆ™: åŸºäºæ ‡ç­¾é…ç½®å‘Šè­¦
5. Traces å…³è”: é€šè¿‡ Exemplar å…³è”è¿½è¸ª
```

---

## Attributes (å±æ€§)

### æ•°æ®ç»“æ„

```protobuf
message KeyValue {
  string key = 1;
  AnyValue value = 2;
}

message AnyValue {
  oneof value {
    string string_value = 1;
    bool bool_value = 2;
    int64 int_value = 3;
    double double_value = 4;
    ArrayValue array_value = 5;
    KeyValueList kvlist_value = 6;
    bytes bytes_value = 7;
  }
}
```

### å±æ€§ç±»å‹

```go
import "go.opentelemetry.io/otel/attribute"

// 1. å­—ç¬¦ä¸²ç±»å‹
attr1 := attribute.String("http.method", "GET")

// 2. æ•´æ•°ç±»å‹
attr2 := attribute.Int("http.status_code", 200)

// 3. æµ®ç‚¹æ•°ç±»å‹
attr3 := attribute.Float64("http.response_time", 0.125)

// 4. å¸ƒå°”ç±»å‹
attr4 := attribute.Bool("http.compressed", true)

// 5. æ•°ç»„ç±»å‹
attr5 := attribute.StringSlice("http.headers", []string{"Accept", "Content-Type"})

// 6. æ•´æ•°æ•°ç»„
attr6 := attribute.IntSlice("response.codes", []int{200, 201, 202})
```

### Go å®ç°

```go
package attributes

import (
    "go.opentelemetry.io/otel/attribute"
)

// åˆ›å»ºå±æ€§é›†
func createAttributeSet() attribute.Set {
    attrs := []attribute.KeyValue{
        attribute.String("service.name", "my-service"),
        attribute.String("service.version", "1.0.0"),
        attribute.String("deployment.environment", "production"),
        attribute.String("http.method", "GET"),
        attribute.String("http.route", "/api/users"),
        attribute.Int("http.status_code", 200),
    }
    
    return attribute.NewSet(attrs...)
}

// é¢„å®šä¹‰å±æ€§é”®
var (
    // æœåŠ¡å±æ€§
    ServiceName    = attribute.Key("service.name")
    ServiceVersion = attribute.Key("service.version")
    
    // HTTP å±æ€§
    HTTPMethod     = attribute.Key("http.method")
    HTTPRoute      = attribute.Key("http.route")
    HTTPStatusCode = attribute.Key("http.status_code")
    
    // æ•°æ®åº“å±æ€§
    DBSystem    = attribute.Key("db.system")
    DBName      = attribute.Key("db.name")
    DBOperation = attribute.Key("db.operation")
)

// ä½¿ç”¨é¢„å®šä¹‰é”®
func usePreDefinedKeys() attribute.Set {
    return attribute.NewSet(
        ServiceName.String("my-service"),
        ServiceVersion.String("1.0.0"),
        HTTPMethod.String("GET"),
        HTTPRoute.String("/api/users"),
        HTTPStatusCode.Int(200),
    )
}

// å±æ€§åˆå¹¶
func mergeAttributes(base, additional []attribute.KeyValue) []attribute.KeyValue {
    result := make([]attribute.KeyValue, 0, len(base)+len(additional))
    result = append(result, base...)
    result = append(result, additional...)
    return result
}

// ç¤ºä¾‹ï¼šåˆ†å±‚å±æ€§
func createLayeredAttributes() attribute.Set {
    // å…¨å±€å±æ€§
    global := []attribute.KeyValue{
        attribute.String("service.name", "my-service"),
        attribute.String("deployment.environment", "production"),
    }
    
    // è¯·æ±‚çº§å±æ€§
    request := []attribute.KeyValue{
        attribute.String("http.method", "GET"),
        attribute.String("http.route", "/api/users"),
    }
    
    // åˆå¹¶
    all := mergeAttributes(global, request)
    return attribute.NewSet(all...)
}
```

### å‘½åçº¦å®š

```go
// âœ… æ¨èçš„å‘½åçº¦å®š
const (
    // ä½¿ç”¨ç‚¹åˆ†éš”çš„å±‚çº§ç»“æ„
    "service.name"
    "service.version"
    "deployment.environment"
    
    // HTTP ç›¸å…³
    "http.method"
    "http.route"
    "http.status_code"
    "http.request.body.size"
    "http.response.body.size"
    
    // æ•°æ®åº“ç›¸å…³
    "db.system"
    "db.name"
    "db.operation"
    "db.statement"
    
    // æ¶ˆæ¯é˜Ÿåˆ—
    "messaging.system"
    "messaging.destination"
    "messaging.operation"
)

// âŒ é¿å…çš„å‘½å
const (
    // ä¸è¦ä½¿ç”¨ä¸‹åˆ’çº¿
    "http_method"  // âŒ
    
    // ä¸è¦ä½¿ç”¨é©¼å³°
    "httpMethod"   // âŒ
    
    // ä¸è¦ä½¿ç”¨å¤§å†™
    "HTTP.METHOD"  // âŒ
)
```

---

## åŸºæ•°é—®é¢˜

### ä»€ä¹ˆæ˜¯åŸºæ•°

**åŸºæ•° (Cardinality)** æ˜¯æ ‡ç­¾ç»„åˆçš„å”¯ä¸€å€¼æ•°é‡ã€‚

```text
ç¤ºä¾‹:
http.method: [GET, POST, PUT, DELETE]           â†’ 4 ä¸ªå€¼
http.status_code: [200, 201, 400, 404, 500]    â†’ 5 ä¸ªå€¼

ç»„åˆåŸºæ•°: 4 Ã— 5 = 20 ä¸ªæ—¶é—´åºåˆ—
```

### é«˜åŸºæ•°çš„å½±å“

```text
é—®é¢˜:
1. å†…å­˜æ¶ˆè€—: æ¯ä¸ªæ—¶é—´åºåˆ—å ç”¨å†…å­˜
2. æŸ¥è¯¢æ€§èƒ½: éœ€è¦æ‰«ææ›´å¤šæ•°æ®
3. å­˜å‚¨æˆæœ¬: å­˜å‚¨ç©ºé—´å¢åŠ 
4. ç´¢å¼•å‹åŠ›: ç´¢å¼•å¤§å°å¢é•¿

ç¤ºä¾‹:
ä½åŸºæ•°:  http.method + http.status_code          â†’ 20 ä¸ªåºåˆ— âœ…
é«˜åŸºæ•°:  user.id (100ä¸‡ç”¨æˆ·)                      â†’ 100ä¸‡åºåˆ— âŒ
è¶…é«˜åŸºæ•°: request.id (æ¯ä¸ªè¯·æ±‚å”¯ä¸€)                â†’ æ— é™åºåˆ— âŒ
```

### åŸºæ•°æ§åˆ¶ç­–ç•¥

```go
// 1. ä½¿ç”¨å›ºå®šå€¼é›†åˆ
var allowedHTTPMethods = map[string]bool{
    "GET":    true,
    "POST":   true,
    "PUT":    true,
    "DELETE": true,
    "PATCH":  true,
}

func normalizeHTTPMethod(method string) string {
    if allowedHTTPMethods[method] {
        return method
    }
    return "OTHER"  // æœªçŸ¥æ–¹æ³•å½’ç±»ä¸º OTHER
}

// 2. çŠ¶æ€ç åˆ†ç»„
func groupStatusCode(code int) string {
    switch {
    case code >= 200 && code < 300:
        return "2xx"
    case code >= 300 && code < 400:
        return "3xx"
    case code >= 400 && code < 500:
        return "4xx"
    case code >= 500 && code < 600:
        return "5xx"
    default:
        return "unknown"
    }
}

// 3. ç”¨æˆ· ID å“ˆå¸Œåˆ†æ¡¶
func hashUserID(userID string, numBuckets int) int {
    import "hash/fnv"
    
    h := fnv.New32a()
    h.Write([]byte(userID))
    return int(h.Sum32()) % numBuckets
}

func getUserBucket(userID string) string {
    bucket := hashUserID(userID, 100)
    return fmt.Sprintf("bucket_%d", bucket)
}

// 4. è·¯å¾„æ¨¡æ¿åŒ–
func templatizePath(path string) string {
    // /api/users/123 â†’ /api/users/{id}
    // /api/orders/456 â†’ /api/orders/{id}
    
    import "regexp"
    
    // æ›¿æ¢æ•°å­— ID
    re := regexp.MustCompile(`/\d+`)
    return re.ReplaceAllString(path, "/{id}")
}
```

### Go å®ç°2

```go
// åŸºæ•°ç›‘æ§å™¨
type CardinalityMonitor struct {
    seriesCount map[string]int
    maxCardinality int
    mu sync.RWMutex
}

func NewCardinalityMonitor(maxCardinality int) *CardinalityMonitor {
    return &CardinalityMonitor{
        seriesCount: make(map[string]int),
        maxCardinality: maxCardinality,
    }
}

// æ£€æŸ¥åŸºæ•°
func (cm *CardinalityMonitor) CheckCardinality(
    attrs []attribute.KeyValue,
) error {
    cm.mu.Lock()
    defer cm.mu.Unlock()
    
    // ç”Ÿæˆåºåˆ—é”®
    key := cm.makeSeriesKey(attrs)
    
    if _, exists := cm.seriesCount[key]; !exists {
        if len(cm.seriesCount) >= cm.maxCardinality {
            return fmt.Errorf(
                "cardinality limit exceeded: %d",
                cm.maxCardinality,
            )
        }
        cm.seriesCount[key] = 0
    }
    
    cm.seriesCount[key]++
    return nil
}

func (cm *CardinalityMonitor) makeSeriesKey(
    attrs []attribute.KeyValue,
) string {
    import "sort"
    import "strings"
    
    // æ’åºå±æ€§ä»¥ç¡®ä¿ä¸€è‡´æ€§
    sorted := make([]string, len(attrs))
    for i, attr := range attrs {
        sorted[i] = fmt.Sprintf("%s=%s", attr.Key, attr.Value.AsString())
    }
    sort.Strings(sorted)
    
    return strings.Join(sorted, ",")
}

// è·å–ç»Ÿè®¡ä¿¡æ¯
func (cm *CardinalityMonitor) GetStats() map[string]interface{} {
    cm.mu.RLock()
    defer cm.mu.RUnlock()
    
    return map[string]interface{}{
        "total_series":    len(cm.seriesCount),
        "max_cardinality": cm.maxCardinality,
        "utilization":     float64(len(cm.seriesCount)) / float64(cm.maxCardinality),
    }
}
```

---

## å±æ€§ç®¡ç†

### å±æ€§ç¼“å­˜

```go
// å±æ€§ç¼“å­˜
type AttributeCache struct {
    cache sync.Map  // map[string]attribute.Set
}

func NewAttributeCache() *AttributeCache {
    return &AttributeCache{}
}

// è·å–æˆ–åˆ›å»ºå±æ€§é›†
func (ac *AttributeCache) GetOrCreate(
    attrs []attribute.KeyValue,
) attribute.Set {
    key := ac.makeKey(attrs)
    
    if cached, ok := ac.cache.Load(key); ok {
        return cached.(attribute.Set)
    }
    
    set := attribute.NewSet(attrs...)
    ac.cache.Store(key, set)
    return set
}

func (ac *AttributeCache) makeKey(attrs []attribute.KeyValue) string {
    import "sort"
    import "strings"
    
    pairs := make([]string, len(attrs))
    for i, attr := range attrs {
        pairs[i] = fmt.Sprintf("%s=%v", attr.Key, attr.Value)
    }
    sort.Strings(pairs)
    return strings.Join(pairs, "|")
}

// æ¸…ç†ç¼“å­˜
func (ac *AttributeCache) Clear() {
    ac.cache = sync.Map{}
}
```

### å±æ€§æ± åŒ–

```go
// å±æ€§åˆ‡ç‰‡æ± 
var attributeSlicePool = sync.Pool{
    New: func() interface{} {
        slice := make([]attribute.KeyValue, 0, 10)
        return &slice
    },
}

// è·å–å±æ€§åˆ‡ç‰‡
func acquireAttributeSlice() *[]attribute.KeyValue {
    return attributeSlicePool.Get().(*[]attribute.KeyValue)
}

// é‡Šæ”¾å±æ€§åˆ‡ç‰‡
func releaseAttributeSlice(slice *[]attribute.KeyValue) {
    *slice = (*slice)[:0]
    attributeSlicePool.Put(slice)
}

// ä½¿ç”¨ç¤ºä¾‹
func useAttributePool() attribute.Set {
    attrs := acquireAttributeSlice()
    defer releaseAttributeSlice(attrs)
    
    *attrs = append(*attrs,
        attribute.String("http.method", "GET"),
        attribute.String("http.route", "/api/users"),
    )
    
    return attribute.NewSet(*attrs...)
}
```

### å±æ€§å»é‡

```go
// å±æ€§å»é‡å™¨
type AttributeDeduplicator struct {
    seen map[string]struct{}
}

func NewAttributeDeduplicator() *AttributeDeduplicator {
    return &AttributeDeduplicator{
        seen: make(map[string]struct{}),
    }
}

// å»é‡
func (ad *AttributeDeduplicator) Deduplicate(
    attrs []attribute.KeyValue,
) []attribute.KeyValue {
    result := make([]attribute.KeyValue, 0, len(attrs))
    
    for _, attr := range attrs {
        key := string(attr.Key)
        if _, exists := ad.seen[key]; !exists {
            result = append(result, attr)
            ad.seen[key] = struct{}{}
        }
    }
    
    return result
}
```

### Go å®ç°3

```go
// å®Œæ•´çš„å±æ€§ç®¡ç†å™¨
type AttributeManager struct {
    cache       *AttributeCache
    monitor     *CardinalityMonitor
    dedupe      *AttributeDeduplicator
    globalAttrs []attribute.KeyValue
    mu          sync.RWMutex
}

func NewAttributeManager(maxCardinality int) *AttributeManager {
    return &AttributeManager{
        cache:   NewAttributeCache(),
        monitor: NewCardinalityMonitor(maxCardinality),
        dedupe:  NewAttributeDeduplicator(),
    }
}

// è®¾ç½®å…¨å±€å±æ€§
func (am *AttributeManager) SetGlobalAttributes(attrs []attribute.KeyValue) {
    am.mu.Lock()
    am.globalAttrs = attrs
    am.mu.Unlock()
}

// åˆ›å»ºå±æ€§é›†
func (am *AttributeManager) CreateAttributeSet(
    attrs []attribute.KeyValue,
) (attribute.Set, error) {
    am.mu.RLock()
    global := am.globalAttrs
    am.mu.RUnlock()
    
    // åˆå¹¶å…¨å±€å±æ€§
    combined := make([]attribute.KeyValue, 0, len(global)+len(attrs))
    combined = append(combined, global...)
    combined = append(combined, attrs...)
    
    // å»é‡
    combined = am.dedupe.Deduplicate(combined)
    
    // æ£€æŸ¥åŸºæ•°
    if err := am.monitor.CheckCardinality(combined); err != nil {
        return attribute.Set{}, err
    }
    
    // ä»ç¼“å­˜è·å–
    return am.cache.GetOrCreate(combined), nil
}
```

---

## Exemplar (ç¤ºä¾‹å€¼)

### å®šä¹‰

**Exemplar** æ˜¯ä¸ Metric æ•°æ®ç‚¹å…³è”çš„ Trace é‡‡æ ·ï¼Œç”¨äºå°† Metrics å’Œ Traces å…³è”èµ·æ¥ã€‚

### æ•°æ®ç»“æ„2

```protobuf
message Exemplar {
  repeated KeyValue filtered_attributes = 7;
  fixed64 time_unix_nano = 2;
  
  oneof value {
    double as_double = 3;
    sfixed64 as_int = 6;
  }
  
  bytes span_id = 4;
  bytes trace_id = 5;
}
```

### å…³è”æœºåˆ¶

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Metrics (Histogram)                         â”‚
â”‚                                             â”‚
â”‚  http.server.request.duration               â”‚
â”‚  â”œâ”€ P50: 0.1s                               â”‚
â”‚  â”œâ”€ P95: 0.5s                               â”‚
â”‚  â”œâ”€ P99: 1.2s  â† Exemplar                   â”‚
â”‚  â”‚              trace_id: abc123            â”‚
â”‚  â”‚              span_id:  def456            â”‚
â”‚  â””â”€ ...                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â”‚ å…³è”
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Traces                                      â”‚
â”‚                                             â”‚
â”‚  Trace ID: abc123                           â”‚
â”‚  â”œâ”€ Span: def456 (HTTP GET /api/users)     â”‚
â”‚  â”‚  Duration: 1.2s                          â”‚
â”‚  â”‚  â”œâ”€ DB Query: 0.8s                       â”‚
â”‚  â”‚  â””â”€ External API: 0.3s                   â”‚
â”‚  â””â”€ ...                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Go å®ç°4

```go
import (
    "go.opentelemetry.io/otel/trace"
    "go.opentelemetry.io/otel/metric"
)

// åˆ›å»ºå¸¦ Exemplar çš„ Histogram è®°å½•
func recordWithExemplar(
    ctx context.Context,
    histogram metric.Float64Histogram,
) {
    // ä» Context è·å–å½“å‰ Span
    span := trace.SpanFromContext(ctx)
    spanContext := span.SpanContext()
    
    // è®°å½•åº¦é‡å€¼
    // SDK ä¼šè‡ªåŠ¨æå– TraceID å’Œ SpanID ä½œä¸º Exemplar
    start := time.Now()
    
    // å¤„ç†è¯·æ±‚...
    processRequest()
    
    duration := time.Since(start).Seconds()
    histogram.Record(ctx, duration,
        metric.WithAttributes(
            attribute.String("http.method", "GET"),
            attribute.String("http.route", "/api/users"),
        ),
    )
    
    // Exemplar è‡ªåŠ¨åŒ…å«:
    // - trace_id: spanContext.TraceID()
    // - span_id: spanContext.SpanID()
    // - value: duration
    // - time: è®°å½•æ—¶é—´
}

// æ‰‹åŠ¨åˆ›å»º Exemplar
type ExemplarData struct {
    TraceID   trace.TraceID
    SpanID    trace.SpanID
    Value     float64
    Timestamp time.Time
    Attributes []attribute.KeyValue
}

func createExemplar(
    ctx context.Context,
    value float64,
) *ExemplarData {
    span := trace.SpanFromContext(ctx)
    spanContext := span.SpanContext()
    
    return &ExemplarData{
        TraceID:   spanContext.TraceID(),
        SpanID:    spanContext.SpanID(),
        Value:     value,
        Timestamp: time.Now(),
    }
}
```

---

## Exemplar é‡‡æ ·

### é‡‡æ ·ç­–ç•¥

```text
1. AlwaysSample: å§‹ç»ˆé‡‡æ ·
2. ProbabilitySample: æ¦‚ç‡é‡‡æ ·
3. OutlierSample: å¼‚å¸¸å€¼é‡‡æ ·
4. TimeWindowSample: æ—¶é—´çª—å£é‡‡æ ·
5. BucketSample: æŒ‰æ¡¶é‡‡æ ·
```

### å§‹ç»ˆé‡‡æ ·

```go
// å§‹ç»ˆé‡‡æ ·
type AlwaysExemplarSampler struct{}

func (s AlwaysExemplarSampler) ShouldSample(
    value float64,
    attrs attribute.Set,
) bool {
    return true
}
```

### æ¦‚ç‡é‡‡æ ·

```go
// æ¦‚ç‡é‡‡æ ·
type ProbabilityExemplarSampler struct {
    Probability float64  // 0.0 ~ 1.0
}

func (s ProbabilityExemplarSampler) ShouldSample(
    value float64,
    attrs attribute.Set,
) bool {
    import "math/rand"
    return rand.Float64() < s.Probability
}
```

### å¼‚å¸¸å€¼é‡‡æ ·

```go
// å¼‚å¸¸å€¼é‡‡æ ·
type OutlierExemplarSampler struct {
    Threshold float64
}

func (s OutlierExemplarSampler) ShouldSample(
    value float64,
    attrs attribute.Set,
) bool {
    return value > s.Threshold
}

// è‡ªé€‚åº”å¼‚å¸¸å€¼é‡‡æ ·
type AdaptiveOutlierSampler struct {
    window     []float64
    windowSize int
    stddevMul  float64
    mu         sync.Mutex
}

func NewAdaptiveOutlierSampler(windowSize int, stddevMul float64) *AdaptiveOutlierSampler {
    return &AdaptiveOutlierSampler{
        window:     make([]float64, 0, windowSize),
        windowSize: windowSize,
        stddevMul:  stddevMul,
    }
}

func (s *AdaptiveOutlierSampler) ShouldSample(
    value float64,
    attrs attribute.Set,
) bool {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    // æ·»åŠ åˆ°çª—å£
    s.window = append(s.window, value)
    if len(s.window) > s.windowSize {
        s.window = s.window[1:]
    }
    
    if len(s.window) < 10 {
        return false
    }
    
    // è®¡ç®—å‡å€¼å’Œæ ‡å‡†å·®
    mean, stddev := s.calculateStats()
    
    // åˆ¤æ–­æ˜¯å¦å¼‚å¸¸å€¼
    return math.Abs(value-mean) > stddev*s.stddevMul
}

func (s *AdaptiveOutlierSampler) calculateStats() (mean, stddev float64) {
    import "math"
    
    // è®¡ç®—å‡å€¼
    var sum float64
    for _, v := range s.window {
        sum += v
    }
    mean = sum / float64(len(s.window))
    
    // è®¡ç®—æ ‡å‡†å·®
    var variance float64
    for _, v := range s.window {
        diff := v - mean
        variance += diff * diff
    }
    variance /= float64(len(s.window))
    stddev = math.Sqrt(variance)
    
    return mean, stddev
}
```

### æ—¶é—´çª—å£é‡‡æ ·

```go
// æ—¶é—´çª—å£é‡‡æ ·
type TimeWindowExemplarSampler struct {
    windowDuration time.Duration
    maxPerWindow   int
    lastReset      time.Time
    count          int
    mu             sync.Mutex
}

func NewTimeWindowExemplarSampler(
    windowDuration time.Duration,
    maxPerWindow int,
) *TimeWindowExemplarSampler {
    return &TimeWindowExemplarSampler{
        windowDuration: windowDuration,
        maxPerWindow:   maxPerWindow,
        lastReset:      time.Now(),
    }
}

func (s *TimeWindowExemplarSampler) ShouldSample(
    value float64,
    attrs attribute.Set,
) bool {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    now := time.Now()
    if now.Sub(s.lastReset) >= s.windowDuration {
        s.count = 0
        s.lastReset = now
    }
    
    if s.count < s.maxPerWindow {
        s.count++
        return true
    }
    
    return false
}
```

### Go å®ç°5

```go
// å¤åˆé‡‡æ ·å™¨
type CompositeExemplarSampler struct {
    samplers []ExemplarSampler
}

type ExemplarSampler interface {
    ShouldSample(value float64, attrs attribute.Set) bool
}

func NewCompositeExemplarSampler(samplers ...ExemplarSampler) *CompositeExemplarSampler {
    return &CompositeExemplarSampler{
        samplers: samplers,
    }
}

// ä»»ä¸€é‡‡æ ·å™¨é€šè¿‡åˆ™é€šè¿‡
func (s *CompositeExemplarSampler) ShouldSample(
    value float64,
    attrs attribute.Set,
) bool {
    for _, sampler := range s.samplers {
        if sampler.ShouldSample(value, attrs) {
            return true
        }
    }
    return false
}

// ä½¿ç”¨ç¤ºä¾‹
func setupExemplarSampling() ExemplarSampler {
    return NewCompositeExemplarSampler(
        // 1% æ¦‚ç‡é‡‡æ ·
        ProbabilityExemplarSampler{Probability: 0.01},
        
        // å¼‚å¸¸å€¼é‡‡æ · (> 1s)
        OutlierExemplarSampler{Threshold: 1.0},
        
        // æ—¶é—´çª—å£é‡‡æ · (æ¯åˆ†é’Ÿæœ€å¤š10ä¸ª)
        NewTimeWindowExemplarSampler(time.Minute, 10),
    )
}
```

---

## Metrics-Traces å…³è”

### å…³è”åœºæ™¯

```text
1. æ€§èƒ½å¼‚å¸¸æ’æŸ¥:
   Metrics å‘ç° P99 å»¶è¿Ÿçªå¢
   â†’ é€šè¿‡ Exemplar æ‰¾åˆ°æ…¢è¯·æ±‚çš„ Trace
   â†’ åˆ†æ Trace æ‰¾åˆ°æ€§èƒ½ç“¶é¢ˆ

2. é”™è¯¯åˆ†æ:
   Metrics å‘ç°é”™è¯¯ç‡ä¸Šå‡
   â†’ é€šè¿‡ Exemplar æ‰¾åˆ°å¤±è´¥è¯·æ±‚çš„ Trace
   â†’ åˆ†æ Trace å®šä½é”™è¯¯åŸå› 

3. å®¹é‡è§„åˆ’:
   Metrics å‘ç°èµ„æºä½¿ç”¨ç‡é«˜
   â†’ é€šè¿‡ Exemplar æ‰¾åˆ°å…¸å‹è¯·æ±‚çš„ Trace
   â†’ åˆ†æ Trace ä¼˜åŒ–èµ„æºä½¿ç”¨
```

### å®ç°åŸç†

```go
// Exemplar è‡ªåŠ¨æ³¨å…¥
func autoInjectExemplar(
    ctx context.Context,
    histogram metric.Float64Histogram,
    value float64,
    sampler ExemplarSampler,
) {
    // æ£€æŸ¥æ˜¯å¦åº”è¯¥é‡‡æ ·
    attrs := attribute.EmptySet()
    if !sampler.ShouldSample(value, attrs) {
        // ä¸é‡‡æ ·ï¼Œä»…è®°å½•å€¼
        histogram.Record(ctx, value)
        return
    }
    
    // é‡‡æ ·ï¼šè®°å½•å€¼ + Exemplar
    // SDK ä¼šè‡ªåŠ¨ä» Context æå– TraceID/SpanID
    histogram.Record(ctx, value,
        metric.WithAttributes(
            attribute.String("http.method", "GET"),
        ),
    )
}

// å®Œæ•´çš„ HTTP è¿½è¸ªç¤ºä¾‹
func traceHTTPRequest(
    w http.ResponseWriter,
    r *http.Request,
    tracer trace.Tracer,
    histogram metric.Float64Histogram,
) {
    // 1. åˆ›å»º Span
    ctx, span := tracer.Start(r.Context(), "HTTP "+r.Method)
    defer span.End()
    
    // 2. è®°å½•å¼€å§‹æ—¶é—´
    start := time.Now()
    
    // 3. å¤„ç†è¯·æ±‚
    statusCode := processHTTPRequest(ctx, w, r)
    
    // 4. è®°å½•å»¶è¿Ÿ (è‡ªåŠ¨å…³è” Exemplar)
    duration := time.Since(start).Seconds()
    histogram.Record(ctx, duration,
        metric.WithAttributes(
            attribute.String("http.method", r.Method),
            attribute.String("http.route", r.URL.Path),
            attribute.Int("http.status_code", statusCode),
        ),
    )
    
    // SDK è‡ªåŠ¨åˆ›å»º Exemplar:
    // {
    //   trace_id: span.SpanContext().TraceID(),
    //   span_id:  span.SpanContext().SpanID(),
    //   value:    duration,
    //   time:     time.Now(),
    // }
}
```

### å¯è§†åŒ–é›†æˆ

```text
Grafana ä¸­ä½¿ç”¨ Exemplar:

1. é…ç½® Prometheus æ•°æ®æº
   å¯ç”¨ Exemplar æ”¯æŒ

2. åœ¨ Histogram é¢æ¿ä¸­æ˜¾ç¤º Exemplar
   Query: histogram_quantile(0.99, 
          rate(http_request_duration_seconds_bucket[5m]))

3. ç‚¹å‡» Exemplar ç‚¹
   â†’ è·³è½¬åˆ° Jaeger/Tempo
   â†’ æŸ¥çœ‹å¯¹åº”çš„ Trace

4. åˆ†ææ…¢è¯·æ±‚
   â†’ æ‰¾åˆ°æ€§èƒ½ç“¶é¢ˆ
   â†’ ä¼˜åŒ–ä»£ç 
```

### Go å®Œæ•´å®ç°

```go
// HTTP æœåŠ¡å™¨ with Metrics-Traces å…³è”
func setupHTTPServer() {
    // 1. åˆå§‹åŒ– Tracer
    tracer := otel.Tracer("my-service")
    
    // 2. åˆå§‹åŒ– Meter
    meter := otel.Meter("my-service")
    
    // 3. åˆ›å»º Histogram
    histogram, _ := meter.Float64Histogram(
        "http.server.request.duration",
        metric.WithDescription("HTTP request duration"),
        metric.WithUnit("s"),
    )
    
    // 4. é…ç½® Exemplar é‡‡æ ·
    sampler := setupExemplarSampling()
    
    // 5. HTTP Handler
    http.HandleFunc("/api/users", func(w http.ResponseWriter, r *http.Request) {
        // åˆ›å»º Span
        ctx, span := tracer.Start(r.Context(), "GET /api/users")
        defer span.End()
        
        start := time.Now()
        
        // å¤„ç†è¯·æ±‚
        users := getUsersFromDB(ctx)
        json.NewEncoder(w).Encode(users)
        
        // è®°å½•å»¶è¿Ÿ with Exemplar
        duration := time.Since(start).Seconds()
        if sampler.ShouldSample(duration, attribute.EmptySet()) {
            histogram.Record(ctx, duration,
                metric.WithAttributes(
                    attribute.String("http.method", r.Method),
                    attribute.String("http.route", "/api/users"),
                    attribute.Int("http.status_code", 200),
                ),
            )
        }
    })
    
    http.ListenAndServe(":8080", nil)
}
```

---

## å±æ€§è¿‡æ»¤ä¸è½¬æ¢

### è¿‡æ»¤ç­–ç•¥

```go
// å±æ€§è¿‡æ»¤å™¨
type AttributeFilter interface {
    Filter(attrs []attribute.KeyValue) []attribute.KeyValue
}

// 1. ç™½åå•è¿‡æ»¤
type WhitelistFilter struct {
    allowed map[attribute.Key]bool
}

func NewWhitelistFilter(keys []attribute.Key) *WhitelistFilter {
    allowed := make(map[attribute.Key]bool)
    for _, key := range keys {
        allowed[key] = true
    }
    return &WhitelistFilter{allowed: allowed}
}

func (f *WhitelistFilter) Filter(attrs []attribute.KeyValue) []attribute.KeyValue {
    result := make([]attribute.KeyValue, 0, len(attrs))
    for _, attr := range attrs {
        if f.allowed[attr.Key] {
            result = append(result, attr)
        }
    }
    return result
}

// 2. é»‘åå•è¿‡æ»¤
type BlacklistFilter struct {
    blocked map[attribute.Key]bool
}

func NewBlacklistFilter(keys []attribute.Key) *BlacklistFilter {
    blocked := make(map[attribute.Key]bool)
    for _, key := range keys {
        blocked[key] = true
    }
    return &BlacklistFilter{blocked: blocked}
}

func (f *BlacklistFilter) Filter(attrs []attribute.KeyValue) []attribute.KeyValue {
    result := make([]attribute.KeyValue, 0, len(attrs))
    for _, attr := range attrs {
        if !f.blocked[attr.Key] {
            result = append(result, attr)
        }
    }
    return result
}

// 3. æ­£åˆ™è¿‡æ»¤
type RegexFilter struct {
    pattern *regexp.Regexp
    include bool
}

func NewRegexFilter(pattern string, include bool) (*RegexFilter, error) {
    re, err := regexp.Compile(pattern)
    if err != nil {
        return nil, err
    }
    return &RegexFilter{
        pattern: re,
        include: include,
    }, nil
}

func (f *RegexFilter) Filter(attrs []attribute.KeyValue) []attribute.KeyValue {
    result := make([]attribute.KeyValue, 0, len(attrs))
    for _, attr := range attrs {
        matches := f.pattern.MatchString(string(attr.Key))
        if (matches && f.include) || (!matches && !f.include) {
            result = append(result, attr)
        }
    }
    return result
}
```

### è½¬æ¢ç­–ç•¥

```go
// å±æ€§è½¬æ¢å™¨
type AttributeTransformer interface {
    Transform(attrs []attribute.KeyValue) []attribute.KeyValue
}

// 1. é‡å‘½å
type RenameTransformer struct {
    mapping map[attribute.Key]attribute.Key
}

func NewRenameTransformer(mapping map[attribute.Key]attribute.Key) *RenameTransformer {
    return &RenameTransformer{mapping: mapping}
}

func (t *RenameTransformer) Transform(attrs []attribute.KeyValue) []attribute.KeyValue {
    result := make([]attribute.KeyValue, len(attrs))
    for i, attr := range attrs {
        if newKey, exists := t.mapping[attr.Key]; exists {
            result[i] = attribute.KeyValue{
                Key:   newKey,
                Value: attr.Value,
            }
        } else {
            result[i] = attr
        }
    }
    return result
}

// 2. å€¼è½¬æ¢
type ValueTransformer struct {
    key       attribute.Key
    transform func(attribute.Value) attribute.Value
}

func NewValueTransformer(
    key attribute.Key,
    transform func(attribute.Value) attribute.Value,
) *ValueTransformer {
    return &ValueTransformer{
        key:       key,
        transform: transform,
    }
}

func (t *ValueTransformer) Transform(attrs []attribute.KeyValue) []attribute.KeyValue {
    result := make([]attribute.KeyValue, len(attrs))
    for i, attr := range attrs {
        if attr.Key == t.key {
            result[i] = attribute.KeyValue{
                Key:   attr.Key,
                Value: t.transform(attr.Value),
            }
        } else {
            result[i] = attr
        }
    }
    return result
}

// 3. æ·»åŠ å‰ç¼€
type PrefixTransformer struct {
    prefix string
}

func NewPrefixTransformer(prefix string) *PrefixTransformer {
    return &PrefixTransformer{prefix: prefix}
}

func (t *PrefixTransformer) Transform(attrs []attribute.KeyValue) []attribute.KeyValue {
    result := make([]attribute.KeyValue, len(attrs))
    for i, attr := range attrs {
        newKey := attribute.Key(t.prefix + string(attr.Key))
        result[i] = attribute.KeyValue{
            Key:   newKey,
            Value: attr.Value,
        }
    }
    return result
}
```

### Go å®ç°6

```go
// å±æ€§å¤„ç†ç®¡é“
type AttributePipeline struct {
    filters      []AttributeFilter
    transformers []AttributeTransformer
}

func NewAttributePipeline() *AttributePipeline {
    return &AttributePipeline{
        filters:      make([]AttributeFilter, 0),
        transformers: make([]AttributeTransformer, 0),
    }
}

func (ap *AttributePipeline) AddFilter(filter AttributeFilter) {
    ap.filters = append(ap.filters, filter)
}

func (ap *AttributePipeline) AddTransformer(transformer AttributeTransformer) {
    ap.transformers = append(ap.transformers, transformer)
}

func (ap *AttributePipeline) Process(attrs []attribute.KeyValue) []attribute.KeyValue {
    result := attrs
    
    // åº”ç”¨è¿‡æ»¤å™¨
    for _, filter := range ap.filters {
        result = filter.Filter(result)
    }
    
    // åº”ç”¨è½¬æ¢å™¨
    for _, transformer := range ap.transformers {
        result = transformer.Transform(result)
    }
    
    return result
}

// ä½¿ç”¨ç¤ºä¾‹
func setupAttributePipeline() *AttributePipeline {
    pipeline := NewAttributePipeline()
    
    // 1. è¿‡æ»¤æ•æ„Ÿå±æ€§
    pipeline.AddFilter(NewBlacklistFilter([]attribute.Key{
        attribute.Key("user.password"),
        attribute.Key("credit.card"),
    }))
    
    // 2. é‡å‘½åå±æ€§
    pipeline.AddTransformer(NewRenameTransformer(map[attribute.Key]attribute.Key{
        attribute.Key("method"): attribute.Key("http.method"),
        attribute.Key("code"):   attribute.Key("http.status_code"),
    }))
    
    // 3. æ·»åŠ å‰ç¼€
    pipeline.AddTransformer(NewPrefixTransformer("app."))
    
    return pipeline
}
```

---

## å±æ€§èšåˆ

### èšåˆç»´åº¦

```go
// å±æ€§èšåˆå™¨
type AttributeAggregator struct {
    groupByKeys []attribute.Key
}

func NewAttributeAggregator(groupByKeys []attribute.Key) *AttributeAggregator {
    return &AttributeAggregator{
        groupByKeys: groupByKeys,
    }
}

// ç”Ÿæˆèšåˆé”®
func (aa *AttributeAggregator) AggregationKey(
    attrs []attribute.KeyValue,
) string {
    import "sort"
    import "strings"
    
    values := make([]string, 0, len(aa.groupByKeys))
    
    // æå–åˆ†ç»„é”®çš„å€¼
    attrMap := make(map[attribute.Key]attribute.Value)
    for _, attr := range attrs {
        attrMap[attr.Key] = attr.Value
    }
    
    for _, key := range aa.groupByKeys {
        if value, exists := attrMap[key]; exists {
            values = append(values, value.AsString())
        } else {
            values = append(values, "")
        }
    }
    
    return strings.Join(values, "|")
}

// ç¤ºä¾‹ï¼šæŒ‰ http.method å’Œ http.status_code èšåˆ
func exampleAggregation() {
    aggregator := NewAttributeAggregator([]attribute.Key{
        attribute.Key("http.method"),
        attribute.Key("http.status_code"),
    })
    
    attrs1 := []attribute.KeyValue{
        attribute.String("http.method", "GET"),
        attribute.Int("http.status_code", 200),
        attribute.String("http.route", "/api/users"),
    }
    
    attrs2 := []attribute.KeyValue{
        attribute.String("http.method", "GET"),
        attribute.Int("http.status_code", 200),
        attribute.String("http.route", "/api/orders"),
    }
    
    key1 := aggregator.AggregationKey(attrs1)  // "GET|200"
    key2 := aggregator.AggregationKey(attrs2)  // "GET|200"
    
    // key1 == key2ï¼Œä¸¤ä¸ªè¯·æ±‚ä¼šèšåˆåˆ°åŒä¸€ä¸ªæ—¶é—´åºåˆ—
}
```

### åŠ¨æ€èšåˆ

```go
// åŠ¨æ€èšåˆé…ç½®
type DynamicAggregationConfig struct {
    rules []AggregationRule
}

type AggregationRule struct {
    Matcher   func([]attribute.KeyValue) bool
    GroupByKeys []attribute.Key
}

func (dac *DynamicAggregationConfig) GetGroupByKeys(
    attrs []attribute.KeyValue,
) []attribute.Key {
    for _, rule := range dac.rules {
        if rule.Matcher(attrs) {
            return rule.GroupByKeys
        }
    }
    return nil
}

// ç¤ºä¾‹ï¼šæ ¹æ®è·¯ç”±å‰ç¼€ä½¿ç”¨ä¸åŒçš„èšåˆé”®
func setupDynamicAggregation() *DynamicAggregationConfig {
    return &DynamicAggregationConfig{
        rules: []AggregationRule{
            {
                // /api/* è·¯ç”±ï¼šæŒ‰ method + status_code èšåˆ
                Matcher: func(attrs []attribute.KeyValue) bool {
                    for _, attr := range attrs {
                        if attr.Key == "http.route" {
                            route := attr.Value.AsString()
                            return strings.HasPrefix(route, "/api/")
                        }
                    }
                    return false
                },
                GroupByKeys: []attribute.Key{
                    attribute.Key("http.method"),
                    attribute.Key("http.status_code"),
                },
            },
            {
                // /admin/* è·¯ç”±ï¼šæŒ‰ method + status_code + route èšåˆ
                Matcher: func(attrs []attribute.KeyValue) bool {
                    for _, attr := range attrs {
                        if attr.Key == "http.route" {
                            route := attr.Value.AsString()
                            return strings.HasPrefix(route, "/admin/")
                        }
                    }
                    return false
                },
                GroupByKeys: []attribute.Key{
                    attribute.Key("http.method"),
                    attribute.Key("http.status_code"),
                    attribute.Key("http.route"),
                },
            },
        },
    }
}
```

### Go å®ç°7

```go
// æ™ºèƒ½èšåˆå™¨
type SmartAggregator struct {
    config *DynamicAggregationConfig
    cache  sync.Map  // map[string][]attribute.Key
}

func NewSmartAggregator(config *DynamicAggregationConfig) *SmartAggregator {
    return &SmartAggregator{
        config: config,
    }
}

func (sa *SmartAggregator) GetAggregationKey(
    attrs []attribute.KeyValue,
) string {
    // ç”Ÿæˆç¼“å­˜é”®
    cacheKey := sa.makeCacheKey(attrs)
    
    // æ£€æŸ¥ç¼“å­˜
    if cached, ok := sa.cache.Load(cacheKey); ok {
        groupByKeys := cached.([]attribute.Key)
        return sa.makeAggregationKey(attrs, groupByKeys)
    }
    
    // è·å–èšåˆé”®
    groupByKeys := sa.config.GetGroupByKeys(attrs)
    sa.cache.Store(cacheKey, groupByKeys)
    
    return sa.makeAggregationKey(attrs, groupByKeys)
}

func (sa *SmartAggregator) makeCacheKey(attrs []attribute.KeyValue) string {
    // ç®€åŒ–ï¼šä»…ä½¿ç”¨ route ä½œä¸ºç¼“å­˜é”®
    for _, attr := range attrs {
        if attr.Key == "http.route" {
            return attr.Value.AsString()
        }
    }
    return ""
}

func (sa *SmartAggregator) makeAggregationKey(
    attrs []attribute.KeyValue,
    groupByKeys []attribute.Key,
) string {
    aggregator := NewAttributeAggregator(groupByKeys)
    return aggregator.AggregationKey(attrs)
}
```

---

## å®Œæ•´å®ç°

### æ ‡ç­¾ç®¡ç†ç³»ç»Ÿ

```go
package labels

import (
    "context"
    "sync"
    
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// LabelManager æ ‡ç­¾ç®¡ç†å™¨
type LabelManager struct {
    // å±æ€§ç®¡ç†
    attrManager *AttributeManager
    
    // å±æ€§å¤„ç†
    pipeline *AttributePipeline
    
    // èšåˆ
    aggregator *SmartAggregator
    
    // Exemplar é‡‡æ ·
    exemplarSampler ExemplarSampler
    
    mu sync.RWMutex
}

func NewLabelManager(
    maxCardinality int,
    exemplarSampler ExemplarSampler,
) *LabelManager {
    return &LabelManager{
        attrManager:     NewAttributeManager(maxCardinality),
        pipeline:        setupAttributePipeline(),
        aggregator:      NewSmartAggregator(setupDynamicAggregation()),
        exemplarSampler: exemplarSampler,
    }
}

// å¤„ç†å±æ€§
func (lm *LabelManager) ProcessAttributes(
    attrs []attribute.KeyValue,
) (attribute.Set, string, error) {
    // 1. è¿‡æ»¤å’Œè½¬æ¢
    processed := lm.pipeline.Process(attrs)
    
    // 2. åˆ›å»ºå±æ€§é›†
    attrSet, err := lm.attrManager.CreateAttributeSet(processed)
    if err != nil {
        return attribute.Set{}, "", err
    }
    
    // 3. ç”Ÿæˆèšåˆé”®
    aggKey := lm.aggregator.GetAggregationKey(processed)
    
    return attrSet, aggKey, nil
}

// åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡‡æ · Exemplar
func (lm *LabelManager) ShouldSampleExemplar(
    value float64,
    attrs attribute.Set,
) bool {
    return lm.exemplarSampler.ShouldSample(value, attrs)
}

// åˆ›å»º Exemplar
func (lm *LabelManager) CreateExemplar(
    ctx context.Context,
    value float64,
) *ExemplarData {
    span := trace.SpanFromContext(ctx)
    spanContext := span.SpanContext()
    
    if !spanContext.IsValid() {
        return nil
    }
    
    return &ExemplarData{
        TraceID:   spanContext.TraceID(),
        SpanID:    spanContext.SpanID(),
        Value:     value,
        Timestamp: time.Now(),
    }
}

// è·å–ç»Ÿè®¡ä¿¡æ¯
func (lm *LabelManager) GetStats() map[string]interface{} {
    return lm.attrManager.monitor.GetStats()
}
```

---

## æœ€ä½³å®è·µ

### 1. é€‰æ‹©ä½åŸºæ•°æ ‡ç­¾

```go
// âœ… æ¨èï¼šä½åŸºæ•°æ ‡ç­¾
attribute.String("http.method", "GET")          // 4-8 ä¸ªå€¼
attribute.Int("http.status_code", 200)          // ~20 ä¸ªå€¼
attribute.String("deployment.environment", "prod")  // 3-5 ä¸ªå€¼

// âŒ é¿å…ï¼šé«˜åŸºæ•°æ ‡ç­¾
attribute.String("user.id", userID)             // æ•°ç™¾ä¸‡ä¸ªå€¼
attribute.String("request.id", requestID)       // æ— é™ä¸ªå€¼
attribute.String("http.url", fullURL)           // æ— é™ä¸ªå€¼
```

### 2. æ ‡å‡†åŒ–å‘½å

```go
// âœ… æ¨èï¼šä½¿ç”¨ OpenTelemetry Semantic Conventions
const (
    ServiceName    = "service.name"
    ServiceVersion = "service.version"
    HTTPMethod     = "http.method"
    HTTPRoute      = "http.route"
    HTTPStatusCode = "http.status_code"
)

// âŒ é¿å…ï¼šè‡ªå®šä¹‰å‘½å
const (
    AppName     = "app_name"      // âŒ
    HttpMethod  = "method"        // âŒ
    StatusCode  = "code"          // âŒ
)
```

### 3. åˆç†çš„ Exemplar é‡‡æ ·

```go
// âœ… æ¨èï¼šæ ¹æ®æµé‡è°ƒæ•´é‡‡æ ·ç‡
func getExemplarSamplingRate(requestsPerSecond float64) float64 {
    switch {
    case requestsPerSecond < 10:
        return 1.0   // 100%
    case requestsPerSecond < 100:
        return 0.1   // 10%
    case requestsPerSecond < 1000:
        return 0.01  // 1%
    default:
        return 0.001 // 0.1%
    }
}
```

### 4. å±æ€§å¤ç”¨

```go
// âœ… æ¨èï¼šé¢„åˆ†é…å¹¶å¤ç”¨
var globalAttrs = []attribute.KeyValue{
    attribute.String("service.name", "my-service"),
    attribute.String("service.version", "1.0.0"),
    attribute.String("deployment.environment", "production"),
}

func createRequestAttrs(method, route string) []attribute.KeyValue {
    attrs := make([]attribute.KeyValue, len(globalAttrs), len(globalAttrs)+2)
    copy(attrs, globalAttrs)
    attrs = append(attrs,
        attribute.String("http.method", method),
        attribute.String("http.route", route),
    )
    return attrs
}
```

---

## æ€§èƒ½ä¼˜åŒ–

### 1. é¢„åˆ†é…

```go
// âœ… é¢„åˆ†é…åˆ‡ç‰‡å®¹é‡
attrs := make([]attribute.KeyValue, 0, 10)  // é¢„åˆ†é… 10 ä¸ªå…ƒç´ 
```

### 2. å­—ç¬¦ä¸²å†…è”

```go
// âœ… ä½¿ç”¨ string interning å‡å°‘å†…å­˜
var stringPool = sync.Map{}

func intern(s string) string {
    if cached, ok := stringPool.Load(s); ok {
        return cached.(string)
    }
    stringPool.Store(s, s)
    return s
}
```

### 3. æ‰¹é‡æ“ä½œ

```go
// âœ… æ‰¹é‡å¤„ç†å±æ€§
func batchProcessAttributes(attrSets [][]attribute.KeyValue) []attribute.Set {
    results := make([]attribute.Set, len(attrSets))
    for i, attrs := range attrSets {
        results[i] = attribute.NewSet(attrs...)
    }
    return results
}
```

---

## å¸¸è§é—®é¢˜

### Q1: å¦‚ä½•åˆ¤æ–­æ ‡ç­¾åŸºæ•°æ˜¯å¦è¿‡é«˜ï¼Ÿ

**A**:

- ç›‘æ§æ—¶é—´åºåˆ—æ•°é‡
- ä¸€èˆ¬å»ºè®®: < 10,000 ä¸ªåºåˆ—/æœåŠ¡
- ä½¿ç”¨åŸºæ•°ç›‘æ§å·¥å…·

---

### Q2: Exemplar é‡‡æ ·ç‡å¦‚ä½•è®¾ç½®ï¼Ÿ

**A**:

- ä½æµé‡ (< 10 RPS): 10-100%
- ä¸­æµé‡ (10-100 RPS): 1-10%
- é«˜æµé‡ (> 100 RPS): 0.1-1%
- ç»“åˆå¼‚å¸¸å€¼é‡‡æ ·

---

### Q3: å¦‚ä½•å¤„ç†åŠ¨æ€æ ‡ç­¾ï¼Ÿ

**A**:

- åˆ†æ¡¶: å°†é«˜åŸºæ•°å€¼åˆ†åˆ°æœ‰é™æ¡¶
- æ¨¡æ¿åŒ–: è·¯å¾„å‚æ•°æ›¿æ¢ä¸ºæ¨¡æ¿
- å“ˆå¸Œ: å¯¹ ID è¿›è¡Œå“ˆå¸Œåˆ†ç»„

---

### Q4: å±æ€§ç¼“å­˜ä¼šå ç”¨å¤šå°‘å†…å­˜ï¼Ÿ

**A**:

- æ¯ä¸ªå±æ€§é›†: ~100-500 å­—èŠ‚
- 10,000 ä¸ªåºåˆ—: ~1-5 MB
- å»ºè®®è®¾ç½®ç¼“å­˜ä¸Šé™

---

### Q5: å¦‚ä½•åœ¨ Grafana ä¸­ä½¿ç”¨ Exemplarï¼Ÿ

**A**:

1. é…ç½® Prometheus æ•°æ®æºå¯ç”¨ Exemplar
2. åœ¨ Histogram é¢æ¿æŸ¥è¯¢ä¸­ä½¿ç”¨
3. ç‚¹å‡» Exemplar ç‚¹è·³è½¬åˆ° Jaeger/Tempo
4. åˆ†æå¯¹åº”çš„ Trace

---

## å‚è€ƒèµ„æº

### å®˜æ–¹æ–‡æ¡£

- [OpenTelemetry Semantic Conventions](https://opentelemetry.io/docs/specs/semconv/)
- [Exemplars](https://opentelemetry.io/docs/specs/otel/metrics/data-model/#exemplars)

### Go å®ç°8

- [go.opentelemetry.io/otel/attribute](https://pkg.go.dev/go.opentelemetry.io/otel/attribute)

### ç›¸å…³æ–‡æ¡£

- [01_Metricç±»å‹.md](./01_Metricç±»å‹.md)
- [02_æ•°æ®ç‚¹.md](./02_æ•°æ®ç‚¹.md)
- [03_æ—¶é—´åºåˆ—.md](./03_æ—¶é—´åºåˆ—.md)

---

**ğŸ‰ æ­å–œï¼ä½ å·²ç»æŒæ¡äº†æ ‡ç­¾çš„å®Œæ•´çŸ¥è¯†ï¼**

ä¸‹ä¸€æ­¥ï¼šå­¦ä¹  [èšåˆ](./05_èšåˆ.md) äº†è§£ Sumã€LastValueã€Histogramã€‚
