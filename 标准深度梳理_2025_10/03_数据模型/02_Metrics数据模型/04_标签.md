# 标签完整指南

## 📋 目录

- [标签完整指南](#标签完整指南)
  - [📋 目录](#-目录)
  - [概述](#概述)
    - [核心概念](#核心概念)
    - [标签的重要性](#标签的重要性)
  - [Attributes (属性)](#attributes-属性)
    - [数据结构](#数据结构)
    - [属性类型](#属性类型)
    - [Go 实现](#go-实现)
    - [命名约定](#命名约定)
  - [基数问题](#基数问题)
    - [什么是基数](#什么是基数)
    - [高基数的影响](#高基数的影响)
    - [基数控制策略](#基数控制策略)
    - [Go 实现2](#go-实现2)
  - [属性管理](#属性管理)
    - [属性缓存](#属性缓存)
    - [属性池化](#属性池化)
    - [属性去重](#属性去重)
    - [Go 实现3](#go-实现3)
  - [Exemplar (示例值)](#exemplar-示例值)
    - [定义](#定义)
    - [数据结构2](#数据结构2)
    - [关联机制](#关联机制)
    - [Go 实现4](#go-实现4)
  - [Exemplar 采样](#exemplar-采样)
    - [采样策略](#采样策略)
    - [始终采样](#始终采样)
    - [概率采样](#概率采样)
    - [异常值采样](#异常值采样)
    - [时间窗口采样](#时间窗口采样)
    - [Go 实现5](#go-实现5)
  - [Metrics-Traces 关联](#metrics-traces-关联)
    - [关联场景](#关联场景)
    - [实现原理](#实现原理)
    - [可视化集成](#可视化集成)
    - [Go 完整实现](#go-完整实现)
  - [属性过滤与转换](#属性过滤与转换)
    - [过滤策略](#过滤策略)
    - [转换策略](#转换策略)
    - [Go 实现6](#go-实现6)
  - [属性聚合](#属性聚合)
    - [聚合维度](#聚合维度)
    - [动态聚合](#动态聚合)
    - [Go 实现7](#go-实现7)
  - [完整实现](#完整实现)
    - [标签管理系统](#标签管理系统)
  - [最佳实践](#最佳实践)
    - [1. 选择低基数标签](#1-选择低基数标签)
    - [2. 标准化命名](#2-标准化命名)
    - [3. 合理的 Exemplar 采样](#3-合理的-exemplar-采样)
    - [4. 属性复用](#4-属性复用)
  - [性能优化](#性能优化)
    - [1. 预分配](#1-预分配)
    - [2. 字符串内联](#2-字符串内联)
    - [3. 批量操作](#3-批量操作)
  - [常见问题](#常见问题)
    - [Q1: 如何判断标签基数是否过高？](#q1-如何判断标签基数是否过高)
    - [Q2: Exemplar 采样率如何设置？](#q2-exemplar-采样率如何设置)
    - [Q3: 如何处理动态标签？](#q3-如何处理动态标签)
    - [Q4: 属性缓存会占用多少内存？](#q4-属性缓存会占用多少内存)
    - [Q5: 如何在 Grafana 中使用 Exemplar？](#q5-如何在-grafana-中使用-exemplar)
  - [参考资源](#参考资源)
    - [官方文档](#官方文档)
    - [Go 实现8](#go-实现8)
    - [相关文档](#相关文档)

---

## 概述

**标签 (Labels)** 是时间序列的关键维度，用于区分和过滤不同的度量数据。在 OpenTelemetry 中，标签主要通过 **Attributes** 和 **Exemplar** 实现。

### 核心概念

- ✅ **Attributes**: 数据点的维度标签
- ✅ **Exemplar**: 关联 Metrics 和 Traces 的桥梁
- ✅ **Cardinality**: 标签组合的数量
- ✅ **Filtering**: 标签过滤和转换

### 标签的重要性

```text
作用:
1. 维度区分: 区分不同类型的数据
2. 过滤查询: 支持灵活的查询
3. 聚合分析: 按维度聚合统计
4. 告警规则: 基于标签配置告警
5. Traces 关联: 通过 Exemplar 关联追踪
```

---

## Attributes (属性)

### 数据结构

```protobuf
message KeyValue {
  string key = 1;
  AnyValue value = 2;
}

message AnyValue {
  oneof value {
    string string_value = 1;
    bool bool_value = 2;
    int64 int_value = 3;
    double double_value = 4;
    ArrayValue array_value = 5;
    KeyValueList kvlist_value = 6;
    bytes bytes_value = 7;
  }
}
```

### 属性类型

```go
import "go.opentelemetry.io/otel/attribute"

// 1. 字符串类型
attr1 := attribute.String("http.method", "GET")

// 2. 整数类型
attr2 := attribute.Int("http.status_code", 200)

// 3. 浮点数类型
attr3 := attribute.Float64("http.response_time", 0.125)

// 4. 布尔类型
attr4 := attribute.Bool("http.compressed", true)

// 5. 数组类型
attr5 := attribute.StringSlice("http.headers", []string{"Accept", "Content-Type"})

// 6. 整数数组
attr6 := attribute.IntSlice("response.codes", []int{200, 201, 202})
```

### Go 实现

```go
package attributes

import (
    "go.opentelemetry.io/otel/attribute"
)

// 创建属性集
func createAttributeSet() attribute.Set {
    attrs := []attribute.KeyValue{
        attribute.String("service.name", "my-service"),
        attribute.String("service.version", "1.0.0"),
        attribute.String("deployment.environment", "production"),
        attribute.String("http.method", "GET"),
        attribute.String("http.route", "/api/users"),
        attribute.Int("http.status_code", 200),
    }
    
    return attribute.NewSet(attrs...)
}

// 预定义属性键
var (
    // 服务属性
    ServiceName    = attribute.Key("service.name")
    ServiceVersion = attribute.Key("service.version")
    
    // HTTP 属性
    HTTPMethod     = attribute.Key("http.method")
    HTTPRoute      = attribute.Key("http.route")
    HTTPStatusCode = attribute.Key("http.status_code")
    
    // 数据库属性
    DBSystem    = attribute.Key("db.system")
    DBName      = attribute.Key("db.name")
    DBOperation = attribute.Key("db.operation")
)

// 使用预定义键
func usePreDefinedKeys() attribute.Set {
    return attribute.NewSet(
        ServiceName.String("my-service"),
        ServiceVersion.String("1.0.0"),
        HTTPMethod.String("GET"),
        HTTPRoute.String("/api/users"),
        HTTPStatusCode.Int(200),
    )
}

// 属性合并
func mergeAttributes(base, additional []attribute.KeyValue) []attribute.KeyValue {
    result := make([]attribute.KeyValue, 0, len(base)+len(additional))
    result = append(result, base...)
    result = append(result, additional...)
    return result
}

// 示例：分层属性
func createLayeredAttributes() attribute.Set {
    // 全局属性
    global := []attribute.KeyValue{
        attribute.String("service.name", "my-service"),
        attribute.String("deployment.environment", "production"),
    }
    
    // 请求级属性
    request := []attribute.KeyValue{
        attribute.String("http.method", "GET"),
        attribute.String("http.route", "/api/users"),
    }
    
    // 合并
    all := mergeAttributes(global, request)
    return attribute.NewSet(all...)
}
```

### 命名约定

```go
// ✅ 推荐的命名约定
const (
    // 使用点分隔的层级结构
    "service.name"
    "service.version"
    "deployment.environment"
    
    // HTTP 相关
    "http.method"
    "http.route"
    "http.status_code"
    "http.request.body.size"
    "http.response.body.size"
    
    // 数据库相关
    "db.system"
    "db.name"
    "db.operation"
    "db.statement"
    
    // 消息队列
    "messaging.system"
    "messaging.destination"
    "messaging.operation"
)

// ❌ 避免的命名
const (
    // 不要使用下划线
    "http_method"  // ❌
    
    // 不要使用驼峰
    "httpMethod"   // ❌
    
    // 不要使用大写
    "HTTP.METHOD"  // ❌
)
```

---

## 基数问题

### 什么是基数

**基数 (Cardinality)** 是标签组合的唯一值数量。

```text
示例:
http.method: [GET, POST, PUT, DELETE]           → 4 个值
http.status_code: [200, 201, 400, 404, 500]    → 5 个值

组合基数: 4 × 5 = 20 个时间序列
```

### 高基数的影响

```text
问题:
1. 内存消耗: 每个时间序列占用内存
2. 查询性能: 需要扫描更多数据
3. 存储成本: 存储空间增加
4. 索引压力: 索引大小增长

示例:
低基数:  http.method + http.status_code          → 20 个序列 ✅
高基数:  user.id (100万用户)                      → 100万序列 ❌
超高基数: request.id (每个请求唯一)                → 无限序列 ❌
```

### 基数控制策略

```go
// 1. 使用固定值集合
var allowedHTTPMethods = map[string]bool{
    "GET":    true,
    "POST":   true,
    "PUT":    true,
    "DELETE": true,
    "PATCH":  true,
}

func normalizeHTTPMethod(method string) string {
    if allowedHTTPMethods[method] {
        return method
    }
    return "OTHER"  // 未知方法归类为 OTHER
}

// 2. 状态码分组
func groupStatusCode(code int) string {
    switch {
    case code >= 200 && code < 300:
        return "2xx"
    case code >= 300 && code < 400:
        return "3xx"
    case code >= 400 && code < 500:
        return "4xx"
    case code >= 500 && code < 600:
        return "5xx"
    default:
        return "unknown"
    }
}

// 3. 用户 ID 哈希分桶
func hashUserID(userID string, numBuckets int) int {
    import "hash/fnv"
    
    h := fnv.New32a()
    h.Write([]byte(userID))
    return int(h.Sum32()) % numBuckets
}

func getUserBucket(userID string) string {
    bucket := hashUserID(userID, 100)
    return fmt.Sprintf("bucket_%d", bucket)
}

// 4. 路径模板化
func templatizePath(path string) string {
    // /api/users/123 → /api/users/{id}
    // /api/orders/456 → /api/orders/{id}
    
    import "regexp"
    
    // 替换数字 ID
    re := regexp.MustCompile(`/\d+`)
    return re.ReplaceAllString(path, "/{id}")
}
```

### Go 实现2

```go
// 基数监控器
type CardinalityMonitor struct {
    seriesCount map[string]int
    maxCardinality int
    mu sync.RWMutex
}

func NewCardinalityMonitor(maxCardinality int) *CardinalityMonitor {
    return &CardinalityMonitor{
        seriesCount: make(map[string]int),
        maxCardinality: maxCardinality,
    }
}

// 检查基数
func (cm *CardinalityMonitor) CheckCardinality(
    attrs []attribute.KeyValue,
) error {
    cm.mu.Lock()
    defer cm.mu.Unlock()
    
    // 生成序列键
    key := cm.makeSeriesKey(attrs)
    
    if _, exists := cm.seriesCount[key]; !exists {
        if len(cm.seriesCount) >= cm.maxCardinality {
            return fmt.Errorf(
                "cardinality limit exceeded: %d",
                cm.maxCardinality,
            )
        }
        cm.seriesCount[key] = 0
    }
    
    cm.seriesCount[key]++
    return nil
}

func (cm *CardinalityMonitor) makeSeriesKey(
    attrs []attribute.KeyValue,
) string {
    import "sort"
    import "strings"
    
    // 排序属性以确保一致性
    sorted := make([]string, len(attrs))
    for i, attr := range attrs {
        sorted[i] = fmt.Sprintf("%s=%s", attr.Key, attr.Value.AsString())
    }
    sort.Strings(sorted)
    
    return strings.Join(sorted, ",")
}

// 获取统计信息
func (cm *CardinalityMonitor) GetStats() map[string]interface{} {
    cm.mu.RLock()
    defer cm.mu.RUnlock()
    
    return map[string]interface{}{
        "total_series":    len(cm.seriesCount),
        "max_cardinality": cm.maxCardinality,
        "utilization":     float64(len(cm.seriesCount)) / float64(cm.maxCardinality),
    }
}
```

---

## 属性管理

### 属性缓存

```go
// 属性缓存
type AttributeCache struct {
    cache sync.Map  // map[string]attribute.Set
}

func NewAttributeCache() *AttributeCache {
    return &AttributeCache{}
}

// 获取或创建属性集
func (ac *AttributeCache) GetOrCreate(
    attrs []attribute.KeyValue,
) attribute.Set {
    key := ac.makeKey(attrs)
    
    if cached, ok := ac.cache.Load(key); ok {
        return cached.(attribute.Set)
    }
    
    set := attribute.NewSet(attrs...)
    ac.cache.Store(key, set)
    return set
}

func (ac *AttributeCache) makeKey(attrs []attribute.KeyValue) string {
    import "sort"
    import "strings"
    
    pairs := make([]string, len(attrs))
    for i, attr := range attrs {
        pairs[i] = fmt.Sprintf("%s=%v", attr.Key, attr.Value)
    }
    sort.Strings(pairs)
    return strings.Join(pairs, "|")
}

// 清理缓存
func (ac *AttributeCache) Clear() {
    ac.cache = sync.Map{}
}
```

### 属性池化

```go
// 属性切片池
var attributeSlicePool = sync.Pool{
    New: func() interface{} {
        slice := make([]attribute.KeyValue, 0, 10)
        return &slice
    },
}

// 获取属性切片
func acquireAttributeSlice() *[]attribute.KeyValue {
    return attributeSlicePool.Get().(*[]attribute.KeyValue)
}

// 释放属性切片
func releaseAttributeSlice(slice *[]attribute.KeyValue) {
    *slice = (*slice)[:0]
    attributeSlicePool.Put(slice)
}

// 使用示例
func useAttributePool() attribute.Set {
    attrs := acquireAttributeSlice()
    defer releaseAttributeSlice(attrs)
    
    *attrs = append(*attrs,
        attribute.String("http.method", "GET"),
        attribute.String("http.route", "/api/users"),
    )
    
    return attribute.NewSet(*attrs...)
}
```

### 属性去重

```go
// 属性去重器
type AttributeDeduplicator struct {
    seen map[string]struct{}
}

func NewAttributeDeduplicator() *AttributeDeduplicator {
    return &AttributeDeduplicator{
        seen: make(map[string]struct{}),
    }
}

// 去重
func (ad *AttributeDeduplicator) Deduplicate(
    attrs []attribute.KeyValue,
) []attribute.KeyValue {
    result := make([]attribute.KeyValue, 0, len(attrs))
    
    for _, attr := range attrs {
        key := string(attr.Key)
        if _, exists := ad.seen[key]; !exists {
            result = append(result, attr)
            ad.seen[key] = struct{}{}
        }
    }
    
    return result
}
```

### Go 实现3

```go
// 完整的属性管理器
type AttributeManager struct {
    cache       *AttributeCache
    monitor     *CardinalityMonitor
    dedupe      *AttributeDeduplicator
    globalAttrs []attribute.KeyValue
    mu          sync.RWMutex
}

func NewAttributeManager(maxCardinality int) *AttributeManager {
    return &AttributeManager{
        cache:   NewAttributeCache(),
        monitor: NewCardinalityMonitor(maxCardinality),
        dedupe:  NewAttributeDeduplicator(),
    }
}

// 设置全局属性
func (am *AttributeManager) SetGlobalAttributes(attrs []attribute.KeyValue) {
    am.mu.Lock()
    am.globalAttrs = attrs
    am.mu.Unlock()
}

// 创建属性集
func (am *AttributeManager) CreateAttributeSet(
    attrs []attribute.KeyValue,
) (attribute.Set, error) {
    am.mu.RLock()
    global := am.globalAttrs
    am.mu.RUnlock()
    
    // 合并全局属性
    combined := make([]attribute.KeyValue, 0, len(global)+len(attrs))
    combined = append(combined, global...)
    combined = append(combined, attrs...)
    
    // 去重
    combined = am.dedupe.Deduplicate(combined)
    
    // 检查基数
    if err := am.monitor.CheckCardinality(combined); err != nil {
        return attribute.Set{}, err
    }
    
    // 从缓存获取
    return am.cache.GetOrCreate(combined), nil
}
```

---

## Exemplar (示例值)

### 定义

**Exemplar** 是与 Metric 数据点关联的 Trace 采样，用于将 Metrics 和 Traces 关联起来。

### 数据结构2

```protobuf
message Exemplar {
  repeated KeyValue filtered_attributes = 7;
  fixed64 time_unix_nano = 2;
  
  oneof value {
    double as_double = 3;
    sfixed64 as_int = 6;
  }
  
  bytes span_id = 4;
  bytes trace_id = 5;
}
```

### 关联机制

```text
┌─────────────────────────────────────────────┐
│ Metrics (Histogram)                         │
│                                             │
│  http.server.request.duration               │
│  ├─ P50: 0.1s                               │
│  ├─ P95: 0.5s                               │
│  ├─ P99: 1.2s  ← Exemplar                   │
│  │              trace_id: abc123            │
│  │              span_id:  def456            │
│  └─ ...                                     │
└─────────────────────────────────────────────┘
                    │
                    │ 关联
                    ▼
┌─────────────────────────────────────────────┐
│ Traces                                      │
│                                             │
│  Trace ID: abc123                           │
│  ├─ Span: def456 (HTTP GET /api/users)     │
│  │  Duration: 1.2s                          │
│  │  ├─ DB Query: 0.8s                       │
│  │  └─ External API: 0.3s                   │
│  └─ ...                                     │
└─────────────────────────────────────────────┘
```

### Go 实现4

```go
import (
    "go.opentelemetry.io/otel/trace"
    "go.opentelemetry.io/otel/metric"
)

// 创建带 Exemplar 的 Histogram 记录
func recordWithExemplar(
    ctx context.Context,
    histogram metric.Float64Histogram,
) {
    // 从 Context 获取当前 Span
    span := trace.SpanFromContext(ctx)
    spanContext := span.SpanContext()
    
    // 记录度量值
    // SDK 会自动提取 TraceID 和 SpanID 作为 Exemplar
    start := time.Now()
    
    // 处理请求...
    processRequest()
    
    duration := time.Since(start).Seconds()
    histogram.Record(ctx, duration,
        metric.WithAttributes(
            attribute.String("http.method", "GET"),
            attribute.String("http.route", "/api/users"),
        ),
    )
    
    // Exemplar 自动包含:
    // - trace_id: spanContext.TraceID()
    // - span_id: spanContext.SpanID()
    // - value: duration
    // - time: 记录时间
}

// 手动创建 Exemplar
type ExemplarData struct {
    TraceID   trace.TraceID
    SpanID    trace.SpanID
    Value     float64
    Timestamp time.Time
    Attributes []attribute.KeyValue
}

func createExemplar(
    ctx context.Context,
    value float64,
) *ExemplarData {
    span := trace.SpanFromContext(ctx)
    spanContext := span.SpanContext()
    
    return &ExemplarData{
        TraceID:   spanContext.TraceID(),
        SpanID:    spanContext.SpanID(),
        Value:     value,
        Timestamp: time.Now(),
    }
}
```

---

## Exemplar 采样

### 采样策略

```text
1. AlwaysSample: 始终采样
2. ProbabilitySample: 概率采样
3. OutlierSample: 异常值采样
4. TimeWindowSample: 时间窗口采样
5. BucketSample: 按桶采样
```

### 始终采样

```go
// 始终采样
type AlwaysExemplarSampler struct{}

func (s AlwaysExemplarSampler) ShouldSample(
    value float64,
    attrs attribute.Set,
) bool {
    return true
}
```

### 概率采样

```go
// 概率采样
type ProbabilityExemplarSampler struct {
    Probability float64  // 0.0 ~ 1.0
}

func (s ProbabilityExemplarSampler) ShouldSample(
    value float64,
    attrs attribute.Set,
) bool {
    import "math/rand"
    return rand.Float64() < s.Probability
}
```

### 异常值采样

```go
// 异常值采样
type OutlierExemplarSampler struct {
    Threshold float64
}

func (s OutlierExemplarSampler) ShouldSample(
    value float64,
    attrs attribute.Set,
) bool {
    return value > s.Threshold
}

// 自适应异常值采样
type AdaptiveOutlierSampler struct {
    window     []float64
    windowSize int
    stddevMul  float64
    mu         sync.Mutex
}

func NewAdaptiveOutlierSampler(windowSize int, stddevMul float64) *AdaptiveOutlierSampler {
    return &AdaptiveOutlierSampler{
        window:     make([]float64, 0, windowSize),
        windowSize: windowSize,
        stddevMul:  stddevMul,
    }
}

func (s *AdaptiveOutlierSampler) ShouldSample(
    value float64,
    attrs attribute.Set,
) bool {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    // 添加到窗口
    s.window = append(s.window, value)
    if len(s.window) > s.windowSize {
        s.window = s.window[1:]
    }
    
    if len(s.window) < 10 {
        return false
    }
    
    // 计算均值和标准差
    mean, stddev := s.calculateStats()
    
    // 判断是否异常值
    return math.Abs(value-mean) > stddev*s.stddevMul
}

func (s *AdaptiveOutlierSampler) calculateStats() (mean, stddev float64) {
    import "math"
    
    // 计算均值
    var sum float64
    for _, v := range s.window {
        sum += v
    }
    mean = sum / float64(len(s.window))
    
    // 计算标准差
    var variance float64
    for _, v := range s.window {
        diff := v - mean
        variance += diff * diff
    }
    variance /= float64(len(s.window))
    stddev = math.Sqrt(variance)
    
    return mean, stddev
}
```

### 时间窗口采样

```go
// 时间窗口采样
type TimeWindowExemplarSampler struct {
    windowDuration time.Duration
    maxPerWindow   int
    lastReset      time.Time
    count          int
    mu             sync.Mutex
}

func NewTimeWindowExemplarSampler(
    windowDuration time.Duration,
    maxPerWindow int,
) *TimeWindowExemplarSampler {
    return &TimeWindowExemplarSampler{
        windowDuration: windowDuration,
        maxPerWindow:   maxPerWindow,
        lastReset:      time.Now(),
    }
}

func (s *TimeWindowExemplarSampler) ShouldSample(
    value float64,
    attrs attribute.Set,
) bool {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    now := time.Now()
    if now.Sub(s.lastReset) >= s.windowDuration {
        s.count = 0
        s.lastReset = now
    }
    
    if s.count < s.maxPerWindow {
        s.count++
        return true
    }
    
    return false
}
```

### Go 实现5

```go
// 复合采样器
type CompositeExemplarSampler struct {
    samplers []ExemplarSampler
}

type ExemplarSampler interface {
    ShouldSample(value float64, attrs attribute.Set) bool
}

func NewCompositeExemplarSampler(samplers ...ExemplarSampler) *CompositeExemplarSampler {
    return &CompositeExemplarSampler{
        samplers: samplers,
    }
}

// 任一采样器通过则通过
func (s *CompositeExemplarSampler) ShouldSample(
    value float64,
    attrs attribute.Set,
) bool {
    for _, sampler := range s.samplers {
        if sampler.ShouldSample(value, attrs) {
            return true
        }
    }
    return false
}

// 使用示例
func setupExemplarSampling() ExemplarSampler {
    return NewCompositeExemplarSampler(
        // 1% 概率采样
        ProbabilityExemplarSampler{Probability: 0.01},
        
        // 异常值采样 (> 1s)
        OutlierExemplarSampler{Threshold: 1.0},
        
        // 时间窗口采样 (每分钟最多10个)
        NewTimeWindowExemplarSampler(time.Minute, 10),
    )
}
```

---

## Metrics-Traces 关联

### 关联场景

```text
1. 性能异常排查:
   Metrics 发现 P99 延迟突增
   → 通过 Exemplar 找到慢请求的 Trace
   → 分析 Trace 找到性能瓶颈

2. 错误分析:
   Metrics 发现错误率上升
   → 通过 Exemplar 找到失败请求的 Trace
   → 分析 Trace 定位错误原因

3. 容量规划:
   Metrics 发现资源使用率高
   → 通过 Exemplar 找到典型请求的 Trace
   → 分析 Trace 优化资源使用
```

### 实现原理

```go
// Exemplar 自动注入
func autoInjectExemplar(
    ctx context.Context,
    histogram metric.Float64Histogram,
    value float64,
    sampler ExemplarSampler,
) {
    // 检查是否应该采样
    attrs := attribute.EmptySet()
    if !sampler.ShouldSample(value, attrs) {
        // 不采样，仅记录值
        histogram.Record(ctx, value)
        return
    }
    
    // 采样：记录值 + Exemplar
    // SDK 会自动从 Context 提取 TraceID/SpanID
    histogram.Record(ctx, value,
        metric.WithAttributes(
            attribute.String("http.method", "GET"),
        ),
    )
}

// 完整的 HTTP 追踪示例
func traceHTTPRequest(
    w http.ResponseWriter,
    r *http.Request,
    tracer trace.Tracer,
    histogram metric.Float64Histogram,
) {
    // 1. 创建 Span
    ctx, span := tracer.Start(r.Context(), "HTTP "+r.Method)
    defer span.End()
    
    // 2. 记录开始时间
    start := time.Now()
    
    // 3. 处理请求
    statusCode := processHTTPRequest(ctx, w, r)
    
    // 4. 记录延迟 (自动关联 Exemplar)
    duration := time.Since(start).Seconds()
    histogram.Record(ctx, duration,
        metric.WithAttributes(
            attribute.String("http.method", r.Method),
            attribute.String("http.route", r.URL.Path),
            attribute.Int("http.status_code", statusCode),
        ),
    )
    
    // SDK 自动创建 Exemplar:
    // {
    //   trace_id: span.SpanContext().TraceID(),
    //   span_id:  span.SpanContext().SpanID(),
    //   value:    duration,
    //   time:     time.Now(),
    // }
}
```

### 可视化集成

```text
Grafana 中使用 Exemplar:

1. 配置 Prometheus 数据源
   启用 Exemplar 支持

2. 在 Histogram 面板中显示 Exemplar
   Query: histogram_quantile(0.99, 
          rate(http_request_duration_seconds_bucket[5m]))

3. 点击 Exemplar 点
   → 跳转到 Jaeger/Tempo
   → 查看对应的 Trace

4. 分析慢请求
   → 找到性能瓶颈
   → 优化代码
```

### Go 完整实现

```go
// HTTP 服务器 with Metrics-Traces 关联
func setupHTTPServer() {
    // 1. 初始化 Tracer
    tracer := otel.Tracer("my-service")
    
    // 2. 初始化 Meter
    meter := otel.Meter("my-service")
    
    // 3. 创建 Histogram
    histogram, _ := meter.Float64Histogram(
        "http.server.request.duration",
        metric.WithDescription("HTTP request duration"),
        metric.WithUnit("s"),
    )
    
    // 4. 配置 Exemplar 采样
    sampler := setupExemplarSampling()
    
    // 5. HTTP Handler
    http.HandleFunc("/api/users", func(w http.ResponseWriter, r *http.Request) {
        // 创建 Span
        ctx, span := tracer.Start(r.Context(), "GET /api/users")
        defer span.End()
        
        start := time.Now()
        
        // 处理请求
        users := getUsersFromDB(ctx)
        json.NewEncoder(w).Encode(users)
        
        // 记录延迟 with Exemplar
        duration := time.Since(start).Seconds()
        if sampler.ShouldSample(duration, attribute.EmptySet()) {
            histogram.Record(ctx, duration,
                metric.WithAttributes(
                    attribute.String("http.method", r.Method),
                    attribute.String("http.route", "/api/users"),
                    attribute.Int("http.status_code", 200),
                ),
            )
        }
    })
    
    http.ListenAndServe(":8080", nil)
}
```

---

## 属性过滤与转换

### 过滤策略

```go
// 属性过滤器
type AttributeFilter interface {
    Filter(attrs []attribute.KeyValue) []attribute.KeyValue
}

// 1. 白名单过滤
type WhitelistFilter struct {
    allowed map[attribute.Key]bool
}

func NewWhitelistFilter(keys []attribute.Key) *WhitelistFilter {
    allowed := make(map[attribute.Key]bool)
    for _, key := range keys {
        allowed[key] = true
    }
    return &WhitelistFilter{allowed: allowed}
}

func (f *WhitelistFilter) Filter(attrs []attribute.KeyValue) []attribute.KeyValue {
    result := make([]attribute.KeyValue, 0, len(attrs))
    for _, attr := range attrs {
        if f.allowed[attr.Key] {
            result = append(result, attr)
        }
    }
    return result
}

// 2. 黑名单过滤
type BlacklistFilter struct {
    blocked map[attribute.Key]bool
}

func NewBlacklistFilter(keys []attribute.Key) *BlacklistFilter {
    blocked := make(map[attribute.Key]bool)
    for _, key := range keys {
        blocked[key] = true
    }
    return &BlacklistFilter{blocked: blocked}
}

func (f *BlacklistFilter) Filter(attrs []attribute.KeyValue) []attribute.KeyValue {
    result := make([]attribute.KeyValue, 0, len(attrs))
    for _, attr := range attrs {
        if !f.blocked[attr.Key] {
            result = append(result, attr)
        }
    }
    return result
}

// 3. 正则过滤
type RegexFilter struct {
    pattern *regexp.Regexp
    include bool
}

func NewRegexFilter(pattern string, include bool) (*RegexFilter, error) {
    re, err := regexp.Compile(pattern)
    if err != nil {
        return nil, err
    }
    return &RegexFilter{
        pattern: re,
        include: include,
    }, nil
}

func (f *RegexFilter) Filter(attrs []attribute.KeyValue) []attribute.KeyValue {
    result := make([]attribute.KeyValue, 0, len(attrs))
    for _, attr := range attrs {
        matches := f.pattern.MatchString(string(attr.Key))
        if (matches && f.include) || (!matches && !f.include) {
            result = append(result, attr)
        }
    }
    return result
}
```

### 转换策略

```go
// 属性转换器
type AttributeTransformer interface {
    Transform(attrs []attribute.KeyValue) []attribute.KeyValue
}

// 1. 重命名
type RenameTransformer struct {
    mapping map[attribute.Key]attribute.Key
}

func NewRenameTransformer(mapping map[attribute.Key]attribute.Key) *RenameTransformer {
    return &RenameTransformer{mapping: mapping}
}

func (t *RenameTransformer) Transform(attrs []attribute.KeyValue) []attribute.KeyValue {
    result := make([]attribute.KeyValue, len(attrs))
    for i, attr := range attrs {
        if newKey, exists := t.mapping[attr.Key]; exists {
            result[i] = attribute.KeyValue{
                Key:   newKey,
                Value: attr.Value,
            }
        } else {
            result[i] = attr
        }
    }
    return result
}

// 2. 值转换
type ValueTransformer struct {
    key       attribute.Key
    transform func(attribute.Value) attribute.Value
}

func NewValueTransformer(
    key attribute.Key,
    transform func(attribute.Value) attribute.Value,
) *ValueTransformer {
    return &ValueTransformer{
        key:       key,
        transform: transform,
    }
}

func (t *ValueTransformer) Transform(attrs []attribute.KeyValue) []attribute.KeyValue {
    result := make([]attribute.KeyValue, len(attrs))
    for i, attr := range attrs {
        if attr.Key == t.key {
            result[i] = attribute.KeyValue{
                Key:   attr.Key,
                Value: t.transform(attr.Value),
            }
        } else {
            result[i] = attr
        }
    }
    return result
}

// 3. 添加前缀
type PrefixTransformer struct {
    prefix string
}

func NewPrefixTransformer(prefix string) *PrefixTransformer {
    return &PrefixTransformer{prefix: prefix}
}

func (t *PrefixTransformer) Transform(attrs []attribute.KeyValue) []attribute.KeyValue {
    result := make([]attribute.KeyValue, len(attrs))
    for i, attr := range attrs {
        newKey := attribute.Key(t.prefix + string(attr.Key))
        result[i] = attribute.KeyValue{
            Key:   newKey,
            Value: attr.Value,
        }
    }
    return result
}
```

### Go 实现6

```go
// 属性处理管道
type AttributePipeline struct {
    filters      []AttributeFilter
    transformers []AttributeTransformer
}

func NewAttributePipeline() *AttributePipeline {
    return &AttributePipeline{
        filters:      make([]AttributeFilter, 0),
        transformers: make([]AttributeTransformer, 0),
    }
}

func (ap *AttributePipeline) AddFilter(filter AttributeFilter) {
    ap.filters = append(ap.filters, filter)
}

func (ap *AttributePipeline) AddTransformer(transformer AttributeTransformer) {
    ap.transformers = append(ap.transformers, transformer)
}

func (ap *AttributePipeline) Process(attrs []attribute.KeyValue) []attribute.KeyValue {
    result := attrs
    
    // 应用过滤器
    for _, filter := range ap.filters {
        result = filter.Filter(result)
    }
    
    // 应用转换器
    for _, transformer := range ap.transformers {
        result = transformer.Transform(result)
    }
    
    return result
}

// 使用示例
func setupAttributePipeline() *AttributePipeline {
    pipeline := NewAttributePipeline()
    
    // 1. 过滤敏感属性
    pipeline.AddFilter(NewBlacklistFilter([]attribute.Key{
        attribute.Key("user.password"),
        attribute.Key("credit.card"),
    }))
    
    // 2. 重命名属性
    pipeline.AddTransformer(NewRenameTransformer(map[attribute.Key]attribute.Key{
        attribute.Key("method"): attribute.Key("http.method"),
        attribute.Key("code"):   attribute.Key("http.status_code"),
    }))
    
    // 3. 添加前缀
    pipeline.AddTransformer(NewPrefixTransformer("app."))
    
    return pipeline
}
```

---

## 属性聚合

### 聚合维度

```go
// 属性聚合器
type AttributeAggregator struct {
    groupByKeys []attribute.Key
}

func NewAttributeAggregator(groupByKeys []attribute.Key) *AttributeAggregator {
    return &AttributeAggregator{
        groupByKeys: groupByKeys,
    }
}

// 生成聚合键
func (aa *AttributeAggregator) AggregationKey(
    attrs []attribute.KeyValue,
) string {
    import "sort"
    import "strings"
    
    values := make([]string, 0, len(aa.groupByKeys))
    
    // 提取分组键的值
    attrMap := make(map[attribute.Key]attribute.Value)
    for _, attr := range attrs {
        attrMap[attr.Key] = attr.Value
    }
    
    for _, key := range aa.groupByKeys {
        if value, exists := attrMap[key]; exists {
            values = append(values, value.AsString())
        } else {
            values = append(values, "")
        }
    }
    
    return strings.Join(values, "|")
}

// 示例：按 http.method 和 http.status_code 聚合
func exampleAggregation() {
    aggregator := NewAttributeAggregator([]attribute.Key{
        attribute.Key("http.method"),
        attribute.Key("http.status_code"),
    })
    
    attrs1 := []attribute.KeyValue{
        attribute.String("http.method", "GET"),
        attribute.Int("http.status_code", 200),
        attribute.String("http.route", "/api/users"),
    }
    
    attrs2 := []attribute.KeyValue{
        attribute.String("http.method", "GET"),
        attribute.Int("http.status_code", 200),
        attribute.String("http.route", "/api/orders"),
    }
    
    key1 := aggregator.AggregationKey(attrs1)  // "GET|200"
    key2 := aggregator.AggregationKey(attrs2)  // "GET|200"
    
    // key1 == key2，两个请求会聚合到同一个时间序列
}
```

### 动态聚合

```go
// 动态聚合配置
type DynamicAggregationConfig struct {
    rules []AggregationRule
}

type AggregationRule struct {
    Matcher   func([]attribute.KeyValue) bool
    GroupByKeys []attribute.Key
}

func (dac *DynamicAggregationConfig) GetGroupByKeys(
    attrs []attribute.KeyValue,
) []attribute.Key {
    for _, rule := range dac.rules {
        if rule.Matcher(attrs) {
            return rule.GroupByKeys
        }
    }
    return nil
}

// 示例：根据路由前缀使用不同的聚合键
func setupDynamicAggregation() *DynamicAggregationConfig {
    return &DynamicAggregationConfig{
        rules: []AggregationRule{
            {
                // /api/* 路由：按 method + status_code 聚合
                Matcher: func(attrs []attribute.KeyValue) bool {
                    for _, attr := range attrs {
                        if attr.Key == "http.route" {
                            route := attr.Value.AsString()
                            return strings.HasPrefix(route, "/api/")
                        }
                    }
                    return false
                },
                GroupByKeys: []attribute.Key{
                    attribute.Key("http.method"),
                    attribute.Key("http.status_code"),
                },
            },
            {
                // /admin/* 路由：按 method + status_code + route 聚合
                Matcher: func(attrs []attribute.KeyValue) bool {
                    for _, attr := range attrs {
                        if attr.Key == "http.route" {
                            route := attr.Value.AsString()
                            return strings.HasPrefix(route, "/admin/")
                        }
                    }
                    return false
                },
                GroupByKeys: []attribute.Key{
                    attribute.Key("http.method"),
                    attribute.Key("http.status_code"),
                    attribute.Key("http.route"),
                },
            },
        },
    }
}
```

### Go 实现7

```go
// 智能聚合器
type SmartAggregator struct {
    config *DynamicAggregationConfig
    cache  sync.Map  // map[string][]attribute.Key
}

func NewSmartAggregator(config *DynamicAggregationConfig) *SmartAggregator {
    return &SmartAggregator{
        config: config,
    }
}

func (sa *SmartAggregator) GetAggregationKey(
    attrs []attribute.KeyValue,
) string {
    // 生成缓存键
    cacheKey := sa.makeCacheKey(attrs)
    
    // 检查缓存
    if cached, ok := sa.cache.Load(cacheKey); ok {
        groupByKeys := cached.([]attribute.Key)
        return sa.makeAggregationKey(attrs, groupByKeys)
    }
    
    // 获取聚合键
    groupByKeys := sa.config.GetGroupByKeys(attrs)
    sa.cache.Store(cacheKey, groupByKeys)
    
    return sa.makeAggregationKey(attrs, groupByKeys)
}

func (sa *SmartAggregator) makeCacheKey(attrs []attribute.KeyValue) string {
    // 简化：仅使用 route 作为缓存键
    for _, attr := range attrs {
        if attr.Key == "http.route" {
            return attr.Value.AsString()
        }
    }
    return ""
}

func (sa *SmartAggregator) makeAggregationKey(
    attrs []attribute.KeyValue,
    groupByKeys []attribute.Key,
) string {
    aggregator := NewAttributeAggregator(groupByKeys)
    return aggregator.AggregationKey(attrs)
}
```

---

## 完整实现

### 标签管理系统

```go
package labels

import (
    "context"
    "sync"
    
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// LabelManager 标签管理器
type LabelManager struct {
    // 属性管理
    attrManager *AttributeManager
    
    // 属性处理
    pipeline *AttributePipeline
    
    // 聚合
    aggregator *SmartAggregator
    
    // Exemplar 采样
    exemplarSampler ExemplarSampler
    
    mu sync.RWMutex
}

func NewLabelManager(
    maxCardinality int,
    exemplarSampler ExemplarSampler,
) *LabelManager {
    return &LabelManager{
        attrManager:     NewAttributeManager(maxCardinality),
        pipeline:        setupAttributePipeline(),
        aggregator:      NewSmartAggregator(setupDynamicAggregation()),
        exemplarSampler: exemplarSampler,
    }
}

// 处理属性
func (lm *LabelManager) ProcessAttributes(
    attrs []attribute.KeyValue,
) (attribute.Set, string, error) {
    // 1. 过滤和转换
    processed := lm.pipeline.Process(attrs)
    
    // 2. 创建属性集
    attrSet, err := lm.attrManager.CreateAttributeSet(processed)
    if err != nil {
        return attribute.Set{}, "", err
    }
    
    // 3. 生成聚合键
    aggKey := lm.aggregator.GetAggregationKey(processed)
    
    return attrSet, aggKey, nil
}

// 判断是否应该采样 Exemplar
func (lm *LabelManager) ShouldSampleExemplar(
    value float64,
    attrs attribute.Set,
) bool {
    return lm.exemplarSampler.ShouldSample(value, attrs)
}

// 创建 Exemplar
func (lm *LabelManager) CreateExemplar(
    ctx context.Context,
    value float64,
) *ExemplarData {
    span := trace.SpanFromContext(ctx)
    spanContext := span.SpanContext()
    
    if !spanContext.IsValid() {
        return nil
    }
    
    return &ExemplarData{
        TraceID:   spanContext.TraceID(),
        SpanID:    spanContext.SpanID(),
        Value:     value,
        Timestamp: time.Now(),
    }
}

// 获取统计信息
func (lm *LabelManager) GetStats() map[string]interface{} {
    return lm.attrManager.monitor.GetStats()
}
```

---

## 最佳实践

### 1. 选择低基数标签

```go
// ✅ 推荐：低基数标签
attribute.String("http.method", "GET")          // 4-8 个值
attribute.Int("http.status_code", 200)          // ~20 个值
attribute.String("deployment.environment", "prod")  // 3-5 个值

// ❌ 避免：高基数标签
attribute.String("user.id", userID)             // 数百万个值
attribute.String("request.id", requestID)       // 无限个值
attribute.String("http.url", fullURL)           // 无限个值
```

### 2. 标准化命名

```go
// ✅ 推荐：使用 OpenTelemetry Semantic Conventions
const (
    ServiceName    = "service.name"
    ServiceVersion = "service.version"
    HTTPMethod     = "http.method"
    HTTPRoute      = "http.route"
    HTTPStatusCode = "http.status_code"
)

// ❌ 避免：自定义命名
const (
    AppName     = "app_name"      // ❌
    HttpMethod  = "method"        // ❌
    StatusCode  = "code"          // ❌
)
```

### 3. 合理的 Exemplar 采样

```go
// ✅ 推荐：根据流量调整采样率
func getExemplarSamplingRate(requestsPerSecond float64) float64 {
    switch {
    case requestsPerSecond < 10:
        return 1.0   // 100%
    case requestsPerSecond < 100:
        return 0.1   // 10%
    case requestsPerSecond < 1000:
        return 0.01  // 1%
    default:
        return 0.001 // 0.1%
    }
}
```

### 4. 属性复用

```go
// ✅ 推荐：预分配并复用
var globalAttrs = []attribute.KeyValue{
    attribute.String("service.name", "my-service"),
    attribute.String("service.version", "1.0.0"),
    attribute.String("deployment.environment", "production"),
}

func createRequestAttrs(method, route string) []attribute.KeyValue {
    attrs := make([]attribute.KeyValue, len(globalAttrs), len(globalAttrs)+2)
    copy(attrs, globalAttrs)
    attrs = append(attrs,
        attribute.String("http.method", method),
        attribute.String("http.route", route),
    )
    return attrs
}
```

---

## 性能优化

### 1. 预分配

```go
// ✅ 预分配切片容量
attrs := make([]attribute.KeyValue, 0, 10)  // 预分配 10 个元素
```

### 2. 字符串内联

```go
// ✅ 使用 string interning 减少内存
var stringPool = sync.Map{}

func intern(s string) string {
    if cached, ok := stringPool.Load(s); ok {
        return cached.(string)
    }
    stringPool.Store(s, s)
    return s
}
```

### 3. 批量操作

```go
// ✅ 批量处理属性
func batchProcessAttributes(attrSets [][]attribute.KeyValue) []attribute.Set {
    results := make([]attribute.Set, len(attrSets))
    for i, attrs := range attrSets {
        results[i] = attribute.NewSet(attrs...)
    }
    return results
}
```

---

## 常见问题

### Q1: 如何判断标签基数是否过高？

**A**:

- 监控时间序列数量
- 一般建议: < 10,000 个序列/服务
- 使用基数监控工具

---

### Q2: Exemplar 采样率如何设置？

**A**:

- 低流量 (< 10 RPS): 10-100%
- 中流量 (10-100 RPS): 1-10%
- 高流量 (> 100 RPS): 0.1-1%
- 结合异常值采样

---

### Q3: 如何处理动态标签？

**A**:

- 分桶: 将高基数值分到有限桶
- 模板化: 路径参数替换为模板
- 哈希: 对 ID 进行哈希分组

---

### Q4: 属性缓存会占用多少内存？

**A**:

- 每个属性集: ~100-500 字节
- 10,000 个序列: ~1-5 MB
- 建议设置缓存上限

---

### Q5: 如何在 Grafana 中使用 Exemplar？

**A**:

1. 配置 Prometheus 数据源启用 Exemplar
2. 在 Histogram 面板查询中使用
3. 点击 Exemplar 点跳转到 Jaeger/Tempo
4. 分析对应的 Trace

---

## 参考资源

### 官方文档

- [OpenTelemetry Semantic Conventions](https://opentelemetry.io/docs/specs/semconv/)
- [Exemplars](https://opentelemetry.io/docs/specs/otel/metrics/data-model/#exemplars)

### Go 实现8

- [go.opentelemetry.io/otel/attribute](https://pkg.go.dev/go.opentelemetry.io/otel/attribute)

### 相关文档

- [01_Metric类型.md](./01_Metric类型.md)
- [02_数据点.md](./02_数据点.md)
- [03_时间序列.md](./03_时间序列.md)

---

**🎉 恭喜！你已经掌握了标签的完整知识！**

下一步：学习 [聚合](./05_聚合.md) 了解 Sum、LastValue、Histogram。
