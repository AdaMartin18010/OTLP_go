# 时间序列完整指南

## 📋 目录

- [时间序列完整指南](#时间序列完整指南)
  - [📋 目录](#-目录)
  - [概述](#概述)
    - [核心概念](#核心概念)
    - [时间序列模型](#时间序列模型)
  - [Temporality (时间性)](#temporality-时间性)
    - [定义](#定义)
    - [Cumulative (累积)](#cumulative-累积)
    - [Delta (增量)](#delta-增量)
    - [对比分析](#对比分析)
    - [Go 实现](#go-实现)
  - [Aggregation (聚合)](#aggregation-聚合)
    - [聚合类型](#聚合类型)
    - [Sum (求和)](#sum-求和)
    - [LastValue (最新值)](#lastvalue-最新值)
    - [Histogram (直方图)](#histogram-直方图)
    - [ExponentialHistogram (指数直方图)](#exponentialhistogram-指数直方图)
  - [Aggregation Temporality](#aggregation-temporality)
    - [Counter 聚合](#counter-聚合)
    - [UpDownCounter 聚合](#updowncounter-聚合)
    - [Gauge 聚合](#gauge-聚合)
    - [Histogram 聚合](#histogram-聚合)
  - [时间窗口管理](#时间窗口管理)
    - [窗口类型](#窗口类型)
    - [滚动窗口](#滚动窗口)
    - [滑动窗口](#滑动窗口)
    - [Go 实现2](#go-实现2)
  - [时间对齐](#时间对齐)
    - [对齐策略](#对齐策略)
    - [时钟偏移处理](#时钟偏移处理)
    - [Go 实现3](#go-实现3)
  - [降采样与上采样](#降采样与上采样)
    - [降采样](#降采样)
    - [上采样](#上采样)
    - [Go 实现4](#go-实现4)
  - [时间序列存储](#时间序列存储)
    - [存储模型](#存储模型)
    - [压缩策略](#压缩策略)
    - [索引优化](#索引优化)
  - [时间序列查询](#时间序列查询)
    - [查询语言](#查询语言)
    - [PromQL 示例](#promql-示例)
    - [Go 客户端查询](#go-客户端查询)
  - [完整实现](#完整实现)
    - [时间序列管理系统](#时间序列管理系统)
  - [最佳实践](#最佳实践)
    - [1. 选择合适的 Temporality](#1-选择合适的-temporality)
    - [2. 合理的聚合粒度](#2-合理的聚合粒度)
    - [3. 时间窗口配置](#3-时间窗口配置)
    - [4. 高基数处理](#4-高基数处理)
  - [性能优化](#性能优化)
    - [1. 批量聚合](#1-批量聚合)
    - [2. 预聚合](#2-预聚合)
    - [3. 分片策略](#3-分片策略)
  - [常见问题](#常见问题)
    - [Q1: Cumulative 和 Delta 如何选择？](#q1-cumulative-和-delta-如何选择)
    - [Q2: 如何处理时间窗口重叠？](#q2-如何处理时间窗口重叠)
    - [Q3: 如何处理时钟偏移？](#q3-如何处理时钟偏移)
    - [Q4: 降采样会丢失数据吗？](#q4-降采样会丢失数据吗)
    - [Q5: 如何优化时间序列存储？](#q5-如何优化时间序列存储)
  - [参考资源](#参考资源)
    - [官方文档](#官方文档)
    - [Go 实现5](#go-实现5)
    - [相关文档](#相关文档)

---

## 概述

**时间序列 (Time Series)** 是按时间顺序排列的数据点集合，用于表示某个指标随时间变化的趋势。

### 核心概念

- ✅ **Temporality**: 时间性，定义数据点的时间语义
- ✅ **Aggregation**: 聚合，定义如何组合多个观测值
- ✅ **Time Window**: 时间窗口，数据采集的时间范围
- ✅ **Resolution**: 分辨率，数据点的时间间隔

### 时间序列模型

```text
Time Series = {(t₁, v₁), (t₂, v₂), ..., (tₙ, vₙ)}

其中:
- tᵢ: 时间戳
- vᵢ: 观测值
- tᵢ < tᵢ₊₁ (单调递增)
```

---

## Temporality (时间性)

### 定义

**Temporality** 定义了数据点的时间语义，决定了如何解释数据点的值。

### Cumulative (累积)

**值是从起始时间累积到当前的总量**。

```text
特点:
- 起始时间: 进程启动或首次记录
- 值是累积的总量
- 适合长期趋势分析

示例:
T0: value = 10  (累积: 0 → 10)
T1: value = 25  (累积: 0 → 25)
T2: value = 42  (累积: 0 → 42)

┌─────────────────────────────────────┐
│ Cumulative Counter                  │
│                                     │
│ 50│                          ●42   │
│   │                    ●25         │
│ 30│                               │
│   │              ●10              │
│ 10│                               │
│   └────┬────┬────┬────────────────│
│       T0   T1   T2               │
└─────────────────────────────────────┘
```

### Delta (增量)

**值是两次导出之间的变化量**。

```text
特点:
- 起始时间: 上次导出时间
- 值是时间段内的增量
- 适合短期变化监控

示例:
T0→T1: value = 10  (增量: +10)
T1→T2: value = 15  (增量: +15)
T2→T3: value = 17  (增量: +17)

┌─────────────────────────────────────┐
│ Delta Counter                       │
│                                     │
│ 20│        ●17                      │
│   │    ●15                          │
│ 10│●10                              │
│   │                                 │
│  0└────┬────┬────┬────────────────│
│      T0→T1 T1→T2 T2→T3           │
└─────────────────────────────────────┘
```

### 对比分析

| 特性 | Cumulative | Delta |
|------|------------|-------|
| **起始时间** | 进程启动 | 上次导出 |
| **值的含义** | 累积总量 | 时间段增量 |
| **Reset 处理** | 需要检测重启 | 自动处理 |
| **存储空间** | 较大 | 较小 |
| **聚合复杂度** | 简单 (取最新值) | 复杂 (需累加) |
| **适用场景** | Prometheus | StatsD, DataDog |

### Go 实现

```go
package timeseries

import (
    "go.opentelemetry.io/otel/sdk/metric"
    "go.opentelemetry.io/otel/sdk/metric/metricdata"
)

// 配置 Temporality
func setupTemporality(exporter metric.Exporter) *metric.PeriodicReader {
    // 1. 全部使用 Cumulative
    return metric.NewPeriodicReader(
        exporter,
        metric.WithTemporalitySelector(
            func(ik metric.InstrumentKind) metricdata.Temporality {
                return metricdata.CumulativeTemporality
            },
        ),
    )
}

// 2. 根据 Instrument 类型选择
func setupMixedTemporality(exporter metric.Exporter) *metric.PeriodicReader {
    return metric.NewPeriodicReader(
        exporter,
        metric.WithTemporalitySelector(
            func(ik metric.InstrumentKind) metricdata.Temporality {
                switch ik {
                case metric.InstrumentKindCounter:
                    return metricdata.DeltaTemporality
                case metric.InstrumentKindUpDownCounter:
                    return metricdata.CumulativeTemporality
                case metric.InstrumentKindHistogram:
                    return metricdata.DeltaTemporality
                default:
                    return metricdata.CumulativeTemporality
                }
            },
        ),
    )
}

// 3. Prometheus 风格 (全部 Cumulative)
func setupPrometheusTemporality(exporter metric.Exporter) *metric.PeriodicReader {
    return metric.NewPeriodicReader(
        exporter,
        metric.WithTemporalitySelector(
            func(ik metric.InstrumentKind) metricdata.Temporality {
                return metricdata.CumulativeTemporality
            },
        ),
    )
}

// 4. StatsD 风格 (全部 Delta)
func setupStatsDTemporality(exporter metric.Exporter) *metric.PeriodicReader {
    return metric.NewPeriodicReader(
        exporter,
        metric.WithTemporalitySelector(
            func(ik metric.InstrumentKind) metricdata.Temporality {
                return metricdata.DeltaTemporality
            },
        ),
    )
}
```

---

## Aggregation (聚合)

### 聚合类型

OpenTelemetry 定义了多种聚合方式：

| 聚合类型 | 适用 Metric | 说明 |
|---------|-------------|------|
| **Sum** | Counter, UpDownCounter | 求和 |
| **LastValue** | Gauge | 最新值 |
| **Histogram** | Histogram | 分布统计 |
| **ExponentialHistogram** | Histogram | 指数分布 |

### Sum (求和)

```go
// Sum 聚合
type SumAggregation struct {
    Value        float64
    StartTime    time.Time
    EndTime      time.Time
    Temporality  metricdata.Temporality
}

// 累加观测值
func (s *SumAggregation) Aggregate(value float64) {
    s.Value += value
    s.EndTime = time.Now()
}

// 导出数据点
func (s *SumAggregation) Export() metricdata.DataPoint {
    return metricdata.DataPoint{
        StartTime: s.StartTime,
        Time:      s.EndTime,
        Value:     s.Value,
    }
}

// Reset (Delta 模式)
func (s *SumAggregation) Reset() {
    s.StartTime = s.EndTime
    s.Value = 0
}
```

### LastValue (最新值)

```go
// LastValue 聚合
type LastValueAggregation struct {
    Value     float64
    Timestamp time.Time
}

// 更新为最新值
func (lv *LastValueAggregation) Update(value float64, timestamp time.Time) {
    if timestamp.After(lv.Timestamp) {
        lv.Value = value
        lv.Timestamp = timestamp
    }
}

// 导出数据点
func (lv *LastValueAggregation) Export() metricdata.DataPoint {
    return metricdata.DataPoint{
        Time:  lv.Timestamp,
        Value: lv.Value,
    }
}
```

### Histogram (直方图)

```go
// Histogram 聚合
type HistogramAggregation struct {
    Bounds       []float64
    Counts       []uint64
    Sum          float64
    Count        uint64
    Min          float64
    Max          float64
    StartTime    time.Time
    EndTime      time.Time
}

func NewHistogramAggregation(bounds []float64) *HistogramAggregation {
    return &HistogramAggregation{
        Bounds:    bounds,
        Counts:    make([]uint64, len(bounds)+1),
        StartTime: time.Now(),
        Min:       math.Inf(1),
        Max:       math.Inf(-1),
    }
}

// 记录观测值
func (h *HistogramAggregation) Record(value float64) {
    h.Count++
    h.Sum += value
    h.EndTime = time.Now()
    
    if value < h.Min {
        h.Min = value
    }
    if value > h.Max {
        h.Max = value
    }
    
    // 找到对应的桶
    bucketIdx := len(h.Bounds)
    for i, bound := range h.Bounds {
        if value <= bound {
            bucketIdx = i
            break
        }
    }
    h.Counts[bucketIdx]++
}

// 导出数据点
func (h *HistogramAggregation) Export() metricdata.HistogramDataPoint {
    return metricdata.HistogramDataPoint{
        StartTime:      h.StartTime,
        Time:           h.EndTime,
        Count:          h.Count,
        Sum:            &h.Sum,
        BucketCounts:   h.Counts,
        ExplicitBounds: h.Bounds,
        Min:            &h.Min,
        Max:            &h.Max,
    }
}

// Reset (Delta 模式)
func (h *HistogramAggregation) Reset() {
    h.StartTime = h.EndTime
    h.Count = 0
    h.Sum = 0
    h.Min = math.Inf(1)
    h.Max = math.Inf(-1)
    for i := range h.Counts {
        h.Counts[i] = 0
    }
}
```

### ExponentialHistogram (指数直方图)

```go
// ExponentialHistogram 聚合
type ExponentialHistogramAggregation struct {
    Scale        int32
    ZeroCount    uint64
    PositiveBuckets map[int32]uint64
    NegativeBuckets map[int32]uint64
    Sum          float64
    Count        uint64
    StartTime    time.Time
    EndTime      time.Time
}

func NewExponentialHistogramAggregation(scale int32) *ExponentialHistogramAggregation {
    return &ExponentialHistogramAggregation{
        Scale:           scale,
        PositiveBuckets: make(map[int32]uint64),
        NegativeBuckets: make(map[int32]uint64),
        StartTime:       time.Now(),
    }
}

// 计算桶索引
func (eh *ExponentialHistogramAggregation) bucketIndex(value float64) int32 {
    if value == 0 {
        return 0
    }
    
    import "math"
    base := math.Pow(2, math.Pow(2, float64(-eh.Scale)))
    return int32(math.Floor(math.Log(math.Abs(value)) / math.Log(base)))
}

// 记录观测值
func (eh *ExponentialHistogramAggregation) Record(value float64) {
    eh.Count++
    eh.Sum += value
    eh.EndTime = time.Now()
    
    if value == 0 {
        eh.ZeroCount++
        return
    }
    
    idx := eh.bucketIndex(value)
    if value > 0 {
        eh.PositiveBuckets[idx]++
    } else {
        eh.NegativeBuckets[idx]++
    }
}
```

---

## Aggregation Temporality

### Counter 聚合

```go
// Counter: Sum + Cumulative/Delta
type CounterAggregation struct {
    value       int64
    startTime   time.Time
    temporality metricdata.Temporality
}

func (c *CounterAggregation) Add(delta int64) {
    atomic.AddInt64(&c.value, delta)
}

func (c *CounterAggregation) Export() (int64, bool) {
    value := atomic.LoadInt64(&c.value)
    
    if c.temporality == metricdata.DeltaTemporality {
        // Delta: 导出后重置
        atomic.StoreInt64(&c.value, 0)
        c.startTime = time.Now()
        return value, true
    }
    
    // Cumulative: 保持累积值
    return value, false
}
```

### UpDownCounter 聚合

```go
// UpDownCounter: Sum + Cumulative/Delta
type UpDownCounterAggregation struct {
    value       int64
    startTime   time.Time
    temporality metricdata.Temporality
}

func (udc *UpDownCounterAggregation) Add(delta int64) {
    atomic.AddInt64(&udc.value, delta)
}

func (udc *UpDownCounterAggregation) Export() (int64, bool) {
    value := atomic.LoadInt64(&udc.value)
    
    if udc.temporality == metricdata.DeltaTemporality {
        atomic.StoreInt64(&udc.value, 0)
        udc.startTime = time.Now()
        return value, true
    }
    
    return value, false
}
```

### Gauge 聚合

```go
// Gauge: LastValue (无 Temporality)
type GaugeAggregation struct {
    value     float64
    timestamp time.Time
    mu        sync.RWMutex
}

func (g *GaugeAggregation) Set(value float64) {
    g.mu.Lock()
    g.value = value
    g.timestamp = time.Now()
    g.mu.Unlock()
}

func (g *GaugeAggregation) Export() (float64, time.Time) {
    g.mu.RLock()
    defer g.mu.RUnlock()
    return g.value, g.timestamp
}
```

### Histogram 聚合

```go
// Histogram: Histogram + Cumulative/Delta
type HistogramAggregationWithTemporality struct {
    *HistogramAggregation
    temporality metricdata.Temporality
}

func (h *HistogramAggregationWithTemporality) Export() metricdata.HistogramDataPoint {
    dp := h.HistogramAggregation.Export()
    
    if h.temporality == metricdata.DeltaTemporality {
        h.HistogramAggregation.Reset()
    }
    
    return dp
}
```

---

## 时间窗口管理

### 窗口类型

```text
1. 固定窗口 (Fixed Window):
   [0, 60s] [60s, 120s] [120s, 180s] ...

2. 滚动窗口 (Tumbling Window):
   每60s一个窗口，无重叠

3. 滑动窗口 (Sliding Window):
   每10s滑动一次，窗口60s
   [0, 60s] [10s, 70s] [20s, 80s] ...

4. 会话窗口 (Session Window):
   基于活动间隔
```

### 滚动窗口

```go
// 滚动窗口
type TumblingWindow struct {
    interval time.Duration
    data     []float64
    startTime time.Time
    mu       sync.Mutex
}

func NewTumblingWindow(interval time.Duration) *TumblingWindow {
    return &TumblingWindow{
        interval:  interval,
        data:      make([]float64, 0, 1000),
        startTime: time.Now(),
    }
}

func (tw *TumblingWindow) Add(value float64) {
    tw.mu.Lock()
    defer tw.mu.Unlock()
    
    now := time.Now()
    if now.Sub(tw.startTime) >= tw.interval {
        // 窗口结束，导出数据
        tw.export()
        tw.data = tw.data[:0]
        tw.startTime = now
    }
    
    tw.data = append(tw.data, value)
}

func (tw *TumblingWindow) export() {
    // 计算聚合值
    var sum float64
    for _, v := range tw.data {
        sum += v
    }
    avg := sum / float64(len(tw.data))
    
    fmt.Printf("Window [%v, %v): count=%d, sum=%.2f, avg=%.2f\n",
        tw.startTime, time.Now(), len(tw.data), sum, avg)
}
```

### 滑动窗口

```go
// 滑动窗口
type SlidingWindow struct {
    windowSize time.Duration
    slideInterval time.Duration
    data       []TimestampedValue
    mu         sync.RWMutex
}

type TimestampedValue struct {
    Value     float64
    Timestamp time.Time
}

func NewSlidingWindow(windowSize, slideInterval time.Duration) *SlidingWindow {
    sw := &SlidingWindow{
        windowSize:    windowSize,
        slideInterval: slideInterval,
        data:          make([]TimestampedValue, 0, 10000),
    }
    
    // 定期清理过期数据
    go sw.cleanup()
    
    return sw
}

func (sw *SlidingWindow) Add(value float64) {
    sw.mu.Lock()
    defer sw.mu.Unlock()
    
    sw.data = append(sw.data, TimestampedValue{
        Value:     value,
        Timestamp: time.Now(),
    })
}

func (sw *SlidingWindow) GetWindowData() []float64 {
    sw.mu.RLock()
    defer sw.mu.RUnlock()
    
    cutoff := time.Now().Add(-sw.windowSize)
    result := make([]float64, 0, len(sw.data))
    
    for _, tv := range sw.data {
        if tv.Timestamp.After(cutoff) {
            result = append(result, tv.Value)
        }
    }
    
    return result
}

func (sw *SlidingWindow) cleanup() {
    ticker := time.NewTicker(sw.slideInterval)
    defer ticker.Stop()
    
    for range ticker.C {
        sw.mu.Lock()
        cutoff := time.Now().Add(-sw.windowSize)
        
        // 移除过期数据
        validIdx := 0
        for i, tv := range sw.data {
            if tv.Timestamp.After(cutoff) {
                validIdx = i
                break
            }
        }
        sw.data = sw.data[validIdx:]
        sw.mu.Unlock()
    }
}
```

### Go 实现2

```go
// 完整的窗口管理器
type WindowManager struct {
    windows map[string]*TumblingWindow
    mu      sync.RWMutex
}

func NewWindowManager() *WindowManager {
    return &WindowManager{
        windows: make(map[string]*TumblingWindow),
    }
}

func (wm *WindowManager) GetOrCreateWindow(
    name string,
    interval time.Duration,
) *TumblingWindow {
    wm.mu.Lock()
    defer wm.mu.Unlock()
    
    if window, exists := wm.windows[name]; exists {
        return window
    }
    
    window := NewTumblingWindow(interval)
    wm.windows[name] = window
    return window
}
```

---

## 时间对齐

### 对齐策略

```go
// 时间对齐器
type TimeAligner struct {
    interval time.Duration
}

func NewTimeAligner(interval time.Duration) *TimeAligner {
    return &TimeAligner{interval: interval}
}

// 对齐到最近的时间点
func (ta *TimeAligner) AlignFloor(t time.Time) time.Time {
    unix := t.Unix()
    intervalSec := int64(ta.interval.Seconds())
    aligned := (unix / intervalSec) * intervalSec
    return time.Unix(aligned, 0)
}

// 对齐到下一个时间点
func (ta *TimeAligner) AlignCeil(t time.Time) time.Time {
    unix := t.Unix()
    intervalSec := int64(ta.interval.Seconds())
    aligned := ((unix + intervalSec - 1) / intervalSec) * intervalSec
    return time.Unix(aligned, 0)
}

// 示例
func exampleTimeAlignment() {
    aligner := NewTimeAligner(60 * time.Second)
    
    now := time.Now()
    // 2025-10-09 14:32:45
    
    floor := aligner.AlignFloor(now)
    // 2025-10-09 14:32:00
    
    ceil := aligner.AlignCeil(now)
    // 2025-10-09 14:33:00
}
```

### 时钟偏移处理

```go
// 时钟偏移检测
type ClockSkewDetector struct {
    lastTimestamp time.Time
    maxSkew       time.Duration
    mu            sync.Mutex
}

func NewClockSkewDetector(maxSkew time.Duration) *ClockSkewDetector {
    return &ClockSkewDetector{
        maxSkew: maxSkew,
    }
}

func (csd *ClockSkewDetector) CheckAndUpdate(t time.Time) error {
    csd.mu.Lock()
    defer csd.mu.Unlock()
    
    if !csd.lastTimestamp.IsZero() {
        if t.Before(csd.lastTimestamp) {
            skew := csd.lastTimestamp.Sub(t)
            if skew > csd.maxSkew {
                return fmt.Errorf("clock skew detected: %v", skew)
            }
        }
    }
    
    csd.lastTimestamp = t
    return nil
}
```

### Go 实现3

```go
// NTP 时间同步
func syncTimeWithNTP(server string) (time.Time, error) {
    import "github.com/beevik/ntp"
    
    response, err := ntp.Query(server)
    if err != nil {
        return time.Time{}, err
    }
    
    return time.Now().Add(response.ClockOffset), nil
}

// 使用 NTP 时间
func useNTPTime() {
    ntpTime, err := syncTimeWithNTP("pool.ntp.org")
    if err != nil {
        log.Printf("NTP sync failed: %v", err)
        return
    }
    
    offset := ntpTime.Sub(time.Now())
    log.Printf("Clock offset: %v", offset)
}
```

---

## 降采样与上采样

### 降采样

**降采样 (Downsampling)**: 降低时间序列的分辨率。

```go
// 降采样器
type Downsampler struct {
    interval time.Duration
}

func NewDownsampler(interval time.Duration) *Downsampler {
    return &Downsampler{interval: interval}
}

// 平均值降采样
func (ds *Downsampler) DownsampleAverage(
    data []TimestampedValue,
) []TimestampedValue {
    if len(data) == 0 {
        return nil
    }
    
    result := make([]TimestampedValue, 0)
    aligner := NewTimeAligner(ds.interval)
    
    var bucket []float64
    var bucketTime time.Time
    
    for _, tv := range data {
        aligned := aligner.AlignFloor(tv.Timestamp)
        
        if bucketTime.IsZero() || aligned == bucketTime {
            bucket = append(bucket, tv.Value)
            bucketTime = aligned
        } else {
            // 计算平均值
            if len(bucket) > 0 {
                var sum float64
                for _, v := range bucket {
                    sum += v
                }
                result = append(result, TimestampedValue{
                    Value:     sum / float64(len(bucket)),
                    Timestamp: bucketTime,
                })
            }
            
            bucket = []float64{tv.Value}
            bucketTime = aligned
        }
    }
    
    // 最后一个桶
    if len(bucket) > 0 {
        var sum float64
        for _, v := range bucket {
            sum += v
        }
        result = append(result, TimestampedValue{
            Value:     sum / float64(len(bucket)),
            Timestamp: bucketTime,
        })
    }
    
    return result
}

// 最大值降采样
func (ds *Downsampler) DownsampleMax(
    data []TimestampedValue,
) []TimestampedValue {
    // 类似实现，使用 max 而不是 average
    return nil
}

// 最小值降采样
func (ds *Downsampler) DownsampleMin(
    data []TimestampedValue,
) []TimestampedValue {
    // 类似实现，使用 min 而不是 average
    return nil
}
```

### 上采样

**上采样 (Upsampling)**: 增加时间序列的分辨率。

```go
// 上采样器
type Upsampler struct {
    interval time.Duration
}

func NewUpsampler(interval time.Duration) *Upsampler {
    return &Upsampler{interval: interval}
}

// 线性插值上采样
func (us *Upsampler) UpsampleLinear(
    data []TimestampedValue,
) []TimestampedValue {
    if len(data) < 2 {
        return data
    }
    
    result := make([]TimestampedValue, 0)
    
    for i := 0; i < len(data)-1; i++ {
        current := data[i]
        next := data[i+1]
        
        result = append(result, current)
        
        // 计算插值点
        duration := next.Timestamp.Sub(current.Timestamp)
        numPoints := int(duration / us.interval)
        
        for j := 1; j < numPoints; j++ {
            t := current.Timestamp.Add(time.Duration(j) * us.interval)
            // 线性插值
            ratio := float64(j) / float64(numPoints)
            value := current.Value + (next.Value-current.Value)*ratio
            
            result = append(result, TimestampedValue{
                Value:     value,
                Timestamp: t,
            })
        }
    }
    
    result = append(result, data[len(data)-1])
    return result
}
```

### Go 实现4

```go
// 自适应采样
type AdaptiveSampler struct {
    minInterval time.Duration
    maxInterval time.Duration
    threshold   float64
}

func (as *AdaptiveSampler) Sample(
    data []TimestampedValue,
) []TimestampedValue {
    result := make([]TimestampedValue, 0)
    
    for i := 0; i < len(data); i++ {
        if i == 0 || i == len(data)-1 {
            result = append(result, data[i])
            continue
        }
        
        // 计算变化率
        prev := data[i-1].Value
        curr := data[i].Value
        change := math.Abs(curr - prev)
        
        // 变化大时保留
        if change > as.threshold {
            result = append(result, data[i])
        }
    }
    
    return result
}
```

---

## 时间序列存储

### 存储模型

```go
// 时间序列存储
type TimeSeriesStore struct {
    data   map[string][]TimestampedValue
    mu     sync.RWMutex
    maxSize int
}

func NewTimeSeriesStore(maxSize int) *TimeSeriesStore {
    return &TimeSeriesStore{
        data:    make(map[string][]TimestampedValue),
        maxSize: maxSize,
    }
}

func (tss *TimeSeriesStore) Append(
    seriesName string,
    value float64,
    timestamp time.Time,
) {
    tss.mu.Lock()
    defer tss.mu.Unlock()
    
    series := tss.data[seriesName]
    series = append(series, TimestampedValue{
        Value:     value,
        Timestamp: timestamp,
    })
    
    // 限制大小
    if len(series) > tss.maxSize {
        series = series[len(series)-tss.maxSize:]
    }
    
    tss.data[seriesName] = series
}

func (tss *TimeSeriesStore) Query(
    seriesName string,
    start, end time.Time,
) []TimestampedValue {
    tss.mu.RLock()
    defer tss.mu.RUnlock()
    
    series := tss.data[seriesName]
    result := make([]TimestampedValue, 0)
    
    for _, tv := range series {
        if tv.Timestamp.After(start) && tv.Timestamp.Before(end) {
            result = append(result, tv)
        }
    }
    
    return result
}
```

### 压缩策略

```go
// Delta-of-Delta 压缩
type DeltaOfDeltaCompressor struct {
    lastValue     int64
    lastDelta     int64
    lastTimestamp int64
}

func (doc *DeltaOfDeltaCompressor) Compress(
    value int64,
    timestamp int64,
) (valueDelta, timeDelta int64) {
    if doc.lastTimestamp == 0 {
        doc.lastValue = value
        doc.lastTimestamp = timestamp
        return value, timestamp
    }
    
    // 计算 delta
    valueDelta = value - doc.lastValue
    timeDelta = timestamp - doc.lastTimestamp
    
    // 计算 delta-of-delta
    valueDeltaOfDelta := valueDelta - doc.lastDelta
    
    doc.lastValue = value
    doc.lastDelta = valueDelta
    doc.lastTimestamp = timestamp
    
    return valueDeltaOfDelta, timeDelta
}
```

### 索引优化

```go
// 时间序列索引
type TimeSeriesIndex struct {
    labelIndex map[string][]string // label -> series names
    mu         sync.RWMutex
}

func NewTimeSeriesIndex() *TimeSeriesIndex {
    return &TimeSeriesIndex{
        labelIndex: make(map[string][]string),
    }
}

func (tsi *TimeSeriesIndex) Index(
    seriesName string,
    labels map[string]string,
) {
    tsi.mu.Lock()
    defer tsi.mu.Unlock()
    
    for key, value := range labels {
        labelKey := key + "=" + value
        tsi.labelIndex[labelKey] = append(
            tsi.labelIndex[labelKey],
            seriesName,
        )
    }
}

func (tsi *TimeSeriesIndex) Query(
    labelKey, labelValue string,
) []string {
    tsi.mu.RLock()
    defer tsi.mu.RUnlock()
    
    labelKey = labelKey + "=" + labelValue
    return tsi.labelIndex[labelKey]
}
```

---

## 时间序列查询

### 查询语言

```text
常见查询语言:
1. PromQL (Prometheus Query Language)
2. InfluxQL (InfluxDB Query Language)
3. Flux (InfluxDB 2.0+)
4. M3QL (M3DB Query Language)
```

### PromQL 示例

```promql
# 即时查询
http_requests_total

# 范围查询
http_requests_total[5m]

# 聚合
sum(rate(http_requests_total[5m])) by (status)

# 算术运算
http_requests_total / http_requests_duration_seconds_sum

# 预测
predict_linear(http_requests_total[1h], 3600)
```

### Go 客户端查询

```go
import (
    "github.com/prometheus/client_golang/api"
    v1 "github.com/prometheus/client_golang/api/prometheus/v1"
)

// Prometheus 查询
func queryPrometheus(query string) error {
    client, err := api.NewClient(api.Config{
        Address: "http://localhost:9090",
    })
    if err != nil {
        return err
    }
    
    v1api := v1.NewAPI(client)
    ctx := context.Background()
    
    // 即时查询
    result, warnings, err := v1api.Query(ctx, query, time.Now())
    if err != nil {
        return err
    }
    
    for _, w := range warnings {
        log.Printf("Warning: %s", w)
    }
    
    fmt.Printf("Result: %v\n", result)
    return nil
}

// 范围查询
func queryPrometheusRange(query string, start, end time.Time, step time.Duration) error {
    client, err := api.NewClient(api.Config{
        Address: "http://localhost:9090",
    })
    if err != nil {
        return err
    }
    
    v1api := v1.NewAPI(client)
    ctx := context.Background()
    
    r := v1.Range{
        Start: start,
        End:   end,
        Step:  step,
    }
    
    result, warnings, err := v1api.QueryRange(ctx, query, r)
    if err != nil {
        return err
    }
    
    for _, w := range warnings {
        log.Printf("Warning: %s", w)
    }
    
    fmt.Printf("Result: %v\n", result)
    return nil
}
```

---

## 完整实现

### 时间序列管理系统

```go
package timeseries

import (
    "context"
    "sync"
    "time"
)

// TimeSeriesManager 时间序列管理器
type TimeSeriesManager struct {
    store       *TimeSeriesStore
    index       *TimeSeriesIndex
    downsampler *Downsampler
    aligner     *TimeAligner
    mu          sync.RWMutex
}

func NewTimeSeriesManager(
    maxSize int,
    downsampleInterval time.Duration,
    alignInterval time.Duration,
) *TimeSeriesManager {
    return &TimeSeriesManager{
        store:       NewTimeSeriesStore(maxSize),
        index:       NewTimeSeriesIndex(),
        downsampler: NewDownsampler(downsampleInterval),
        aligner:     NewTimeAligner(alignInterval),
    }
}

// Record 记录数据点
func (tsm *TimeSeriesManager) Record(
    ctx context.Context,
    seriesName string,
    value float64,
    labels map[string]string,
) {
    timestamp := time.Now()
    alignedTime := tsm.aligner.AlignFloor(timestamp)
    
    // 存储数据
    tsm.store.Append(seriesName, value, alignedTime)
    
    // 索引标签
    tsm.index.Index(seriesName, labels)
}

// Query 查询数据
func (tsm *TimeSeriesManager) Query(
    seriesName string,
    start, end time.Time,
    downsample bool,
) []TimestampedValue {
    data := tsm.store.Query(seriesName, start, end)
    
    if downsample {
        data = tsm.downsampler.DownsampleAverage(data)
    }
    
    return data
}

// QueryByLabel 按标签查询
func (tsm *TimeSeriesManager) QueryByLabel(
    labelKey, labelValue string,
    start, end time.Time,
) map[string][]TimestampedValue {
    seriesNames := tsm.index.Query(labelKey, labelValue)
    
    result := make(map[string][]TimestampedValue)
    for _, name := range seriesNames {
        result[name] = tsm.store.Query(name, start, end)
    }
    
    return result
}

// Aggregate 聚合多个序列
func (tsm *TimeSeriesManager) Aggregate(
    seriesNames []string,
    start, end time.Time,
    aggFunc func([]float64) float64,
) []TimestampedValue {
    // 获取所有序列数据
    allData := make([][]TimestampedValue, len(seriesNames))
    for i, name := range seriesNames {
        allData[i] = tsm.store.Query(name, start, end)
    }
    
    // 时间对齐和聚合
    result := make([]TimestampedValue, 0)
    // ... 实现聚合逻辑
    
    return result
}
```

---

## 最佳实践

### 1. 选择合适的 Temporality

```go
// ✅ 推荐：根据后端选择
// Prometheus: Cumulative
// StatsD/DataDog: Delta

func setupForPrometheus() {
    // 使用 Cumulative
}

func setupForStatsD() {
    // 使用 Delta
}
```

### 2. 合理的聚合粒度

```go
// ✅ 推荐：多级聚合
// 原始数据: 1s
// 1分钟聚合: 降采样到 10s
// 1小时聚合: 降采样到 1min
// 1天聚合: 降采样到 5min

type MultiLevelAggregation struct {
    raw       *TimeSeriesStore  // 1s
    minute    *TimeSeriesStore  // 10s
    hour      *TimeSeriesStore  // 1min
    day       *TimeSeriesStore  // 5min
}
```

### 3. 时间窗口配置

```go
// ✅ 推荐：根据场景选择窗口大小
const (
    RealtimeWindow  = 5 * time.Minute   // 实时监控
    ShortTermWindow = 1 * time.Hour     // 短期分析
    LongTermWindow  = 24 * time.Hour    // 长期趋势
)
```

### 4. 高基数处理

```go
// ✅ 推荐：限制标签基数
const MaxCardinality = 10000

func checkCardinality(labels map[string]string) error {
    // 检查标签组合数量
    if cardinality > MaxCardinality {
        return fmt.Errorf("cardinality too high: %d", cardinality)
    }
    return nil
}
```

---

## 性能优化

### 1. 批量聚合

```go
// ✅ 批量处理
func batchAggregate(data []TimestampedValue, batchSize int) {
    for i := 0; i < len(data); i += batchSize {
        end := i + batchSize
        if end > len(data) {
            end = len(data)
        }
        batch := data[i:end]
        processBatch(batch)
    }
}
```

### 2. 预聚合

```go
// ✅ 预聚合热数据
type PreAggregator struct {
    cache map[string]float64
    mu    sync.RWMutex
}

func (pa *PreAggregator) Update(key string, value float64) {
    pa.mu.Lock()
    pa.cache[key] += value
    pa.mu.Unlock()
}
```

### 3. 分片策略

```go
// ✅ 按时间分片
type ShardedStore struct {
    shards    []*TimeSeriesStore
    shardSize time.Duration
}

func (ss *ShardedStore) getShard(t time.Time) *TimeSeriesStore {
    idx := int(t.Unix() / int64(ss.shardSize.Seconds()))
    return ss.shards[idx%len(ss.shards)]
}
```

---

## 常见问题

### Q1: Cumulative 和 Delta 如何选择？

**A**: 根据监控后端

- **Prometheus**: Cumulative
- **StatsD/DataDog**: Delta
- **混合环境**: 根据 Instrument 类型分别配置

---

### Q2: 如何处理时间窗口重叠？

**A**: 使用滚动窗口避免重叠，或使用滑动窗口并去重

---

### Q3: 如何处理时钟偏移？

**A**:

1. 使用 NTP 同步
2. 检测并记录偏移
3. 容忍小范围偏移 (< 5s)

---

### Q4: 降采样会丢失数据吗？

**A**:

- 平均值降采样: 保留趋势
- 最大/最小值降采样: 保留极值
- 使用多种聚合方式保留更多信息

---

### Q5: 如何优化时间序列存储？

**A**:

1. 使用压缩 (Delta-of-Delta)
2. 分级存储 (热/冷数据)
3. 定期清理过期数据
4. 使用专用时序数据库

---

## 参考资源

### 官方文档

- [OpenTelemetry Metrics Data Model](https://opentelemetry.io/docs/specs/otel/metrics/data-model/)
- [Temporality](https://opentelemetry.io/docs/specs/otel/metrics/data-model/#temporality)

### Go 实现5

- [go.opentelemetry.io/otel/sdk/metric](https://pkg.go.dev/go.opentelemetry.io/otel/sdk/metric)

### 相关文档

- [01_Metric类型.md](./01_Metric类型.md)
- [02_数据点.md](./02_数据点.md)
- [04_标签.md](./04_标签.md)

---

**🎉 恭喜！你已经掌握了时间序列的完整知识！**

下一步：学习 [标签](./04_标签.md) 了解 Attributes 和 Exemplars。
