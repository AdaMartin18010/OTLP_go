# 数据点完整指南

## 📋 目录

- [数据点完整指南](#数据点完整指南)
  - [📋 目录](#-目录)
  - [概述](#概述)
    - [核心概念](#核心概念)
    - [数据点生命周期](#数据点生命周期)
  - [NumberDataPoint (数值数据点)](#numberdatapoint-数值数据点)
    - [数据结构](#数据结构)
    - [字段详解](#字段详解)
    - [Go 实现](#go-实现)
    - [使用场景](#使用场景)
  - [HistogramDataPoint (直方图数据点)](#histogramdatapoint-直方图数据点)
    - [数据结构2](#数据结构2)
    - [字段详解2](#字段详解2)
    - [Go 实现2](#go-实现2)
    - [桶边界说明](#桶边界说明)
  - [ExponentialHistogramDataPoint (指数直方图数据点)](#exponentialhistogramdatapoint-指数直方图数据点)
    - [数据结构3](#数据结构3)
    - [字段详解3](#字段详解3)
    - [Go 实现3](#go-实现3)
    - [指数桶机制](#指数桶机制)
  - [SummaryDataPoint (摘要数据点)](#summarydatapoint-摘要数据点)
    - [数据结构4](#数据结构4)
    - [字段详解4](#字段详解4)
    - [Go 实现4](#go-实现4)
  - [Exemplar (示例值)](#exemplar-示例值)
    - [定义](#定义)
    - [数据结构5](#数据结构5)
    - [Go 实现5](#go-实现5)
    - [采样策略](#采样策略)
  - [时间戳语义](#时间戳语义)
    - [TimeUnixNano](#timeunixnano)
    - [StartTimeUnixNano](#starttimeunixnano)
    - [时间窗口](#时间窗口)
  - [Temporality (时间性)](#temporality-时间性)
    - [Cumulative (累积)](#cumulative-累积)
    - [Delta (增量)](#delta-增量)
    - [对比分析](#对比分析)
    - [Go 实现6](#go-实现6)
  - [Attributes (属性)](#attributes-属性)
    - [属性管理](#属性管理)
    - [最佳实践](#最佳实践)
    - [Go 实现7](#go-实现7)
  - [Flags (标志位)](#flags-标志位)
    - [定义2](#定义2)
    - [标志位说明](#标志位说明)
    - [Go 实现8](#go-实现8)
  - [完整实现](#完整实现)
    - [数据点处理系统](#数据点处理系统)
  - [性能优化](#性能优化)
    - [1. 批量处理](#1-批量处理)
    - [2. 内存池](#2-内存池)
    - [3. 零拷贝](#3-零拷贝)
  - [常见问题](#常见问题)
    - [Q1: NumberDataPoint 和 HistogramDataPoint 如何选择？](#q1-numberdatapoint-和-histogramdatapoint-如何选择)
    - [Q2: Exemplar 应该采样多少？](#q2-exemplar-应该采样多少)
    - [Q3: Cumulative 和 Delta 如何选择？](#q3-cumulative-和-delta-如何选择)
    - [Q4: 如何减少数据点的内存占用？](#q4-如何减少数据点的内存占用)
    - [Q5: 如何处理数据点的时间戳？](#q5-如何处理数据点的时间戳)
  - [参考资源](#参考资源)
    - [官方文档](#官方文档)
    - [Go 实现9](#go-实现9)
    - [相关文档](#相关文档)

---

## 概述

**数据点 (DataPoint)** 是 OpenTelemetry Metrics 的核心数据结构，表示在特定时间点或时间段内采集的度量值。

### 核心概念

- ✅ **时间戳**: 记录数据采集的时间
- ✅ **值**: 实际测量的数值
- ✅ **属性**: 描述数据点的维度标签
- ✅ **Exemplar**: 关联的追踪样本

### 数据点生命周期

```text
┌─────────────┐
│  记录观测值   │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  聚合处理    │ ← Delta/Cumulative
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  生成数据点   │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  导出到后端   │
└─────────────┘
```

---

## NumberDataPoint (数值数据点)

### 数据结构

```protobuf
message NumberDataPoint {
  repeated KeyValue attributes = 7;
  fixed64 start_time_unix_nano = 2;
  fixed64 time_unix_nano = 3;
  
  oneof value {
    double as_double = 4;
    sfixed64 as_int = 6;
  }
  
  repeated Exemplar exemplars = 5;
  uint32 flags = 8;
}
```

### 字段详解

| 字段 | 类型 | 说明 |
|------|------|------|
| `attributes` | `[]KeyValue` | 维度标签 |
| `start_time_unix_nano` | `uint64` | 时间窗口起始时间 (纳秒) |
| `time_unix_nano` | `uint64` | 数据点采集时间 (纳秒) |
| `value` | `double/int64` | 数值（浮点或整数） |
| `exemplars` | `[]Exemplar` | 关联的示例值 |
| `flags` | `uint32` | 标志位 |

### Go 实现

```go
package main

import (
    "context"
    "time"

    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/sdk/metric/metricdata"
)

// NumberDataPoint 的 Go 表示
type NumberDataPointExample struct {
    Attributes        attribute.Set
    StartTime         time.Time
    Time              time.Time
    IntValue          *int64
    FloatValue        *float64
    Exemplars         []ExemplarExample
    Flags             uint32
}

// 创建整数数据点
func createIntDataPoint(value int64, attrs []attribute.KeyValue) *NumberDataPointExample {
    now := time.Now()
    return &NumberDataPointExample{
        Attributes: attribute.NewSet(attrs...),
        StartTime:  now.Add(-time.Minute),
        Time:       now,
        IntValue:   &value,
        Flags:      0,
    }
}

// 创建浮点数据点
func createFloatDataPoint(value float64, attrs []attribute.KeyValue) *NumberDataPointExample {
    now := time.Now()
    return &NumberDataPointExample{
        Attributes: attribute.NewSet(attrs...),
        StartTime:  now.Add(-time.Minute),
        Time:       now,
        FloatValue: &value,
        Flags:      0,
    }
}

// 实际使用：Counter 生成 NumberDataPoint
func recordCounterDataPoint(ctx context.Context, counter metric.Int64Counter) {
    counter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("http.method", "GET"),
            attribute.String("http.route", "/api/users"),
            attribute.Int("http.status_code", 200),
        ),
    )
    // SDK 内部会创建 NumberDataPoint
}
```

### 使用场景

- ✅ **Counter**: 累积计数
- ✅ **UpDownCounter**: 可增减计数
- ✅ **Gauge**: 瞬时值

---

## HistogramDataPoint (直方图数据点)

### 数据结构2

```protobuf
message HistogramDataPoint {
  repeated KeyValue attributes = 9;
  fixed64 start_time_unix_nano = 2;
  fixed64 time_unix_nano = 3;
  
  uint64 count = 4;
  optional double sum = 5;
  repeated uint64 bucket_counts = 6;
  repeated double explicit_bounds = 7;
  
  repeated Exemplar exemplars = 8;
  uint32 flags = 10;
  
  optional double min = 11;
  optional double max = 12;
}
```

### 字段详解2

| 字段 | 类型 | 说明 |
|------|------|------|
| `attributes` | `[]KeyValue` | 维度标签 |
| `start_time_unix_nano` | `uint64` | 时间窗口起始时间 |
| `time_unix_nano` | `uint64` | 数据点采集时间 |
| `count` | `uint64` | 观测值总数 |
| `sum` | `double` | 观测值总和（可选） |
| `bucket_counts` | `[]uint64` | 各桶的计数 |
| `explicit_bounds` | `[]double` | 桶边界 |
| `exemplars` | `[]Exemplar` | 示例值 |
| `flags` | `uint32` | 标志位 |
| `min` | `double` | 最小值（可选） |
| `max` | `double` | 最大值（可选） |

### Go 实现2

```go
// HistogramDataPoint 的 Go 表示
type HistogramDataPointExample struct {
    Attributes     attribute.Set
    StartTime      time.Time
    Time           time.Time
    Count          uint64
    Sum            *float64
    BucketCounts   []uint64
    ExplicitBounds []float64
    Exemplars      []ExemplarExample
    Flags          uint32
    Min            *float64
    Max            *float64
}

// 创建 Histogram 数据点
func createHistogramDataPoint(
    observations []float64,
    bounds []float64,
    attrs []attribute.KeyValue,
) *HistogramDataPointExample {
    now := time.Now()
    
    // 统计各桶的计数
    bucketCounts := make([]uint64, len(bounds)+1)
    var sum float64
    var min, max float64
    
    if len(observations) > 0 {
        min = observations[0]
        max = observations[0]
    }
    
    for _, obs := range observations {
        sum += obs
        if obs < min {
            min = obs
        }
        if obs > max {
            max = obs
        }
        
        // 找到对应的桶
        bucketIdx := 0
        for i, bound := range bounds {
            if obs > bound {
                bucketIdx = i + 1
            } else {
                break
            }
        }
        bucketCounts[bucketIdx]++
    }
    
    return &HistogramDataPointExample{
        Attributes:     attribute.NewSet(attrs...),
        StartTime:      now.Add(-time.Minute),
        Time:           now,
        Count:          uint64(len(observations)),
        Sum:            &sum,
        BucketCounts:   bucketCounts,
        ExplicitBounds: bounds,
        Min:            &min,
        Max:            &max,
    }
}

// 实际使用：Histogram 生成 HistogramDataPoint
func recordHistogramDataPoint(ctx context.Context, histogram metric.Float64Histogram) {
    start := time.Now()
    
    // 模拟请求处理
    time.Sleep(100 * time.Millisecond)
    
    duration := time.Since(start).Seconds()
    histogram.Record(ctx, duration,
        metric.WithAttributes(
            attribute.String("http.method", "GET"),
            attribute.String("http.route", "/api/users"),
        ),
    )
    // SDK 内部会创建 HistogramDataPoint
}
```

### 桶边界说明

```text
Bounds: [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1]

桶划分:
Bucket 0: (-∞, 0.005]
Bucket 1: (0.005, 0.01]
Bucket 2: (0.01, 0.025]
Bucket 3: (0.025, 0.05]
Bucket 4: (0.05, 0.1]
Bucket 5: (0.1, 0.25]
Bucket 6: (0.25, 0.5]
Bucket 7: (0.5, 1]
Bucket 8: (1, +∞)

bucket_counts 长度 = len(bounds) + 1
```

---

## ExponentialHistogramDataPoint (指数直方图数据点)

### 数据结构3

```protobuf
message ExponentialHistogramDataPoint {
  repeated KeyValue attributes = 1;
  fixed64 start_time_unix_nano = 2;
  fixed64 time_unix_nano = 3;
  
  uint64 count = 4;
  optional double sum = 5;
  sint32 scale = 6;
  uint64 zero_count = 7;
  
  Buckets positive = 8;
  Buckets negative = 9;
  
  repeated Exemplar exemplars = 10;
  uint32 flags = 11;
  
  optional double min = 12;
  optional double max = 13;
}

message Buckets {
  sint32 offset = 1;
  repeated uint64 bucket_counts = 2;
}
```

### 字段详解3

| 字段 | 类型 | 说明 |
|------|------|------|
| `scale` | `int32` | 桶的精度等级 |
| `zero_count` | `uint64` | 零值计数 |
| `positive` | `Buckets` | 正值桶 |
| `negative` | `Buckets` | 负值桶 |

### Go 实现3

```go
// ExponentialHistogramDataPoint 的 Go 表示
type ExponentialHistogramDataPointExample struct {
    Attributes attribute.Set
    StartTime  time.Time
    Time       time.Time
    Count      uint64
    Sum        *float64
    Scale      int32
    ZeroCount  uint64
    Positive   BucketsExample
    Negative   BucketsExample
    Exemplars  []ExemplarExample
    Flags      uint32
    Min        *float64
    Max        *float64
}

type BucketsExample struct {
    Offset       int32
    BucketCounts []uint64
}

// 计算桶索引（简化版）
func calculateBucketIndex(value float64, scale int32) int32 {
    if value == 0 {
        return 0
    }
    
    // 对数桶索引计算
    import "math"
    base := math.Pow(2, math.Pow(2, float64(-scale)))
    return int32(math.Floor(math.Log(value) / math.Log(base)))
}
```

### 指数桶机制

```text
Scale = 0: 桶边界 = 2^(2^0) = 2
  Bucket 0: (1, 2]
  Bucket 1: (2, 4]
  Bucket 2: (4, 8]
  Bucket 3: (8, 16]
  ...

Scale = 1: 桶边界 = 2^(2^-1) = √2 ≈ 1.414
  更细粒度的桶划分

Scale = -1: 桶边界 = 2^(2^1) = 4
  更粗粒度的桶划分
```

---

## SummaryDataPoint (摘要数据点)

### 数据结构4

```protobuf
message SummaryDataPoint {
  repeated KeyValue attributes = 7;
  fixed64 start_time_unix_nano = 2;
  fixed64 time_unix_nano = 3;
  
  uint64 count = 4;
  double sum = 5;
  repeated ValueAtQuantile quantile_values = 6;
  
  uint32 flags = 8;
}

message ValueAtQuantile {
  double quantile = 1;  // 0.0 ~ 1.0
  double value = 2;
}
```

### 字段详解4

| 字段 | 类型 | 说明 |
|------|------|------|
| `count` | `uint64` | 观测值总数 |
| `sum` | `double` | 观测值总和 |
| `quantile_values` | `[]ValueAtQuantile` | 分位数值 |

### Go 实现4

```go
// SummaryDataPoint 的 Go 表示
type SummaryDataPointExample struct {
    Attributes     attribute.Set
    StartTime      time.Time
    Time           time.Time
    Count          uint64
    Sum            float64
    QuantileValues []ValueAtQuantileExample
    Flags          uint32
}

type ValueAtQuantileExample struct {
    Quantile float64  // 0.5 = P50, 0.95 = P95, 0.99 = P99
    Value    float64
}

// 创建 Summary 数据点
func createSummaryDataPoint(
    observations []float64,
    quantiles []float64,
    attrs []attribute.KeyValue,
) *SummaryDataPointExample {
    import "sort"
    
    now := time.Now()
    sort.Float64s(observations)
    
    var sum float64
    for _, obs := range observations {
        sum += obs
    }
    
    quantileValues := make([]ValueAtQuantileExample, len(quantiles))
    for i, q := range quantiles {
        idx := int(float64(len(observations)-1) * q)
        quantileValues[i] = ValueAtQuantileExample{
            Quantile: q,
            Value:    observations[idx],
        }
    }
    
    return &SummaryDataPointExample{
        Attributes:     attribute.NewSet(attrs...),
        StartTime:      now.Add(-time.Minute),
        Time:           now,
        Count:          uint64(len(observations)),
        Sum:            sum,
        QuantileValues: quantileValues,
    }
}
```

---

## Exemplar (示例值)

### 定义

**Exemplar** 是与 Metric 数据点关联的 Trace 采样，用于将 Metrics 和 Traces 关联起来。

### 数据结构5

```protobuf
message Exemplar {
  repeated KeyValue filtered_attributes = 7;
  fixed64 time_unix_nano = 2;
  
  oneof value {
    double as_double = 3;
    sfixed64 as_int = 6;
  }
  
  bytes span_id = 4;
  bytes trace_id = 5;
}
```

### Go 实现5

```go
import (
    "go.opentelemetry.io/otel/trace"
)

// Exemplar 的 Go 表示
type ExemplarExample struct {
    FilteredAttributes attribute.Set
    Time               time.Time
    Value              float64  // or int64
    SpanID             trace.SpanID
    TraceID            trace.TraceID
}

// 创建带 Exemplar 的数据点
func recordWithExemplar(ctx context.Context, histogram metric.Float64Histogram) {
    // 从 Context 获取当前 Span
    span := trace.SpanFromContext(ctx)
    spanContext := span.SpanContext()
    
    start := time.Now()
    
    // 处理请求
    time.Sleep(100 * time.Millisecond)
    
    duration := time.Since(start).Seconds()
    
    // 记录 Histogram 值
    // SDK 自动关联 TraceID/SpanID 作为 Exemplar
    histogram.Record(ctx, duration,
        metric.WithAttributes(
            attribute.String("http.method", "GET"),
            attribute.String("http.route", "/api/users"),
        ),
    )
    
    // Exemplar 会自动包含:
    // - trace_id: spanContext.TraceID()
    // - span_id: spanContext.SpanID()
    // - value: duration
    // - time: 记录时间
}
```

### 采样策略

```go
// Exemplar 采样配置
type ExemplarSampler interface {
    ShouldSample(value float64, attributes attribute.Set) bool
}

// 1. 始终采样
type AlwaysSampler struct{}

func (s AlwaysSampler) ShouldSample(value float64, attributes attribute.Set) bool {
    return true
}

// 2. 概率采样
type ProbabilitySampler struct {
    Probability float64  // 0.0 ~ 1.0
}

func (s ProbabilitySampler) ShouldSample(value float64, attributes attribute.Set) bool {
    import "math/rand"
    return rand.Float64() < s.Probability
}

// 3. 异常值采样
type OutlierSampler struct {
    Threshold float64
}

func (s OutlierSampler) ShouldSample(value float64, attributes attribute.Set) bool {
    // 仅采样超过阈值的值
    return value > s.Threshold
}
```

---

## 时间戳语义

### TimeUnixNano

**数据点的观测/采集时间** (纳秒精度 Unix 时间戳)

```go
timeUnixNano := uint64(time.Now().UnixNano())
```

### StartTimeUnixNano

**时间窗口的起始时间**:

- **Cumulative**: 首次记录的时间（进程启动时间）
- **Delta**: 上一次导出的时间

```go
// Cumulative: 从进程启动开始
startTime := processStartTime

// Delta: 从上次导出开始
startTime := lastExportTime
```

### 时间窗口

```text
Cumulative (累积):
  Start: Process Start (T0)
  ─────────────────────────────────────▶
  T0                                  T1
  └────────── Time Window ─────────────┘

Delta (增量):
  Export 1: [T0, T1]
  Export 2: [T1, T2]
  Export 3: [T2, T3]
  ───────┬─────────┬─────────┬─────────▶
        T0        T1        T2        T3
```

---

## Temporality (时间性)

### Cumulative (累积)

从起始时间累积到当前的总值。

```go
// Counter: Cumulative
// T0: 0 → 10
// T1: 0 → 25  (累积值)
// T2: 0 → 42  (累积值)

Export @ T0: value = 10
Export @ T1: value = 25
Export @ T2: value = 42
```

### Delta (增量)

两次导出之间的变化量。

```go
// Counter: Delta
// T0 → T1: +10
// T1 → T2: +15
// T2 → T3: +17

Export @ T0: value = 10   (初始值)
Export @ T1: value = 15   (增量)
Export @ T2: value = 17   (增量)
```

### 对比分析

| 特性 | Cumulative | Delta |
|------|------------|-------|
| **值的含义** | 累积总量 | 时间段增量 |
| **起始时间** | 进程启动 | 上次导出 |
| **聚合** | 简单 (取最新值) | 复杂 (需累加) |
| **存储** | 占用更多 | 占用更少 |
| **适用场景** | 长期趋势 | 短期变化 |

### Go 实现6

```go
import (
    "go.opentelemetry.io/otel/sdk/metric"
)

// 配置 Temporality
func setupTemporality() *metric.PeriodicReader {
    // Cumulative (默认)
    return metric.NewPeriodicReader(
        exporter,
        metric.WithTemporalitySelector(
            func(ik metric.InstrumentKind) metricdata.Temporality {
                return metricdata.CumulativeTemporality
            },
        ),
    )
    
    // Delta
    return metric.NewPeriodicReader(
        exporter,
        metric.WithTemporalitySelector(
            func(ik metric.InstrumentKind) metricdata.Temporality {
                // Counter/UpDownCounter: Delta
                if ik == metric.InstrumentKindCounter ||
                   ik == metric.InstrumentKindUpDownCounter {
                    return metricdata.DeltaTemporality
                }
                // Histogram: Cumulative
                return metricdata.CumulativeTemporality
            },
        ),
    )
}
```

---

## Attributes (属性)

### 属性管理

```go
// 创建属性集
attrs := attribute.NewSet(
    attribute.String("http.method", "GET"),
    attribute.String("http.route", "/api/users"),
    attribute.Int("http.status_code", 200),
)

// 属性不可变
// attrs.Add(...) // ❌ 不存在此方法

// 需要创建新的属性集
newAttrs := attribute.NewSet(
    attribute.String("http.method", "POST"),
    attribute.String("http.route", "/api/users"),
    attribute.Int("http.status_code", 201),
)
```

### 最佳实践

```go
// ✅ 推荐：预定义属性键
var (
    HTTPMethod     = attribute.Key("http.method")
    HTTPRoute      = attribute.Key("http.route")
    HTTPStatusCode = attribute.Key("http.status_code")
)

// 使用
attrs := attribute.NewSet(
    HTTPMethod.String("GET"),
    HTTPRoute.String("/api/users"),
    HTTPStatusCode.Int(200),
)

// ✅ 推荐：属性复用
baseAttrs := []attribute.KeyValue{
    attribute.String("service.name", "my-service"),
    attribute.String("service.version", "1.0.0"),
}

// 每次添加特定属性
requestAttrs := append(baseAttrs,
    attribute.String("http.method", "GET"),
)
```

### Go 实现7

```go
// 高效的属性管理
type AttributeCache struct {
    cache sync.Map  // map[string]attribute.Set
}

func (c *AttributeCache) Get(method, route string, statusCode int) attribute.Set {
    key := fmt.Sprintf("%s|%s|%d", method, route, statusCode)
    
    if cached, ok := c.cache.Load(key); ok {
        return cached.(attribute.Set)
    }
    
    attrs := attribute.NewSet(
        attribute.String("http.method", method),
        attribute.String("http.route", route),
        attribute.Int("http.status_code", statusCode),
    )
    
    c.cache.Store(key, attrs)
    return attrs
}
```

---

## Flags (标志位)

### 定义2

**Flags** 用于标识数据点的特殊状态。

### 标志位说明

```go
const (
    // NoRecordedValue: 无记录值（数据点为空）
    FlagNoRecordedValue = 1 << 0  // 0x01
)

// 检查标志位
func hasNoRecordedValue(flags uint32) bool {
    return flags & FlagNoRecordedValue != 0
}
```

### Go 实现8

```go
// 设置标志位
func createDataPointWithFlags() *NumberDataPointExample {
    return &NumberDataPointExample{
        Attributes: attribute.NewSet(),
        Time:       time.Now(),
        IntValue:   nil,  // 无值
        Flags:      FlagNoRecordedValue,  // 标记为无记录值
    }
}

// 处理带标志位的数据点
func processDataPoint(dp *NumberDataPointExample) {
    if hasNoRecordedValue(dp.Flags) {
        // 跳过无值的数据点
        return
    }
    
    // 正常处理
    if dp.IntValue != nil {
        fmt.Printf("Value: %d\n", *dp.IntValue)
    } else if dp.FloatValue != nil {
        fmt.Printf("Value: %f\n", *dp.FloatValue)
    }
}
```

---

## 完整实现

### 数据点处理系统

```go
package datapoint

import (
    "context"
    "sync"
    "time"

    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/sdk/metric/metricdata"
)

// DataPointProcessor 数据点处理器
type DataPointProcessor struct {
    mu            sync.RWMutex
    numberPoints  []NumberDataPointExample
    histoPoints   []HistogramDataPointExample
    attrCache     *AttributeCache
}

func NewDataPointProcessor() *DataPointProcessor {
    return &DataPointProcessor{
        numberPoints: make([]NumberDataPointExample, 0, 1000),
        histoPoints:  make([]HistogramDataPointExample, 0, 1000),
        attrCache:    &AttributeCache{},
    }
}

// RecordNumber 记录数值数据点
func (p *DataPointProcessor) RecordNumber(
    value float64,
    attrs []attribute.KeyValue,
    startTime, endTime time.Time,
) {
    dp := NumberDataPointExample{
        Attributes: attribute.NewSet(attrs...),
        StartTime:  startTime,
        Time:       endTime,
        FloatValue: &value,
        Flags:      0,
    }
    
    p.mu.Lock()
    p.numberPoints = append(p.numberPoints, dp)
    p.mu.Unlock()
}

// RecordHistogram 记录直方图数据点
func (p *DataPointProcessor) RecordHistogram(
    observations []float64,
    bounds []float64,
    attrs []attribute.KeyValue,
    startTime, endTime time.Time,
) {
    dp := createHistogramDataPoint(observations, bounds, attrs)
    dp.StartTime = startTime
    dp.Time = endTime
    
    p.mu.Lock()
    p.histoPoints = append(p.histoPoints, *dp)
    p.mu.Unlock()
}

// Export 导出所有数据点
func (p *DataPointProcessor) Export() ([]NumberDataPointExample, []HistogramDataPointExample) {
    p.mu.Lock()
    defer p.mu.Unlock()
    
    numbers := make([]NumberDataPointExample, len(p.numberPoints))
    copy(numbers, p.numberPoints)
    
    histos := make([]HistogramDataPointExample, len(p.histoPoints))
    copy(histos, p.histoPoints)
    
    // 清空已导出的数据点 (Delta 模式)
    p.numberPoints = p.numberPoints[:0]
    p.histoPoints = p.histoPoints[:0]
    
    return numbers, histos
}

// GetStats 获取统计信息
func (p *DataPointProcessor) GetStats() (numCount, histoCount int) {
    p.mu.RLock()
    defer p.mu.RUnlock()
    return len(p.numberPoints), len(p.histoPoints)
}
```

---

## 性能优化

### 1. 批量处理

```go
// ✅ 推荐：批量处理数据点
func batchProcessDataPoints(points []NumberDataPointExample) {
    const batchSize = 100
    
    for i := 0; i < len(points); i += batchSize {
        end := i + batchSize
        if end > len(points) {
            end = len(points)
        }
        
        batch := points[i:end]
        processBatch(batch)
    }
}
```

### 2. 内存池

```go
// 数据点对象池
var numberDataPointPool = sync.Pool{
    New: func() interface{} {
        return &NumberDataPointExample{}
    },
}

// 获取数据点
func acquireNumberDataPoint() *NumberDataPointExample {
    return numberDataPointPool.Get().(*NumberDataPointExample)
}

// 释放数据点
func releaseNumberDataPoint(dp *NumberDataPointExample) {
    // 重置字段
    dp.IntValue = nil
    dp.FloatValue = nil
    dp.Exemplars = nil
    
    numberDataPointPool.Put(dp)
}
```

### 3. 零拷贝

```go
// ✅ 避免不必要的拷贝
func efficientAttributeHandling(attrs []attribute.KeyValue) attribute.Set {
    // 直接使用 NewSet，避免中间拷贝
    return attribute.NewSet(attrs...)
}

// ❌ 避免
func inefficientAttributeHandling(attrs []attribute.KeyValue) attribute.Set {
    temp := make([]attribute.KeyValue, len(attrs))
    copy(temp, attrs)  // 不必要的拷贝
    return attribute.NewSet(temp...)
}
```

---

## 常见问题

### Q1: NumberDataPoint 和 HistogramDataPoint 如何选择？

**A**: 基于 Metric 类型

- **Counter/UpDownCounter/Gauge**: NumberDataPoint
- **Histogram**: HistogramDataPoint

---

### Q2: Exemplar 应该采样多少？

**A**: 通常 1%-10%

- 低流量: 10% 或更高
- 高流量: 1% 或更低
- 关注异常值: 使用 OutlierSampler

---

### Q3: Cumulative 和 Delta 如何选择？

**A**:

- **Cumulative**: 适合长期趋势分析，Prometheus 风格
- **Delta**: 适合短期变化监控，节省存储

---

### Q4: 如何减少数据点的内存占用？

**A**:

1. 使用对象池
2. 批量处理
3. 及时导出和清理
4. 减少高基数属性

---

### Q5: 如何处理数据点的时间戳？

**A**:

- 使用 `time.Now()` 获取当前时间
- 使用 `UnixNano()` 转换为纳秒精度
- 确保单调递增

---

## 参考资源

### 官方文档

- [OpenTelemetry Metrics Data Model](https://opentelemetry.io/docs/specs/otel/metrics/data-model/)
- [Temporality](https://opentelemetry.io/docs/specs/otel/metrics/data-model/#temporality)

### Go 实现9

- [go.opentelemetry.io/otel/sdk/metric/metricdata](https://pkg.go.dev/go.opentelemetry.io/otel/sdk/metric/metricdata)

### 相关文档

- [01_Metric类型.md](./01_Metric类型.md)
- [03_时间序列.md](./03_时间序列.md)
- [06_Exemplars.md](./06_Exemplars.md)

---

**🎉 恭喜！你已经掌握了数据点的完整知识！**

下一步：学习 [时间序列](./03_时间序列.md) 了解 Metric 的聚合和存储。
