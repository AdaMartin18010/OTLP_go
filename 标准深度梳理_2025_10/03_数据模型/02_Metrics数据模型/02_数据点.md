# æ•°æ®ç‚¹å®Œæ•´æŒ‡å—

## ğŸ“‹ ç›®å½•

- [æ•°æ®ç‚¹å®Œæ•´æŒ‡å—](#æ•°æ®ç‚¹å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
    - [æ•°æ®ç‚¹ç”Ÿå‘½å‘¨æœŸ](#æ•°æ®ç‚¹ç”Ÿå‘½å‘¨æœŸ)
  - [NumberDataPoint (æ•°å€¼æ•°æ®ç‚¹)](#numberdatapoint-æ•°å€¼æ•°æ®ç‚¹)
    - [æ•°æ®ç»“æ„](#æ•°æ®ç»“æ„)
    - [å­—æ®µè¯¦è§£](#å­—æ®µè¯¦è§£)
    - [Go å®ç°](#go-å®ç°)
    - [ä½¿ç”¨åœºæ™¯](#ä½¿ç”¨åœºæ™¯)
  - [HistogramDataPoint (ç›´æ–¹å›¾æ•°æ®ç‚¹)](#histogramdatapoint-ç›´æ–¹å›¾æ•°æ®ç‚¹)
    - [æ•°æ®ç»“æ„2](#æ•°æ®ç»“æ„2)
    - [å­—æ®µè¯¦è§£2](#å­—æ®µè¯¦è§£2)
    - [Go å®ç°2](#go-å®ç°2)
    - [æ¡¶è¾¹ç•Œè¯´æ˜](#æ¡¶è¾¹ç•Œè¯´æ˜)
  - [ExponentialHistogramDataPoint (æŒ‡æ•°ç›´æ–¹å›¾æ•°æ®ç‚¹)](#exponentialhistogramdatapoint-æŒ‡æ•°ç›´æ–¹å›¾æ•°æ®ç‚¹)
    - [æ•°æ®ç»“æ„3](#æ•°æ®ç»“æ„3)
    - [å­—æ®µè¯¦è§£3](#å­—æ®µè¯¦è§£3)
    - [Go å®ç°3](#go-å®ç°3)
    - [æŒ‡æ•°æ¡¶æœºåˆ¶](#æŒ‡æ•°æ¡¶æœºåˆ¶)
  - [SummaryDataPoint (æ‘˜è¦æ•°æ®ç‚¹)](#summarydatapoint-æ‘˜è¦æ•°æ®ç‚¹)
    - [æ•°æ®ç»“æ„4](#æ•°æ®ç»“æ„4)
    - [å­—æ®µè¯¦è§£4](#å­—æ®µè¯¦è§£4)
    - [Go å®ç°4](#go-å®ç°4)
  - [Exemplar (ç¤ºä¾‹å€¼)](#exemplar-ç¤ºä¾‹å€¼)
    - [å®šä¹‰](#å®šä¹‰)
    - [æ•°æ®ç»“æ„5](#æ•°æ®ç»“æ„5)
    - [Go å®ç°5](#go-å®ç°5)
    - [é‡‡æ ·ç­–ç•¥](#é‡‡æ ·ç­–ç•¥)
  - [æ—¶é—´æˆ³è¯­ä¹‰](#æ—¶é—´æˆ³è¯­ä¹‰)
    - [TimeUnixNano](#timeunixnano)
    - [StartTimeUnixNano](#starttimeunixnano)
    - [æ—¶é—´çª—å£](#æ—¶é—´çª—å£)
  - [Temporality (æ—¶é—´æ€§)](#temporality-æ—¶é—´æ€§)
    - [Cumulative (ç´¯ç§¯)](#cumulative-ç´¯ç§¯)
    - [Delta (å¢é‡)](#delta-å¢é‡)
    - [å¯¹æ¯”åˆ†æ](#å¯¹æ¯”åˆ†æ)
    - [Go å®ç°6](#go-å®ç°6)
  - [Attributes (å±æ€§)](#attributes-å±æ€§)
    - [å±æ€§ç®¡ç†](#å±æ€§ç®¡ç†)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [Go å®ç°7](#go-å®ç°7)
  - [Flags (æ ‡å¿—ä½)](#flags-æ ‡å¿—ä½)
    - [å®šä¹‰2](#å®šä¹‰2)
    - [æ ‡å¿—ä½è¯´æ˜](#æ ‡å¿—ä½è¯´æ˜)
    - [Go å®ç°8](#go-å®ç°8)
  - [å®Œæ•´å®ç°](#å®Œæ•´å®ç°)
    - [æ•°æ®ç‚¹å¤„ç†ç³»ç»Ÿ](#æ•°æ®ç‚¹å¤„ç†ç³»ç»Ÿ)
  - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
    - [1. æ‰¹é‡å¤„ç†](#1-æ‰¹é‡å¤„ç†)
    - [2. å†…å­˜æ± ](#2-å†…å­˜æ± )
    - [3. é›¶æ‹·è´](#3-é›¶æ‹·è´)
  - [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)
    - [Q1: NumberDataPoint å’Œ HistogramDataPoint å¦‚ä½•é€‰æ‹©ï¼Ÿ](#q1-numberdatapoint-å’Œ-histogramdatapoint-å¦‚ä½•é€‰æ‹©)
    - [Q2: Exemplar åº”è¯¥é‡‡æ ·å¤šå°‘ï¼Ÿ](#q2-exemplar-åº”è¯¥é‡‡æ ·å¤šå°‘)
    - [Q3: Cumulative å’Œ Delta å¦‚ä½•é€‰æ‹©ï¼Ÿ](#q3-cumulative-å’Œ-delta-å¦‚ä½•é€‰æ‹©)
    - [Q4: å¦‚ä½•å‡å°‘æ•°æ®ç‚¹çš„å†…å­˜å ç”¨ï¼Ÿ](#q4-å¦‚ä½•å‡å°‘æ•°æ®ç‚¹çš„å†…å­˜å ç”¨)
    - [Q5: å¦‚ä½•å¤„ç†æ•°æ®ç‚¹çš„æ—¶é—´æˆ³ï¼Ÿ](#q5-å¦‚ä½•å¤„ç†æ•°æ®ç‚¹çš„æ—¶é—´æˆ³)
  - [å‚è€ƒèµ„æº](#å‚è€ƒèµ„æº)
    - [å®˜æ–¹æ–‡æ¡£](#å®˜æ–¹æ–‡æ¡£)
    - [Go å®ç°9](#go-å®ç°9)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)

---

## æ¦‚è¿°

**æ•°æ®ç‚¹ (DataPoint)** æ˜¯ OpenTelemetry Metrics çš„æ ¸å¿ƒæ•°æ®ç»“æ„ï¼Œè¡¨ç¤ºåœ¨ç‰¹å®šæ—¶é—´ç‚¹æˆ–æ—¶é—´æ®µå†…é‡‡é›†çš„åº¦é‡å€¼ã€‚

### æ ¸å¿ƒæ¦‚å¿µ

- âœ… **æ—¶é—´æˆ³**: è®°å½•æ•°æ®é‡‡é›†çš„æ—¶é—´
- âœ… **å€¼**: å®é™…æµ‹é‡çš„æ•°å€¼
- âœ… **å±æ€§**: æè¿°æ•°æ®ç‚¹çš„ç»´åº¦æ ‡ç­¾
- âœ… **Exemplar**: å…³è”çš„è¿½è¸ªæ ·æœ¬

### æ•°æ®ç‚¹ç”Ÿå‘½å‘¨æœŸ

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è®°å½•è§‚æµ‹å€¼   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  èšåˆå¤„ç†    â”‚ â† Delta/Cumulative
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç”Ÿæˆæ•°æ®ç‚¹   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å¯¼å‡ºåˆ°åç«¯   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## NumberDataPoint (æ•°å€¼æ•°æ®ç‚¹)

### æ•°æ®ç»“æ„

```protobuf
message NumberDataPoint {
  repeated KeyValue attributes = 7;
  fixed64 start_time_unix_nano = 2;
  fixed64 time_unix_nano = 3;
  
  oneof value {
    double as_double = 4;
    sfixed64 as_int = 6;
  }
  
  repeated Exemplar exemplars = 5;
  uint32 flags = 8;
}
```

### å­—æ®µè¯¦è§£

| å­—æ®µ | ç±»å‹ | è¯´æ˜ |
|------|------|------|
| `attributes` | `[]KeyValue` | ç»´åº¦æ ‡ç­¾ |
| `start_time_unix_nano` | `uint64` | æ—¶é—´çª—å£èµ·å§‹æ—¶é—´ (çº³ç§’) |
| `time_unix_nano` | `uint64` | æ•°æ®ç‚¹é‡‡é›†æ—¶é—´ (çº³ç§’) |
| `value` | `double/int64` | æ•°å€¼ï¼ˆæµ®ç‚¹æˆ–æ•´æ•°ï¼‰ |
| `exemplars` | `[]Exemplar` | å…³è”çš„ç¤ºä¾‹å€¼ |
| `flags` | `uint32` | æ ‡å¿—ä½ |

### Go å®ç°

```go
package main

import (
    "context"
    "time"

    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/sdk/metric/metricdata"
)

// NumberDataPoint çš„ Go è¡¨ç¤º
type NumberDataPointExample struct {
    Attributes        attribute.Set
    StartTime         time.Time
    Time              time.Time
    IntValue          *int64
    FloatValue        *float64
    Exemplars         []ExemplarExample
    Flags             uint32
}

// åˆ›å»ºæ•´æ•°æ•°æ®ç‚¹
func createIntDataPoint(value int64, attrs []attribute.KeyValue) *NumberDataPointExample {
    now := time.Now()
    return &NumberDataPointExample{
        Attributes: attribute.NewSet(attrs...),
        StartTime:  now.Add(-time.Minute),
        Time:       now,
        IntValue:   &value,
        Flags:      0,
    }
}

// åˆ›å»ºæµ®ç‚¹æ•°æ®ç‚¹
func createFloatDataPoint(value float64, attrs []attribute.KeyValue) *NumberDataPointExample {
    now := time.Now()
    return &NumberDataPointExample{
        Attributes: attribute.NewSet(attrs...),
        StartTime:  now.Add(-time.Minute),
        Time:       now,
        FloatValue: &value,
        Flags:      0,
    }
}

// å®é™…ä½¿ç”¨ï¼šCounter ç”Ÿæˆ NumberDataPoint
func recordCounterDataPoint(ctx context.Context, counter metric.Int64Counter) {
    counter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("http.method", "GET"),
            attribute.String("http.route", "/api/users"),
            attribute.Int("http.status_code", 200),
        ),
    )
    // SDK å†…éƒ¨ä¼šåˆ›å»º NumberDataPoint
}
```

### ä½¿ç”¨åœºæ™¯

- âœ… **Counter**: ç´¯ç§¯è®¡æ•°
- âœ… **UpDownCounter**: å¯å¢å‡è®¡æ•°
- âœ… **Gauge**: ç¬æ—¶å€¼

---

## HistogramDataPoint (ç›´æ–¹å›¾æ•°æ®ç‚¹)

### æ•°æ®ç»“æ„2

```protobuf
message HistogramDataPoint {
  repeated KeyValue attributes = 9;
  fixed64 start_time_unix_nano = 2;
  fixed64 time_unix_nano = 3;
  
  uint64 count = 4;
  optional double sum = 5;
  repeated uint64 bucket_counts = 6;
  repeated double explicit_bounds = 7;
  
  repeated Exemplar exemplars = 8;
  uint32 flags = 10;
  
  optional double min = 11;
  optional double max = 12;
}
```

### å­—æ®µè¯¦è§£2

| å­—æ®µ | ç±»å‹ | è¯´æ˜ |
|------|------|------|
| `attributes` | `[]KeyValue` | ç»´åº¦æ ‡ç­¾ |
| `start_time_unix_nano` | `uint64` | æ—¶é—´çª—å£èµ·å§‹æ—¶é—´ |
| `time_unix_nano` | `uint64` | æ•°æ®ç‚¹é‡‡é›†æ—¶é—´ |
| `count` | `uint64` | è§‚æµ‹å€¼æ€»æ•° |
| `sum` | `double` | è§‚æµ‹å€¼æ€»å’Œï¼ˆå¯é€‰ï¼‰ |
| `bucket_counts` | `[]uint64` | å„æ¡¶çš„è®¡æ•° |
| `explicit_bounds` | `[]double` | æ¡¶è¾¹ç•Œ |
| `exemplars` | `[]Exemplar` | ç¤ºä¾‹å€¼ |
| `flags` | `uint32` | æ ‡å¿—ä½ |
| `min` | `double` | æœ€å°å€¼ï¼ˆå¯é€‰ï¼‰ |
| `max` | `double` | æœ€å¤§å€¼ï¼ˆå¯é€‰ï¼‰ |

### Go å®ç°2

```go
// HistogramDataPoint çš„ Go è¡¨ç¤º
type HistogramDataPointExample struct {
    Attributes     attribute.Set
    StartTime      time.Time
    Time           time.Time
    Count          uint64
    Sum            *float64
    BucketCounts   []uint64
    ExplicitBounds []float64
    Exemplars      []ExemplarExample
    Flags          uint32
    Min            *float64
    Max            *float64
}

// åˆ›å»º Histogram æ•°æ®ç‚¹
func createHistogramDataPoint(
    observations []float64,
    bounds []float64,
    attrs []attribute.KeyValue,
) *HistogramDataPointExample {
    now := time.Now()
    
    // ç»Ÿè®¡å„æ¡¶çš„è®¡æ•°
    bucketCounts := make([]uint64, len(bounds)+1)
    var sum float64
    var min, max float64
    
    if len(observations) > 0 {
        min = observations[0]
        max = observations[0]
    }
    
    for _, obs := range observations {
        sum += obs
        if obs < min {
            min = obs
        }
        if obs > max {
            max = obs
        }
        
        // æ‰¾åˆ°å¯¹åº”çš„æ¡¶
        bucketIdx := 0
        for i, bound := range bounds {
            if obs > bound {
                bucketIdx = i + 1
            } else {
                break
            }
        }
        bucketCounts[bucketIdx]++
    }
    
    return &HistogramDataPointExample{
        Attributes:     attribute.NewSet(attrs...),
        StartTime:      now.Add(-time.Minute),
        Time:           now,
        Count:          uint64(len(observations)),
        Sum:            &sum,
        BucketCounts:   bucketCounts,
        ExplicitBounds: bounds,
        Min:            &min,
        Max:            &max,
    }
}

// å®é™…ä½¿ç”¨ï¼šHistogram ç”Ÿæˆ HistogramDataPoint
func recordHistogramDataPoint(ctx context.Context, histogram metric.Float64Histogram) {
    start := time.Now()
    
    // æ¨¡æ‹Ÿè¯·æ±‚å¤„ç†
    time.Sleep(100 * time.Millisecond)
    
    duration := time.Since(start).Seconds()
    histogram.Record(ctx, duration,
        metric.WithAttributes(
            attribute.String("http.method", "GET"),
            attribute.String("http.route", "/api/users"),
        ),
    )
    // SDK å†…éƒ¨ä¼šåˆ›å»º HistogramDataPoint
}
```

### æ¡¶è¾¹ç•Œè¯´æ˜

```text
Bounds: [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1]

æ¡¶åˆ’åˆ†:
Bucket 0: (-âˆ, 0.005]
Bucket 1: (0.005, 0.01]
Bucket 2: (0.01, 0.025]
Bucket 3: (0.025, 0.05]
Bucket 4: (0.05, 0.1]
Bucket 5: (0.1, 0.25]
Bucket 6: (0.25, 0.5]
Bucket 7: (0.5, 1]
Bucket 8: (1, +âˆ)

bucket_counts é•¿åº¦ = len(bounds) + 1
```

---

## ExponentialHistogramDataPoint (æŒ‡æ•°ç›´æ–¹å›¾æ•°æ®ç‚¹)

### æ•°æ®ç»“æ„3

```protobuf
message ExponentialHistogramDataPoint {
  repeated KeyValue attributes = 1;
  fixed64 start_time_unix_nano = 2;
  fixed64 time_unix_nano = 3;
  
  uint64 count = 4;
  optional double sum = 5;
  sint32 scale = 6;
  uint64 zero_count = 7;
  
  Buckets positive = 8;
  Buckets negative = 9;
  
  repeated Exemplar exemplars = 10;
  uint32 flags = 11;
  
  optional double min = 12;
  optional double max = 13;
}

message Buckets {
  sint32 offset = 1;
  repeated uint64 bucket_counts = 2;
}
```

### å­—æ®µè¯¦è§£3

| å­—æ®µ | ç±»å‹ | è¯´æ˜ |
|------|------|------|
| `scale` | `int32` | æ¡¶çš„ç²¾åº¦ç­‰çº§ |
| `zero_count` | `uint64` | é›¶å€¼è®¡æ•° |
| `positive` | `Buckets` | æ­£å€¼æ¡¶ |
| `negative` | `Buckets` | è´Ÿå€¼æ¡¶ |

### Go å®ç°3

```go
// ExponentialHistogramDataPoint çš„ Go è¡¨ç¤º
type ExponentialHistogramDataPointExample struct {
    Attributes attribute.Set
    StartTime  time.Time
    Time       time.Time
    Count      uint64
    Sum        *float64
    Scale      int32
    ZeroCount  uint64
    Positive   BucketsExample
    Negative   BucketsExample
    Exemplars  []ExemplarExample
    Flags      uint32
    Min        *float64
    Max        *float64
}

type BucketsExample struct {
    Offset       int32
    BucketCounts []uint64
}

// è®¡ç®—æ¡¶ç´¢å¼•ï¼ˆç®€åŒ–ç‰ˆï¼‰
func calculateBucketIndex(value float64, scale int32) int32 {
    if value == 0 {
        return 0
    }
    
    // å¯¹æ•°æ¡¶ç´¢å¼•è®¡ç®—
    import "math"
    base := math.Pow(2, math.Pow(2, float64(-scale)))
    return int32(math.Floor(math.Log(value) / math.Log(base)))
}
```

### æŒ‡æ•°æ¡¶æœºåˆ¶

```text
Scale = 0: æ¡¶è¾¹ç•Œ = 2^(2^0) = 2
  Bucket 0: (1, 2]
  Bucket 1: (2, 4]
  Bucket 2: (4, 8]
  Bucket 3: (8, 16]
  ...

Scale = 1: æ¡¶è¾¹ç•Œ = 2^(2^-1) = âˆš2 â‰ˆ 1.414
  æ›´ç»†ç²’åº¦çš„æ¡¶åˆ’åˆ†

Scale = -1: æ¡¶è¾¹ç•Œ = 2^(2^1) = 4
  æ›´ç²—ç²’åº¦çš„æ¡¶åˆ’åˆ†
```

---

## SummaryDataPoint (æ‘˜è¦æ•°æ®ç‚¹)

### æ•°æ®ç»“æ„4

```protobuf
message SummaryDataPoint {
  repeated KeyValue attributes = 7;
  fixed64 start_time_unix_nano = 2;
  fixed64 time_unix_nano = 3;
  
  uint64 count = 4;
  double sum = 5;
  repeated ValueAtQuantile quantile_values = 6;
  
  uint32 flags = 8;
}

message ValueAtQuantile {
  double quantile = 1;  // 0.0 ~ 1.0
  double value = 2;
}
```

### å­—æ®µè¯¦è§£4

| å­—æ®µ | ç±»å‹ | è¯´æ˜ |
|------|------|------|
| `count` | `uint64` | è§‚æµ‹å€¼æ€»æ•° |
| `sum` | `double` | è§‚æµ‹å€¼æ€»å’Œ |
| `quantile_values` | `[]ValueAtQuantile` | åˆ†ä½æ•°å€¼ |

### Go å®ç°4

```go
// SummaryDataPoint çš„ Go è¡¨ç¤º
type SummaryDataPointExample struct {
    Attributes     attribute.Set
    StartTime      time.Time
    Time           time.Time
    Count          uint64
    Sum            float64
    QuantileValues []ValueAtQuantileExample
    Flags          uint32
}

type ValueAtQuantileExample struct {
    Quantile float64  // 0.5 = P50, 0.95 = P95, 0.99 = P99
    Value    float64
}

// åˆ›å»º Summary æ•°æ®ç‚¹
func createSummaryDataPoint(
    observations []float64,
    quantiles []float64,
    attrs []attribute.KeyValue,
) *SummaryDataPointExample {
    import "sort"
    
    now := time.Now()
    sort.Float64s(observations)
    
    var sum float64
    for _, obs := range observations {
        sum += obs
    }
    
    quantileValues := make([]ValueAtQuantileExample, len(quantiles))
    for i, q := range quantiles {
        idx := int(float64(len(observations)-1) * q)
        quantileValues[i] = ValueAtQuantileExample{
            Quantile: q,
            Value:    observations[idx],
        }
    }
    
    return &SummaryDataPointExample{
        Attributes:     attribute.NewSet(attrs...),
        StartTime:      now.Add(-time.Minute),
        Time:           now,
        Count:          uint64(len(observations)),
        Sum:            sum,
        QuantileValues: quantileValues,
    }
}
```

---

## Exemplar (ç¤ºä¾‹å€¼)

### å®šä¹‰

**Exemplar** æ˜¯ä¸ Metric æ•°æ®ç‚¹å…³è”çš„ Trace é‡‡æ ·ï¼Œç”¨äºå°† Metrics å’Œ Traces å…³è”èµ·æ¥ã€‚

### æ•°æ®ç»“æ„5

```protobuf
message Exemplar {
  repeated KeyValue filtered_attributes = 7;
  fixed64 time_unix_nano = 2;
  
  oneof value {
    double as_double = 3;
    sfixed64 as_int = 6;
  }
  
  bytes span_id = 4;
  bytes trace_id = 5;
}
```

### Go å®ç°5

```go
import (
    "go.opentelemetry.io/otel/trace"
)

// Exemplar çš„ Go è¡¨ç¤º
type ExemplarExample struct {
    FilteredAttributes attribute.Set
    Time               time.Time
    Value              float64  // or int64
    SpanID             trace.SpanID
    TraceID            trace.TraceID
}

// åˆ›å»ºå¸¦ Exemplar çš„æ•°æ®ç‚¹
func recordWithExemplar(ctx context.Context, histogram metric.Float64Histogram) {
    // ä» Context è·å–å½“å‰ Span
    span := trace.SpanFromContext(ctx)
    spanContext := span.SpanContext()
    
    start := time.Now()
    
    // å¤„ç†è¯·æ±‚
    time.Sleep(100 * time.Millisecond)
    
    duration := time.Since(start).Seconds()
    
    // è®°å½• Histogram å€¼
    // SDK è‡ªåŠ¨å…³è” TraceID/SpanID ä½œä¸º Exemplar
    histogram.Record(ctx, duration,
        metric.WithAttributes(
            attribute.String("http.method", "GET"),
            attribute.String("http.route", "/api/users"),
        ),
    )
    
    // Exemplar ä¼šè‡ªåŠ¨åŒ…å«:
    // - trace_id: spanContext.TraceID()
    // - span_id: spanContext.SpanID()
    // - value: duration
    // - time: è®°å½•æ—¶é—´
}
```

### é‡‡æ ·ç­–ç•¥

```go
// Exemplar é‡‡æ ·é…ç½®
type ExemplarSampler interface {
    ShouldSample(value float64, attributes attribute.Set) bool
}

// 1. å§‹ç»ˆé‡‡æ ·
type AlwaysSampler struct{}

func (s AlwaysSampler) ShouldSample(value float64, attributes attribute.Set) bool {
    return true
}

// 2. æ¦‚ç‡é‡‡æ ·
type ProbabilitySampler struct {
    Probability float64  // 0.0 ~ 1.0
}

func (s ProbabilitySampler) ShouldSample(value float64, attributes attribute.Set) bool {
    import "math/rand"
    return rand.Float64() < s.Probability
}

// 3. å¼‚å¸¸å€¼é‡‡æ ·
type OutlierSampler struct {
    Threshold float64
}

func (s OutlierSampler) ShouldSample(value float64, attributes attribute.Set) bool {
    // ä»…é‡‡æ ·è¶…è¿‡é˜ˆå€¼çš„å€¼
    return value > s.Threshold
}
```

---

## æ—¶é—´æˆ³è¯­ä¹‰

### TimeUnixNano

**æ•°æ®ç‚¹çš„è§‚æµ‹/é‡‡é›†æ—¶é—´** (çº³ç§’ç²¾åº¦ Unix æ—¶é—´æˆ³)

```go
timeUnixNano := uint64(time.Now().UnixNano())
```

### StartTimeUnixNano

**æ—¶é—´çª—å£çš„èµ·å§‹æ—¶é—´**:

- **Cumulative**: é¦–æ¬¡è®°å½•çš„æ—¶é—´ï¼ˆè¿›ç¨‹å¯åŠ¨æ—¶é—´ï¼‰
- **Delta**: ä¸Šä¸€æ¬¡å¯¼å‡ºçš„æ—¶é—´

```go
// Cumulative: ä»è¿›ç¨‹å¯åŠ¨å¼€å§‹
startTime := processStartTime

// Delta: ä»ä¸Šæ¬¡å¯¼å‡ºå¼€å§‹
startTime := lastExportTime
```

### æ—¶é—´çª—å£

```text
Cumulative (ç´¯ç§¯):
  Start: Process Start (T0)
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
  T0                                  T1
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Time Window â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Delta (å¢é‡):
  Export 1: [T0, T1]
  Export 2: [T1, T2]
  Export 3: [T2, T3]
  â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
        T0        T1        T2        T3
```

---

## Temporality (æ—¶é—´æ€§)

### Cumulative (ç´¯ç§¯)

ä»èµ·å§‹æ—¶é—´ç´¯ç§¯åˆ°å½“å‰çš„æ€»å€¼ã€‚

```go
// Counter: Cumulative
// T0: 0 â†’ 10
// T1: 0 â†’ 25  (ç´¯ç§¯å€¼)
// T2: 0 â†’ 42  (ç´¯ç§¯å€¼)

Export @ T0: value = 10
Export @ T1: value = 25
Export @ T2: value = 42
```

### Delta (å¢é‡)

ä¸¤æ¬¡å¯¼å‡ºä¹‹é—´çš„å˜åŒ–é‡ã€‚

```go
// Counter: Delta
// T0 â†’ T1: +10
// T1 â†’ T2: +15
// T2 â†’ T3: +17

Export @ T0: value = 10   (åˆå§‹å€¼)
Export @ T1: value = 15   (å¢é‡)
Export @ T2: value = 17   (å¢é‡)
```

### å¯¹æ¯”åˆ†æ

| ç‰¹æ€§ | Cumulative | Delta |
|------|------------|-------|
| **å€¼çš„å«ä¹‰** | ç´¯ç§¯æ€»é‡ | æ—¶é—´æ®µå¢é‡ |
| **èµ·å§‹æ—¶é—´** | è¿›ç¨‹å¯åŠ¨ | ä¸Šæ¬¡å¯¼å‡º |
| **èšåˆ** | ç®€å• (å–æœ€æ–°å€¼) | å¤æ‚ (éœ€ç´¯åŠ ) |
| **å­˜å‚¨** | å ç”¨æ›´å¤š | å ç”¨æ›´å°‘ |
| **é€‚ç”¨åœºæ™¯** | é•¿æœŸè¶‹åŠ¿ | çŸ­æœŸå˜åŒ– |

### Go å®ç°6

```go
import (
    "go.opentelemetry.io/otel/sdk/metric"
)

// é…ç½® Temporality
func setupTemporality() *metric.PeriodicReader {
    // Cumulative (é»˜è®¤)
    return metric.NewPeriodicReader(
        exporter,
        metric.WithTemporalitySelector(
            func(ik metric.InstrumentKind) metricdata.Temporality {
                return metricdata.CumulativeTemporality
            },
        ),
    )
    
    // Delta
    return metric.NewPeriodicReader(
        exporter,
        metric.WithTemporalitySelector(
            func(ik metric.InstrumentKind) metricdata.Temporality {
                // Counter/UpDownCounter: Delta
                if ik == metric.InstrumentKindCounter ||
                   ik == metric.InstrumentKindUpDownCounter {
                    return metricdata.DeltaTemporality
                }
                // Histogram: Cumulative
                return metricdata.CumulativeTemporality
            },
        ),
    )
}
```

---

## Attributes (å±æ€§)

### å±æ€§ç®¡ç†

```go
// åˆ›å»ºå±æ€§é›†
attrs := attribute.NewSet(
    attribute.String("http.method", "GET"),
    attribute.String("http.route", "/api/users"),
    attribute.Int("http.status_code", 200),
)

// å±æ€§ä¸å¯å˜
// attrs.Add(...) // âŒ ä¸å­˜åœ¨æ­¤æ–¹æ³•

// éœ€è¦åˆ›å»ºæ–°çš„å±æ€§é›†
newAttrs := attribute.NewSet(
    attribute.String("http.method", "POST"),
    attribute.String("http.route", "/api/users"),
    attribute.Int("http.status_code", 201),
)
```

### æœ€ä½³å®è·µ

```go
// âœ… æ¨èï¼šé¢„å®šä¹‰å±æ€§é”®
var (
    HTTPMethod     = attribute.Key("http.method")
    HTTPRoute      = attribute.Key("http.route")
    HTTPStatusCode = attribute.Key("http.status_code")
)

// ä½¿ç”¨
attrs := attribute.NewSet(
    HTTPMethod.String("GET"),
    HTTPRoute.String("/api/users"),
    HTTPStatusCode.Int(200),
)

// âœ… æ¨èï¼šå±æ€§å¤ç”¨
baseAttrs := []attribute.KeyValue{
    attribute.String("service.name", "my-service"),
    attribute.String("service.version", "1.0.0"),
}

// æ¯æ¬¡æ·»åŠ ç‰¹å®šå±æ€§
requestAttrs := append(baseAttrs,
    attribute.String("http.method", "GET"),
)
```

### Go å®ç°7

```go
// é«˜æ•ˆçš„å±æ€§ç®¡ç†
type AttributeCache struct {
    cache sync.Map  // map[string]attribute.Set
}

func (c *AttributeCache) Get(method, route string, statusCode int) attribute.Set {
    key := fmt.Sprintf("%s|%s|%d", method, route, statusCode)
    
    if cached, ok := c.cache.Load(key); ok {
        return cached.(attribute.Set)
    }
    
    attrs := attribute.NewSet(
        attribute.String("http.method", method),
        attribute.String("http.route", route),
        attribute.Int("http.status_code", statusCode),
    )
    
    c.cache.Store(key, attrs)
    return attrs
}
```

---

## Flags (æ ‡å¿—ä½)

### å®šä¹‰2

**Flags** ç”¨äºæ ‡è¯†æ•°æ®ç‚¹çš„ç‰¹æ®ŠçŠ¶æ€ã€‚

### æ ‡å¿—ä½è¯´æ˜

```go
const (
    // NoRecordedValue: æ— è®°å½•å€¼ï¼ˆæ•°æ®ç‚¹ä¸ºç©ºï¼‰
    FlagNoRecordedValue = 1 << 0  // 0x01
)

// æ£€æŸ¥æ ‡å¿—ä½
func hasNoRecordedValue(flags uint32) bool {
    return flags & FlagNoRecordedValue != 0
}
```

### Go å®ç°8

```go
// è®¾ç½®æ ‡å¿—ä½
func createDataPointWithFlags() *NumberDataPointExample {
    return &NumberDataPointExample{
        Attributes: attribute.NewSet(),
        Time:       time.Now(),
        IntValue:   nil,  // æ— å€¼
        Flags:      FlagNoRecordedValue,  // æ ‡è®°ä¸ºæ— è®°å½•å€¼
    }
}

// å¤„ç†å¸¦æ ‡å¿—ä½çš„æ•°æ®ç‚¹
func processDataPoint(dp *NumberDataPointExample) {
    if hasNoRecordedValue(dp.Flags) {
        // è·³è¿‡æ— å€¼çš„æ•°æ®ç‚¹
        return
    }
    
    // æ­£å¸¸å¤„ç†
    if dp.IntValue != nil {
        fmt.Printf("Value: %d\n", *dp.IntValue)
    } else if dp.FloatValue != nil {
        fmt.Printf("Value: %f\n", *dp.FloatValue)
    }
}
```

---

## å®Œæ•´å®ç°

### æ•°æ®ç‚¹å¤„ç†ç³»ç»Ÿ

```go
package datapoint

import (
    "context"
    "sync"
    "time"

    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/sdk/metric/metricdata"
)

// DataPointProcessor æ•°æ®ç‚¹å¤„ç†å™¨
type DataPointProcessor struct {
    mu            sync.RWMutex
    numberPoints  []NumberDataPointExample
    histoPoints   []HistogramDataPointExample
    attrCache     *AttributeCache
}

func NewDataPointProcessor() *DataPointProcessor {
    return &DataPointProcessor{
        numberPoints: make([]NumberDataPointExample, 0, 1000),
        histoPoints:  make([]HistogramDataPointExample, 0, 1000),
        attrCache:    &AttributeCache{},
    }
}

// RecordNumber è®°å½•æ•°å€¼æ•°æ®ç‚¹
func (p *DataPointProcessor) RecordNumber(
    value float64,
    attrs []attribute.KeyValue,
    startTime, endTime time.Time,
) {
    dp := NumberDataPointExample{
        Attributes: attribute.NewSet(attrs...),
        StartTime:  startTime,
        Time:       endTime,
        FloatValue: &value,
        Flags:      0,
    }
    
    p.mu.Lock()
    p.numberPoints = append(p.numberPoints, dp)
    p.mu.Unlock()
}

// RecordHistogram è®°å½•ç›´æ–¹å›¾æ•°æ®ç‚¹
func (p *DataPointProcessor) RecordHistogram(
    observations []float64,
    bounds []float64,
    attrs []attribute.KeyValue,
    startTime, endTime time.Time,
) {
    dp := createHistogramDataPoint(observations, bounds, attrs)
    dp.StartTime = startTime
    dp.Time = endTime
    
    p.mu.Lock()
    p.histoPoints = append(p.histoPoints, *dp)
    p.mu.Unlock()
}

// Export å¯¼å‡ºæ‰€æœ‰æ•°æ®ç‚¹
func (p *DataPointProcessor) Export() ([]NumberDataPointExample, []HistogramDataPointExample) {
    p.mu.Lock()
    defer p.mu.Unlock()
    
    numbers := make([]NumberDataPointExample, len(p.numberPoints))
    copy(numbers, p.numberPoints)
    
    histos := make([]HistogramDataPointExample, len(p.histoPoints))
    copy(histos, p.histoPoints)
    
    // æ¸…ç©ºå·²å¯¼å‡ºçš„æ•°æ®ç‚¹ (Delta æ¨¡å¼)
    p.numberPoints = p.numberPoints[:0]
    p.histoPoints = p.histoPoints[:0]
    
    return numbers, histos
}

// GetStats è·å–ç»Ÿè®¡ä¿¡æ¯
func (p *DataPointProcessor) GetStats() (numCount, histoCount int) {
    p.mu.RLock()
    defer p.mu.RUnlock()
    return len(p.numberPoints), len(p.histoPoints)
}
```

---

## æ€§èƒ½ä¼˜åŒ–

### 1. æ‰¹é‡å¤„ç†

```go
// âœ… æ¨èï¼šæ‰¹é‡å¤„ç†æ•°æ®ç‚¹
func batchProcessDataPoints(points []NumberDataPointExample) {
    const batchSize = 100
    
    for i := 0; i < len(points); i += batchSize {
        end := i + batchSize
        if end > len(points) {
            end = len(points)
        }
        
        batch := points[i:end]
        processBatch(batch)
    }
}
```

### 2. å†…å­˜æ± 

```go
// æ•°æ®ç‚¹å¯¹è±¡æ± 
var numberDataPointPool = sync.Pool{
    New: func() interface{} {
        return &NumberDataPointExample{}
    },
}

// è·å–æ•°æ®ç‚¹
func acquireNumberDataPoint() *NumberDataPointExample {
    return numberDataPointPool.Get().(*NumberDataPointExample)
}

// é‡Šæ”¾æ•°æ®ç‚¹
func releaseNumberDataPoint(dp *NumberDataPointExample) {
    // é‡ç½®å­—æ®µ
    dp.IntValue = nil
    dp.FloatValue = nil
    dp.Exemplars = nil
    
    numberDataPointPool.Put(dp)
}
```

### 3. é›¶æ‹·è´

```go
// âœ… é¿å…ä¸å¿…è¦çš„æ‹·è´
func efficientAttributeHandling(attrs []attribute.KeyValue) attribute.Set {
    // ç›´æ¥ä½¿ç”¨ NewSetï¼Œé¿å…ä¸­é—´æ‹·è´
    return attribute.NewSet(attrs...)
}

// âŒ é¿å…
func inefficientAttributeHandling(attrs []attribute.KeyValue) attribute.Set {
    temp := make([]attribute.KeyValue, len(attrs))
    copy(temp, attrs)  // ä¸å¿…è¦çš„æ‹·è´
    return attribute.NewSet(temp...)
}
```

---

## å¸¸è§é—®é¢˜

### Q1: NumberDataPoint å’Œ HistogramDataPoint å¦‚ä½•é€‰æ‹©ï¼Ÿ

**A**: åŸºäº Metric ç±»å‹

- **Counter/UpDownCounter/Gauge**: NumberDataPoint
- **Histogram**: HistogramDataPoint

---

### Q2: Exemplar åº”è¯¥é‡‡æ ·å¤šå°‘ï¼Ÿ

**A**: é€šå¸¸ 1%-10%

- ä½æµé‡: 10% æˆ–æ›´é«˜
- é«˜æµé‡: 1% æˆ–æ›´ä½
- å…³æ³¨å¼‚å¸¸å€¼: ä½¿ç”¨ OutlierSampler

---

### Q3: Cumulative å’Œ Delta å¦‚ä½•é€‰æ‹©ï¼Ÿ

**A**:

- **Cumulative**: é€‚åˆé•¿æœŸè¶‹åŠ¿åˆ†æï¼ŒPrometheus é£æ ¼
- **Delta**: é€‚åˆçŸ­æœŸå˜åŒ–ç›‘æ§ï¼ŒèŠ‚çœå­˜å‚¨

---

### Q4: å¦‚ä½•å‡å°‘æ•°æ®ç‚¹çš„å†…å­˜å ç”¨ï¼Ÿ

**A**:

1. ä½¿ç”¨å¯¹è±¡æ± 
2. æ‰¹é‡å¤„ç†
3. åŠæ—¶å¯¼å‡ºå’Œæ¸…ç†
4. å‡å°‘é«˜åŸºæ•°å±æ€§

---

### Q5: å¦‚ä½•å¤„ç†æ•°æ®ç‚¹çš„æ—¶é—´æˆ³ï¼Ÿ

**A**:

- ä½¿ç”¨ `time.Now()` è·å–å½“å‰æ—¶é—´
- ä½¿ç”¨ `UnixNano()` è½¬æ¢ä¸ºçº³ç§’ç²¾åº¦
- ç¡®ä¿å•è°ƒé€’å¢

---

## å‚è€ƒèµ„æº

### å®˜æ–¹æ–‡æ¡£

- [OpenTelemetry Metrics Data Model](https://opentelemetry.io/docs/specs/otel/metrics/data-model/)
- [Temporality](https://opentelemetry.io/docs/specs/otel/metrics/data-model/#temporality)

### Go å®ç°9

- [go.opentelemetry.io/otel/sdk/metric/metricdata](https://pkg.go.dev/go.opentelemetry.io/otel/sdk/metric/metricdata)

### ç›¸å…³æ–‡æ¡£

- [01_Metricç±»å‹.md](./01_Metricç±»å‹.md)
- [03_æ—¶é—´åºåˆ—.md](./03_æ—¶é—´åºåˆ—.md)
- [06_Exemplars.md](./06_Exemplars.md)

---

**ğŸ‰ æ­å–œï¼ä½ å·²ç»æŒæ¡äº†æ•°æ®ç‚¹çš„å®Œæ•´çŸ¥è¯†ï¼**

ä¸‹ä¸€æ­¥ï¼šå­¦ä¹  [æ—¶é—´åºåˆ—](./03_æ—¶é—´åºåˆ—.md) äº†è§£ Metric çš„èšåˆå’Œå­˜å‚¨ã€‚
