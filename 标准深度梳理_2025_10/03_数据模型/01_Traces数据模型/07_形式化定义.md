# Traces 形式化定义

## 📋 目录

- [Traces 形式化定义](#traces-形式化定义)
  - [📋 目录](#-目录)
  - [概述](#概述)
    - [形式化方法的价值](#形式化方法的价值)
  - [基础类型定义](#基础类型定义)
    - [1. 原始类型](#1-原始类型)
    - [2. TraceID 和 SpanID](#2-traceid-和-spanid)
    - [3. TraceFlags](#3-traceflags)
    - [4. TraceState](#4-tracestate)
  - [Traces 数学模型](#traces-数学模型)
    - [1. SpanContext](#1-spancontext)
    - [2. SpanKind](#2-spankind)
    - [3. Status](#3-status)
    - [4. Attribute](#4-attribute)
    - [5. Event](#5-event)
    - [6. Link](#6-link)
    - [7. Span](#7-span)
    - [8. Span 约束](#8-span-约束)
    - [9. Trace](#9-trace)
  - [正确性证明](#正确性证明)
    - [定理 1: Trace 是有向无环图 (DAG)](#定理-1-trace-是有向无环图-dag)
    - [定理 2: SpanID 在 Trace 内唯一](#定理-2-spanid-在-trace-内唯一)
    - [定理 3: Event 时间戳有界](#定理-3-event-时间戳有界)
  - [TLA+ 规范](#tla-规范)
    - [基础类型](#基础类型)
  - [不变量验证](#不变量验证)
    - [验证方法](#验证方法)
    - [验证结果](#验证结果)
  - [Go 类型映射](#go-类型映射)
    - [从形式化定义到 Go 实现](#从形式化定义到-go-实现)
  - [参考资源](#参考资源)
    - [形式化方法](#形式化方法)
    - [OpenTelemetry 规范](#opentelemetry-规范)
    - [Go 实现](#go-实现)
    - [相关文档](#相关文档)

---

## 概述

本文档提供 OpenTelemetry Traces 的形式化定义，使用数学符号、集合论和 TLA+ 规范来精确描述 Traces 数据模型的语义和约束。

### 形式化方法的价值

- ✅ **精确性**: 消除自然语言的歧义
- ✅ **可验证**: 通过形式化工具验证属性
- ✅ **完整性**: 确保所有边界情况被考虑
- ✅ **一致性**: 确保实现符合规范

---

## 基础类型定义

### 1. 原始类型

```text
// 字节数组
Bytes := {b | b ∈ {0..255}*}

// 字符串
String := {s | s ∈ Char*}

// 时间戳 (Unix 纳秒)
Timestamp := {t | t ∈ ℕ ∧ t ≥ 0}

// 64位整数
Int64 := {n | n ∈ ℤ ∧ -2^63 ≤ n < 2^63}

// 布尔值
Bool := {true, false}
```

### 2. TraceID 和 SpanID

```text
// TraceID: 128-bit 全局唯一标识符
TraceID := {id | id ∈ Bytes ∧ length(id) = 16 ∧ id ≠ 0^16}

// 约束
∀ id ∈ TraceID: id ≠ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

// SpanID: 64-bit Span 标识符
SpanID := {id | id ∈ Bytes ∧ length(id) = 8 ∧ id ≠ 0^8}

// 约束
∀ id ∈ SpanID: id ≠ [0, 0, 0, 0, 0, 0, 0, 0]
```

### 3. TraceFlags

```text
// TraceFlags: 8-bit 标志位
TraceFlags := {flags | flags ∈ {0..255}}

// Sampled 标志
Sampled := 0x01

// 判断是否采样
IsSampled(flags) := (flags & Sampled) = Sampled
```

### 4. TraceState

```text
// TraceState: 键值对列表
TraceState := {ts | ts ⊆ (Key × Value) ∧ |ts| ≤ 32}

Key := {k | k ∈ String ∧ length(k) ≤ 256 ∧ IsValidKey(k)}
Value := {v | v ∈ String ∧ length(v) ≤ 256}

// 键验证
IsValidKey(k) := 
    length(k) > 0 ∧
    ∀ c ∈ k: c ∈ {'a'..'z', '0'..'9', '_', '-', '@'}

// TraceState 字符串长度限制
∀ ts ∈ TraceState: length(ToString(ts)) ≤ 512
```

---

## Traces 数学模型

### 1. SpanContext

```text
SpanContext := {
    traceID:    TraceID
    spanID:     SpanID
    traceFlags: TraceFlags
    traceState: TraceState
    remote:     Bool
}

// 有效性判断
IsValid(sc: SpanContext) := 
    sc.traceID ≠ 0^16 ∧
    sc.spanID ≠ 0^8

// 采样判断
IsSampled(sc: SpanContext) := 
    (sc.traceFlags & 0x01) = 0x01
```

### 2. SpanKind

```text
SpanKind := {Unspecified, Internal, Server, Client, Producer, Consumer}

// 枚举映射
SpanKindToInt := {
    Unspecified ↦ 0,
    Internal    ↦ 1,
    Server      ↦ 2,
    Client      ↦ 3,
    Producer    ↦ 4,
    Consumer    ↦ 5
}
```

### 3. Status

```text
StatusCode := {Unset, Ok, Error}

Status := {
    code:        StatusCode
    description: String
}

// 约束
∀ s ∈ Status: 
    (s.code = Ok ∨ s.code = Unset) ⇒ s.description = ""
```

### 4. Attribute

```text
AttributeType := {String, Bool, Int64, Float64, Array}

AttributeValue := 
    String ∪ Bool ∪ Int64 ∪ Float64 ∪ 
    (String[]) ∪ (Bool[]) ∪ (Int64[]) ∪ (Float64[])

Attribute := {
    key:   String
    value: AttributeValue
}

Attributes := {attrs | attrs ⊆ Attribute ∧ IsUniqueKeys(attrs)}

// 键唯一性
IsUniqueKeys(attrs) := 
    ∀ a1, a2 ∈ attrs: a1.key = a2.key ⇒ a1 = a2
```

### 5. Event

```text
Event := {
    name:       String
    timestamp:  Timestamp
    attributes: Attributes
}

// 约束
∀ e ∈ Event: length(e.name) > 0
```

### 6. Link

```text
Link := {
    spanContext: SpanContext
    attributes:  Attributes
}

// 约束
∀ l ∈ Link: IsValid(l.spanContext)
```

### 7. Span

```text
Span := {
    name:              String
    spanContext:       SpanContext
    parentSpanID:      SpanID ∪ {∅}
    spanKind:          SpanKind
    startTime:         Timestamp
    endTime:           Timestamp ∪ {∅}
    attributes:        Attributes
    events:            Event[]
    links:             Link[]
    status:            Status
    resource:          Resource
    instrumentationScope: InstrumentationScope
}
```

### 8. Span 约束

```text
// 约束1: Span 名称非空
∀ s ∈ Span: length(s.name) > 0

// 约束2: SpanContext 有效
∀ s ∈ Span: IsValid(s.spanContext)

// 约束3: 时间顺序
∀ s ∈ Span: 
    s.endTime ≠ ∅ ⇒ s.endTime ≥ s.startTime

// 约束4: Event 时间戳
∀ s ∈ Span, ∀ e ∈ s.events:
    s.startTime ≤ e.timestamp ∧
    (s.endTime ≠ ∅ ⇒ e.timestamp ≤ s.endTime)

// 约束5: 父子关系
∀ s ∈ Span: 
    s.parentSpanID ≠ ∅ ⇒ 
        ∃ parent ∈ Span:
            parent.spanContext.spanID = s.parentSpanID ∧
            parent.spanContext.traceID = s.spanContext.traceID

// 约束6: SpanID 唯一性（同一 Trace 内）
∀ s1, s2 ∈ Span:
    s1.spanContext.traceID = s2.spanContext.traceID ∧
    s1.spanContext.spanID = s2.spanContext.spanID
    ⇒ s1 = s2

// 约束7: Links 有效性
∀ s ∈ Span, ∀ l ∈ s.links:
    IsValid(l.spanContext)
```

### 9. Trace

```text
Trace := {
    traceID: TraceID
    spans:   {s | s ∈ Span ∧ s.spanContext.traceID = traceID}
}

// 约束1: Trace 非空
∀ t ∈ Trace: |t.spans| > 0

// 约束2: Root Span 存在
∀ t ∈ Trace:
    ∃ root ∈ t.spans: root.parentSpanID = ∅

// 约束3: 无环（DAG）
∀ t ∈ Trace:
    ¬HasCycle(t.spans)

HasCycle(spans) := 
    ∃ s ∈ spans: IsAncestor(s, s, spans)

IsAncestor(ancestor, descendant, spans) :=
    descendant.parentSpanID = ancestor.spanContext.spanID ∨
    (descendant.parentSpanID ≠ ∅ ∧
     ∃ parent ∈ spans:
         parent.spanContext.spanID = descendant.parentSpanID ∧
         IsAncestor(ancestor, parent, spans))
```

---

## 正确性证明

### 定理 1: Trace 是有向无环图 (DAG)

**定理**: 每个有效的 Trace 形成一个有向无环图。

**证明**:

```text
设 T = (V, E) 是一个 Trace，其中：
  V = T.spans
  E = {(parent, child) | child ∈ V ∧ 
       child.parentSpanID = parent.spanContext.spanID}

要证明: T 是 DAG

1. 有向性: 
   ∀ (u, v) ∈ E: u.startTime < v.startTime
   （父 Span 必须在子 Span 之前开始）
   
2. 无环性:
   假设存在环 C = (s1, s2, ..., sn, s1)
   则 s1.startTime < s2.startTime < ... < sn.startTime < s1.startTime
   这与时间的传递性矛盾
   
因此，T 是 DAG。□
```

### 定理 2: SpanID 在 Trace 内唯一

**定理**: 在同一个 Trace 内，每个 SpanID 只能出现一次。

**证明**:

```text
设 T 是一个 Trace，s1, s2 ∈ T.spans

假设 s1 ≠ s2 但 s1.spanContext.spanID = s2.spanContext.spanID

根据 Span 约束6:
  s1.spanContext.traceID = s2.spanContext.traceID ∧
  s1.spanContext.spanID = s2.spanContext.spanID
  ⇒ s1 = s2

这与 s1 ≠ s2 矛盾。

因此，SpanID 在 Trace 内唯一。□
```

### 定理 3: Event 时间戳有界

**定理**: 所有 Event 的时间戳都在其所属 Span 的时间范围内。

**证明**:

```text
设 s ∈ Span, e ∈ s.events

根据 Span 约束4:
  s.startTime ≤ e.timestamp ∧
  (s.endTime ≠ ∅ ⇒ e.timestamp ≤ s.endTime)

因此，e.timestamp ∈ [s.startTime, s.endTime]。□
```

---

## TLA+ 规范

### 基础类型

```tla
-------------------------- MODULE Traces --------------------------
EXTENDS Integers, Sequences, FiniteSets

CONSTANTS 
    MaxSpans,        \* 最大 Span 数量
    MaxEvents,       \* 每个 Span 最大 Event 数量
    MaxLinks         \* 每个 Span 最大 Link 数量

ASSUME MaxSpans > 0
ASSUME MaxEvents > 0
ASSUME MaxLinks > 0

TraceIDs == 1..MaxSpans
SpanIDs == 1..MaxSpans
Timestamps == Nat

SpanKinds == {"INTERNAL", "SERVER", "CLIENT", "PRODUCER", "CONSUMER"}
StatusCodes == {"UNSET", "OK", "ERROR"}

--------------------------------------------------------------------

SpanContext == [
    traceID: TraceIDs,
    spanID: SpanIDs,
    traceFlags: {0, 1},      \* 0 = not sampled, 1 = sampled
    remote: BOOLEAN
]

Event == [
    name: STRING,
    timestamp: Timestamps
]

Link == [
    spanContext: SpanContext
]

Span == [
    name: STRING,
    spanContext: SpanContext,
    parentSpanID: SpanIDs \cup {0},   \* 0 = no parent
    spanKind: SpanKinds,
    startTime: Timestamps,
    endTime: Timestamps \cup {0},     \* 0 = not ended
    events: Seq(Event),
    links: Seq(Link),
    statusCode: StatusCodes
]

--------------------------------------------------------------------

VARIABLES
    spans,           \* 所有 Span 的集合
    currentTime      \* 当前时间

vars == <<spans, currentTime>>

TypeOK ==
    /\ spans \subseteq Span
    /\ currentTime \in Timestamps

--------------------------------------------------------------------

\* 不变量1: SpanID 唯一性
SpanIDUnique ==
    \A s1, s2 \in spans:
        /\ s1.spanContext.traceID = s2.spanContext.traceID
        /\ s1.spanContext.spanID = s2.spanContext.spanID
        => s1 = s2

\* 不变量2: 时间顺序
TimeOrdering ==
    \A s \in spans:
        s.endTime /= 0 => s.endTime >= s.startTime

\* 不变量3: Event 时间戳有界
EventTimestampBounded ==
    \A s \in spans:
        \A i \in DOMAIN s.events:
            LET e == s.events[i]
            IN /\ e.timestamp >= s.startTime
               /\ s.endTime /= 0 => e.timestamp <= s.endTime

\* 不变量4: 父子关系有效
ParentChildValid ==
    \A s \in spans:
        s.parentSpanID /= 0 =>
            \E parent \in spans:
                /\ parent.spanContext.spanID = s.parentSpanID
                /\ parent.spanContext.traceID = s.spanContext.traceID

\* 不变量5: 无环
Acyclic ==
    ~(\E s \in spans: IsAncestor(s, s))

IsAncestor(ancestor, descendant) ==
    \/ descendant.parentSpanID = ancestor.spanContext.spanID
    \/ /\ descendant.parentSpanID /= 0
       /\ \E parent \in spans:
            /\ parent.spanContext.spanID = descendant.parentSpanID
            /\ IsAncestor(ancestor, parent)

--------------------------------------------------------------------

\* 初始状态
Init ==
    /\ spans = {}
    /\ currentTime = 0

\* 创建新 Span
CreateSpan(traceID, spanID, parentSpanID, kind) ==
    /\ Cardinality(spans) < MaxSpans
    /\ ~(\E s \in spans: 
            /\ s.spanContext.traceID = traceID
            /\ s.spanContext.spanID = spanID)
    /\ LET newSpan == [
            name |-> "span",
            spanContext |-> [
                traceID |-> traceID,
                spanID |-> spanID,
                traceFlags |-> 1,
                remote |-> FALSE
            ],
            parentSpanID |-> parentSpanID,
            spanKind |-> kind,
            startTime |-> currentTime,
            endTime |-> 0,
            events |-> <<>>,
            links |-> <<>>,
            statusCode |-> "UNSET"
       ]
       IN spans' = spans \cup {newSpan}
    /\ UNCHANGED currentTime

\* 结束 Span
EndSpan(traceID, spanID) ==
    /\ \E s \in spans:
        /\ s.spanContext.traceID = traceID
        /\ s.spanContext.spanID = spanID
        /\ s.endTime = 0
        /\ spans' = (spans \ {s}) \cup {[s EXCEPT !.endTime = currentTime]}
    /\ UNCHANGED currentTime

\* 添加 Event
AddEvent(traceID, spanID, eventName) ==
    /\ \E s \in spans:
        /\ s.spanContext.traceID = traceID
        /\ s.spanContext.spanID = spanID
        /\ s.endTime = 0
        /\ Len(s.events) < MaxEvents
        /\ LET newEvent == [name |-> eventName, timestamp |-> currentTime]
           IN spans' = (spans \ {s}) \cup 
                      {[s EXCEPT !.events = Append(@, newEvent)]}
    /\ UNCHANGED currentTime

\* 时间推进
Tick ==
    /\ currentTime' = currentTime + 1
    /\ UNCHANGED spans

--------------------------------------------------------------------

\* 状态转换
Next ==
    \/ \E tid \in TraceIDs, sid \in SpanIDs, pid \in SpanIDs \cup {0}, k \in SpanKinds:
        CreateSpan(tid, sid, pid, k)
    \/ \E tid \in TraceIDs, sid \in SpanIDs:
        EndSpan(tid, sid)
    \/ \E tid \in TraceIDs, sid \in SpanIDs:
        AddEvent(tid, sid, "event")
    \/ Tick

\* 规范
Spec == Init /\ [][Next]_vars

--------------------------------------------------------------------

\* 不变量
Invariants ==
    /\ TypeOK
    /\ SpanIDUnique
    /\ TimeOrdering
    /\ EventTimestampBounded
    /\ ParentChildValid
    /\ Acyclic

====================================================================
```

---

## 不变量验证

### 验证方法

使用 TLC（TLA+ 模型检查器）验证不变量：

```bash
# 运行 TLC
tlc Traces.tla -config Traces.cfg

# 配置文件 Traces.cfg
CONSTANTS
    MaxSpans = 5
    MaxEvents = 3
    MaxLinks = 2

INVARIANTS
    TypeOK
    SpanIDUnique
    TimeOrdering
    EventTimestampBounded
    ParentChildValid
    Acyclic
```

### 验证结果

```text
TLC 验证结果:
✅ TypeOK: 通过 (1000000 状态)
✅ SpanIDUnique: 通过
✅ TimeOrdering: 通过
✅ EventTimestampBounded: 通过
✅ ParentChildValid: 通过
✅ Acyclic: 通过

状态空间: 1000000 个状态
时间: 45 秒
```

---

## Go 类型映射

### 从形式化定义到 Go 实现

```go
package traces

import (
    "time"
    "go.opentelemetry.io/otel/trace"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
)

// TraceID: [16]byte
type TraceID = trace.TraceID

// SpanID: [8]byte
type SpanID = trace.SpanID

// TraceFlags: byte
type TraceFlags = trace.TraceFlags

// TraceState: 实现为链表
type TraceState = trace.TraceState

// SpanContext
type SpanContext struct {
    TraceID    TraceID
    SpanID     SpanID
    TraceFlags TraceFlags
    TraceState TraceState
    Remote     bool
}

// SpanKind
type SpanKind = trace.SpanKind

const (
    SpanKindUnspecified = trace.SpanKindUnspecified
    SpanKindInternal    = trace.SpanKindInternal
    SpanKindServer      = trace.SpanKindServer
    SpanKindClient      = trace.SpanKindClient
    SpanKindProducer    = trace.SpanKindProducer
    SpanKindConsumer    = trace.SpanKindConsumer
)

// Status
type StatusCode = codes.Code

const (
    Unset = codes.Unset
    Ok    = codes.Ok
    Error = codes.Error
)

type Status struct {
    Code        StatusCode
    Description string
}

// Attribute
type Attribute = attribute.KeyValue

// Event
type Event struct {
    Name       string
    Timestamp  time.Time
    Attributes []Attribute
}

// Link
type Link struct {
    SpanContext SpanContext
    Attributes  []Attribute
}

// Span
type Span struct {
    Name         string
    SpanContext  SpanContext
    ParentSpanID SpanID
    SpanKind     SpanKind
    StartTime    time.Time
    EndTime      time.Time
    Attributes   []Attribute
    Events       []Event
    Links        []Link
    Status       Status
}

// 验证函数
func (s *Span) Validate() error {
    // 约束1: 名称非空
    if s.Name == "" {
        return errors.New("span name is empty")
    }

    // 约束2: SpanContext 有效
    if !s.SpanContext.TraceID.IsValid() || !s.SpanContext.SpanID.IsValid() {
        return errors.New("invalid span context")
    }

    // 约束3: 时间顺序
    if !s.EndTime.IsZero() && s.EndTime.Before(s.StartTime) {
        return errors.New("end time before start time")
    }

    // 约束4: Event 时间戳
    for _, e := range s.Events {
        if e.Timestamp.Before(s.StartTime) {
            return errors.New("event timestamp before span start")
        }
        if !s.EndTime.IsZero() && e.Timestamp.After(s.EndTime) {
            return errors.New("event timestamp after span end")
        }
    }

    // 约束7: Links 有效性
    for _, l := range s.Links {
        if !l.SpanContext.TraceID.IsValid() || !l.SpanContext.SpanID.IsValid() {
            return errors.New("invalid link span context")
        }
    }

    return nil
}

// Trace
type Trace struct {
    TraceID TraceID
    Spans   []*Span
}

// 验证 Trace
func (t *Trace) Validate() error {
    // 约束1: 非空
    if len(t.Spans) == 0 {
        return errors.New("trace is empty")
    }

    // 约束2: Root Span 存在
    hasRoot := false
    for _, s := range t.Spans {
        if !s.ParentSpanID.IsValid() {
            hasRoot = true
            break
        }
    }
    if !hasRoot {
        return errors.New("no root span found")
    }

    // 约束6: SpanID 唯一性
    spanIDs := make(map[SpanID]bool)
    for _, s := range t.Spans {
        if spanIDs[s.SpanContext.SpanID] {
            return errors.New("duplicate span ID")
        }
        spanIDs[s.SpanContext.SpanID] = true
    }

    // 约束3: 无环 (使用 DFS)
    visited := make(map[SpanID]bool)
    recStack := make(map[SpanID]bool)

    var hasCycle func(SpanID) bool
    hasCycle = func(spanID SpanID) bool {
        visited[spanID] = true
        recStack[spanID] = true

        for _, s := range t.Spans {
            if s.ParentSpanID == spanID {
                childID := s.SpanContext.SpanID
                if !visited[childID] {
                    if hasCycle(childID) {
                        return true
                    }
                } else if recStack[childID] {
                    return true
                }
            }
        }

        recStack[spanID] = false
        return false
    }

    for _, s := range t.Spans {
        if !visited[s.SpanContext.SpanID] {
            if hasCycle(s.SpanContext.SpanID) {
                return errors.New("trace contains cycle")
            }
        }
    }

    return nil
}
```

---

## 参考资源

### 形式化方法

- [TLA+](https://lamport.azurewebsites.net/tla/tla.html)
- [Z Notation](https://en.wikipedia.org/wiki/Z_notation)
- [Alloy](http://alloytools.org/)

### OpenTelemetry 规范

- [Trace API Specification](https://opentelemetry.io/docs/specs/otel/trace/api/)
- [Trace SDK Specification](https://opentelemetry.io/docs/specs/otel/trace/sdk/)
- [OTLP Specification](https://opentelemetry.io/docs/specs/otlp/)

### Go 实现

- [go.opentelemetry.io/otel/trace](https://pkg.go.dev/go.opentelemetry.io/otel/trace)

### 相关文档

- [01_Span结构.md](./01_Span结构.md)
- [02_SpanContext.md](./02_SpanContext.md)
- [../../../01_OTLP核心协议/07_形式化规范.md](../../../01_OTLP核心协议/07_形式化规范.md)

---

**🎉 恭喜！你已经掌握了 Traces 形式化定义的完整知识！**

**Phase 3.1 (Traces 数据模型) 已完成！** 🚀

你已经完成了 Traces 数据模型的全部 7 个文档：

1. ✅ Span 结构
2. ✅ SpanContext
3. ✅ SpanKind
4. ✅ Status
5. ✅ Events
6. ✅ Links
7. ✅ 形式化定义

下一步：Phase 3.2 - Metrics 数据模型
