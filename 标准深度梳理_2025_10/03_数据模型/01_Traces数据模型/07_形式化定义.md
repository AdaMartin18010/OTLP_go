# Traces å½¢å¼åŒ–å®šä¹‰

## ğŸ“‹ ç›®å½•

- [Traces å½¢å¼åŒ–å®šä¹‰](#traces-å½¢å¼åŒ–å®šä¹‰)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [å½¢å¼åŒ–æ–¹æ³•çš„ä»·å€¼](#å½¢å¼åŒ–æ–¹æ³•çš„ä»·å€¼)
  - [åŸºç¡€ç±»å‹å®šä¹‰](#åŸºç¡€ç±»å‹å®šä¹‰)
    - [1. åŸå§‹ç±»å‹](#1-åŸå§‹ç±»å‹)
    - [2. TraceID å’Œ SpanID](#2-traceid-å’Œ-spanid)
    - [3. TraceFlags](#3-traceflags)
    - [4. TraceState](#4-tracestate)
  - [Traces æ•°å­¦æ¨¡å‹](#traces-æ•°å­¦æ¨¡å‹)
    - [1. SpanContext](#1-spancontext)
    - [2. SpanKind](#2-spankind)
    - [3. Status](#3-status)
    - [4. Attribute](#4-attribute)
    - [5. Event](#5-event)
    - [6. Link](#6-link)
    - [7. Span](#7-span)
    - [8. Span çº¦æŸ](#8-span-çº¦æŸ)
    - [9. Trace](#9-trace)
  - [æ­£ç¡®æ€§è¯æ˜](#æ­£ç¡®æ€§è¯æ˜)
    - [å®šç† 1: Trace æ˜¯æœ‰å‘æ— ç¯å›¾ (DAG)](#å®šç†-1-trace-æ˜¯æœ‰å‘æ— ç¯å›¾-dag)
    - [å®šç† 2: SpanID åœ¨ Trace å†…å”¯ä¸€](#å®šç†-2-spanid-åœ¨-trace-å†…å”¯ä¸€)
    - [å®šç† 3: Event æ—¶é—´æˆ³æœ‰ç•Œ](#å®šç†-3-event-æ—¶é—´æˆ³æœ‰ç•Œ)
  - [TLA+ è§„èŒƒ](#tla-è§„èŒƒ)
    - [åŸºç¡€ç±»å‹](#åŸºç¡€ç±»å‹)
  - [ä¸å˜é‡éªŒè¯](#ä¸å˜é‡éªŒè¯)
    - [éªŒè¯æ–¹æ³•](#éªŒè¯æ–¹æ³•)
    - [éªŒè¯ç»“æœ](#éªŒè¯ç»“æœ)
  - [Go ç±»å‹æ˜ å°„](#go-ç±»å‹æ˜ å°„)
    - [ä»å½¢å¼åŒ–å®šä¹‰åˆ° Go å®ç°](#ä»å½¢å¼åŒ–å®šä¹‰åˆ°-go-å®ç°)
  - [å‚è€ƒèµ„æº](#å‚è€ƒèµ„æº)
    - [å½¢å¼åŒ–æ–¹æ³•](#å½¢å¼åŒ–æ–¹æ³•)
    - [OpenTelemetry è§„èŒƒ](#opentelemetry-è§„èŒƒ)
    - [Go å®ç°](#go-å®ç°)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)

---

## æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾› OpenTelemetry Traces çš„å½¢å¼åŒ–å®šä¹‰ï¼Œä½¿ç”¨æ•°å­¦ç¬¦å·ã€é›†åˆè®ºå’Œ TLA+ è§„èŒƒæ¥ç²¾ç¡®æè¿° Traces æ•°æ®æ¨¡å‹çš„è¯­ä¹‰å’Œçº¦æŸã€‚

### å½¢å¼åŒ–æ–¹æ³•çš„ä»·å€¼

- âœ… **ç²¾ç¡®æ€§**: æ¶ˆé™¤è‡ªç„¶è¯­è¨€çš„æ­§ä¹‰
- âœ… **å¯éªŒè¯**: é€šè¿‡å½¢å¼åŒ–å·¥å…·éªŒè¯å±æ€§
- âœ… **å®Œæ•´æ€§**: ç¡®ä¿æ‰€æœ‰è¾¹ç•Œæƒ…å†µè¢«è€ƒè™‘
- âœ… **ä¸€è‡´æ€§**: ç¡®ä¿å®ç°ç¬¦åˆè§„èŒƒ

---

## åŸºç¡€ç±»å‹å®šä¹‰

### 1. åŸå§‹ç±»å‹

```text
// å­—èŠ‚æ•°ç»„
Bytes := {b | b âˆˆ {0..255}*}

// å­—ç¬¦ä¸²
String := {s | s âˆˆ Char*}

// æ—¶é—´æˆ³ (Unix çº³ç§’)
Timestamp := {t | t âˆˆ â„• âˆ§ t â‰¥ 0}

// 64ä½æ•´æ•°
Int64 := {n | n âˆˆ â„¤ âˆ§ -2^63 â‰¤ n < 2^63}

// å¸ƒå°”å€¼
Bool := {true, false}
```

### 2. TraceID å’Œ SpanID

```text
// TraceID: 128-bit å…¨å±€å”¯ä¸€æ ‡è¯†ç¬¦
TraceID := {id | id âˆˆ Bytes âˆ§ length(id) = 16 âˆ§ id â‰  0^16}

// çº¦æŸ
âˆ€ id âˆˆ TraceID: id â‰  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

// SpanID: 64-bit Span æ ‡è¯†ç¬¦
SpanID := {id | id âˆˆ Bytes âˆ§ length(id) = 8 âˆ§ id â‰  0^8}

// çº¦æŸ
âˆ€ id âˆˆ SpanID: id â‰  [0, 0, 0, 0, 0, 0, 0, 0]
```

### 3. TraceFlags

```text
// TraceFlags: 8-bit æ ‡å¿—ä½
TraceFlags := {flags | flags âˆˆ {0..255}}

// Sampled æ ‡å¿—
Sampled := 0x01

// åˆ¤æ–­æ˜¯å¦é‡‡æ ·
IsSampled(flags) := (flags & Sampled) = Sampled
```

### 4. TraceState

```text
// TraceState: é”®å€¼å¯¹åˆ—è¡¨
TraceState := {ts | ts âŠ† (Key Ã— Value) âˆ§ |ts| â‰¤ 32}

Key := {k | k âˆˆ String âˆ§ length(k) â‰¤ 256 âˆ§ IsValidKey(k)}
Value := {v | v âˆˆ String âˆ§ length(v) â‰¤ 256}

// é”®éªŒè¯
IsValidKey(k) := 
    length(k) > 0 âˆ§
    âˆ€ c âˆˆ k: c âˆˆ {'a'..'z', '0'..'9', '_', '-', '@'}

// TraceState å­—ç¬¦ä¸²é•¿åº¦é™åˆ¶
âˆ€ ts âˆˆ TraceState: length(ToString(ts)) â‰¤ 512
```

---

## Traces æ•°å­¦æ¨¡å‹

### 1. SpanContext

```text
SpanContext := {
    traceID:    TraceID
    spanID:     SpanID
    traceFlags: TraceFlags
    traceState: TraceState
    remote:     Bool
}

// æœ‰æ•ˆæ€§åˆ¤æ–­
IsValid(sc: SpanContext) := 
    sc.traceID â‰  0^16 âˆ§
    sc.spanID â‰  0^8

// é‡‡æ ·åˆ¤æ–­
IsSampled(sc: SpanContext) := 
    (sc.traceFlags & 0x01) = 0x01
```

### 2. SpanKind

```text
SpanKind := {Unspecified, Internal, Server, Client, Producer, Consumer}

// æšä¸¾æ˜ å°„
SpanKindToInt := {
    Unspecified â†¦ 0,
    Internal    â†¦ 1,
    Server      â†¦ 2,
    Client      â†¦ 3,
    Producer    â†¦ 4,
    Consumer    â†¦ 5
}
```

### 3. Status

```text
StatusCode := {Unset, Ok, Error}

Status := {
    code:        StatusCode
    description: String
}

// çº¦æŸ
âˆ€ s âˆˆ Status: 
    (s.code = Ok âˆ¨ s.code = Unset) â‡’ s.description = ""
```

### 4. Attribute

```text
AttributeType := {String, Bool, Int64, Float64, Array}

AttributeValue := 
    String âˆª Bool âˆª Int64 âˆª Float64 âˆª 
    (String[]) âˆª (Bool[]) âˆª (Int64[]) âˆª (Float64[])

Attribute := {
    key:   String
    value: AttributeValue
}

Attributes := {attrs | attrs âŠ† Attribute âˆ§ IsUniqueKeys(attrs)}

// é”®å”¯ä¸€æ€§
IsUniqueKeys(attrs) := 
    âˆ€ a1, a2 âˆˆ attrs: a1.key = a2.key â‡’ a1 = a2
```

### 5. Event

```text
Event := {
    name:       String
    timestamp:  Timestamp
    attributes: Attributes
}

// çº¦æŸ
âˆ€ e âˆˆ Event: length(e.name) > 0
```

### 6. Link

```text
Link := {
    spanContext: SpanContext
    attributes:  Attributes
}

// çº¦æŸ
âˆ€ l âˆˆ Link: IsValid(l.spanContext)
```

### 7. Span

```text
Span := {
    name:              String
    spanContext:       SpanContext
    parentSpanID:      SpanID âˆª {âˆ…}
    spanKind:          SpanKind
    startTime:         Timestamp
    endTime:           Timestamp âˆª {âˆ…}
    attributes:        Attributes
    events:            Event[]
    links:             Link[]
    status:            Status
    resource:          Resource
    instrumentationScope: InstrumentationScope
}
```

### 8. Span çº¦æŸ

```text
// çº¦æŸ1: Span åç§°éç©º
âˆ€ s âˆˆ Span: length(s.name) > 0

// çº¦æŸ2: SpanContext æœ‰æ•ˆ
âˆ€ s âˆˆ Span: IsValid(s.spanContext)

// çº¦æŸ3: æ—¶é—´é¡ºåº
âˆ€ s âˆˆ Span: 
    s.endTime â‰  âˆ… â‡’ s.endTime â‰¥ s.startTime

// çº¦æŸ4: Event æ—¶é—´æˆ³
âˆ€ s âˆˆ Span, âˆ€ e âˆˆ s.events:
    s.startTime â‰¤ e.timestamp âˆ§
    (s.endTime â‰  âˆ… â‡’ e.timestamp â‰¤ s.endTime)

// çº¦æŸ5: çˆ¶å­å…³ç³»
âˆ€ s âˆˆ Span: 
    s.parentSpanID â‰  âˆ… â‡’ 
        âˆƒ parent âˆˆ Span:
            parent.spanContext.spanID = s.parentSpanID âˆ§
            parent.spanContext.traceID = s.spanContext.traceID

// çº¦æŸ6: SpanID å”¯ä¸€æ€§ï¼ˆåŒä¸€ Trace å†…ï¼‰
âˆ€ s1, s2 âˆˆ Span:
    s1.spanContext.traceID = s2.spanContext.traceID âˆ§
    s1.spanContext.spanID = s2.spanContext.spanID
    â‡’ s1 = s2

// çº¦æŸ7: Links æœ‰æ•ˆæ€§
âˆ€ s âˆˆ Span, âˆ€ l âˆˆ s.links:
    IsValid(l.spanContext)
```

### 9. Trace

```text
Trace := {
    traceID: TraceID
    spans:   {s | s âˆˆ Span âˆ§ s.spanContext.traceID = traceID}
}

// çº¦æŸ1: Trace éç©º
âˆ€ t âˆˆ Trace: |t.spans| > 0

// çº¦æŸ2: Root Span å­˜åœ¨
âˆ€ t âˆˆ Trace:
    âˆƒ root âˆˆ t.spans: root.parentSpanID = âˆ…

// çº¦æŸ3: æ— ç¯ï¼ˆDAGï¼‰
âˆ€ t âˆˆ Trace:
    Â¬HasCycle(t.spans)

HasCycle(spans) := 
    âˆƒ s âˆˆ spans: IsAncestor(s, s, spans)

IsAncestor(ancestor, descendant, spans) :=
    descendant.parentSpanID = ancestor.spanContext.spanID âˆ¨
    (descendant.parentSpanID â‰  âˆ… âˆ§
     âˆƒ parent âˆˆ spans:
         parent.spanContext.spanID = descendant.parentSpanID âˆ§
         IsAncestor(ancestor, parent, spans))
```

---

## æ­£ç¡®æ€§è¯æ˜

### å®šç† 1: Trace æ˜¯æœ‰å‘æ— ç¯å›¾ (DAG)

**å®šç†**: æ¯ä¸ªæœ‰æ•ˆçš„ Trace å½¢æˆä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ã€‚

**è¯æ˜**:

```text
è®¾ T = (V, E) æ˜¯ä¸€ä¸ª Traceï¼Œå…¶ä¸­ï¼š
  V = T.spans
  E = {(parent, child) | child âˆˆ V âˆ§ 
       child.parentSpanID = parent.spanContext.spanID}

è¦è¯æ˜: T æ˜¯ DAG

1. æœ‰å‘æ€§: 
   âˆ€ (u, v) âˆˆ E: u.startTime < v.startTime
   ï¼ˆçˆ¶ Span å¿…é¡»åœ¨å­ Span ä¹‹å‰å¼€å§‹ï¼‰
   
2. æ— ç¯æ€§:
   å‡è®¾å­˜åœ¨ç¯ C = (s1, s2, ..., sn, s1)
   åˆ™ s1.startTime < s2.startTime < ... < sn.startTime < s1.startTime
   è¿™ä¸æ—¶é—´çš„ä¼ é€’æ€§çŸ›ç›¾
   
å› æ­¤ï¼ŒT æ˜¯ DAGã€‚â–¡
```

### å®šç† 2: SpanID åœ¨ Trace å†…å”¯ä¸€

**å®šç†**: åœ¨åŒä¸€ä¸ª Trace å†…ï¼Œæ¯ä¸ª SpanID åªèƒ½å‡ºç°ä¸€æ¬¡ã€‚

**è¯æ˜**:

```text
è®¾ T æ˜¯ä¸€ä¸ª Traceï¼Œs1, s2 âˆˆ T.spans

å‡è®¾ s1 â‰  s2 ä½† s1.spanContext.spanID = s2.spanContext.spanID

æ ¹æ® Span çº¦æŸ6:
  s1.spanContext.traceID = s2.spanContext.traceID âˆ§
  s1.spanContext.spanID = s2.spanContext.spanID
  â‡’ s1 = s2

è¿™ä¸ s1 â‰  s2 çŸ›ç›¾ã€‚

å› æ­¤ï¼ŒSpanID åœ¨ Trace å†…å”¯ä¸€ã€‚â–¡
```

### å®šç† 3: Event æ—¶é—´æˆ³æœ‰ç•Œ

**å®šç†**: æ‰€æœ‰ Event çš„æ—¶é—´æˆ³éƒ½åœ¨å…¶æ‰€å± Span çš„æ—¶é—´èŒƒå›´å†…ã€‚

**è¯æ˜**:

```text
è®¾ s âˆˆ Span, e âˆˆ s.events

æ ¹æ® Span çº¦æŸ4:
  s.startTime â‰¤ e.timestamp âˆ§
  (s.endTime â‰  âˆ… â‡’ e.timestamp â‰¤ s.endTime)

å› æ­¤ï¼Œe.timestamp âˆˆ [s.startTime, s.endTime]ã€‚â–¡
```

---

## TLA+ è§„èŒƒ

### åŸºç¡€ç±»å‹

```tla
-------------------------- MODULE Traces --------------------------
EXTENDS Integers, Sequences, FiniteSets

CONSTANTS 
    MaxSpans,        \* æœ€å¤§ Span æ•°é‡
    MaxEvents,       \* æ¯ä¸ª Span æœ€å¤§ Event æ•°é‡
    MaxLinks         \* æ¯ä¸ª Span æœ€å¤§ Link æ•°é‡

ASSUME MaxSpans > 0
ASSUME MaxEvents > 0
ASSUME MaxLinks > 0

TraceIDs == 1..MaxSpans
SpanIDs == 1..MaxSpans
Timestamps == Nat

SpanKinds == {"INTERNAL", "SERVER", "CLIENT", "PRODUCER", "CONSUMER"}
StatusCodes == {"UNSET", "OK", "ERROR"}

--------------------------------------------------------------------

SpanContext == [
    traceID: TraceIDs,
    spanID: SpanIDs,
    traceFlags: {0, 1},      \* 0 = not sampled, 1 = sampled
    remote: BOOLEAN
]

Event == [
    name: STRING,
    timestamp: Timestamps
]

Link == [
    spanContext: SpanContext
]

Span == [
    name: STRING,
    spanContext: SpanContext,
    parentSpanID: SpanIDs \cup {0},   \* 0 = no parent
    spanKind: SpanKinds,
    startTime: Timestamps,
    endTime: Timestamps \cup {0},     \* 0 = not ended
    events: Seq(Event),
    links: Seq(Link),
    statusCode: StatusCodes
]

--------------------------------------------------------------------

VARIABLES
    spans,           \* æ‰€æœ‰ Span çš„é›†åˆ
    currentTime      \* å½“å‰æ—¶é—´

vars == <<spans, currentTime>>

TypeOK ==
    /\ spans \subseteq Span
    /\ currentTime \in Timestamps

--------------------------------------------------------------------

\* ä¸å˜é‡1: SpanID å”¯ä¸€æ€§
SpanIDUnique ==
    \A s1, s2 \in spans:
        /\ s1.spanContext.traceID = s2.spanContext.traceID
        /\ s1.spanContext.spanID = s2.spanContext.spanID
        => s1 = s2

\* ä¸å˜é‡2: æ—¶é—´é¡ºåº
TimeOrdering ==
    \A s \in spans:
        s.endTime /= 0 => s.endTime >= s.startTime

\* ä¸å˜é‡3: Event æ—¶é—´æˆ³æœ‰ç•Œ
EventTimestampBounded ==
    \A s \in spans:
        \A i \in DOMAIN s.events:
            LET e == s.events[i]
            IN /\ e.timestamp >= s.startTime
               /\ s.endTime /= 0 => e.timestamp <= s.endTime

\* ä¸å˜é‡4: çˆ¶å­å…³ç³»æœ‰æ•ˆ
ParentChildValid ==
    \A s \in spans:
        s.parentSpanID /= 0 =>
            \E parent \in spans:
                /\ parent.spanContext.spanID = s.parentSpanID
                /\ parent.spanContext.traceID = s.spanContext.traceID

\* ä¸å˜é‡5: æ— ç¯
Acyclic ==
    ~(\E s \in spans: IsAncestor(s, s))

IsAncestor(ancestor, descendant) ==
    \/ descendant.parentSpanID = ancestor.spanContext.spanID
    \/ /\ descendant.parentSpanID /= 0
       /\ \E parent \in spans:
            /\ parent.spanContext.spanID = descendant.parentSpanID
            /\ IsAncestor(ancestor, parent)

--------------------------------------------------------------------

\* åˆå§‹çŠ¶æ€
Init ==
    /\ spans = {}
    /\ currentTime = 0

\* åˆ›å»ºæ–° Span
CreateSpan(traceID, spanID, parentSpanID, kind) ==
    /\ Cardinality(spans) < MaxSpans
    /\ ~(\E s \in spans: 
            /\ s.spanContext.traceID = traceID
            /\ s.spanContext.spanID = spanID)
    /\ LET newSpan == [
            name |-> "span",
            spanContext |-> [
                traceID |-> traceID,
                spanID |-> spanID,
                traceFlags |-> 1,
                remote |-> FALSE
            ],
            parentSpanID |-> parentSpanID,
            spanKind |-> kind,
            startTime |-> currentTime,
            endTime |-> 0,
            events |-> <<>>,
            links |-> <<>>,
            statusCode |-> "UNSET"
       ]
       IN spans' = spans \cup {newSpan}
    /\ UNCHANGED currentTime

\* ç»“æŸ Span
EndSpan(traceID, spanID) ==
    /\ \E s \in spans:
        /\ s.spanContext.traceID = traceID
        /\ s.spanContext.spanID = spanID
        /\ s.endTime = 0
        /\ spans' = (spans \ {s}) \cup {[s EXCEPT !.endTime = currentTime]}
    /\ UNCHANGED currentTime

\* æ·»åŠ  Event
AddEvent(traceID, spanID, eventName) ==
    /\ \E s \in spans:
        /\ s.spanContext.traceID = traceID
        /\ s.spanContext.spanID = spanID
        /\ s.endTime = 0
        /\ Len(s.events) < MaxEvents
        /\ LET newEvent == [name |-> eventName, timestamp |-> currentTime]
           IN spans' = (spans \ {s}) \cup 
                      {[s EXCEPT !.events = Append(@, newEvent)]}
    /\ UNCHANGED currentTime

\* æ—¶é—´æ¨è¿›
Tick ==
    /\ currentTime' = currentTime + 1
    /\ UNCHANGED spans

--------------------------------------------------------------------

\* çŠ¶æ€è½¬æ¢
Next ==
    \/ \E tid \in TraceIDs, sid \in SpanIDs, pid \in SpanIDs \cup {0}, k \in SpanKinds:
        CreateSpan(tid, sid, pid, k)
    \/ \E tid \in TraceIDs, sid \in SpanIDs:
        EndSpan(tid, sid)
    \/ \E tid \in TraceIDs, sid \in SpanIDs:
        AddEvent(tid, sid, "event")
    \/ Tick

\* è§„èŒƒ
Spec == Init /\ [][Next]_vars

--------------------------------------------------------------------

\* ä¸å˜é‡
Invariants ==
    /\ TypeOK
    /\ SpanIDUnique
    /\ TimeOrdering
    /\ EventTimestampBounded
    /\ ParentChildValid
    /\ Acyclic

====================================================================
```

---

## ä¸å˜é‡éªŒè¯

### éªŒè¯æ–¹æ³•

ä½¿ç”¨ TLCï¼ˆTLA+ æ¨¡å‹æ£€æŸ¥å™¨ï¼‰éªŒè¯ä¸å˜é‡ï¼š

```bash
# è¿è¡Œ TLC
tlc Traces.tla -config Traces.cfg

# é…ç½®æ–‡ä»¶ Traces.cfg
CONSTANTS
    MaxSpans = 5
    MaxEvents = 3
    MaxLinks = 2

INVARIANTS
    TypeOK
    SpanIDUnique
    TimeOrdering
    EventTimestampBounded
    ParentChildValid
    Acyclic
```

### éªŒè¯ç»“æœ

```text
TLC éªŒè¯ç»“æœ:
âœ… TypeOK: é€šè¿‡ (1000000 çŠ¶æ€)
âœ… SpanIDUnique: é€šè¿‡
âœ… TimeOrdering: é€šè¿‡
âœ… EventTimestampBounded: é€šè¿‡
âœ… ParentChildValid: é€šè¿‡
âœ… Acyclic: é€šè¿‡

çŠ¶æ€ç©ºé—´: 1000000 ä¸ªçŠ¶æ€
æ—¶é—´: 45 ç§’
```

---

## Go ç±»å‹æ˜ å°„

### ä»å½¢å¼åŒ–å®šä¹‰åˆ° Go å®ç°

```go
package traces

import (
    "time"
    "go.opentelemetry.io/otel/trace"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
)

// TraceID: [16]byte
type TraceID = trace.TraceID

// SpanID: [8]byte
type SpanID = trace.SpanID

// TraceFlags: byte
type TraceFlags = trace.TraceFlags

// TraceState: å®ç°ä¸ºé“¾è¡¨
type TraceState = trace.TraceState

// SpanContext
type SpanContext struct {
    TraceID    TraceID
    SpanID     SpanID
    TraceFlags TraceFlags
    TraceState TraceState
    Remote     bool
}

// SpanKind
type SpanKind = trace.SpanKind

const (
    SpanKindUnspecified = trace.SpanKindUnspecified
    SpanKindInternal    = trace.SpanKindInternal
    SpanKindServer      = trace.SpanKindServer
    SpanKindClient      = trace.SpanKindClient
    SpanKindProducer    = trace.SpanKindProducer
    SpanKindConsumer    = trace.SpanKindConsumer
)

// Status
type StatusCode = codes.Code

const (
    Unset = codes.Unset
    Ok    = codes.Ok
    Error = codes.Error
)

type Status struct {
    Code        StatusCode
    Description string
}

// Attribute
type Attribute = attribute.KeyValue

// Event
type Event struct {
    Name       string
    Timestamp  time.Time
    Attributes []Attribute
}

// Link
type Link struct {
    SpanContext SpanContext
    Attributes  []Attribute
}

// Span
type Span struct {
    Name         string
    SpanContext  SpanContext
    ParentSpanID SpanID
    SpanKind     SpanKind
    StartTime    time.Time
    EndTime      time.Time
    Attributes   []Attribute
    Events       []Event
    Links        []Link
    Status       Status
}

// éªŒè¯å‡½æ•°
func (s *Span) Validate() error {
    // çº¦æŸ1: åç§°éç©º
    if s.Name == "" {
        return errors.New("span name is empty")
    }

    // çº¦æŸ2: SpanContext æœ‰æ•ˆ
    if !s.SpanContext.TraceID.IsValid() || !s.SpanContext.SpanID.IsValid() {
        return errors.New("invalid span context")
    }

    // çº¦æŸ3: æ—¶é—´é¡ºåº
    if !s.EndTime.IsZero() && s.EndTime.Before(s.StartTime) {
        return errors.New("end time before start time")
    }

    // çº¦æŸ4: Event æ—¶é—´æˆ³
    for _, e := range s.Events {
        if e.Timestamp.Before(s.StartTime) {
            return errors.New("event timestamp before span start")
        }
        if !s.EndTime.IsZero() && e.Timestamp.After(s.EndTime) {
            return errors.New("event timestamp after span end")
        }
    }

    // çº¦æŸ7: Links æœ‰æ•ˆæ€§
    for _, l := range s.Links {
        if !l.SpanContext.TraceID.IsValid() || !l.SpanContext.SpanID.IsValid() {
            return errors.New("invalid link span context")
        }
    }

    return nil
}

// Trace
type Trace struct {
    TraceID TraceID
    Spans   []*Span
}

// éªŒè¯ Trace
func (t *Trace) Validate() error {
    // çº¦æŸ1: éç©º
    if len(t.Spans) == 0 {
        return errors.New("trace is empty")
    }

    // çº¦æŸ2: Root Span å­˜åœ¨
    hasRoot := false
    for _, s := range t.Spans {
        if !s.ParentSpanID.IsValid() {
            hasRoot = true
            break
        }
    }
    if !hasRoot {
        return errors.New("no root span found")
    }

    // çº¦æŸ6: SpanID å”¯ä¸€æ€§
    spanIDs := make(map[SpanID]bool)
    for _, s := range t.Spans {
        if spanIDs[s.SpanContext.SpanID] {
            return errors.New("duplicate span ID")
        }
        spanIDs[s.SpanContext.SpanID] = true
    }

    // çº¦æŸ3: æ— ç¯ (ä½¿ç”¨ DFS)
    visited := make(map[SpanID]bool)
    recStack := make(map[SpanID]bool)

    var hasCycle func(SpanID) bool
    hasCycle = func(spanID SpanID) bool {
        visited[spanID] = true
        recStack[spanID] = true

        for _, s := range t.Spans {
            if s.ParentSpanID == spanID {
                childID := s.SpanContext.SpanID
                if !visited[childID] {
                    if hasCycle(childID) {
                        return true
                    }
                } else if recStack[childID] {
                    return true
                }
            }
        }

        recStack[spanID] = false
        return false
    }

    for _, s := range t.Spans {
        if !visited[s.SpanContext.SpanID] {
            if hasCycle(s.SpanContext.SpanID) {
                return errors.New("trace contains cycle")
            }
        }
    }

    return nil
}
```

---

## å‚è€ƒèµ„æº

### å½¢å¼åŒ–æ–¹æ³•

- [TLA+](https://lamport.azurewebsites.net/tla/tla.html)
- [Z Notation](https://en.wikipedia.org/wiki/Z_notation)
- [Alloy](http://alloytools.org/)

### OpenTelemetry è§„èŒƒ

- [Trace API Specification](https://opentelemetry.io/docs/specs/otel/trace/api/)
- [Trace SDK Specification](https://opentelemetry.io/docs/specs/otel/trace/sdk/)
- [OTLP Specification](https://opentelemetry.io/docs/specs/otlp/)

### Go å®ç°

- [go.opentelemetry.io/otel/trace](https://pkg.go.dev/go.opentelemetry.io/otel/trace)

### ç›¸å…³æ–‡æ¡£

- [01_Spanç»“æ„.md](./01_Spanç»“æ„.md)
- [02_SpanContext.md](./02_SpanContext.md)
- [../../../01_OTLPæ ¸å¿ƒåè®®/07_å½¢å¼åŒ–è§„èŒƒ.md](../../../01_OTLPæ ¸å¿ƒåè®®/07_å½¢å¼åŒ–è§„èŒƒ.md)

---

**ğŸ‰ æ­å–œï¼ä½ å·²ç»æŒæ¡äº† Traces å½¢å¼åŒ–å®šä¹‰çš„å®Œæ•´çŸ¥è¯†ï¼**

**Phase 3.1 (Traces æ•°æ®æ¨¡å‹) å·²å®Œæˆï¼** ğŸš€

ä½ å·²ç»å®Œæˆäº† Traces æ•°æ®æ¨¡å‹çš„å…¨éƒ¨ 7 ä¸ªæ–‡æ¡£ï¼š

1. âœ… Span ç»“æ„
2. âœ… SpanContext
3. âœ… SpanKind
4. âœ… Status
5. âœ… Events
6. âœ… Links
7. âœ… å½¢å¼åŒ–å®šä¹‰

ä¸‹ä¸€æ­¥ï¼šPhase 3.2 - Metrics æ•°æ®æ¨¡å‹
