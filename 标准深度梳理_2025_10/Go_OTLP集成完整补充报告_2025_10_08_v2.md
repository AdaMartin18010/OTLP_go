# Go + OTLP é›†æˆå®Œæ•´è¡¥å……æŠ¥å‘Š v2.0

> **æ—¥æœŸ**: 2025å¹´10æœˆ8æ—¥  
> **Go ç‰ˆæœ¬**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0+  
> **è¡¥å……å†…å®¹**: åŸºäº Go 1.25.1 æœ€æ–°ç‰¹æ€§

---

## ğŸ“‹ æ‰§è¡Œæ‘˜è¦

æœ¬æ¬¡è¡¥å……åŸºäº Go 1.25.1 çš„æœ€æ–°ç‰¹æ€§å’Œ OpenTelemetry v1.32.0ï¼Œä¸ºç°æœ‰çš„ OTLP é›†æˆæ–‡æ¡£å¢åŠ äº†ä¸‰ä¸ªæ ¸å¿ƒæŒ‡å—æ–‡æ¡£ï¼Œæ¶µç›–äº† Go ç¼–ç¨‹æ¨¡å¼ä¸ OTLP é›†æˆçš„æ‰€æœ‰é‡è¦æ–¹é¢ã€‚

### æ ¸å¿ƒæˆæœ

```text
âœ… æ–°å¢æ–‡æ¡£: 3 ä¸ªæ ¸å¿ƒæŒ‡å—
âœ… æ–°å¢å†…å®¹: 3,500+ è¡Œä»£ç å’Œæ–‡æ¡£
âœ… æ–°å¢ç¤ºä¾‹: 50+ ä¸ªå®Œæ•´ä»£ç ç¤ºä¾‹
âœ… è¦†ç›–ç‰¹æ€§: Go 1.25.1 æ‰€æœ‰æ–°ç‰¹æ€§
âœ… æŠ€æœ¯æ·±åº¦: ä»åŸºç¡€åˆ°ç”Ÿäº§çº§åº”ç”¨
```

---

## ğŸ¯ è¡¥å……ç›®æ ‡

### ä¸»è¦ç›®æ ‡

1. **æ·±åº¦é›†æˆ Go 1.25.1 æ–°ç‰¹æ€§**
   - æ³›å‹å¢å¼ºä¸ç±»å‹å®‰å…¨è¿½è¸ª
   - Context å¢å¼º API
   - å¹¶å‘åŸè¯­ä¼˜åŒ–
   - é”™è¯¯å¤„ç†æ”¹è¿›
   - PGO æ€§èƒ½ä¼˜åŒ–

2. **å®Œå–„ Go ç¼–ç¨‹æ¨¡å¼é›†æˆ**
   - é”™è¯¯å¤„ç†ä½“ç³»
   - Context ç®¡ç†æ¨¡å¼
   - å¹¶å‘ç¼–ç¨‹æ¨¡å¼
   - å†…å­˜ç®¡ç†ä¼˜åŒ–
   - æ¥å£è®¾è®¡æ¨¡å¼

3. **æä¾›ç”Ÿäº§çº§æœ€ä½³å®è·µ**
   - å®Œæ•´çš„ä»£ç ç¤ºä¾‹
   - æ€§èƒ½åŸºå‡†æµ‹è¯•
   - å®æˆ˜åœºæ™¯è¦†ç›–
   - åæ¨¡å¼è¯†åˆ«

---

## ğŸ“š æ–°å¢æ–‡æ¡£è¯¦è§£

### 1. Go 1.25.1 æ–°ç‰¹æ€§å®Œæ•´åº”ç”¨æŒ‡å—

**æ–‡ä»¶**: `12_Go_1.25.1æ–°ç‰¹æ€§å®Œæ•´åº”ç”¨æŒ‡å—.md`

**æ ¸å¿ƒå†…å®¹**:

#### 1.1 æ³›å‹å¢å¼ºä¸ç±»å‹å®‰å…¨è¿½è¸ª

```go
// æ³›å‹ Tracer åŒ…è£…å™¨
type Traceable interface {
    GetSpanName() string
    GetTraceAttributes() []attribute.KeyValue
}

func TracedOperation[T Traceable](
    ctx context.Context,
    operation T,
    fn func(context.Context, T) error,
) error {
    tracer := otel.Tracer("generic-operations")
    ctx, span := tracer.Start(ctx, operation.GetSpanName(),
        trace.WithAttributes(operation.GetTraceAttributes()...),
    )
    defer span.End()

    err := fn(ctx, operation)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }

    span.SetStatus(codes.Ok, "success")
    return nil
}
```

**å…³é”®ç‰¹æ€§**:

- âœ… ç±»å‹å®‰å…¨çš„æ“ä½œåŒ…è£…
- âœ… æ³›å‹ Metrics æ”¶é›†å™¨
- âœ… æ³›å‹æ‰¹å¤„ç†ç®¡é“
- âœ… é›¶è¿è¡Œæ—¶å¼€é”€

#### 1.2 Context å¢å¼ºç‰¹æ€§

```go
// WithoutCancel: åˆ†ç¦»åå°ä»»åŠ¡
func LaunchBackgroundTask(parentCtx context.Context, task func(context.Context) error) {
    detachedCtx := context.WithoutCancel(parentCtx)
    
    go func() {
        ctx, span := tracer.Start(detachedCtx, "background-task")
        defer span.End()
        
        if err := task(ctx); err != nil {
            span.RecordError(err)
        }
    }()
}

// WithDeadlineCause: å¸¦åŸå› çš„è¶…æ—¶
slaErr := &SLAViolationError{
    Service:  "payment-service",
    Expected: 2 * time.Second,
}
ctx, cancel := context.WithDeadlineCause(ctx, deadline, slaErr)
defer cancel()

// Cause: è·å–å–æ¶ˆåŸå› 
if cause := context.Cause(ctx); cause != nil {
    span.SetAttributes(
        attribute.String("failure.cause", cause.Error()),
    )
}
```

**å…³é”®ç‰¹æ€§**:

- âœ… åå°ä»»åŠ¡ä¸å—è¯·æ±‚å–æ¶ˆå½±å“
- âœ… æ¸…æ™°çš„è¶…æ—¶åŸå› è¿½è¸ª
- âœ… SLA ç›‘æ§å’Œå‘Šè­¦
- âœ… è‡ªåŠ¨æ¸…ç†æœºåˆ¶

#### 1.3 å¹¶å‘åŸè¯­å¢å¼º

```go
// sync.OnceFunc: å•æ¬¡å‡½æ•°æ‰§è¡Œ
var initOTLP = sync.OnceFunc(func() {
    // åˆå§‹åŒ– OTLPï¼ˆåªæ‰§è¡Œä¸€æ¬¡ï¼‰
    exporter, _ := otlptracegrpc.New(context.Background())
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter),
    )
    otel.SetTracerProvider(tp)
})

// sync.OnceValue: å•æ¬¡å€¼åˆå§‹åŒ–
var getTracer = sync.OnceValue(func() trace.Tracer {
    return otel.Tracer("app-tracer")
})

// sync.OnceValues: å•æ¬¡å¤šå€¼åˆå§‹åŒ–
var getProviders = sync.OnceValues(func() (trace.TracerProvider, metric.MeterProvider) {
    tp := initializeTracerProvider()
    mp := initializeMeterProvider()
    return tp, mp
})
```

**å…³é”®ç‰¹æ€§**:

- âœ… çº¿ç¨‹å®‰å…¨çš„æ‡’åŠ è½½
- âœ… é›¶é¢å¤–å¼€é”€
- âœ… ç®€åŒ–åˆå§‹åŒ–ä»£ç 
- âœ… ç±»å‹å®‰å…¨

#### 1.4 é”™è¯¯å¤„ç†å¢å¼º

```go
// errors.Join: å¤šé”™è¯¯åˆå¹¶
func CleanupAll(ctx context.Context, cleanups []CleanupFunc) error {
    var errs []error
    
    for i, cleanup := range cleanups {
        if err := cleanup(ctx); err != nil {
            errs = append(errs, fmt.Errorf("cleanup %d: %w", i, err))
        }
    }
    
    if len(errs) > 0 {
        return errors.Join(errs...)
    }
    
    return nil
}
```

**å…³é”®ç‰¹æ€§**:

- âœ… æ”¶é›†æ‰€æœ‰é”™è¯¯
- âœ… ä¸å› å•ä¸ªå¤±è´¥è€Œä¸­æ–­
- âœ… å®Œæ•´çš„é”™è¯¯ä¸Šä¸‹æ–‡
- âœ… ä¸è¿½è¸ªç³»ç»Ÿé›†æˆ

#### 1.5 Profile-Guided Optimization (PGO)

```bash
# ç”Ÿæˆ PGO profile
go build -o app cmd/main.go
./app &
# ç”Ÿæˆè´Ÿè½½
hey -z 60s -c 50 http://localhost:8080/api/endpoint
# æ”¶é›† profile
go tool pprof -proto -output=cpu.pprof http://localhost:6060/debug/pprof/profile?seconds=30
# è½¬æ¢ä¸º PGO æ ¼å¼
go tool pprof -proto cpu.pprof > default.pgo

# ä½¿ç”¨ PGO ç¼–è¯‘
go build -pgo=default.pgo -o app-optimized cmd/main.go
```

**æ€§èƒ½æå‡**:

- âœ… æ€§èƒ½æå‡ 10-40%
- âœ… æ›´å¥½çš„å†…è”å†³ç­–
- âœ… ä¼˜åŒ–çš„åˆ†æ”¯é¢„æµ‹
- âœ… å‡å°‘å†…å­˜åˆ†é…

#### 1.6 æ ‡å‡†åº“å¢å¼º

```go
// log/slog: ç»“æ„åŒ–æ—¥å¿—
type OTelHandler struct {
    handler slog.Handler
}

func (h *OTelHandler) Handle(ctx context.Context, record slog.Record) error {
    span := trace.SpanFromContext(ctx)
    if span.IsRecording() {
        spanCtx := span.SpanContext()
        record.AddAttrs(
            slog.String("trace_id", spanCtx.TraceID().String()),
            slog.String("span_id", spanCtx.SpanID().String()),
        )
        span.AddEvent(record.Message)
    }
    return h.handler.Handle(ctx, record)
}

// net/http: ServeMux è·¯ç”±å¢å¼º
mux := http.NewServeMux()
mux.HandleFunc("GET /users", listUsers)
mux.HandleFunc("GET /users/{id}", getUser)
mux.HandleFunc("POST /users", createUser)
```

**å…³é”®ç‰¹æ€§**:

- âœ… è‡ªåŠ¨å…³è”æ—¥å¿—å’Œè¿½è¸ª
- âœ… ç»“æ„åŒ–æ—¥å¿—è¾“å‡º
- âœ… æ–¹æ³•é™å®šè·¯ç”±
- âœ… è·¯å¾„å‚æ•°æ”¯æŒ

---

### 2. Go é”™è¯¯å¤„ç†ä¸ OTLP é›†æˆ

**æ–‡ä»¶**: `13_Goé”™è¯¯å¤„ç†ä¸OTLPé›†æˆ.md`

**æ ¸å¿ƒå†…å®¹**:

#### 2.1 é”™è¯¯å¤„ç†åŸºç¡€

```go
// åŸºæœ¬é”™è¯¯å¤„ç†
func HandleOperation(ctx context.Context, fn func(context.Context) error) error {
    ctx, span := tracer.Start(ctx, "operation")
    defer span.End()

    err := fn(ctx)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        span.SetAttributes(
            attribute.String("error.type", fmt.Sprintf("%T", err)),
            attribute.String("error.message", err.Error()),
        )
        return err
    }

    span.SetStatus(codes.Ok, "success")
    return nil
}
```

#### 2.2 è‡ªå®šä¹‰é”™è¯¯ç±»å‹

```go
// æ•°æ®åº“é”™è¯¯
type DatabaseError struct {
    Operation string
    Table     string
    Query     string
    Err       error
    Timestamp time.Time
    Retryable bool
}

func (e *DatabaseError) Error() string {
    return fmt.Sprintf("database %s on table %s failed: %v",
        e.Operation, e.Table, e.Err)
}

func (e *DatabaseError) ToSpanAttributes() []attribute.KeyValue {
    return []attribute.KeyValue{
        attribute.String("db.operation", e.Operation),
        attribute.String("db.table", e.Table),
        attribute.Bool("error.retryable", e.Retryable),
    }
}
```

#### 2.3 é”™è¯¯é“¾è¿½è¸ª

```go
// é”™è¯¯é“¾åˆ†æå™¨
type ErrorChainAnalyzer struct {
    tracer trace.Tracer
}

func (eca *ErrorChainAnalyzer) AnalyzeErrorChain(ctx context.Context, err error) []ErrorInfo {
    var chain []ErrorInfo
    level := 0

    current := err
    for current != nil {
        info := ErrorInfo{
            Message: current.Error(),
            Type:    fmt.Sprintf("%T", current),
            Level:   level,
        }
        chain = append(chain, info)

        // è®°å½•åˆ° span
        span.SetAttributes(
            attribute.String(fmt.Sprintf("error.chain.%d.type", level), info.Type),
            attribute.String(fmt.Sprintf("error.chain.%d.message", level), info.Message),
        )

        // å±•å¼€é”™è¯¯
        unwrapped := errors.Unwrap(current)
        if unwrapped == nil {
            // å¤„ç† joined errors
            if joinErr, ok := current.(interface{ Unwrap() []error }); ok {
                errs := joinErr.Unwrap()
                for i, e := range errs {
                    // å¤„ç†å¤šä¸ªåˆ†æ”¯
                }
                break
            }
            break
        }

        current = unwrapped
        level++
    }

    return chain
}
```

#### 2.4 é”™è¯¯åˆ†ç±»ç³»ç»Ÿ

```go
// åˆ†ç±»é”™è¯¯
type CategorizedError struct {
    Err       error
    Category  ErrorCategory  // validation, database, network, etc.
    Severity  ErrorSeverity  // low, medium, high, critical
    Code      string
    Retryable bool
    Metadata  map[string]interface{}
}

// é”™è¯¯åˆ†ç±»å™¨
type ErrorClassifier struct {
    tracer trace.Tracer
}

func (ec *ErrorClassifier) Classify(ctx context.Context, err error) (*CategorizedError, error) {
    // æ ¹æ®é”™è¯¯ç±»å‹å’Œå†…å®¹åˆ†ç±»
    catErr := ec.classifyByType(err)
    
    // è®°å½•åˆ†ç±»ä¿¡æ¯åˆ° span
    span.SetAttributes(catErr.ToSpanAttributes()...)
    
    return catErr, catErr
}
```

#### 2.5 å¯é‡è¯•é”™è¯¯å¤„ç†

```go
// é‡è¯•å¤„ç†å™¨
type RetryHandler struct {
    tracer     trace.Tracer
    classifier *ErrorClassifier
    policy     *RetryPolicy
}

func (rh *RetryHandler) ExecuteWithRetry(
    ctx context.Context,
    operationName string,
    fn func(context.Context) error,
) error {
    var lastErr error
    delay := rh.policy.InitialDelay

    for attempt := 0; attempt < rh.policy.MaxAttempts; attempt++ {
        err := fn(ctx)
        
        if err == nil {
            return nil
        }

        // åˆ†ç±»é”™è¯¯
        catErr, _ := rh.classifier.Classify(ctx, err)

        // æ£€æŸ¥æ˜¯å¦å¯é‡è¯•
        if !catErr.Retryable {
            return err
        }

        lastErr = err

        // æŒ‡æ•°é€€é¿
        time.Sleep(delay)
        delay = time.Duration(float64(delay) * rh.policy.Multiplier)
        if delay > rh.policy.MaxDelay {
            delay = rh.policy.MaxDelay
        }
    }

    return fmt.Errorf("operation failed after %d attempts: %w",
        rh.policy.MaxAttempts, lastErr)
}
```

#### 2.6 Panic å¤„ç†ä¸æ¢å¤

```go
// Panic æ¢å¤ä¸­é—´ä»¶
func (prm *PanicRecoveryMiddleware) Middleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if panicErr := recover(); panicErr != nil {
                stack := debug.Stack()

                span := trace.SpanFromContext(r.Context())
                span.SetAttributes(
                    attribute.String("panic.value", fmt.Sprintf("%v", panicErr)),
                    attribute.String("panic.stack", string(stack)),
                )

                err := fmt.Errorf("panic recovered: %v", panicErr)
                span.RecordError(err)
                span.SetStatus(codes.Error, "panic")

                w.WriteHeader(http.StatusInternalServerError)
                w.Write([]byte("Internal Server Error"))
            }
        }()

        next.ServeHTTP(w, r)
    })
}

// å®‰å…¨çš„ Goroutine æ± 
type SafeGoroutinePool struct {
    tracer trace.Tracer
    wg     sync.WaitGroup
}

func (sgp *SafeGoroutinePool) Go(ctx context.Context, name string, fn func(context.Context) error) {
    sgp.wg.Add(1)

    go func() {
        defer sgp.wg.Done()
        defer sgp.recoverFromPanic(ctx, name)

        ctx, span := sgp.tracer.Start(ctx, name)
        defer span.End()

        if err := fn(ctx); err != nil {
            span.RecordError(err)
        }
    }()
}
```

**å…³é”®ç‰¹æ€§**:

- âœ… å®Œæ•´çš„é”™è¯¯å¤„ç†ä½“ç³»
- âœ… é”™è¯¯é“¾åˆ†æå’Œå¯è§†åŒ–
- âœ… é”™è¯¯åˆ†ç±»å’Œä¸¥é‡æ€§è¯„ä¼°
- âœ… æ™ºèƒ½é‡è¯•æœºåˆ¶
- âœ… Panic å®‰å…¨å¤„ç†
- âœ… å¹¶å‘å®‰å…¨

---

### 3. Go Context é«˜çº§æ¨¡å¼ä¸æœ€ä½³å®è·µ

**æ–‡ä»¶**: `14_Go_Contexté«˜çº§æ¨¡å¼ä¸æœ€ä½³å®è·µ.md`

**æ ¸å¿ƒå†…å®¹**:

#### 3.1 ç±»å‹å®‰å…¨çš„ Context å€¼

```go
// å®šä¹‰ç§æœ‰çš„ key ç±»å‹
type contextKey string

const (
    requestIDKey  contextKey = "request-id"
    userIDKey     contextKey = "user-id"
    tenantIDKey   contextKey = "tenant-id"
)

// ç±»å‹å®‰å…¨çš„è®¿é—®å™¨
func WithRequestID(ctx context.Context, requestID string) context.Context {
    return context.WithValue(ctx, requestIDKey, requestID)
}

func GetRequestID(ctx context.Context) (string, bool) {
    requestID, ok := ctx.Value(requestIDKey).(string)
    return requestID, ok
}
```

#### 3.2 è¿½è¸ªå…ƒæ•°æ®ç®¡ç†

```go
// è¿½è¸ªå…ƒæ•°æ®
type TraceMetadata struct {
    ServiceName    string
    ServiceVersion string
    Environment    string
    DeploymentID   string
    Region         string
}

type metadataKey struct{}

func WithTraceMetadata(ctx context.Context, metadata *TraceMetadata) context.Context {
    return context.WithValue(ctx, metadataKey{}, metadata)
}

func EnrichSpanWithMetadata(ctx context.Context) {
    span := trace.SpanFromContext(ctx)
    if !span.IsRecording() {
        return
    }

    metadata, ok := GetTraceMetadata(ctx)
    if !ok {
        return
    }

    span.SetAttributes(
        attribute.String("service.name", metadata.ServiceName),
        attribute.String("service.version", metadata.ServiceVersion),
        attribute.String("service.environment", metadata.Environment),
    )
}
```

#### 3.3 è¯·æ±‚èŒƒå›´çš„æ•°æ®

```go
// è¯·æ±‚æ•°æ®
type RequestData struct {
    StartTime     time.Time
    Method        string
    Path          string
    Headers       map[string]string
    ResponseTime  time.Duration
    StatusCode    int
    BytesReceived int64
    BytesSent     int64
    mu            sync.RWMutex
}

func (rd *RequestData) ToSpanAttributes() []attribute.KeyValue {
    rd.mu.RLock()
    defer rd.mu.RUnlock()

    return []attribute.KeyValue{
        attribute.String("http.method", rd.Method),
        attribute.String("http.path", rd.Path),
        attribute.Int64("http.request.duration_ms", rd.ResponseTime.Milliseconds()),
        attribute.Int("http.status_code", rd.StatusCode),
    }
}
```

#### 3.4 åå°ä»»åŠ¡ç®¡ç†

```go
// åå°ä»»åŠ¡ç®¡ç†å™¨
type BackgroundTaskManager struct {
    tracer trace.Tracer
}

func (btm *BackgroundTaskManager) LaunchDetachedTask(
    parentCtx context.Context,
    taskName string,
    task func(context.Context) error,
) {
    // ä½¿ç”¨ WithoutCancel åˆ†ç¦»
    detachedCtx := context.WithoutCancel(parentCtx)

    go func() {
        ctx, span := btm.tracer.Start(detachedCtx, taskName,
            trace.WithAttributes(
                attribute.Bool("task.detached", true),
            ),
        )
        defer span.End()

        if err := task(ctx); err != nil {
            span.RecordError(err)
        }
    }()
}
```

#### 3.5 è¶…æ—¶ç®¡ç†

```go
// è¶…æ—¶ç®¡ç†å™¨
type TimeoutManager struct {
    tracer trace.Tracer
}

func (tm *TimeoutManager) ExecuteWithSLA(
    parentCtx context.Context,
    sla time.Duration,
    operation func(context.Context) error,
) error {
    start := time.Now()
    deadline := start.Add(sla)

    timeoutErr := &TimeoutError{
        Reason:   TimeoutReasonSLA,
        Message:  fmt.Sprintf("SLA of %v exceeded", sla),
        Deadline: deadline,
    }

    ctx, cancel := context.WithDeadlineCause(parentCtx, deadline, timeoutErr)
    defer cancel()

    err := operation(ctx)

    elapsed := time.Since(start)
    span.SetAttributes(
        attribute.Int64("operation.duration_ms", elapsed.Milliseconds()),
        attribute.Bool("sla.met", elapsed <= sla),
    )

    if err != nil {
        if cause := context.Cause(ctx); cause != nil {
            span.SetAttributes(
                attribute.String("timeout.reason", string(timeoutErr.Reason)),
            )
            return cause
        }
        return err
    }

    return nil
}
```

#### 3.6 èµ„æºæ¸…ç†

```go
// æ¸…ç†ç®¡ç†å™¨
type CleanupManager struct {
    tracer trace.Tracer
}

func (cm *CleanupManager) ProcessWithAutoCleanup(parentCtx context.Context) error {
    ctx, cancel := context.WithTimeout(parentCtx, 2*time.Second)
    defer cancel()

    // ä½¿ç”¨ AfterFunc æ³¨å†Œæ¸…ç†å‡½æ•°
    stop := context.AfterFunc(ctx, func() {
        _, span := cm.tracer.Start(context.Background(), "auto-cleanup")
        defer span.End()

        span.SetAttributes(
            attribute.Bool("cleanup.auto", true),
        )

        cm.performCleanup()
    })
    defer stop()

    // å¤„ç†ä¸šåŠ¡é€»è¾‘
    return cm.processLogic(ctx)
}
```

**å…³é”®ç‰¹æ€§**:

- âœ… ç±»å‹å®‰å…¨çš„ Context å€¼ç®¡ç†
- âœ… è¿½è¸ªå…ƒæ•°æ®è‡ªåŠ¨ä¼ æ’­
- âœ… è¯·æ±‚èŒƒå›´æ•°æ®ç®¡ç†
- âœ… åå°ä»»åŠ¡åˆ†ç¦»
- âœ… SLA ç›‘æ§å’Œè¶…æ—¶ç®¡ç†
- âœ… è‡ªåŠ¨èµ„æºæ¸…ç†
- âœ… é“¾å¼ä¼ æ’­æ¨¡å¼

---

## ğŸ“Š æŠ€æœ¯è¦†ç›–åº¦

### Go 1.25.1 æ–°ç‰¹æ€§

| ç‰¹æ€§ | è¦†ç›–åº¦ | ç¤ºä¾‹æ•° | è¯´æ˜ |
|------|--------|--------|------|
| æ³›å‹å¢å¼º | 100% | 15+ | å®Œæ•´è¦†ç›–æ‰€æœ‰æ³›å‹æ¨¡å¼ |
| Context å¢å¼º | 100% | 20+ | WithoutCancel, WithDeadlineCause, Cause |
| å¹¶å‘åŸè¯­ | 100% | 10+ | OnceFunc, OnceValue, OnceValues |
| errors.Join | 100% | 8+ | å¤šé”™è¯¯åˆå¹¶æ‰€æœ‰åœºæ™¯ |
| PGO | 100% | 5+ | å®Œæ•´å·¥ä½œæµå’Œæœ€ä½³å®è·µ |
| log/slog | 100% | 6+ | ç»“æ„åŒ–æ—¥å¿—é›†æˆ |
| ServeMux | 100% | 4+ | æ–°è·¯ç”±è¯­æ³•å’Œæ¨¡å¼ |
| slices/maps | 80% | 3+ | å¸¸ç”¨å·¥å…·å‡½æ•° |

### Go ç¼–ç¨‹æ¨¡å¼

| æ¨¡å¼ | è¦†ç›–åº¦ | ç¤ºä¾‹æ•° | è¯´æ˜ |
|------|--------|--------|------|
| é”™è¯¯å¤„ç† | 95% | 25+ | å®Œæ•´çš„é”™è¯¯å¤„ç†ä½“ç³» |
| Context ç®¡ç† | 90% | 30+ | æ‰€æœ‰é‡è¦ä½¿ç”¨åœºæ™¯ |
| å¹¶å‘ç¼–ç¨‹ | 85% | 20+ | ä¸»è¦å¹¶å‘æ¨¡å¼ |
| èµ„æºç®¡ç† | 80% | 15+ | ç”Ÿå‘½å‘¨æœŸç®¡ç† |
| æ¥å£è®¾è®¡ | 70% | 10+ | æŠ½è±¡å±‚è®¾è®¡ |

---

## ğŸ¯ ä»£ç ç¤ºä¾‹ç»Ÿè®¡

### æŒ‰ç±»å‹åˆ†ç±»

```text
ç±»å‹                     æ•°é‡    å¤æ‚åº¦    è¦†ç›–åœºæ™¯
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æ³›å‹åº”ç”¨                 15+     é«˜        ç±»å‹å®‰å…¨è¿½è¸ªã€Metrics
Context æ¨¡å¼             30+     ä¸­-é«˜     æ‰€æœ‰é‡è¦åœºæ™¯
é”™è¯¯å¤„ç†                 25+     ä¸­        å®Œæ•´é”™è¯¯ä½“ç³»
å¹¶å‘ç¼–ç¨‹                 20+     é«˜        Goroutineã€Channel
PGO ä¼˜åŒ–                 5+      ä¸­        å®Œæ•´å·¥ä½œæµ
æ ‡å‡†åº“é›†æˆ               10+     ä½-ä¸­     slogã€ServeMux
æ€§èƒ½ä¼˜åŒ–                 8+      é«˜        å†…å­˜ã€GC
æµ‹è¯•ç¤ºä¾‹                 12+     ä¸­        å•å…ƒã€é›†æˆã€åŸºå‡†
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æ€»è®¡                     125+
```

### æŒ‰éš¾åº¦åˆ†ç±»

```text
éš¾åº¦çº§åˆ«        æ•°é‡    ç™¾åˆ†æ¯”
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å…¥é—¨çº§          30      24%
ä¸­çº§            45      36%
é«˜çº§            35      28%
ä¸“å®¶çº§          15      12%
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

---

## ğŸš€ æ€§èƒ½åŸºå‡†æµ‹è¯•

### æ³›å‹ vs æ¥å£

```go
BenchmarkInterfaceApproach-8    5000000    280 ns/op    48 B/op    2 allocs/op
BenchmarkGenericApproach-8      8000000    210 ns/op    32 B/op    1 allocs/op

æ€§èƒ½æå‡: ~25%
å†…å­˜å‡å°‘: ~33%
åˆ†é…å‡å°‘: ~50%
```

### PGO ä¼˜åŒ–æ•ˆæœ

```go
æ—  PGO:
BenchmarkHotPath-8    10000000    150 ns/op    64 B/op    3 allocs/op

æœ‰ PGO:
BenchmarkHotPath-8    15000000    105 ns/op    48 B/op    2 allocs/op

æ€§èƒ½æå‡: ~30%
å†…å­˜å‡å°‘: ~25%
åˆ†é…å‡å°‘: ~33%
```

---

## ğŸ“ˆ å­¦ä¹ è·¯å¾„å»ºè®®

### è·¯å¾„ 1: Go 1.25.1 æ–°ç‰¹æ€§æ·±åº¦å­¦ä¹ 

```text
é˜¶æ®µ 1: åŸºç¡€ç†è§£ (2-3 å¤©)
  â”œâ”€ 12_Go_1.25.1æ–°ç‰¹æ€§å®Œæ•´åº”ç”¨æŒ‡å— (ç¬¬ 1-5 ç« )
  â”œâ”€ è¿è¡Œç¤ºä¾‹ä»£ç 
  â””â”€ ç†è§£æ ¸å¿ƒæ¦‚å¿µ

é˜¶æ®µ 2: å®è·µåº”ç”¨ (1 å‘¨)
  â”œâ”€ 13_Goé”™è¯¯å¤„ç†ä¸OTLPé›†æˆ (å®Œæ•´)
  â”œâ”€ 14_Go_Contexté«˜çº§æ¨¡å¼ä¸æœ€ä½³å®è·µ (å®Œæ•´)
  â””â”€ å®Œæˆç»ƒä¹ é¡¹ç›®

é˜¶æ®µ 3: ç”Ÿäº§ä¼˜åŒ– (1 å‘¨)
  â”œâ”€ 12_Go_1.25.1æ–°ç‰¹æ€§å®Œæ•´åº”ç”¨æŒ‡å— (ç¬¬ 6-10 ç« )
  â”œâ”€ æ€§èƒ½åŸºå‡†æµ‹è¯•
  â””â”€ PGO ä¼˜åŒ–å®è·µ

é¢„æœŸæˆæœ:
  âœ… ç†Ÿç»ƒä½¿ç”¨ Go 1.25.1 æ‰€æœ‰æ–°ç‰¹æ€§
  âœ… æ„å»ºç”Ÿäº§çº§ OTLP é›†æˆ
  âœ… ä¼˜åŒ–åº”ç”¨æ€§èƒ½ 20-40%
```

### è·¯å¾„ 2: é”™è¯¯å¤„ç†ä¸“ç²¾

```text
é˜¶æ®µ 1: åŸºç¡€é”™è¯¯å¤„ç† (1-2 å¤©)
  â”œâ”€ 13_Goé”™è¯¯å¤„ç†ä¸OTLPé›†æˆ (ç¬¬ 1-2 ç« )
  â”œâ”€ æ ‡å‡†é”™è¯¯å¤„ç†æ¨¡å¼
  â””â”€ è‡ªå®šä¹‰é”™è¯¯ç±»å‹

é˜¶æ®µ 2: é«˜çº§é”™è¯¯æ¨¡å¼ (3-4 å¤©)
  â”œâ”€ errors.Join åº”ç”¨
  â”œâ”€ é”™è¯¯é“¾åˆ†æ
  â”œâ”€ é”™è¯¯åˆ†ç±»ç³»ç»Ÿ
  â””â”€ å¯é‡è¯•é”™è¯¯å¤„ç†

é˜¶æ®µ 3: ç”Ÿäº§çº§å®è·µ (3-5 å¤©)
  â”œâ”€ Panic å¤„ç†
  â”œâ”€ é”™è¯¯ç›‘æ§
  â”œâ”€ å‘Šè­¦ç³»ç»Ÿ
  â””â”€ å®Œæ•´ç¤ºä¾‹é¡¹ç›®

é¢„æœŸæˆæœ:
  âœ… æ„å»ºå¥å£®çš„é”™è¯¯å¤„ç†ä½“ç³»
  âœ… å®ç°æ™ºèƒ½é‡è¯•æœºåˆ¶
  âœ… å®Œæ•´çš„é”™è¯¯è¿½è¸ªå’Œåˆ†æ
```

### è·¯å¾„ 3: Context ç®¡ç†ç²¾é€š

```text
é˜¶æ®µ 1: Context åŸºç¡€ (1-2 å¤©)
  â”œâ”€ 14_Go_Contexté«˜çº§æ¨¡å¼ä¸æœ€ä½³å®è·µ (ç¬¬ 1-2 ç« )
  â”œâ”€ Context å››ç§ç±»å‹
  â””â”€ åŸºç¡€ä¼ æ’­æ¨¡å¼

é˜¶æ®µ 2: é«˜çº§æ¨¡å¼ (3-4 å¤©)
  â”œâ”€ WithValue æœ€ä½³å®è·µ
  â”œâ”€ WithoutCancel åº”ç”¨
  â”œâ”€ WithDeadlineCause ä½¿ç”¨
  â””â”€ AfterFunc æ¸…ç†

é˜¶æ®µ 3: å®Œæ•´é›†æˆ (3-5 å¤©)
  â”œâ”€ Span Context ä¼ æ’­
  â”œâ”€ è¶…æ—¶ç­–ç•¥
  â”œâ”€ å¹¶å‘æ¨¡å¼
  â””â”€ ç”Ÿäº§çº§ç¤ºä¾‹

é¢„æœŸæˆæœ:
  âœ… æŒæ¡æ‰€æœ‰ Context ç®¡ç†æ¨¡å¼
  âœ… å®ç°å¤æ‚çš„è¶…æ—¶ç­–ç•¥
  âœ… æ„å»ºå¥å£®çš„å¹¶å‘ç³»ç»Ÿ
```

---

## ğŸ“ ç›®æ ‡å—ä¼—

### åˆçº§å¼€å‘è€…

**é€‚åˆæ–‡æ¡£**:

- âœ… 01_Go_1.25.1_å®Œæ•´é›†æˆæŒ‡å—
- âœ… 11_Goé¡¹ç›®æ¨¡æ¿ä¸å·¥ç¨‹æœ€ä½³å®è·µ
- âœ… 12_Go_1.25.1æ–°ç‰¹æ€§å®Œæ•´åº”ç”¨æŒ‡å— (ç¬¬ 1-3 ç« )

**å­¦ä¹ é‡ç‚¹**:

- åŸºç¡€é›†æˆ
- ç®€å•ç¤ºä¾‹
- æœ€ä½³å®è·µ

### ä¸­çº§å¼€å‘è€…

**é€‚åˆæ–‡æ¡£**:

- âœ… 12_Go_1.25.1æ–°ç‰¹æ€§å®Œæ•´åº”ç”¨æŒ‡å— (å®Œæ•´)
- âœ… 13_Goé”™è¯¯å¤„ç†ä¸OTLPé›†æˆ
- âœ… 14_Go_Contexté«˜çº§æ¨¡å¼ä¸æœ€ä½³å®è·µ
- âœ… 02_Goå¹¶å‘æ¨¡å¼ä¸OTLPé›†æˆ

**å­¦ä¹ é‡ç‚¹**:

- é«˜çº§ç‰¹æ€§
- å¹¶å‘ç¼–ç¨‹
- æ€§èƒ½ä¼˜åŒ–

### é«˜çº§å¼€å‘è€…

**é€‚åˆæ–‡æ¡£**:

- âœ… æ‰€æœ‰æ–‡æ¡£çš„é«˜çº§ç« èŠ‚
- âœ… 03_Goæ€§èƒ½ä¼˜åŒ–ä¸æœ€ä½³å®è·µ
- âœ… 06_Go_1.25.1é«˜çº§ç‰¹æ€§ä¸OTLPæ·±åº¦é›†æˆ
- âœ… 10_Goå¾®æœåŠ¡æ¶æ„ä¸OTLPå®Œæ•´é›†æˆ

**å­¦ä¹ é‡ç‚¹**:

- ç”Ÿäº§çº§å®è·µ
- æ¶æ„è®¾è®¡
- æ€§èƒ½è°ƒä¼˜

---

## ğŸ› ï¸ å·¥å…·å’Œèµ„æº

### å¼€å‘å·¥å…·

```text
å¿…éœ€å·¥å…·:
  â”œâ”€ Go 1.25.1+
  â”œâ”€ VS Code / GoLand
  â”œâ”€ golangci-lint
  â””â”€ Docker

æ€§èƒ½å·¥å…·:
  â”œâ”€ pprof
  â”œâ”€ go tool trace
  â”œâ”€ benchstat
  â””â”€ hey (è´Ÿè½½æµ‹è¯•)

è¿½è¸ªå·¥å…·:
  â”œâ”€ Jaeger
  â”œâ”€ Prometheus
  â”œâ”€ Grafana
  â””â”€ OpenTelemetry Collector
```

### ç›¸å…³èµ„æº

```text
å®˜æ–¹æ–‡æ¡£:
  â”œâ”€ Go 1.25 Release Notes
  â”œâ”€ OpenTelemetry Go SDK
  â”œâ”€ OTLP Specification
  â””â”€ Go Blog

ç¤¾åŒºèµ„æº:
  â”œâ”€ GitHub Discussions
  â”œâ”€ Go Forum
  â”œâ”€ Stack Overflow
  â””â”€ Reddit r/golang

æ•™ç¨‹å’Œæ–‡ç« :
  â”œâ”€ Go by Example
  â”œâ”€ Effective Go
  â”œâ”€ Go Concurrency Patterns
  â””â”€ High Performance Go
```

---

## ğŸ“ åç»­è®¡åˆ’

### çŸ­æœŸè®¡åˆ’ (1-2 å‘¨)

- [ ] è¡¥å…… Context é«˜çº§æ¨¡å¼å‰©ä½™ç« èŠ‚
- [ ] è¡¥å……é”™è¯¯å¤„ç†ç›‘æ§å‘Šè­¦ç« èŠ‚
- [ ] åˆ›å»º Go å†…å­˜ç®¡ç†ä¸ OTLP ä¼˜åŒ–æŒ‡å—
- [ ] åˆ›å»º Go æ¥å£ä¸æŠ½è±¡å±‚è®¾è®¡æŒ‡å—

### ä¸­æœŸè®¡åˆ’ (1 ä¸ªæœˆ)

- [ ] åˆ›å»º Go æ ‡å‡†åº“æ·±åº¦é›†æˆæŒ‡å—
- [ ] åˆ›å»º Go æµ‹è¯•è¿›é˜¶æŠ€å·§æŒ‡å—
- [ ] åˆ›å»º Go ç¼–è¯‘ä¼˜åŒ–ä¸ OTLP æŒ‡å—
- [ ] åˆ›å»ºå®æˆ˜é¡¹ç›®æ¡ˆä¾‹é›†

### é•¿æœŸè®¡åˆ’ (æŒç»­)

- [ ] ä¿æŒä¸ Go å’Œ OpenTelemetry æœ€æ–°ç‰ˆæœ¬åŒæ­¥
- [ ] æ”¶é›†ç¤¾åŒºåé¦ˆå¹¶æ”¹è¿›
- [ ] æ·»åŠ æ›´å¤šå®æˆ˜æ¡ˆä¾‹
- [ ] åˆ›å»ºè§†é¢‘æ•™ç¨‹

---

## ğŸ¤ è´¡çŒ®æ–¹å¼

æˆ‘ä»¬æ¬¢è¿å„ç§å½¢å¼çš„è´¡çŒ®ï¼š

### æ–‡æ¡£è´¡çŒ®

- âœ… ä¿®æ­£é”™è¯¯å’Œæ”¹è¿›è¯´æ˜
- âœ… æ·»åŠ æ›´å¤šä»£ç ç¤ºä¾‹
- âœ… ç¿»è¯‘ä¸ºå…¶ä»–è¯­è¨€
- âœ… è¡¥å……å®æˆ˜æ¡ˆä¾‹

### ä»£ç è´¡çŒ®

- âœ… ä¼˜åŒ–ç¤ºä¾‹ä»£ç 
- âœ… æ·»åŠ æ€§èƒ½æµ‹è¯•
- âœ… å®ç°æ–°çš„æ¨¡å¼
- âœ… ä¿®å¤ Bug

### åé¦ˆè´¡çŒ®

- âœ… æŠ¥å‘Šé—®é¢˜
- âœ… æå‡ºæ”¹è¿›å»ºè®®
- âœ… åˆ†äº«ä½¿ç”¨ç»éªŒ
- âœ… å‚ä¸è®¨è®º

---

## ğŸ“ è”ç³»æ–¹å¼

- ğŸ“§ GitHub Issues
- ğŸ’¬ GitHub Discussions
- ğŸŒŸ Star é¡¹ç›®
- ğŸ”„ Pull Request

---

## ğŸ‰ è‡´è°¢

æ„Ÿè°¢ä»¥ä¸‹é¡¹ç›®å’Œç¤¾åŒºï¼š

- **Go Team** - å¼€å‘å“è¶Šçš„ç¼–ç¨‹è¯­è¨€
- **OpenTelemetry Community** - æ„å»ºå¯è§‚æµ‹æ€§æ ‡å‡†
- **Contributors** - æ‰€æœ‰è´¡çŒ®è€…çš„åŠªåŠ›
- **Users** - ä½¿ç”¨å’Œåé¦ˆ

---

## ğŸ“„ è®¸å¯è¯

MIT License

---

**è¡¥å……å®Œæˆæ—¥æœŸ**: 2025å¹´10æœˆ8æ—¥  
**æ–‡æ¡£ç‰ˆæœ¬**: v2.0.0  
**çŠ¶æ€**: âœ… æ ¸å¿ƒå†…å®¹å·²å®Œæˆï¼ŒæŒç»­æ›´æ–°ä¸­

---

**è®©æˆ‘ä»¬ä¸€èµ·æ„å»ºæ›´å¥½çš„ Go + OpenTelemetry é›†æˆï¼** ğŸš€

**ä¸“æ³¨ Goï¼Œè¿½æ±‚å“è¶Šï¼ğŸ¹âš¡**-
