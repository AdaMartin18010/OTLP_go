# 77. OTLPæ•…éšœæ’æŸ¥ä¸è¯Šæ–­å®Œå…¨æŒ‡å—ï¼ˆ2025ç‰ˆï¼‰

> **é€‚ç”¨ç‰ˆæœ¬**: Go 1.25.1 + OpenTelemetry v1.32.0  
> **å®Œæˆæ—¥æœŸ**: 2025-10-11  
> **çŠ¶æ€**: âœ… ç”Ÿäº§éªŒè¯

---

## ğŸ“‹ ç›®å½•

- [1. å¸¸è§é—®é¢˜FAQ](#1-å¸¸è§é—®é¢˜faq)
- [2. è¿½è¸ªé—®é¢˜æ’æŸ¥æµç¨‹](#2-è¿½è¸ªé—®é¢˜æ’æŸ¥æµç¨‹)
- [3. æ€§èƒ½é—®é¢˜è¯Šæ–­](#3-æ€§èƒ½é—®é¢˜è¯Šæ–­)
- [4. ç”Ÿäº§ç¯å¢ƒè¯Šæ–­å·¥å…·](#4-ç”Ÿäº§ç¯å¢ƒè¯Šæ–­å·¥å…·)
- [5. ç›‘æ§å‘Šè­¦é…ç½®](#5-ç›‘æ§å‘Šè­¦é…ç½®)

---

## 1. å¸¸è§é—®é¢˜FAQ

### 1.1 åˆå§‹åŒ–é—®é¢˜

#### Q1: ç¨‹åºå¯åŠ¨åæ²¡æœ‰çœ‹åˆ°ä»»ä½•Trace

**ç—‡çŠ¶**:
```bash
# Jaeger UI: æ²¡æœ‰ä»»ä½•Traceæ•°æ®
# æ—¥å¿—: æ— é”™è¯¯ä¿¡æ¯
```

**æ’æŸ¥æ­¥éª¤**:

```go
// 1. æ£€æŸ¥TracerProvideræ˜¯å¦æ­£ç¡®åˆå§‹åŒ–
tp, err := initTracing(ctx, "localhost:4317")
if err != nil {
    log.Fatal(err)  // ç¡®ä¿ä¸ä¼šé™é»˜å¤±è´¥
}
defer tp.Shutdown(ctx)  // âš ï¸ å¿…é¡»è°ƒç”¨Shutdown

// 2. éªŒè¯Traceræ˜¯å¦æ­£ç¡®è·å–
tracer := otel.Tracer("my-service")  // âš ï¸ å¿…é¡»åœ¨SetTracerProviderä¹‹å

// 3. ç¡®è®¤Spanè¢«æ­£ç¡®åˆ›å»ºå’Œç»“æŸ
ctx, span := tracer.Start(ctx, "operation")
defer span.End()  // âš ï¸ å¿…é¡»è°ƒç”¨End()

// 4. æ£€æŸ¥é‡‡æ ·å™¨é…ç½®
// âŒ é”™è¯¯: é‡‡æ ·ç‡ä¸º0
tp := sdktrace.NewTracerProvider(
    sdktrace.WithSampler(sdktrace.NeverSample()),  // æ°¸ä¸é‡‡æ ·
)

// âœ… æ­£ç¡®: ä½¿ç”¨AlwaysSampleæˆ–åˆç†çš„é‡‡æ ·ç‡
tp := sdktrace.NewTracerProvider(
    sdktrace.WithSampler(sdktrace.AlwaysSample()),  // 100%é‡‡æ · (æµ‹è¯•ç¯å¢ƒ)
    // æˆ–
    sdktrace.WithSampler(sdktrace.TraceIDRatioBased(0.1)),  // 10%é‡‡æ · (ç”Ÿäº§ç¯å¢ƒ)
)
```

**å¸¸è§åŸå› **:

| åŸå›  | è§£å†³æ–¹æ¡ˆ |
|-----|---------|
| âŒ å¿˜è®°è°ƒç”¨`Shutdown()` | ç¨‹åºé€€å‡ºå‰è°ƒç”¨`tp.Shutdown(ctx)` |
| âŒ é‡‡æ ·ç‡ä¸º0 | ä½¿ç”¨`AlwaysSample()`æˆ–åˆç†é‡‡æ ·ç‡ |
| âŒ Exporteræœªåˆå§‹åŒ– | æ£€æŸ¥`otlptracegrpc.New()`æ˜¯å¦æˆåŠŸ |
| âŒ Collectoræœªå¯åŠ¨ | `docker-compose up otel-collector` |

**å¿«é€ŸéªŒè¯**:

```bash
# 1. æ£€æŸ¥Collectoræ˜¯å¦å¯è¾¾
nc -zv localhost 4317

# 2. æŸ¥çœ‹Collectoræ—¥å¿—
docker logs otel-collector

# 3. ä½¿ç”¨ç¯å¢ƒå˜é‡å¯ç”¨è°ƒè¯•æ—¥å¿—
export OTEL_LOG_LEVEL=debug
go run main.go
```

---

#### Q2: Traceä¸ŠæŠ¥ååœ¨Collectorä¸­ä¸¢å¤±

**ç—‡çŠ¶**:
```bash
# å®¢æˆ·ç«¯æ—¥å¿—: æˆåŠŸå‘é€
2025-10-11T10:00:00Z INFO Successfully exported 100 spans

# Jaeger UI: ä»ç„¶æ²¡æœ‰æ•°æ®
```

**æ’æŸ¥æ­¥éª¤**:

```yaml
# 1. æ£€æŸ¥Collectoré…ç½®
# otel-collector-config.yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317  # âœ… ç›‘å¬æ‰€æœ‰æ¥å£

processors:
  batch:
    timeout: 1s
    send_batch_size: 100

exporters:
  jaeger:
    endpoint: jaeger:14250  # âš ï¸ æ£€æŸ¥Jaegeråœ°å€æ˜¯å¦æ­£ç¡®
    tls:
      insecure: true

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [jaeger]  # âš ï¸ ç¡®ä¿exportersæ‹¼å†™æ­£ç¡®
```

**è°ƒè¯•å‘½ä»¤**:

```bash
# 2. æŸ¥çœ‹CollectoræŒ‡æ ‡
curl http://localhost:8888/metrics | grep -E "(otelcol_receiver|otelcol_exporter)"

# å…³é”®æŒ‡æ ‡:
# otelcol_receiver_accepted_spans{} - æ¥æ”¶çš„Spanæ•°
# otelcol_exporter_sent_spans{} - å‘é€çš„Spanæ•°
# otelcol_exporter_send_failed_spans{} - å‘é€å¤±è´¥çš„Spanæ•°

# 3. æ£€æŸ¥Collectorå¥åº·çŠ¶æ€
curl http://localhost:13133/
```

**å¸¸è§åŸå› **:

| åŸå›  | è§£å†³æ–¹æ¡ˆ |
|-----|---------|
| âŒ Jaegeråœ°å€é”™è¯¯ | ä½¿ç”¨`docker-compose`ç½‘ç»œå†…éƒ¨åœ°å€ |
| âŒ Pipelineé…ç½®é”™è¯¯ | æ£€æŸ¥`receivers/processors/exporters`æ‹¼å†™ |
| âŒ Batchå¤„ç†å™¨è¶…æ—¶ | è°ƒæ•´`timeout`å‚æ•° (å¦‚: 1s) |
| âŒ TLSé…ç½®é—®é¢˜ | ä½¿ç”¨`insecure: true` (æµ‹è¯•ç¯å¢ƒ) |

---

#### Q3: Contextä¼ æ’­å¤±è´¥ (åˆ†å¸ƒå¼è¿½è¸ªæ–­é“¾)

**ç—‡çŠ¶**:
```text
Service A (TraceID: abc123)
  â†“
Service B (TraceID: def456)  âŒ æ–°çš„TraceID, è¿½è¸ªæ–­é“¾
```

**æ’æŸ¥æ­¥éª¤**:

```go
// 1. æ£€æŸ¥Propagatoræ˜¯å¦æ­£ç¡®é…ç½®
// âŒ é”™è¯¯: æœªè®¾ç½®Propagator
// (é»˜è®¤ä½¿ç”¨NoOp Propagator, ä¸ä¼ æ’­Context)

// âœ… æ­£ç¡®: è®¾ç½®W3C TraceContext
otel.SetTextMapPropagator(
    propagation.NewCompositeTextMapPropagator(
        propagation.TraceContext{},  // W3Cæ ‡å‡†
        propagation.Baggage{},       // Baggageä¼ æ’­
    ),
)

// 2. HTTPå®¢æˆ·ç«¯: å¿…é¡»æ³¨å…¥Context
func makeHTTPRequest(ctx context.Context, url string) (*http.Response, error) {
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, err
    }

    // âœ… æ³¨å…¥TraceContextåˆ°HTTP Header
    otel.GetTextMapPropagator().Inject(ctx, propagation.HeaderCarrier(req.Header))

    client := &http.Client{
        Transport: otelhttp.NewTransport(http.DefaultTransport),  // âœ… ä½¿ç”¨instrumented transport
    }
    return client.Do(req)
}

// 3. HTTPæœåŠ¡ç«¯: å¿…é¡»æå–Context
func httpHandler(w http.ResponseWriter, r *http.Request) {
    // âœ… æå–TraceContext
    ctx := otel.GetTextMapPropagator().Extract(r.Context(),
        propagation.HeaderCarrier(r.Header))

    // ä½¿ç”¨æå–çš„Context
    tracer := otel.Tracer("my-service")
    ctx, span := tracer.Start(ctx, "handle-request")
    defer span.End()

    // ... ä¸šåŠ¡é€»è¾‘
}

// 4. gRPC: ä½¿ç”¨å®˜æ–¹æ‹¦æˆªå™¨
import "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"

// å®¢æˆ·ç«¯
conn, err := grpc.Dial(address,
    grpc.WithStatsHandler(otelgrpc.NewClientHandler()),  // âœ… è‡ªåŠ¨ä¼ æ’­
)

// æœåŠ¡ç«¯
server := grpc.NewServer(
    grpc.StatsHandler(otelgrpc.NewServerHandler()),  // âœ… è‡ªåŠ¨æå–
)
```

**éªŒè¯ä¼ æ’­**:

```go
// éªŒè¯HTTP Headeræ˜¯å¦åŒ…å«traceparent
func verifyPropagation(r *http.Request) {
    traceparent := r.Header.Get("traceparent")
    if traceparent == "" {
        log.Error("Missing traceparent header!")
        return
    }
    
    log.Printf("traceparent: %s", traceparent)
    // æ ¼å¼: 00-{trace-id}-{span-id}-{trace-flags}
    // ç¤ºä¾‹: 00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01
}
```

**å¸¸è§åŸå› **:

| åŸå›  | è§£å†³æ–¹æ¡ˆ |
|-----|---------|
| âŒ æœªè®¾ç½®Propagator | è°ƒç”¨`otel.SetTextMapPropagator()` |
| âŒ HTTPå®¢æˆ·ç«¯æœªæ³¨å…¥ | ä½¿ç”¨`otelhttp.NewTransport()` |
| âŒ HTTPæœåŠ¡ç«¯æœªæå– | ä½¿ç”¨`otelhttp.NewHandler()` |
| âŒ gRPCæœªä½¿ç”¨æ‹¦æˆªå™¨ | ä½¿ç”¨`otelgrpc.NewClientHandler()` |

---

### 1.2 æ€§èƒ½é—®é¢˜

#### Q4: å¯ç”¨OTLPåæ€§èƒ½å¤§å¹…ä¸‹é™

**ç—‡çŠ¶**:
```text
æ— OTLP: QPS=10000, P99=50ms
å¯ç”¨OTLP: QPS=3000, P99=180ms  âŒ æ€§èƒ½ä¸‹é™70%
```

**æ’æŸ¥æ­¥éª¤**:

```go
// 1. æ£€æŸ¥æ˜¯å¦ä½¿ç”¨äº†åŒæ­¥Exporter
// âŒ é”™è¯¯: ä½¿ç”¨SimpleSpanProcessor (åŒæ­¥å¯¼å‡º)
tp := sdktrace.NewTracerProvider(
    sdktrace.WithSpanProcessor(
        sdktrace.NewSimpleSpanProcessor(exporter),  // æ¯ä¸ªSpanç«‹å³å¯¼å‡º
    ),
)

// âœ… æ­£ç¡®: ä½¿ç”¨BatchSpanProcessor (æ‰¹é‡å¼‚æ­¥å¯¼å‡º)
tp := sdktrace.NewTracerProvider(
    sdktrace.WithBatcher(exporter,
        sdktrace.WithMaxQueueSize(10000),      // å¤§é˜Ÿåˆ—
        sdktrace.WithBatchTimeout(5*time.Second),  // 5ç§’æ‰¹é‡
        sdktrace.WithMaxExportBatchSize(512),  // æ¯æ‰¹512ä¸ª
    ),
)

// 2. æ£€æŸ¥é‡‡æ ·ç‡
// âŒ é”™è¯¯: 100%é‡‡æ · (é«˜QPSåœºæ™¯)
tp := sdktrace.NewTracerProvider(
    sdktrace.WithSampler(sdktrace.AlwaysSample()),  // æ‰€æœ‰è¯·æ±‚éƒ½è¿½è¸ª
)

// âœ… æ­£ç¡®: åˆç†é‡‡æ ·ç‡
tp := sdktrace.NewTracerProvider(
    sdktrace.WithSampler(sdktrace.TraceIDRatioBased(0.01)),  // 1%é‡‡æ ·
)

// 3. æ£€æŸ¥Spanå±æ€§æ•°é‡
// âŒ é”™è¯¯: æ·»åŠ å¤§é‡å±æ€§
span.SetAttributes(
    attribute.String("user.id", userID),
    attribute.String("user.name", userName),
    attribute.String("user.email", userEmail),
    attribute.String("user.phone", userPhone),
    // ... 100+ ä¸ªå±æ€§
)

// âœ… æ­£ç¡®: åªæ·»åŠ å…³é”®å±æ€§
span.SetAttributes(
    attribute.String("user.id", userID),
    attribute.String("operation", "checkout"),
)

// 4. æ£€æŸ¥æ˜¯å¦å¯ç”¨äº†Resourceæ£€æµ‹å™¨
// âŒ é”™è¯¯: ä½¿ç”¨æ‰€æœ‰æ£€æµ‹å™¨
resource.New(ctx,
    resource.WithFromEnv(),
    resource.WithHost(),
    resource.WithOS(),
    resource.WithProcess(),
    resource.WithContainer(),
    resource.WithOSType(),
    // ... å¯åŠ¨è€—æ—¶5-10ç§’
)

// âœ… æ­£ç¡®: åªä½¿ç”¨å¿…è¦çš„æ£€æµ‹å™¨
resource.New(ctx,
    resource.WithAttributes(
        semconv.ServiceName("my-service"),
        semconv.ServiceVersion("1.0.0"),
    ),
)
```

**æ€§èƒ½ä¼˜åŒ–æ¸…å•**:

| ä¼˜åŒ–é¡¹ | å½±å“ | å®ç° |
|-------|------|------|
| âœ… BatchSpanProcessor | -90% å»¶è¿Ÿ | `WithBatcher()` |
| âœ… åˆç†é‡‡æ ·ç‡ | -95% CPU | `TraceIDRatioBased(0.01)` |
| âœ… å‡å°‘Attributes | -50% å†…å­˜ | åªä¿ç•™å…³é”®å±æ€§ |
| âœ… å¼‚æ­¥å¯¼å‡º | -99% é˜»å¡ | `NonBlocking` |
| âœ… è¿æ¥æ±  | -30% ç½‘ç»œ | gRPCè¿æ¥å¤ç”¨ |

---

#### Q5: å†…å­˜æŒç»­å¢é•¿ (OOM)

**ç—‡çŠ¶**:
```bash
# ç¨‹åºè¿è¡Œ2å°æ—¶å
FATAL: runtime: out of memory
```

**æ’æŸ¥æ­¥éª¤**:

```bash
# 1. å¯ç”¨pprof
import _ "net/http/pprof"
go func() {
    http.ListenAndServe(":6060", nil)
}()

# 2. è·å–heap profile
curl http://localhost:6060/debug/pprof/heap > heap.prof

# 3. åˆ†æå†…å­˜åˆ†é…
go tool pprof -http=:8080 heap.prof

# å…³é”®æŒ‡æ ‡:
# - BatchSpanProcessorçš„é˜Ÿåˆ—æ˜¯å¦æ— é™å¢é•¿
# - Spanå¯¹è±¡æ˜¯å¦æ³„æ¼ (æœªè°ƒç”¨End())
# - Contextæ³„æ¼
```

**å¸¸è§åŸå› ä¸è§£å†³æ–¹æ¡ˆ**:

```go
// åŸå› 1: Spanæœªè°ƒç”¨End()
// âŒ é”™è¯¯
ctx, span := tracer.Start(ctx, "operation")
if err != nil {
    return err  // å¿˜è®°è°ƒç”¨span.End()
}
span.End()

// âœ… æ­£ç¡®: ä½¿ç”¨defer
ctx, span := tracer.Start(ctx, "operation")
defer span.End()  // æ— è®ºå¦‚ä½•éƒ½ä¼šè°ƒç”¨

// åŸå› 2: BatchProcessoré˜Ÿåˆ—æ»¡äº†
// âŒ é”™è¯¯: Collectorå®•æœº, é˜Ÿåˆ—æŒç»­ç§¯å‹
tp := sdktrace.NewTracerProvider(
    sdktrace.WithBatcher(exporter,
        sdktrace.WithMaxQueueSize(1000000),  // 100ä¸‡, å ç”¨å¤§é‡å†…å­˜
    ),
)

// âœ… æ­£ç¡®: åˆç†é˜Ÿåˆ—å¤§å° + æº¢å‡ºç­–ç•¥
tp := sdktrace.NewTracerProvider(
    sdktrace.WithBatcher(exporter,
        sdktrace.WithMaxQueueSize(10000),  // 1ä¸‡
        sdktrace.WithBlocking(),  // é˜Ÿåˆ—æ»¡æ—¶é˜»å¡ (æˆ–ç›´æ¥ä¸¢å¼ƒ)
    ),
)

// åŸå› 3: Contextæ³„æ¼
// âŒ é”™è¯¯: GoroutineæŒæœ‰Context
go func() {
    time.Sleep(1 * time.Hour)
    processData(ctx)  // ctxæ°¸ä¸é‡Šæ”¾
}()

// âœ… æ­£ç¡®: ä½¿ç”¨ç‹¬ç«‹Context
go func() {
    newCtx := context.Background()
    newCtx = trace.ContextWithSpanContext(newCtx, trace.SpanContextFromContext(ctx))
    processData(newCtx)
}()
```

---

### 1.3 é…ç½®é—®é¢˜

#### Q6: ç¯å¢ƒå˜é‡ä¸ç”Ÿæ•ˆ

**ç—‡çŠ¶**:
```bash
export OTEL_EXPORTER_OTLP_ENDPOINT=https://collector.example.com:4317
# ä½†ç¨‹åºä»è¿æ¥localhost:4317
```

**åŸå› **: ç¯å¢ƒå˜é‡ä¼˜å…ˆçº§ä½äºä»£ç é…ç½®

```go
// âŒ ä»£ç æ˜¾å¼æŒ‡å®š, ç¯å¢ƒå˜é‡è¢«å¿½ç•¥
exporter, _ := otlptracegrpc.New(ctx,
    otlptracegrpc.WithEndpoint("localhost:4317"),  // ç¡¬ç¼–ç 
    otlptracegrpc.WithInsecure(),
)

// âœ… æ­£ç¡®: ä¸æŒ‡å®šEndpoint, è‡ªåŠ¨è¯»å–ç¯å¢ƒå˜é‡
exporter, _ := otlptracegrpc.New(ctx)  // ä½¿ç”¨OTEL_EXPORTER_OTLP_ENDPOINT
```

**ç¯å¢ƒå˜é‡åˆ—è¡¨**:

| ç¯å¢ƒå˜é‡ | é»˜è®¤å€¼ | è¯´æ˜ |
|---------|-------|------|
| `OTEL_EXPORTER_OTLP_ENDPOINT` | `localhost:4317` | Collectoråœ°å€ |
| `OTEL_SERVICE_NAME` | `unknown_service:go` | æœåŠ¡å |
| `OTEL_TRACES_SAMPLER` | `parentbased_always_on` | é‡‡æ ·å™¨ |
| `OTEL_TRACES_SAMPLER_ARG` | - | é‡‡æ ·ç‡ (å¦‚: `0.1`) |
| `OTEL_LOG_LEVEL` | `info` | æ—¥å¿—çº§åˆ« |

---

## 2. è¿½è¸ªé—®é¢˜æ’æŸ¥æµç¨‹

### 2.1 Spanä¸¢å¤±è¯Šæ–­

#### æµç¨‹å›¾

```text
Spanä¸¢å¤±
   â†“
1. å®¢æˆ·ç«¯æ˜¯å¦åˆ›å»ºSpan?
   â”œâ”€ å¦ â†’ æ£€æŸ¥Traceråˆå§‹åŒ–
   â””â”€ æ˜¯ â†’ ç»§ç»­
      â†“
2. å®¢æˆ·ç«¯æ˜¯å¦è°ƒç”¨End()?
   â”œâ”€ å¦ â†’ æ·»åŠ defer span.End()
   â””â”€ æ˜¯ â†’ ç»§ç»­
      â†“
3. é‡‡æ ·å™¨æ˜¯å¦ä¸¢å¼ƒ?
   â”œâ”€ æ˜¯ â†’ è°ƒæ•´é‡‡æ ·ç‡
   â””â”€ å¦ â†’ ç»§ç»­
      â†“
4. Exporteræ˜¯å¦æˆåŠŸå¯¼å‡º?
   â”œâ”€ å¦ â†’ æ£€æŸ¥Collectorè¿æ¥
   â””â”€ æ˜¯ â†’ ç»§ç»­
      â†“
5. Collectoræ˜¯å¦æ”¶åˆ°?
   â”œâ”€ å¦ â†’ æ£€æŸ¥ç½‘ç»œ/é˜²ç«å¢™
   â””â”€ æ˜¯ â†’ ç»§ç»­
      â†“
6. Collectoræ˜¯å¦æˆåŠŸå¯¼å‡ºåˆ°Backend?
   â”œâ”€ å¦ â†’ æ£€æŸ¥Jaegeré…ç½®
   â””â”€ æ˜¯ â†’ æ£€æŸ¥Backendå­˜å‚¨
```

#### è¯Šæ–­å·¥å…·

```bash
# 1. æ£€æŸ¥å®¢æˆ·ç«¯æ—¥å¿— (å¯ç”¨debug)
export OTEL_LOG_LEVEL=debug
go run main.go 2>&1 | grep -i "span"

# 2. æŠ“åŒ…åˆ†æ
tcpdump -i lo -A 'port 4317'

# 3. æ£€æŸ¥Collectoræ¥æ”¶
curl http://localhost:8888/metrics | grep otelcol_receiver_accepted_spans

# 4. æ£€æŸ¥Collectorå¯¼å‡º
curl http://localhost:8888/metrics | grep otelcol_exporter_sent_spans

# 5. æ£€æŸ¥Jaeger
curl http://localhost:16686/api/traces?service=my-service&limit=10
```

### 2.2 TraceIDæŸ¥è¯¢æŠ€å·§

```bash
# 1. ä»æ—¥å¿—ä¸­æå–TraceID
# å‡è®¾æ—¥å¿—æ ¼å¼: [2025-10-11T10:00:00Z] [INFO] [trace_id=abc123] Processing request

grep "Processing request" app.log | sed 's/.*trace_id=\([a-z0-9]*\).*/\1/'

# 2. åœ¨Jaegerä¸­æŸ¥è¯¢
curl "http://localhost:16686/api/traces/abc123"

# 3. ä½¿ç”¨TraceIDå…³è”å¤šä¸ªæœåŠ¡çš„æ—¥å¿—
# Service A
grep "trace_id=abc123" service-a.log

# Service B
grep "trace_id=abc123" service-b.log

# Service C
grep "trace_id=abc123" service-c.log
```

### 2.3 Spanå…³ç³»éªŒè¯

```go
// éªŒè¯çˆ¶å­Spanå…³ç³»
func verifySpanRelationship(spans []trace.ReadOnlySpan) {
    for _, span := range spans {
        parentSpanID := span.Parent().SpanID()
        if !parentSpanID.IsValid() {
            log.Printf("Root Span: %s", span.Name())
        } else {
            log.Printf("Child Span: %s (Parent: %s)", span.Name(), parentSpanID)
        }
    }
}

// ç¤ºä¾‹è¾“å‡º:
// Root Span: HTTP GET /api/users/123
// Child Span: db.query (Parent: 00f067aa0ba902b7)
// Child Span: cache.get (Parent: 00f067aa0ba902b7)
```

---

## 3. æ€§èƒ½é—®é¢˜è¯Šæ–­

### 3.1 é«˜å»¶è¿Ÿå®šä½

#### 3.1.1 ä½¿ç”¨Jaeger UIåˆ†æ

```text
# 1. æ‰“å¼€Jaeger UI
http://localhost:16686

# 2. æœç´¢æ…¢è¯·æ±‚
Service: my-service
Operation: HTTP GET /api/users/{id}
Min Duration: 1s  # æ‰¾å‡ºå»¶è¿Ÿ>1sçš„è¯·æ±‚

# 3. æŸ¥çœ‹Traceè¯¦æƒ…
- æ€»è€—æ—¶: 1.2s
  - HTTP GET /api/users/123 (1.2s)
    - db.query (800ms)  â† ç“¶é¢ˆ
    - cache.get (50ms)
    - redis.set (20ms)

# 4. å®šä½é—®é¢˜
- db.queryè€—æ—¶800ms â†’ æ£€æŸ¥SQLç´¢å¼•
```

#### 3.1.2 è‡ªåŠ¨åŒ–åˆ†æè„šæœ¬

```go
package main

import (
    "context"
    "fmt"
    "sort"
    "time"

    sdktrace "go.opentelemetry.io/otel/sdk/trace"
)

// AnalyzeSlowSpans åˆ†ææ…¢Span
func AnalyzeSlowSpans(spans []sdktrace.ReadOnlySpan, threshold time.Duration) {
    type SpanDuration struct {
        Name     string
        Duration time.Duration
    }

    var slowSpans []SpanDuration
    for _, span := range spans {
        duration := span.EndTime().Sub(span.StartTime())
        if duration > threshold {
            slowSpans = append(slowSpans, SpanDuration{
                Name:     span.Name(),
                Duration: duration,
            })
        }
    }

    // æŒ‰è€—æ—¶æ’åº
    sort.Slice(slowSpans, func(i, j int) bool {
        return slowSpans[i].Duration > slowSpans[j].Duration
    })

    // è¾“å‡ºTop 10
    fmt.Println("=== Top 10 Slow Spans ===")
    for i, span := range slowSpans {
        if i >= 10 {
            break
        }
        fmt.Printf("%d. %s: %v\n", i+1, span.Name, span.Duration)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    // ä»Jaeger APIè·å–spans
    spans := fetchSpansFromJaeger("my-service", time.Now().Add(-1*time.Hour), time.Now())
    
    // åˆ†æå»¶è¿Ÿ>500msçš„Span
    AnalyzeSlowSpans(spans, 500*time.Millisecond)
}
```

### 3.2 é«˜å†…å­˜å ç”¨å®šä½

```bash
# 1. è·å–heap profile
curl http://localhost:6060/debug/pprof/heap > heap.prof

# 2. åˆ†æTopåˆ†é…
go tool pprof -top heap.prof

# ç¤ºä¾‹è¾“å‡º:
#   flat  flat%   sum%        cum   cum%
#  512MB 45.71% 45.71%     512MB 45.71%  BatchSpanProcessor.enqueue
#  256MB 22.86% 68.57%     256MB 22.86%  Span.SetAttributes
#  128MB 11.43% 80.00%     128MB 11.43%  Context.WithValue

# 3. æŸ¥çœ‹è°ƒç”¨æ ˆ
go tool pprof -http=:8080 heap.prof
# æµè§ˆå™¨æ‰“å¼€ http://localhost:8080
# View â†’ Flame Graph â†’ æ‰¾åˆ°å ç”¨å†…å­˜æœ€å¤šçš„è·¯å¾„
```

**ä¼˜åŒ–å»ºè®®**:

```go
// 1. ä½¿ç”¨å¯¹è±¡æ± 
var spanPool = sync.Pool{
    New: func() interface{} {
        return &Span{}
    },
}

func getSpan() *Span {
    return spanPool.Get().(*Span)
}

func putSpan(s *Span) {
    s.Reset()
    spanPool.Put(s)
}

// 2. é™åˆ¶Attributesæ•°é‡
const maxAttributes = 20

func setAttributes(span trace.Span, attrs []attribute.KeyValue) {
    if len(attrs) > maxAttributes {
        attrs = attrs[:maxAttributes]
    }
    span.SetAttributes(attrs...)
}

// 3. ä½¿ç”¨æµå¼å¤„ç† (é¿å…å¤§æ‰¹é‡accumulate)
processor := NewStreamingProcessor(exporter)
```

### 3.3 é«˜CPUå ç”¨å®šä½

```bash
# 1. è·å–CPU profile
curl http://localhost:6060/debug/pprof/profile?seconds=30 > cpu.prof

# 2. åˆ†æçƒ­ç‚¹å‡½æ•°
go tool pprof -top cpu.prof

# ç¤ºä¾‹è¾“å‡º:
#   flat  flat%   sum%        cum   cum%
#  12.5s 45.45% 45.45%     15.2s 55.27%  BatchSpanProcessor.exportSpans
#   5.2s 18.91% 64.36%      5.2s 18.91%  proto.Marshal
#   3.1s 11.27% 75.63%      3.1s 11.27%  gzip.compress

# 3. æŸ¥çœ‹ç«ç„°å›¾
go tool pprof -http=:8080 cpu.prof
```

**ä¼˜åŒ–å»ºè®®**:

```go
// 1. å‡å°‘åºåˆ—åŒ–æ¬¡æ•°
// âŒ é”™è¯¯: æ¯ä¸ªSpanå•ç‹¬åºåˆ—åŒ–
for _, span := range spans {
    data := proto.Marshal(span)
    send(data)
}

// âœ… æ­£ç¡®: æ‰¹é‡åºåˆ—åŒ–
batch := &tracepb.TracesData{Spans: spans}
data := proto.Marshal(batch)
send(data)

// 2. ç¦ç”¨å‹ç¼© (å¦‚æœå¸¦å®½å……è¶³)
exporter, _ := otlptracegrpc.New(ctx,
    otlptracegrpc.WithCompressor(""),  // ç¦ç”¨gzip
)

// 3. ä½¿ç”¨æ›´å¿«çš„åºåˆ—åŒ–åº“
import "github.com/gogo/protobuf/proto"  // æ¯”æ ‡å‡†protobufå¿«30%
```

---

## 4. ç”Ÿäº§ç¯å¢ƒè¯Šæ–­å·¥å…·

### 4.1 å®æ—¶ç›‘æ§Dashboard

```yaml
# Grafana Dashboardé…ç½®
# prometheus.yml
scrape_configs:
  - job_name: 'otel-sdk'
    static_configs:
      - targets: ['app:8888']  # åº”ç”¨æš´éœ²çš„metricsç«¯ç‚¹

# å…³é”®æŒ‡æ ‡
- otelcol_receiver_accepted_spans  # æ¥æ”¶çš„Spanæ•°
- otelcol_exporter_sent_spans      # å‘é€çš„Spanæ•°
- otelcol_exporter_send_failed_spans  # å¤±è´¥çš„Spanæ•°
- otelcol_processor_batch_batch_send_size  # æ‰¹é‡å¤§å°
- process_cpu_seconds_total  # CPUä½¿ç”¨
- process_resident_memory_bytes  # å†…å­˜ä½¿ç”¨
```

### 4.2 è‡ªåŠ¨åŒ–å¥åº·æ£€æŸ¥

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "time"

    "go.opentelemetry.io/otel"
)

// HealthChecker OTLPå¥åº·æ£€æŸ¥
type HealthChecker struct {
    tp           *sdktrace.TracerProvider
    lastSpanTime time.Time
}

// Check å¥åº·æ£€æŸ¥
func (hc *HealthChecker) Check(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()

    // 1. æ£€æŸ¥TracerProvider
    if hc.tp == nil {
        http.Error(w, "TracerProvider not initialized", 503)
        return
    }

    // 2. æµ‹è¯•åˆ›å»ºSpan
    tracer := otel.Tracer("health-check")
    ctx, span := tracer.Start(ctx, "health-check")
    span.End()

    // 3. æ£€æŸ¥æœ€è¿‘æ˜¯å¦æœ‰Spanå¯¼å‡º
    if time.Since(hc.lastSpanTime) > 5*time.Minute {
        http.Error(w, "No spans exported in last 5 minutes", 503)
        return
    }

    // 4. æ£€æŸ¥Collectorè¿æ¥
    if err := hc.checkCollectorConnection(ctx); err != nil {
        http.Error(w, fmt.Sprintf("Collector unreachable: %v", err), 503)
        return
    }

    w.WriteHeader(200)
    w.Write([]byte("OK"))
}

func (hc *HealthChecker) checkCollectorConnection(ctx context.Context) error {
    // å°è¯•è¿æ¥Collector
    // (ç®€åŒ–å®ç°)
    return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    hc := &HealthChecker{tp: initTracing()}
    http.HandleFunc("/health/otlp", hc.Check)
    http.ListenAndServe(":8080", nil)
}
```

### 4.3 Traceè´¨é‡ç›‘æ§

```go
// TraceQualityMonitor è¿½è¸ªè´¨é‡ç›‘æ§
type TraceQualityMonitor struct {
    meter metric.Meter
}

func (m *TraceQualityMonitor) MonitorTrace(spans []trace.ReadOnlySpan) {
    // 1. æ£€æŸ¥Spanå®Œæ•´æ€§
    for _, span := range spans {
        if !span.EndTime().After(span.StartTime()) {
            m.recordAnomaly("invalid_span_time")
        }

        if span.Name() == "" {
            m.recordAnomaly("empty_span_name")
        }

        // æ£€æŸ¥å¿…éœ€å±æ€§
        hasServiceName := false
        for _, attr := range span.Resource().Attributes() {
            if attr.Key == "service.name" {
                hasServiceName = true
                break
            }
        }
        if !hasServiceName {
            m.recordAnomaly("missing_service_name")
        }
    }

    // 2. æ£€æŸ¥Traceæ·±åº¦
    depth := calculateTraceDepth(spans)
    if depth > 20 {
        m.recordAnomaly("trace_too_deep")
    }

    // 3. æ£€æŸ¥Spanæ•°é‡
    if len(spans) > 1000 {
        m.recordAnomaly("too_many_spans")
    }
}

func (m *TraceQualityMonitor) recordAnomaly(anomalyType string) {
    counter, _ := m.meter.Int64Counter("trace.anomalies")
    counter.Add(context.Background(), 1,
        metric.WithAttributes(attribute.String("type", anomalyType)))
}
```

---

## 5. ç›‘æ§å‘Šè­¦é…ç½®

### 5.1 Prometheuså‘Šè­¦è§„åˆ™

```yaml
# prometheus-alerts.yml
groups:
  - name: otlp-alerts
    rules:
      # 1. Spanå¯¼å‡ºå¤±è´¥ç‡è¿‡é«˜
      - alert: HighSpanExportFailureRate
        expr: |
          rate(otelcol_exporter_send_failed_spans[5m])
          / rate(otelcol_exporter_sent_spans[5m]) > 0.05
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High span export failure rate (>5%)"
          description: "{{ $value | humanizePercentage }} spans failed to export"

      # 2. Collectoré˜Ÿåˆ—ç§¯å‹
      - alert: CollectorQueueBacklog
        expr: otelcol_processor_batch_batch_send_size_bucket > 5000
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "Collector queue backlog"

      # 3. åº”ç”¨OTLPå»¶è¿Ÿè¿‡é«˜
      - alert: HighOTLPOverhead
        expr: |
          histogram_quantile(0.99,
            rate(http_request_duration_with_otlp_seconds_bucket[5m]))
          / histogram_quantile(0.99,
            rate(http_request_duration_without_otlp_seconds_bucket[5m]))
          > 1.2
        for: 15m
        labels:
          severity: critical
        annotations:
          summary: "OTLP overhead > 20%"

      # 4. Traceæ•°æ®ä¸¢å¤±
      - alert: TraceDataLoss
        expr: |
          rate(otelcol_receiver_accepted_spans[5m])
          - rate(otelcol_exporter_sent_spans[5m]) > 1000
        for: 10m
        labels:
          severity: critical
        annotations:
          summary: "Trace data loss detected"
```

### 5.2 å‘Šè­¦é€šçŸ¥é…ç½®

```yaml
# alertmanager.yml
route:
  receiver: 'default'
  group_by: ['alertname', 'severity']
  group_wait: 30s
  group_interval: 5m
  repeat_interval: 4h

  routes:
    - match:
        severity: critical
      receiver: 'pagerduty'
    
    - match:
        severity: warning
      receiver: 'slack'

receivers:
  - name: 'default'
    slack_configs:
      - api_url: 'https://hooks.slack.com/services/xxx'
        channel: '#otlp-alerts'
        title: '{{ .GroupLabels.alertname }}'
        text: '{{ range .Alerts }}{{ .Annotations.summary }}{{ end }}'

  - name: 'pagerduty'
    pagerduty_configs:
      - service_key: 'xxx'
```

---

## æ€»ç»“

### å¿«é€Ÿæ’æŸ¥æ¸…å•

| é—®é¢˜ç±»å‹ | æ£€æŸ¥é¡¹ | å·¥å…· |
|---------|-------|------|
| **Traceä¸¢å¤±** | é‡‡æ ·ç‡ã€Exporterã€Collectoré…ç½® | Jaeger UI, Collector logs |
| **Contextæ–­é“¾** | Propagatorã€HTTP/gRPCæ‹¦æˆªå™¨ | curl, tcpdump |
| **æ€§èƒ½ä¸‹é™** | BatchProcessorã€é‡‡æ ·ç‡ã€Attributes | pprof, benchmarks |
| **å†…å­˜æ³„æ¼** | Span.End()ã€é˜Ÿåˆ—å¤§å°ã€Contextæ³„æ¼ | pprof heap |
| **CPUè¿‡é«˜** | åºåˆ—åŒ–ã€å‹ç¼©ã€æ‰¹é‡å¤§å° | pprof cpu |

### æ¨èå®è·µ

âœ… **æ—¥å¿—å…³è”**: åœ¨æ—¥å¿—ä¸­è®°å½•TraceID  
âœ… **å¥åº·æ£€æŸ¥**: å®šæœŸéªŒè¯OTLPè¿é€šæ€§  
âœ… **ç›‘æ§å‘Šè­¦**: é…ç½®å…³é”®æŒ‡æ ‡å‘Šè­¦  
âœ… **å®šæœŸå®¡è®¡**: æ¯æœˆreview Traceè´¨é‡  
âœ… **æ–‡æ¡£æ›´æ–°**: è®°å½•æ•…éšœå¤„ç†è¿‡ç¨‹

---

**ç‰ˆæœ¬**: v1.0.0  
**å®Œæˆæ—¥æœŸ**: 2025-10-11  
**ä¸‹æ¬¡æ›´æ–°**: æ ¹æ®ç”¨æˆ·åé¦ˆæŒç»­ä¼˜åŒ–

