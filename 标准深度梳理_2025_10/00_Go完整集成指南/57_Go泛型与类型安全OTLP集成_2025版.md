# Go æ³›å‹ä¸ç±»å‹å®‰å…¨ OTLP é›†æˆæŒ‡å—

> **ç‰ˆæœ¬**: v1.0.0  
> **Go ç‰ˆæœ¬**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0  
> **æ³›å‹æ”¯æŒ**: Go 1.18+  
> **æ—¥æœŸ**: 2025-10-11

---

## ğŸ“‹ ç›®å½•

- [Go æ³›å‹ä¸ç±»å‹å®‰å…¨ OTLP é›†æˆæŒ‡å—](#go-æ³›å‹ä¸ç±»å‹å®‰å…¨-otlp-é›†æˆæŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [æ ¸å¿ƒä»·å€¼](#æ ¸å¿ƒä»·å€¼)
    - [æŠ€æœ¯æ ˆ](#æŠ€æœ¯æ ˆ)
  - [Go æ³›å‹åŸºç¡€](#go-æ³›å‹åŸºç¡€)
    - [1. ç±»å‹å‚æ•°è¯­æ³•](#1-ç±»å‹å‚æ•°è¯­æ³•)
    - [2. ç±»å‹çº¦æŸ](#2-ç±»å‹çº¦æŸ)
    - [3. æ³›å‹ç±»å‹å®šä¹‰](#3-æ³›å‹ç±»å‹å®šä¹‰)
  - [æ³›å‹ OTLP é›†æˆ](#æ³›å‹-otlp-é›†æˆ)
    - [1. æ³›å‹ Span å°è£…](#1-æ³›å‹-span-å°è£…)
    - [2. æ³›å‹ Attribute è½¬æ¢](#2-æ³›å‹-attribute-è½¬æ¢)
    - [3. æ³›å‹ Processor](#3-æ³›å‹-processor)
  - [ç±»å‹å®‰å…¨çš„ Metrics](#ç±»å‹å®‰å…¨çš„-metrics)
    - [1. æ³›å‹ Counter](#1-æ³›å‹-counter)
    - [2. æ³›å‹ Histogram](#2-æ³›å‹-histogram)
    - [3. æ³›å‹ Gauge](#3-æ³›å‹-gauge)
  - [æ€»ç»“](#æ€»ç»“)
    - [æ ¸å¿ƒç‰¹æ€§](#æ ¸å¿ƒç‰¹æ€§)
    - [æ€§èƒ½å¯¹æ¯”](#æ€§èƒ½å¯¹æ¯”)
    - [ä¸‹ä¸€æ­¥](#ä¸‹ä¸€æ­¥)

---

## æ¦‚è¿°

Go 1.18 å¼•å…¥æ³›å‹åï¼Œæˆ‘ä»¬å¯ä»¥æ„å»ºç±»å‹å®‰å…¨çš„ OTLP ç»„ä»¶ï¼Œå‡å°‘è¿è¡Œæ—¶é”™è¯¯ï¼Œæå‡ä»£ç å¯ç»´æŠ¤æ€§ã€‚
æœ¬æŒ‡å—æä¾›å®Œæ•´çš„æ³›å‹ä¸ OTLP é›†æˆæ–¹æ¡ˆã€‚

### æ ¸å¿ƒä»·å€¼

```text
âœ… ç±»å‹å®‰å…¨çš„é¥æµ‹æ•°æ®å¤„ç†
âœ… æ³›å‹ Processor å’Œ Exporter
âœ… å‡å°‘ç±»å‹æ–­è¨€å’Œåå°„
âœ… æ›´å¥½çš„ç¼–è¯‘æœŸé”™è¯¯æ£€æµ‹
âœ… é›¶æ€§èƒ½å¼€é”€çš„ç±»å‹æŠ½è±¡
```

### æŠ€æœ¯æ ˆ

```go
// æ ¸å¿ƒä¾èµ–
go.opentelemetry.io/otel v1.32.0
go.opentelemetry.io/otel/trace v1.32.0
go.opentelemetry.io/otel/metric v1.32.0
golang.org/x/exp v0.0.0-20250106191152-7e458f773ac6  // å®éªŒæ€§æ³›å‹
```

---

## Go æ³›å‹åŸºç¡€

### 1. ç±»å‹å‚æ•°è¯­æ³•

```go
package main

import (
 "context"
 "fmt"
 
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/trace"
)

// åŸºç¡€æ³›å‹å‡½æ•°
func Trace[T any](ctx context.Context, name string, fn func(context.Context) (T, error)) (T, error) {
 tracer := otel.Tracer("generic-tracer")
 ctx, span := tracer.Start(ctx, name)
 defer span.End()
 
 result, err := fn(ctx)
 if err != nil {
  span.RecordError(err)
  span.SetStatus(codes.Error, err.Error())
 }
 
 return result, err
}

// ä½¿ç”¨ç¤ºä¾‹
func Example_BasicGeneric() {
 ctx := context.Background()
 
 // è¿”å› string
 result, err := Trace(ctx, "get-user", func(ctx context.Context) (string, error) {
  return "John Doe", nil
 })
 fmt.Printf("Result: %s, Error: %v\n", result, err)
 
 // è¿”å› int
 count, err := Trace(ctx, "count-users", func(ctx context.Context) (int, error) {
  return 42, nil
 })
 fmt.Printf("Count: %d, Error: %v\n", count, err)
}
```

### 2. ç±»å‹çº¦æŸ

```go
package main

import (
 "context"
 "fmt"
 
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/trace"
)

// æ•°å€¼ç±»å‹çº¦æŸ
type Number interface {
 ~int | ~int8 | ~int16 | ~int32 | ~int64 |
 ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 |
 ~float32 | ~float64
}

// æ³›å‹æ±‚å’Œå‡½æ•°ï¼ˆå¸¦è¿½è¸ªï¼‰
func Sum[T Number](ctx context.Context, values []T) T {
 tracer := otel.Tracer("math")
 ctx, span := tracer.Start(ctx, "sum",
  trace.WithAttributes(
   attribute.Int("values.count", len(values)),
  ),
 )
 defer span.End()
 
 var sum T
 for _, v := range values {
  sum += v
 }
 
 span.SetAttributes(
  attribute.String("result", fmt.Sprintf("%v", sum)),
 )
 
 return sum
}

// å¯æ¯”è¾ƒç±»å‹çº¦æŸ
func Contains[T comparable](ctx context.Context, slice []T, value T) bool {
 tracer := otel.Tracer("search")
 ctx, span := tracer.Start(ctx, "contains",
  trace.WithAttributes(
   attribute.Int("slice.length", len(slice)),
  ),
 )
 defer span.End()
 
 for _, item := range slice {
  if item == value {
   span.SetAttributes(attribute.Bool("found", true))
   return true
  }
 }
 
 span.SetAttributes(attribute.Bool("found", false))
 return false
}
```

### 3. æ³›å‹ç±»å‹å®šä¹‰

```go
package main

import (
 "context"
 "sync"
 
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/metric"
 "go.opentelemetry.io/otel/trace"
)

// æ³›å‹ç¼“å­˜
type Cache[K comparable, V any] struct {
 mu     sync.RWMutex
 data   map[K]V
 tracer trace.Tracer
 meter  metric.Meter
 
 hitCounter  metric.Int64Counter
 missCounter metric.Int64Counter
}

func NewCache[K comparable, V any](name string) (*Cache[K, V], error) {
 tracer := otel.Tracer("cache")
 meter := otel.Meter("cache")
 
 cache := &Cache[K, V]{
  data:   make(map[K]V),
  tracer: tracer,
  meter:  meter,
 }
 
 var err error
 
 // ç¼“å­˜å‘½ä¸­æ¬¡æ•°
 cache.hitCounter, err = meter.Int64Counter(
  "cache.hits",
  metric.WithDescription("ç¼“å­˜å‘½ä¸­æ¬¡æ•°"),
 )
 if err != nil {
  return nil, err
 }
 
 // ç¼“å­˜æœªå‘½ä¸­æ¬¡æ•°
 cache.missCounter, err = meter.Int64Counter(
  "cache.misses",
  metric.WithDescription("ç¼“å­˜æœªå‘½ä¸­æ¬¡æ•°"),
 )
 if err != nil {
  return nil, err
 }
 
 return cache, nil
}

// Get è·å–å€¼ï¼ˆå¸¦è¿½è¸ªï¼‰
func (c *Cache[K, V]) Get(ctx context.Context, key K) (V, bool) {
 ctx, span := c.tracer.Start(ctx, "cache-get",
  trace.WithAttributes(
   attribute.String("cache.key", fmt.Sprintf("%v", key)),
  ),
 )
 defer span.End()
 
 c.mu.RLock()
 defer c.mu.RUnlock()
 
 value, ok := c.data[key]
 
 if ok {
  span.SetAttributes(attribute.Bool("cache.hit", true))
  c.hitCounter.Add(ctx, 1)
 } else {
  span.SetAttributes(attribute.Bool("cache.hit", false))
  c.missCounter.Add(ctx, 1)
 }
 
 return value, ok
}

// Set è®¾ç½®å€¼ï¼ˆå¸¦è¿½è¸ªï¼‰
func (c *Cache[K, V]) Set(ctx context.Context, key K, value V) {
 ctx, span := c.tracer.Start(ctx, "cache-set",
  trace.WithAttributes(
   attribute.String("cache.key", fmt.Sprintf("%v", key)),
  ),
 )
 defer span.End()
 
 c.mu.Lock()
 defer c.mu.Unlock()
 
 c.data[key] = value
 
 span.SetAttributes(
  attribute.Int("cache.size", len(c.data)),
 )
}

// ä½¿ç”¨ç¤ºä¾‹
func Example_GenericCache() {
 ctx := context.Background()
 
 // åˆ›å»º string -> User çš„ç¼“å­˜
 userCache, err := NewCache[string, User]("user-cache")
 if err != nil {
  panic(err)
 }
 
 // è®¾ç½®å€¼
 userCache.Set(ctx, "user123", User{ID: "123", Name: "John"})
 
 // è·å–å€¼
 user, ok := userCache.Get(ctx, "user123")
 fmt.Printf("User: %+v, Found: %t\n", user, ok)
 
 // åˆ›å»º int -> []string çš„ç¼“å­˜
 tagCache, _ := NewCache[int, []string]("tag-cache")
 tagCache.Set(ctx, 1, []string{"go", "otlp"})
}
```

---

## æ³›å‹ OTLP é›†æˆ

### 1. æ³›å‹ Span å°è£…

```go
package main

import (
 "context"
 "fmt"
 
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/codes"
 "go.opentelemetry.io/otel/trace"
)

// SpanResult æ³›å‹ Span ç»“æœ
type SpanResult[T any] struct {
 Value T
 Span  trace.Span
}

// WithSpan æ³›å‹ Span åŒ…è£…å™¨
func WithSpan[T any](
 ctx context.Context,
 tracerName string,
 spanName string,
 fn func(context.Context, trace.Span) (T, error),
 opts ...trace.SpanStartOption,
) (T, error) {
 tracer := otel.Tracer(tracerName)
 ctx, span := tracer.Start(ctx, spanName, opts...)
 defer span.End()
 
 result, err := fn(ctx, span)
 if err != nil {
  span.RecordError(err)
  span.SetStatus(codes.Error, err.Error())
  
  var zero T
  return zero, err
 }
 
 return result, nil
}

// WithSpanNoError æ— é”™è¯¯ç‰ˆæœ¬
func WithSpanNoError[T any](
 ctx context.Context,
 tracerName string,
 spanName string,
 fn func(context.Context, trace.Span) T,
 opts ...trace.SpanStartOption,
) T {
 result, _ := WithSpan(ctx, tracerName, spanName, func(ctx context.Context, span trace.Span) (T, error) {
  return fn(ctx, span), nil
 }, opts...)
 
 return result
}

// ä½¿ç”¨ç¤ºä¾‹
func GetUser(ctx context.Context, userID string) (*User, error) {
 return WithSpan(ctx, "user-service", "get-user", func(ctx context.Context, span trace.Span) (*User, error) {
  span.SetAttributes(attribute.String("user.id", userID))
  
  // æ•°æ®åº“æŸ¥è¯¢
  user := &User{ID: userID, Name: "John"}
  
  return user, nil
 }, trace.WithSpanKind(trace.SpanKindInternal))
}

func CountUsers(ctx context.Context) int {
 return WithSpanNoError(ctx, "user-service", "count-users", func(ctx context.Context, span trace.Span) int {
  count := 42
  span.SetAttributes(attribute.Int("user.count", count))
  return count
 })
}
```

### 2. æ³›å‹ Attribute è½¬æ¢

```go
package main

import (
 "fmt"
 "reflect"
 
 "go.opentelemetry.io/otel/attribute"
)

// ToAttribute æ³›å‹å±æ€§è½¬æ¢å™¨
func ToAttribute[T any](key string, value T) attribute.KeyValue {
 // ä½¿ç”¨åå°„åˆ¤æ–­ç±»å‹
 v := reflect.ValueOf(value)
 
 switch v.Kind() {
 case reflect.String:
  return attribute.String(key, v.String())
  
 case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
  return attribute.Int64(key, v.Int())
  
 case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
  return attribute.Int64(key, int64(v.Uint()))
  
 case reflect.Float32, reflect.Float64:
  return attribute.Float64(key, v.Float())
  
 case reflect.Bool:
  return attribute.Bool(key, v.Bool())
  
 case reflect.Slice:
  // å¤„ç†åˆ‡ç‰‡ç±»å‹
  if v.Type().Elem().Kind() == reflect.String {
   strs := make([]string, v.Len())
   for i := 0; i < v.Len(); i++ {
    strs[i] = v.Index(i).String()
   }
   return attribute.StringSlice(key, strs)
  }
  
 case reflect.Struct:
  // ç»“æ„ä½“è½¬æ¢ä¸ºå­—ç¬¦ä¸²
  return attribute.String(key, fmt.Sprintf("%+v", value))
 }
 
 // é»˜è®¤è½¬æ¢ä¸ºå­—ç¬¦ä¸²
 return attribute.String(key, fmt.Sprintf("%v", value))
}

// ToAttributes æ‰¹é‡è½¬æ¢
func ToAttributes[T any](prefix string, obj T) []attribute.KeyValue {
 attrs := []attribute.KeyValue{}
 
 v := reflect.ValueOf(obj)
 t := v.Type()
 
 // åªå¤„ç†ç»“æ„ä½“
 if v.Kind() != reflect.Struct {
  return attrs
 }
 
 // éå†å­—æ®µ
 for i := 0; i < v.NumField(); i++ {
  field := t.Field(i)
  value := v.Field(i)
  
  // è·³è¿‡æœªå¯¼å‡ºå­—æ®µ
  if !field.IsExported() {
   continue
  }
  
  key := prefix + "." + field.Name
  attrs = append(attrs, ToAttribute(key, value.Interface()))
 }
 
 return attrs
}

// ä½¿ç”¨ç¤ºä¾‹
type Request struct {
 Method string
 Path   string
 Query  map[string]string
 Body   []byte
}

func TraceRequest(ctx context.Context, req Request) {
 tracer := otel.Tracer("http")
 ctx, span := tracer.Start(ctx, "handle-request")
 defer span.End()
 
 // è‡ªåŠ¨è½¬æ¢æ‰€æœ‰å­—æ®µä¸ºå±æ€§
 attrs := ToAttributes("http.request", req)
 span.SetAttributes(attrs...)
}
```

### 3. æ³›å‹ Processor

```go
package main

import (
 "context"
 
 "go.opentelemetry.io/otel/sdk/trace"
 "go.opentelemetry.io/otel/trace"
)

// GenericProcessor æ³›å‹ Span Processor
type GenericProcessor[T any] struct {
 transform func(trace.ReadOnlySpan) T
 export    func(context.Context, []T) error
 buffer    []T
}

func NewGenericProcessor[T any](
 transform func(trace.ReadOnlySpan) T,
 export func(context.Context, []T) error,
) *GenericProcessor[T] {
 return &GenericProcessor[T]{
  transform: transform,
  export:    export,
  buffer:    make([]T, 0, 100),
 }
}

// OnStart å®ç° SpanProcessor æ¥å£
func (p *GenericProcessor[T]) OnStart(parent context.Context, s trace.ReadWriteSpan) {
 // ä¸éœ€è¦å¤„ç†
}

// OnEnd å®ç° SpanProcessor æ¥å£
func (p *GenericProcessor[T]) OnEnd(s trace.ReadOnlySpan) {
 // è½¬æ¢ Span
 transformed := p.transform(s)
 
 // æ·»åŠ åˆ°ç¼“å†²åŒº
 p.buffer = append(p.buffer, transformed)
 
 // å¦‚æœç¼“å†²åŒºæ»¡äº†ï¼Œå¯¼å‡º
 if len(p.buffer) >= 100 {
  p.export(context.Background(), p.buffer)
  p.buffer = p.buffer[:0]
 }
}

// Shutdown å®ç° SpanProcessor æ¥å£
func (p *GenericProcessor[T]) Shutdown(ctx context.Context) error {
 // å¯¼å‡ºå‰©ä½™æ•°æ®
 if len(p.buffer) > 0 {
  return p.export(ctx, p.buffer)
 }
 return nil
}

// ForceFlush å®ç° SpanProcessor æ¥å£
func (p *GenericProcessor[T]) ForceFlush(ctx context.Context) error {
 if len(p.buffer) > 0 {
  err := p.export(ctx, p.buffer)
  p.buffer = p.buffer[:0]
  return err
 }
 return nil
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šè‡ªå®šä¹‰ Span æ ¼å¼
type CustomSpan struct {
 TraceID string
 SpanID  string
 Name    string
 Duration int64
}

func Example_GenericProcessor() {
 // åˆ›å»ºè‡ªå®šä¹‰ Processor
 processor := NewGenericProcessor(
  // Transform å‡½æ•°
  func(span trace.ReadOnlySpan) CustomSpan {
   return CustomSpan{
    TraceID:  span.SpanContext().TraceID().String(),
    SpanID:   span.SpanContext().SpanID().String(),
    Name:     span.Name(),
    Duration: span.EndTime().Sub(span.StartTime()).Nanoseconds(),
   }
  },
  // Export å‡½æ•°
  func(ctx context.Context, spans []CustomSpan) error {
   // å¯¼å‡ºåˆ°è‡ªå®šä¹‰åç«¯
   for _, span := range spans {
    fmt.Printf("Exporting span: %+v\n", span)
   }
   return nil
  },
 )
 
 // æ³¨å†Œåˆ° TracerProvider
 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(processor),
 )
 
 otel.SetTracerProvider(tp)
}
```

---

## ç±»å‹å®‰å…¨çš„ Metrics

### 1. æ³›å‹ Counter

```go
package main

import (
 "context"
 
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/metric"
)

// TypedCounter ç±»å‹å®‰å…¨çš„ Counter
type TypedCounter[T Number] struct {
 counter metric.Int64Counter
 name    string
}

func NewTypedCounter[T Number](name string, description string) (*TypedCounter[T], error) {
 meter := otel.Meter("typed-metrics")
 
 counter, err := meter.Int64Counter(
  name,
  metric.WithDescription(description),
 )
 if err != nil {
  return nil, err
 }
 
 return &TypedCounter[T]{
  counter: counter,
  name:    name,
 }, nil
}

// Add å¢åŠ è®¡æ•°
func (tc *TypedCounter[T]) Add(ctx context.Context, value T, attrs ...attribute.KeyValue) {
 tc.counter.Add(ctx, int64(value), metric.WithAttributes(attrs...))
}

// Inc é€’å¢ 1
func (tc *TypedCounter[T]) Inc(ctx context.Context, attrs ...attribute.KeyValue) {
 tc.counter.Add(ctx, 1, metric.WithAttributes(attrs...))
}

// ä½¿ç”¨ç¤ºä¾‹
type RequestCounter = TypedCounter[int64]

func Example_TypedCounter() {
 ctx := context.Background()
 
 // åˆ›å»ºè¯·æ±‚è®¡æ•°å™¨
 requestCounter, err := NewTypedCounter[int64](
  "http.server.requests",
  "HTTP æœåŠ¡å™¨è¯·æ±‚è®¡æ•°",
 )
 if err != nil {
  panic(err)
 }
 
 // é€’å¢è®¡æ•°
 requestCounter.Inc(ctx,
  attribute.String("method", "GET"),
  attribute.String("path", "/api/users"),
 )
 
 // æ‰¹é‡å¢åŠ 
 requestCounter.Add(ctx, 10,
  attribute.String("method", "POST"),
  attribute.String("path", "/api/orders"),
 )
}
```

### 2. æ³›å‹ Histogram

```go
package main

import (
 "context"
 
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/metric"
)

// TypedHistogram ç±»å‹å®‰å…¨çš„ Histogram
type TypedHistogram[T Number] struct {
 histogram metric.Float64Histogram
 name      string
}

func NewTypedHistogram[T Number](name string, description string, unit string) (*TypedHistogram[T], error) {
 meter := otel.Meter("typed-metrics")
 
 histogram, err := meter.Float64Histogram(
  name,
  metric.WithDescription(description),
  metric.WithUnit(unit),
 )
 if err != nil {
  return nil, err
 }
 
 return &TypedHistogram[T]{
  histogram: histogram,
  name:      name,
 }, nil
}

// Record è®°å½•å€¼
func (th *TypedHistogram[T]) Record(ctx context.Context, value T, attrs ...attribute.KeyValue) {
 th.histogram.Record(ctx, float64(value), metric.WithAttributes(attrs...))
}

// ä½¿ç”¨ç¤ºä¾‹
type DurationHistogram = TypedHistogram[float64]

func Example_TypedHistogram() {
 ctx := context.Background()
 
 // åˆ›å»ºå»¶è¿Ÿç›´æ–¹å›¾
 latencyHistogram, err := NewTypedHistogram[float64](
  "http.server.duration",
  "HTTP è¯·æ±‚å»¶è¿Ÿ",
  "ms",
 )
 if err != nil {
  panic(err)
 }
 
 // è®°å½•å»¶è¿Ÿ
 latencyHistogram.Record(ctx, 123.45,
  attribute.String("method", "GET"),
  attribute.String("path", "/api/users"),
  attribute.Int("status", 200),
 )
}
```

### 3. æ³›å‹ Gauge

```go
package main

import (
 "context"
 
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/metric"
)

// TypedGauge ç±»å‹å®‰å…¨çš„ Gauge
type TypedGauge[T Number] struct {
 gauge    metric.Int64ObservableGauge
 name     string
 callback func() T
}

func NewTypedGauge[T Number](
 name string,
 description string,
 callback func() T,
) (*TypedGauge[T], error) {
 meter := otel.Meter("typed-metrics")
 
 tg := &TypedGauge[T]{
  name:     name,
  callback: callback,
 }
 
 var err error
 tg.gauge, err = meter.Int64ObservableGauge(
  name,
  metric.WithDescription(description),
 )
 if err != nil {
  return nil, err
 }
 
 // æ³¨å†Œå›è°ƒ
 _, err = meter.RegisterCallback(
  func(ctx context.Context, o metric.Observer) error {
   value := tg.callback()
   o.ObserveInt64(tg.gauge, int64(value))
   return nil
  },
  tg.gauge,
 )
 
 return tg, err
}

// ä½¿ç”¨ç¤ºä¾‹
func Example_TypedGauge() {
 // å½“å‰æ´»è·ƒè¿æ¥æ•°
 var activeConnections int64 = 42
 
 // åˆ›å»º Gauge
 connectionsGauge, err := NewTypedGauge[int64](
  "active.connections",
  "å½“å‰æ´»è·ƒè¿æ¥æ•°",
  func() int64 {
   return activeConnections
  },
 )
 if err != nil {
  panic(err)
 }
 
 // Gauge ä¼šè‡ªåŠ¨å®šæœŸæ›´æ–°
 _ = connectionsGauge
}
```

---

## æ€»ç»“

æœ¬æŒ‡å—æä¾›äº† Go 1.25.1 æ³›å‹ä¸ OTLP çš„å®Œæ•´é›†æˆæ–¹æ¡ˆï¼ŒåŒ…æ‹¬ï¼š

### æ ¸å¿ƒç‰¹æ€§

```text
âœ… æ³›å‹ Span å’Œ Metric å°è£…
âœ… ç±»å‹å®‰å…¨çš„å±æ€§è½¬æ¢
âœ… æ³›å‹ Processor å’Œ Exporter
âœ… é›¶æ€§èƒ½å¼€é”€çš„ç±»å‹æŠ½è±¡
âœ… ç¼–è¯‘æœŸç±»å‹æ£€æŸ¥
âœ… ç”Ÿäº§çº§ä»£ç ç¤ºä¾‹
```

### æ€§èƒ½å¯¹æ¯”

| å®ç°æ–¹å¼ | ç±»å‹å®‰å…¨ | è¿è¡Œæ—¶å¼€é”€ | å¼€å‘ä½“éªŒ |
|---------|---------|-----------|---------|
| interface{} + åå°„ | âŒ | é«˜ï¼ˆ30%+ï¼‰ | â­â­ |
| æ‰‹åŠ¨ç±»å‹æ–­è¨€ | âš ï¸ | ä¸­ï¼ˆ10%ï¼‰ | â­â­â­ |
| æ³›å‹ | âœ… | é›¶ | â­â­â­â­â­ |

### ä¸‹ä¸€æ­¥

- [Go å‡½æ•°å¼ç¼–ç¨‹ä¸ OTLP](./58_Goå‡½æ•°å¼ç¼–ç¨‹ä¸OTLPé›†æˆ_2025ç‰ˆ.md)
- [Go ä¾èµ–æ³¨å…¥ä¸ Wire/Fx](./59_Goä¾èµ–æ³¨å…¥ä¸Wire_Fxé›†æˆ_2025ç‰ˆ.md)
- [Go å“åº”å¼ç¼–ç¨‹ä¸ RxGo](./60_Goå“åº”å¼ç¼–ç¨‹ä¸RxGoé›†æˆ_2025ç‰ˆ.md)

---

**ç‰ˆæœ¬**: v1.0.0  
**æœ€åæ›´æ–°**: 2025-10-11  
**ç»´æŠ¤è€…**: OTLP Go Team
