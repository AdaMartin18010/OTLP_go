# 40. 实战案例：订单、支付、库存服务集成

## 📚 目录

- [40. 实战案例：订单、支付、库存服务集成](#40-实战案例订单支付库存服务集成)
  - [📚 目录](#-目录)
  - [1. 订单服务](#1-订单服务)
    - [1.1 数据模型](#11-数据模型)
    - [1.2 订单服务实现](#12-订单服务实现)
  - [2. 支付服务](#2-支付服务)
    - [2.1 数据模型](#21-数据模型)
    - [2.2 支付服务实现](#22-支付服务实现)
  - [3. 库存服务](#3-库存服务)
    - [3.1 数据模型](#31-数据模型)
    - [3.2 库存服务实现](#32-库存服务实现)
  - [4. Saga 分布式事务](#4-saga-分布式事务)
    - [4.1 Saga 编排器](#41-saga-编排器)
  - [5. 服务编排](#5-服务编排)
    - [5.1 完整流程示例](#51-完整流程示例)
  - [6. 总结](#6-总结)
    - [核心特性](#核心特性)
    - [相关文档](#相关文档)

---

## 1. 订单服务

### 1.1 数据模型

```go
package order

import (
    "time"
    
    "github.com/google/uuid"
    "gorm.io/gorm"
)

// Order 订单模型
type Order struct {
    ID            uuid.UUID      `gorm:"type:uuid;primary_key" json:"id"`
    UserID        uuid.UUID      `gorm:"type:uuid;not null;index" json:"user_id"`
    Status        string         `gorm:"not null;index" json:"status"` // pending, paid, confirmed, cancelled, failed
    TotalAmount   float64        `gorm:"not null" json:"total_amount"`
    PaymentID     *uuid.UUID     `gorm:"type:uuid" json:"payment_id,omitempty"`
    PaymentMethod string         `json:"payment_method,omitempty"`
    CreatedAt     time.Time      `json:"created_at"`
    UpdatedAt     time.Time      `json:"updated_at"`
    DeletedAt     gorm.DeletedAt `gorm:"index" json:"-"`
    
    Items []OrderItem `gorm:"foreignKey:OrderID" json:"items"`
}

// OrderItem 订单项
type OrderItem struct {
    ID        uuid.UUID `gorm:"type:uuid;primary_key" json:"id"`
    OrderID   uuid.UUID `gorm:"type:uuid;not null;index" json:"order_id"`
    ProductID uuid.UUID `gorm:"type:uuid;not null" json:"product_id"`
    SKU       string    `gorm:"not null" json:"sku"`
    Name      string    `gorm:"not null" json:"name"`
    Price     float64   `gorm:"not null" json:"price"`
    Quantity  int       `gorm:"not null" json:"quantity"`
    Subtotal  float64   `gorm:"not null" json:"subtotal"`
    CreatedAt time.Time `json:"created_at"`
}

// BeforeCreate Hook
func (o *Order) BeforeCreate(tx *gorm.DB) error {
    if o.ID == uuid.Nil {
        o.ID = uuid.New()
    }
    return nil
}

func (oi *OrderItem) BeforeCreate(tx *gorm.DB) error {
    if oi.ID == uuid.Nil {
        oi.ID = uuid.New()
    }
    return nil
}
```

### 1.2 订单服务实现

```go
package order

import (
    "context"
    "errors"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/baggage"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
    "gorm.io/gorm"
)

// Service 订单服务
type Service struct {
    db              *gorm.DB
    productService  ProductServiceClient
    inventoryService InventoryServiceClient
    paymentService  PaymentServiceClient
    tracer          trace.Tracer
    meter           metric.Meter
    
    // Metrics
    createCounter    metric.Int64Counter
    statusCounter    metric.Int64Counter
    processDuration  metric.Float64Histogram
}

// NewService 创建订单服务
func NewService(
    db *gorm.DB,
    productSvc ProductServiceClient,
    inventorySvc InventoryServiceClient,
    paymentSvc PaymentServiceClient,
) (*Service, error) {
    tracer := otel.Tracer("order-service")
    meter := otel.Meter("order-service")
    
    svc := &Service{
        db:               db,
        productService:   productSvc,
        inventoryService: inventorySvc,
        paymentService:   paymentSvc,
        tracer:           tracer,
        meter:            meter,
    }
    
    var err error
    
    // 创建订单计数器
    svc.createCounter, err = meter.Int64Counter(
        "order.create.count",
        metric.WithDescription("Order creation count"),
    )
    if err != nil {
        return nil, err
    }
    
    // 订单状态计数器
    svc.statusCounter, err = meter.Int64Counter(
        "order.status.count",
        metric.WithDescription("Order status count"),
    )
    if err != nil {
        return nil, err
    }
    
    // 处理时长
    svc.processDuration, err = meter.Float64Histogram(
        "order.process.duration",
        metric.WithDescription("Order processing duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    return svc, nil
}

// Create 创建订单（使用 Saga 模式）
func (s *Service) Create(ctx context.Context, req *CreateOrderRequest) (*Order, error) {
    ctx, span := s.tracer.Start(ctx, "order.create",
        trace.WithSpanKind(trace.SpanKindServer),
        trace.WithAttributes(
            attribute.String("user.id", req.UserID.String()),
            attribute.Int("items.count", len(req.Items)),
        ),
    )
    defer span.End()
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        s.processDuration.Record(ctx, float64(duration.Milliseconds()),
            metric.WithAttributes(attribute.String("operation", "create")),
        )
    }()
    
    // 添加 Baggage：订单ID 传播到所有下游服务
    orderID := uuid.New()
    member, _ := baggage.NewMember("order.id", orderID.String())
    bag, _ := baggage.New(member)
    ctx = baggage.ContextWithBaggage(ctx, bag)
    
    span.SetAttributes(attribute.String("order.id", orderID.String()))
    
    // 执行 Saga 编排
    saga := NewOrderSaga(s, orderID, req)
    order, err := saga.Execute(ctx)
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        s.createCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("status", "failed"),
            ),
        )
        return nil, err
    }
    
    span.SetStatus(codes.Ok, "")
    s.createCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("status", "success"),
        ),
    )
    
    return order, nil
}

// GetByID 获取订单
func (s *Service) GetByID(ctx context.Context, orderID string) (*Order, error) {
    ctx, span := s.tracer.Start(ctx, "order.get_by_id",
        trace.WithAttributes(
            attribute.String("order.id", orderID),
        ),
    )
    defer span.End()
    
    var order Order
    if err := s.db.WithContext(ctx).
        Preload("Items").
        Where("id = ?", orderID).
        First(&order).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            span.SetStatus(codes.Error, "order not found")
            return nil, errors.New("order not found")
        }
        span.RecordError(err)
        span.SetStatus(codes.Error, "database error")
        return nil, err
    }
    
    span.SetStatus(codes.Ok, "")
    return &order, nil
}

// UpdateStatus 更新订单状态
func (s *Service) UpdateStatus(ctx context.Context, orderID string, status string) error {
    ctx, span := s.tracer.Start(ctx, "order.update_status",
        trace.WithAttributes(
            attribute.String("order.id", orderID),
            attribute.String("status", status),
        ),
    )
    defer span.End()
    
    result := s.db.WithContext(ctx).
        Model(&Order{}).
        Where("id = ?", orderID).
        Update("status", status)
    
    if result.Error != nil {
        span.RecordError(result.Error)
        span.SetStatus(codes.Error, "database error")
        return result.Error
    }
    
    if result.RowsAffected == 0 {
        err := errors.New("order not found")
        span.SetStatus(codes.Error, "order not found")
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    s.statusCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("status", status),
        ),
    )
    
    return nil
}

// CreateOrderRequest 创建订单请求
type CreateOrderRequest struct {
    UserID        uuid.UUID           `json:"user_id" binding:"required"`
    Items         []CreateOrderItem   `json:"items" binding:"required,min=1"`
    PaymentMethod string              `json:"payment_method" binding:"required"`
}

// CreateOrderItem 创建订单项
type CreateOrderItem struct {
    ProductID uuid.UUID `json:"product_id" binding:"required"`
    Quantity  int       `json:"quantity" binding:"required,min=1"`
}
```

---

## 2. 支付服务

### 2.1 数据模型

```go
package payment

import (
    "time"
    
    "github.com/google/uuid"
    "gorm.io/gorm"
)

// Payment 支付记录
type Payment struct {
    ID              uuid.UUID      `gorm:"type:uuid;primary_key" json:"id"`
    OrderID         uuid.UUID      `gorm:"type:uuid;not null;uniqueIndex" json:"order_id"`
    UserID          uuid.UUID      `gorm:"type:uuid;not null;index" json:"user_id"`
    Amount          float64        `gorm:"not null" json:"amount"`
    Method          string         `gorm:"not null" json:"method"` // credit_card, debit_card, paypal, alipay, wechat
    Status          string         `gorm:"not null;index" json:"status"` // pending, processing, success, failed, refunded
    TransactionID   string         `gorm:"uniqueIndex" json:"transaction_id,omitempty"`
    GatewayResponse string         `gorm:"type:text" json:"gateway_response,omitempty"`
    FailureReason   string         `json:"failure_reason,omitempty"`
    CreatedAt       time.Time      `json:"created_at"`
    UpdatedAt       time.Time      `json:"updated_at"`
    DeletedAt       gorm.DeletedAt `gorm:"index" json:"-"`
}

// BeforeCreate Hook
func (p *Payment) BeforeCreate(tx *gorm.DB) error {
    if p.ID == uuid.Nil {
        p.ID = uuid.New()
    }
    return nil
}
```

### 2.2 支付服务实现

```go
package payment

import (
    "context"
    "errors"
    "fmt"
    "time"
    
    "github.com/google/uuid"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
    "gorm.io/gorm"
)

// Service 支付服务
type Service struct {
    db     *gorm.DB
    tracer trace.Tracer
    meter  metric.Meter
    
    // Metrics
    processCounter   metric.Int64Counter
    amountHistogram  metric.Float64Histogram
    successRate      metric.Float64ObservableGauge
    
    // 统计
    totalProcessed   int64
    totalSuccess     int64
}

// NewService 创建支付服务
func NewService(db *gorm.DB) (*Service, error) {
    tracer := otel.Tracer("payment-service")
    meter := otel.Meter("payment-service")
    
    svc := &Service{
        db:     db,
        tracer: tracer,
        meter:  meter,
    }
    
    var err error
    
    // 处理计数器
    svc.processCounter, err = meter.Int64Counter(
        "payment.process.count",
        metric.WithDescription("Payment processing count"),
    )
    if err != nil {
        return nil, err
    }
    
    // 金额直方图
    svc.amountHistogram, err = meter.Float64Histogram(
        "payment.amount",
        metric.WithDescription("Payment amount"),
        metric.WithUnit("USD"),
    )
    if err != nil {
        return nil, err
    }
    
    // 成功率
    svc.successRate, err = meter.Float64ObservableGauge(
        "payment.success.rate",
        metric.WithDescription("Payment success rate"),
        metric.WithUnit("%"),
        metric.WithFloat64Callback(func(ctx context.Context, observer metric.Float64Observer) error {
            var rate float64
            if svc.totalProcessed > 0 {
                rate = float64(svc.totalSuccess) / float64(svc.totalProcessed) * 100
            }
            observer.Observe(rate)
            return nil
        }),
    )
    if err != nil {
        return nil, err
    }
    
    return svc, nil
}

// Process 处理支付
func (s *Service) Process(ctx context.Context, req *ProcessPaymentRequest) (*Payment, error) {
    ctx, span := s.tracer.Start(ctx, "payment.process",
        trace.WithSpanKind(trace.SpanKindServer),
        trace.WithAttributes(
            attribute.String("order.id", req.OrderID.String()),
            attribute.String("user.id", req.UserID.String()),
            attribute.Float64("amount", req.Amount),
            attribute.String("method", req.Method),
        ),
    )
    defer span.End()
    
    // 创建支付记录
    payment := &Payment{
        OrderID: req.OrderID,
        UserID:  req.UserID,
        Amount:  req.Amount,
        Method:  req.Method,
        Status:  "pending",
    }
    
    if err := s.db.WithContext(ctx).Create(payment).Error; err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "failed to create payment record")
        return nil, err
    }
    
    span.SetAttributes(attribute.String("payment.id", payment.ID.String()))
    
    // 更新为处理中
    payment.Status = "processing"
    s.db.WithContext(ctx).Save(payment)
    
    // 调用支付网关（模拟）
    gatewaySpan := trace.SpanFromContext(ctx)
    gatewaySpan.AddEvent("calling payment gateway")
    
    transactionID, err := s.callPaymentGateway(ctx, req)
    
    if err != nil {
        // 支付失败
        payment.Status = "failed"
        payment.FailureReason = err.Error()
        s.db.WithContext(ctx).Save(payment)
        
        span.RecordError(err)
        span.SetStatus(codes.Error, "payment failed")
        
        s.processCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("status", "failed"),
                attribute.String("method", req.Method),
            ),
        )
        s.totalProcessed++
        
        return nil, err
    }
    
    // 支付成功
    payment.Status = "success"
    payment.TransactionID = transactionID
    s.db.WithContext(ctx).Save(payment)
    
    span.SetAttributes(
        attribute.String("transaction.id", transactionID),
        attribute.String("payment.status", "success"),
    )
    span.SetStatus(codes.Ok, "")
    
    s.processCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("status", "success"),
            attribute.String("method", req.Method),
        ),
    )
    s.amountHistogram.Record(ctx, req.Amount,
        metric.WithAttributes(
            attribute.String("method", req.Method),
        ),
    )
    
    s.totalProcessed++
    s.totalSuccess++
    
    return payment, nil
}

// callPaymentGateway 调用支付网关（模拟）
func (s *Service) callPaymentGateway(ctx context.Context, req *ProcessPaymentRequest) (string, error) {
    ctx, span := s.tracer.Start(ctx, "payment.gateway.call",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            attribute.String("gateway.method", req.Method),
            attribute.Float64("gateway.amount", req.Amount),
        ),
    )
    defer span.End()
    
    // 模拟网关延迟
    time.Sleep(100 * time.Millisecond)
    
    // 模拟 95% 成功率
    if time.Now().UnixNano()%100 < 95 {
        transactionID := fmt.Sprintf("TXN-%d", time.Now().UnixNano())
        span.SetAttributes(attribute.String("transaction.id", transactionID))
        span.SetStatus(codes.Ok, "")
        return transactionID, nil
    }
    
    err := errors.New("payment gateway error")
    span.RecordError(err)
    span.SetStatus(codes.Error, "gateway error")
    return "", err
}

// Refund 退款
func (s *Service) Refund(ctx context.Context, paymentID string) error {
    ctx, span := s.tracer.Start(ctx, "payment.refund",
        trace.WithAttributes(
            attribute.String("payment.id", paymentID),
        ),
    )
    defer span.End()
    
    var payment Payment
    if err := s.db.WithContext(ctx).Where("id = ?", paymentID).First(&payment).Error; err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "payment not found")
        return err
    }
    
    if payment.Status != "success" {
        err := errors.New("can only refund successful payments")
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    // 执行退款（模拟）
    payment.Status = "refunded"
    if err := s.db.WithContext(ctx).Save(&payment).Error; err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "database error")
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// ProcessPaymentRequest 处理支付请求
type ProcessPaymentRequest struct {
    OrderID uuid.UUID `json:"order_id" binding:"required"`
    UserID  uuid.UUID `json:"user_id" binding:"required"`
    Amount  float64   `json:"amount" binding:"required,gt=0"`
    Method  string    `json:"method" binding:"required"`
}
```

---

## 3. 库存服务

### 3.1 数据模型

```go
package inventory

import (
    "time"
    
    "github.com/google/uuid"
    "gorm.io/gorm"
)

// Inventory 库存记录
type Inventory struct {
    ID            uuid.UUID      `gorm:"type:uuid;primary_key" json:"id"`
    ProductID     uuid.UUID      `gorm:"type:uuid;not null;uniqueIndex" json:"product_id"`
    SKU           string         `gorm:"not null;uniqueIndex" json:"sku"`
    Available     int            `gorm:"not null" json:"available"`
    Reserved      int            `gorm:"not null;default:0" json:"reserved"`
    Total         int            `gorm:"not null" json:"total"`
    WarehouseCode string         `gorm:"not null;index" json:"warehouse_code"`
    CreatedAt     time.Time      `json:"created_at"`
    UpdatedAt     time.Time      `json:"updated_at"`
    DeletedAt     gorm.DeletedAt `gorm:"index" json:"-"`
}

// InventoryReservation 库存预留
type InventoryReservation struct {
    ID          uuid.UUID      `gorm:"type:uuid;primary_key" json:"id"`
    OrderID     uuid.UUID      `gorm:"type:uuid;not null;uniqueIndex" json:"order_id"`
    ProductID   uuid.UUID      `gorm:"type:uuid;not null;index" json:"product_id"`
    Quantity    int            `gorm:"not null" json:"quantity"`
    Status      string         `gorm:"not null;index" json:"status"` // reserved, confirmed, released
    ExpiresAt   time.Time      `gorm:"not null;index" json:"expires_at"`
    CreatedAt   time.Time      `json:"created_at"`
    UpdatedAt   time.Time      `json:"updated_at"`
    DeletedAt   gorm.DeletedAt `gorm:"index" json:"-"`
}

// BeforeCreate Hooks
func (i *Inventory) BeforeCreate(tx *gorm.DB) error {
    if i.ID == uuid.Nil {
        i.ID = uuid.New()
    }
    return nil
}

func (ir *InventoryReservation) BeforeCreate(tx *gorm.DB) error {
    if ir.ID == uuid.Nil {
        ir.ID = uuid.New()
    }
    return nil
}
```

### 3.2 库存服务实现

```go
package inventory

import (
    "context"
    "errors"
    "time"
    
    "github.com/google/uuid"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
    "gorm.io/gorm"
    "gorm.io/gorm/clause"
)

// Service 库存服务
type Service struct {
    db     *gorm.DB
    tracer trace.Tracer
    meter  metric.Meter
    
    // Metrics
    reserveCounter  metric.Int64Counter
    confirmCounter  metric.Int64Counter
    releaseCounter  metric.Int64Counter
    stockGauge      metric.Int64ObservableGauge
}

// NewService 创建库存服务
func NewService(db *gorm.DB) (*Service, error) {
    tracer := otel.Tracer("inventory-service")
    meter := otel.Meter("inventory-service")
    
    svc := &Service{
        db:     db,
        tracer: tracer,
        meter:  meter,
    }
    
    var err error
    
    // 预留计数器
    svc.reserveCounter, err = meter.Int64Counter(
        "inventory.reserve.count",
        metric.WithDescription("Inventory reservation count"),
    )
    if err != nil {
        return nil, err
    }
    
    // 确认计数器
    svc.confirmCounter, err = meter.Int64Counter(
        "inventory.confirm.count",
        metric.WithDescription("Inventory confirmation count"),
    )
    if err != nil {
        return nil, err
    }
    
    // 释放计数器
    svc.releaseCounter, err = meter.Int64Counter(
        "inventory.release.count",
        metric.WithDescription("Inventory release count"),
    )
    if err != nil {
        return nil, err
    }
    
    // 库存水位
    svc.stockGauge, err = meter.Int64ObservableGauge(
        "inventory.stock.level",
        metric.WithDescription("Current inventory stock level"),
        metric.WithInt64Callback(func(ctx context.Context, observer metric.Int64Observer) error {
            var result struct {
                TotalAvailable int64
                TotalReserved  int64
            }
            
            db.WithContext(ctx).Model(&Inventory{}).
                Select("SUM(available) as total_available, SUM(reserved) as total_reserved").
                Scan(&result)
            
            observer.Observe(result.TotalAvailable,
                metric.WithAttributes(attribute.String("type", "available")),
            )
            observer.Observe(result.TotalReserved,
                metric.WithAttributes(attribute.String("type", "reserved")),
            )
            
            return nil
        }),
    )
    if err != nil {
        return nil, err
    }
    
    return svc, nil
}

// Reserve 预留库存
func (s *Service) Reserve(ctx context.Context, req *ReserveRequest) error {
    ctx, span := s.tracer.Start(ctx, "inventory.reserve",
        trace.WithSpanKind(trace.SpanKindServer),
        trace.WithAttributes(
            attribute.String("order.id", req.OrderID.String()),
            attribute.String("product.id", req.ProductID.String()),
            attribute.Int("quantity", req.Quantity),
        ),
    )
    defer span.End()
    
    err := s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        // 锁定库存行
        var inventory Inventory
        if err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).
            Where("product_id = ?", req.ProductID).
            First(&inventory).Error; err != nil {
            if errors.Is(err, gorm.ErrRecordNotFound) {
                return errors.New("product not found in inventory")
            }
            return err
        }
        
        span.SetAttributes(
            attribute.Int("inventory.available", inventory.Available),
            attribute.Int("inventory.reserved", inventory.Reserved),
        )
        
        // 检查可用库存
        if inventory.Available < req.Quantity {
            span.SetStatus(codes.Error, "insufficient inventory")
            return errors.New("insufficient inventory")
        }
        
        // 更新库存（减少可用，增加预留）
        if err := tx.Model(&inventory).Updates(map[string]interface{}{
            "available": gorm.Expr("available - ?", req.Quantity),
            "reserved":  gorm.Expr("reserved + ?", req.Quantity),
        }).Error; err != nil {
            return err
        }
        
        // 创建预留记录
        reservation := &InventoryReservation{
            OrderID:   req.OrderID,
            ProductID: req.ProductID,
            Quantity:  req.Quantity,
            Status:    "reserved",
            ExpiresAt: time.Now().Add(15 * time.Minute), // 15分钟后过期
        }
        
        if err := tx.Create(reservation).Error; err != nil {
            return err
        }
        
        span.SetAttributes(attribute.String("reservation.id", reservation.ID.String()))
        
        return nil
    })
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        s.reserveCounter.Add(ctx, 1,
            metric.WithAttributes(attribute.String("status", "failed")),
        )
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    s.reserveCounter.Add(ctx, 1,
        metric.WithAttributes(attribute.String("status", "success")),
    )
    
    return nil
}

// Confirm 确认库存扣减
func (s *Service) Confirm(ctx context.Context, orderID uuid.UUID) error {
    ctx, span := s.tracer.Start(ctx, "inventory.confirm",
        trace.WithAttributes(
            attribute.String("order.id", orderID.String()),
        ),
    )
    defer span.End()
    
    err := s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        // 查找预留记录
        var reservations []InventoryReservation
        if err := tx.Where("order_id = ? AND status = ?", orderID, "reserved").
            Find(&reservations).Error; err != nil {
            return err
        }
        
        if len(reservations) == 0 {
            return errors.New("no reservations found for order")
        }
        
        span.SetAttributes(attribute.Int("reservations.count", len(reservations)))
        
        // 确认所有预留
        for _, reservation := range reservations {
            // 更新预留状态
            if err := tx.Model(&reservation).Update("status", "confirmed").Error; err != nil {
                return err
            }
            
            // 更新库存（减少预留和总量）
            if err := tx.Model(&Inventory{}).
                Where("product_id = ?", reservation.ProductID).
                Updates(map[string]interface{}{
                    "reserved": gorm.Expr("reserved - ?", reservation.Quantity),
                    "total":    gorm.Expr("total - ?", reservation.Quantity),
                }).Error; err != nil {
                return err
            }
        }
        
        return nil
    })
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        s.confirmCounter.Add(ctx, 1,
            metric.WithAttributes(attribute.String("status", "failed")),
        )
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    s.confirmCounter.Add(ctx, 1,
        metric.WithAttributes(attribute.String("status", "success")),
    )
    
    return nil
}

// Release 释放库存（回滚）
func (s *Service) Release(ctx context.Context, orderID uuid.UUID) error {
    ctx, span := s.tracer.Start(ctx, "inventory.release",
        trace.WithAttributes(
            attribute.String("order.id", orderID.String()),
        ),
    )
    defer span.End()
    
    err := s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        // 查找预留记录
        var reservations []InventoryReservation
        if err := tx.Where("order_id = ? AND status = ?", orderID, "reserved").
            Find(&reservations).Error; err != nil {
            return err
        }
        
        if len(reservations) == 0 {
            return errors.New("no reservations found for order")
        }
        
        span.SetAttributes(attribute.Int("reservations.count", len(reservations)))
        
        // 释放所有预留
        for _, reservation := range reservations {
            // 更新预留状态
            if err := tx.Model(&reservation).Update("status", "released").Error; err != nil {
                return err
            }
            
            // 恢复库存（减少预留，增加可用）
            if err := tx.Model(&Inventory{}).
                Where("product_id = ?", reservation.ProductID).
                Updates(map[string]interface{}{
                    "reserved":  gorm.Expr("reserved - ?", reservation.Quantity),
                    "available": gorm.Expr("available + ?", reservation.Quantity),
                }).Error; err != nil {
                return err
            }
        }
        
        return nil
    })
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        s.releaseCounter.Add(ctx, 1,
            metric.WithAttributes(attribute.String("status", "failed")),
        )
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    s.releaseCounter.Add(ctx, 1,
        metric.WithAttributes(attribute.String("status", "success")),
    )
    
    return nil
}

// ReserveRequest 预留请求
type ReserveRequest struct {
    OrderID   uuid.UUID `json:"order_id" binding:"required"`
    ProductID uuid.UUID `json:"product_id" binding:"required"`
    Quantity  int       `json:"quantity" binding:"required,gt=0"`
}
```

---

## 4. Saga 分布式事务

### 4.1 Saga 编排器

```go
package order

import (
    "context"
    "fmt"
    
    "github.com/google/uuid"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// OrderSaga 订单 Saga 编排
type OrderSaga struct {
    service  *Service
    orderID  uuid.UUID
    request  *CreateOrderRequest
    tracer   trace.Tracer
    
    // 状态跟踪
    inventoryReserved bool
    orderCreated      bool
    paymentProcessed  bool
}

// NewOrderSaga 创建 Saga 编排器
func NewOrderSaga(service *Service, orderID uuid.UUID, req *CreateOrderRequest) *OrderSaga {
    return &OrderSaga{
        service: service,
        orderID: orderID,
        request: req,
        tracer:  otel.Tracer("order-saga"),
    }
}

// Execute 执行 Saga 流程
func (s *OrderSaga) Execute(ctx context.Context) (*Order, error) {
    ctx, span := s.tracer.Start(ctx, "saga.order.execute",
        trace.WithSpanKind(trace.SpanKindInternal),
        trace.WithAttributes(
            attribute.String("order.id", s.orderID.String()),
        ),
    )
    defer span.End()
    
    // 步骤 1: 验证商品并计算总价
    totalAmount, err := s.validateAndCalculate(ctx)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "validation failed")
        return nil, err
    }
    
    span.AddEvent("validation completed",
        trace.WithAttributes(attribute.Float64("total_amount", totalAmount)),
    )
    
    // 步骤 2: 预留库存
    if err := s.reserveInventory(ctx); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "inventory reservation failed")
        return nil, err
    }
    s.inventoryReserved = true
    span.AddEvent("inventory reserved")
    
    // 步骤 3: 创建订单
    order, err := s.createOrder(ctx, totalAmount)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "order creation failed")
        // 回滚：释放库存
        s.rollback(ctx)
        return nil, err
    }
    s.orderCreated = true
    span.AddEvent("order created")
    
    // 步骤 4: 处理支付
    payment, err := s.processPayment(ctx, totalAmount)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "payment failed")
        // 回滚：删除订单、释放库存
        s.rollback(ctx)
        return nil, err
    }
    s.paymentProcessed = true
    span.AddEvent("payment processed",
        trace.WithAttributes(attribute.String("payment.id", payment.ID.String())),
    )
    
    // 步骤 5: 确认库存扣减
    if err := s.confirmInventory(ctx); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "inventory confirmation failed")
        // 回滚：退款、删除订单、释放库存
        s.rollback(ctx)
        return nil, err
    }
    span.AddEvent("inventory confirmed")
    
    // 步骤 6: 更新订单状态为已确认
    if err := s.service.UpdateStatus(ctx, s.orderID.String(), "confirmed"); err != nil {
        span.RecordError(err)
        // 此时只记录错误，不回滚（因为支付已完成）
        span.AddEvent("order status update failed (non-critical)")
    }
    
    order.Status = "confirmed"
    order.PaymentID = &payment.ID
    
    span.SetStatus(codes.Ok, "")
    return order, nil
}

// validateAndCalculate 验证商品并计算总价
func (s *OrderSaga) validateAndCalculate(ctx context.Context) (float64, error) {
    ctx, span := s.tracer.Start(ctx, "saga.validate_and_calculate")
    defer span.End()
    
    var totalAmount float64
    
    for _, item := range s.request.Items {
        // 查询商品信息
        product, err := s.service.productService.GetByID(ctx, item.ProductID.String())
        if err != nil {
            return 0, fmt.Errorf("product %s not found: %w", item.ProductID, err)
        }
        
        if product.Status != "active" {
            return 0, fmt.Errorf("product %s is not available", item.ProductID)
        }
        
        totalAmount += product.Price * float64(item.Quantity)
    }
    
    span.SetAttributes(attribute.Float64("total_amount", totalAmount))
    return totalAmount, nil
}

// reserveInventory 预留库存
func (s *OrderSaga) reserveInventory(ctx context.Context) error {
    ctx, span := s.tracer.Start(ctx, "saga.reserve_inventory")
    defer span.End()
    
    for _, item := range s.request.Items {
        if err := s.service.inventoryService.Reserve(ctx, &ReserveRequest{
            OrderID:   s.orderID,
            ProductID: item.ProductID,
            Quantity:  item.Quantity,
        }); err != nil {
            return err
        }
    }
    
    return nil
}

// createOrder 创建订单
func (s *OrderSaga) createOrder(ctx context.Context, totalAmount float64) (*Order, error) {
    ctx, span := s.tracer.Start(ctx, "saga.create_order")
    defer span.End()
    
    order := &Order{
        ID:            s.orderID,
        UserID:        s.request.UserID,
        Status:        "pending",
        TotalAmount:   totalAmount,
        PaymentMethod: s.request.PaymentMethod,
    }
    
    // 创建订单项
    for _, item := range s.request.Items {
        product, _ := s.service.productService.GetByID(ctx, item.ProductID.String())
        
        orderItem := OrderItem{
            OrderID:   s.orderID,
            ProductID: item.ProductID,
            SKU:       product.SKU,
            Name:      product.Name,
            Price:     product.Price,
            Quantity:  item.Quantity,
            Subtotal:  product.Price * float64(item.Quantity),
        }
        
        order.Items = append(order.Items, orderItem)
    }
    
    // 保存到数据库
    if err := s.service.db.WithContext(ctx).Create(order).Error; err != nil {
        return nil, err
    }
    
    return order, nil
}

// processPayment 处理支付
func (s *OrderSaga) processPayment(ctx context.Context, amount float64) (*Payment, error) {
    ctx, span := s.tracer.Start(ctx, "saga.process_payment")
    defer span.End()
    
    payment, err := s.service.paymentService.Process(ctx, &ProcessPaymentRequest{
        OrderID: s.orderID,
        UserID:  s.request.UserID,
        Amount:  amount,
        Method:  s.request.PaymentMethod,
    })
    
    if err != nil {
        return nil, err
    }
    
    return payment, nil
}

// confirmInventory 确认库存扣减
func (s *OrderSaga) confirmInventory(ctx context.Context) error {
    ctx, span := s.tracer.Start(ctx, "saga.confirm_inventory")
    defer span.End()
    
    return s.service.inventoryService.Confirm(ctx, s.orderID)
}

// rollback 回滚操作
func (s *OrderSaga) rollback(ctx context.Context) {
    ctx, span := s.tracer.Start(ctx, "saga.rollback")
    defer span.End()
    
    span.AddEvent("starting rollback")
    
    // 回滚顺序：支付 -> 订单 -> 库存
    
    // 1. 如果支付已处理，执行退款
    if s.paymentProcessed {
        span.AddEvent("refunding payment")
        // 这里应调用支付服务的 Refund 方法
        // s.service.paymentService.Refund(ctx, paymentID)
    }
    
    // 2. 如果订单已创建，更新状态为已取消
    if s.orderCreated {
        span.AddEvent("cancelling order")
        s.service.UpdateStatus(ctx, s.orderID.String(), "cancelled")
    }
    
    // 3. 如果库存已预留，释放库存
    if s.inventoryReserved {
        span.AddEvent("releasing inventory")
        s.service.inventoryService.Release(ctx, s.orderID)
    }
    
    span.AddEvent("rollback completed")
}
```

---

## 5. 服务编排

### 5.1 完整流程示例

```go
// 订单创建完整流程
func CreateOrderFlow(ctx context.Context, req *CreateOrderRequest) (*Order, error) {
    // 1. 用户认证（从 JWT 获取 UserID）
    // 2. 调用订单服务创建订单（内部触发 Saga）
    //    - 验证商品
    //    - 预留库存
    //    - 创建订单
    //    - 处理支付
    //    - 确认库存
    // 3. 返回订单信息
}
```

---

## 6. 总结

本文档展示了电商系统中订单、支付、库存三个核心服务的完整实现，以及使用 **Saga 模式**实现分布式事务。

### 核心特性

✅ **完整的 OTLP 集成**

- Trace：完整的分布式追踪链路
- Metrics：业务指标和系统指标
- Baggage：跨服务的上下文传播

✅ **Saga 分布式事务**

- 正向流程：验证 → 预留 → 创建 → 支付 → 确认
- 回滚流程：退款 → 取消 → 释放
- 补偿机制：确保数据一致性

✅ **高并发处理**

- 悲观锁：库存行锁定
- 乐观锁：预留机制
- 超时控制：预留过期自动释放

✅ **可观测性**

- 完整的 Span 链路
- 业务指标监控
- 成功率和延迟统计

### 相关文档

- [39_实战案例_电商微服务系统](./39_实战案例_电商微服务系统.md)
- [36_Go微服务间通信与分布式追踪](./36_Go微服务间通信与分布式追踪.md)
- [33_Go高级错误处理模式与Context传播](./33_Go高级错误处理模式与Context传播.md)
- [31_Go高级并发模式与OTLP完整集成](./31_Go高级并发模式与OTLP完整集成.md)
