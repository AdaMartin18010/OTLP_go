# 40. å®æˆ˜æ¡ˆä¾‹ï¼šè®¢å•ã€æ”¯ä»˜ã€åº“å­˜æœåŠ¡é›†æˆ

## ğŸ“š ç›®å½•

- [40. å®æˆ˜æ¡ˆä¾‹ï¼šè®¢å•ã€æ”¯ä»˜ã€åº“å­˜æœåŠ¡é›†æˆ](#40-å®æˆ˜æ¡ˆä¾‹è®¢å•æ”¯ä»˜åº“å­˜æœåŠ¡é›†æˆ)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [1. è®¢å•æœåŠ¡](#1-è®¢å•æœåŠ¡)
    - [1.1 æ•°æ®æ¨¡å‹](#11-æ•°æ®æ¨¡å‹)
    - [1.2 è®¢å•æœåŠ¡å®ç°](#12-è®¢å•æœåŠ¡å®ç°)
  - [2. æ”¯ä»˜æœåŠ¡](#2-æ”¯ä»˜æœåŠ¡)
    - [2.1 æ•°æ®æ¨¡å‹](#21-æ•°æ®æ¨¡å‹)
    - [2.2 æ”¯ä»˜æœåŠ¡å®ç°](#22-æ”¯ä»˜æœåŠ¡å®ç°)
  - [3. åº“å­˜æœåŠ¡](#3-åº“å­˜æœåŠ¡)
    - [3.1 æ•°æ®æ¨¡å‹](#31-æ•°æ®æ¨¡å‹)
    - [3.2 åº“å­˜æœåŠ¡å®ç°](#32-åº“å­˜æœåŠ¡å®ç°)
  - [4. Saga åˆ†å¸ƒå¼äº‹åŠ¡](#4-saga-åˆ†å¸ƒå¼äº‹åŠ¡)
    - [4.1 Saga ç¼–æ’å™¨](#41-saga-ç¼–æ’å™¨)
  - [5. æœåŠ¡ç¼–æ’](#5-æœåŠ¡ç¼–æ’)
    - [5.1 å®Œæ•´æµç¨‹ç¤ºä¾‹](#51-å®Œæ•´æµç¨‹ç¤ºä¾‹)
  - [6. æ€»ç»“](#6-æ€»ç»“)
    - [æ ¸å¿ƒç‰¹æ€§](#æ ¸å¿ƒç‰¹æ€§)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)

---

## 1. è®¢å•æœåŠ¡

### 1.1 æ•°æ®æ¨¡å‹

```go
package order

import (
    "time"
    
    "github.com/google/uuid"
    "gorm.io/gorm"
)

// Order è®¢å•æ¨¡å‹
type Order struct {
    ID            uuid.UUID      `gorm:"type:uuid;primary_key" json:"id"`
    UserID        uuid.UUID      `gorm:"type:uuid;not null;index" json:"user_id"`
    Status        string         `gorm:"not null;index" json:"status"` // pending, paid, confirmed, cancelled, failed
    TotalAmount   float64        `gorm:"not null" json:"total_amount"`
    PaymentID     *uuid.UUID     `gorm:"type:uuid" json:"payment_id,omitempty"`
    PaymentMethod string         `json:"payment_method,omitempty"`
    CreatedAt     time.Time      `json:"created_at"`
    UpdatedAt     time.Time      `json:"updated_at"`
    DeletedAt     gorm.DeletedAt `gorm:"index" json:"-"`
    
    Items []OrderItem `gorm:"foreignKey:OrderID" json:"items"`
}

// OrderItem è®¢å•é¡¹
type OrderItem struct {
    ID        uuid.UUID `gorm:"type:uuid;primary_key" json:"id"`
    OrderID   uuid.UUID `gorm:"type:uuid;not null;index" json:"order_id"`
    ProductID uuid.UUID `gorm:"type:uuid;not null" json:"product_id"`
    SKU       string    `gorm:"not null" json:"sku"`
    Name      string    `gorm:"not null" json:"name"`
    Price     float64   `gorm:"not null" json:"price"`
    Quantity  int       `gorm:"not null" json:"quantity"`
    Subtotal  float64   `gorm:"not null" json:"subtotal"`
    CreatedAt time.Time `json:"created_at"`
}

// BeforeCreate Hook
func (o *Order) BeforeCreate(tx *gorm.DB) error {
    if o.ID == uuid.Nil {
        o.ID = uuid.New()
    }
    return nil
}

func (oi *OrderItem) BeforeCreate(tx *gorm.DB) error {
    if oi.ID == uuid.Nil {
        oi.ID = uuid.New()
    }
    return nil
}
```

### 1.2 è®¢å•æœåŠ¡å®ç°

```go
package order

import (
    "context"
    "errors"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/baggage"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
    "gorm.io/gorm"
)

// Service è®¢å•æœåŠ¡
type Service struct {
    db              *gorm.DB
    productService  ProductServiceClient
    inventoryService InventoryServiceClient
    paymentService  PaymentServiceClient
    tracer          trace.Tracer
    meter           metric.Meter
    
    // Metrics
    createCounter    metric.Int64Counter
    statusCounter    metric.Int64Counter
    processDuration  metric.Float64Histogram
}

// NewService åˆ›å»ºè®¢å•æœåŠ¡
func NewService(
    db *gorm.DB,
    productSvc ProductServiceClient,
    inventorySvc InventoryServiceClient,
    paymentSvc PaymentServiceClient,
) (*Service, error) {
    tracer := otel.Tracer("order-service")
    meter := otel.Meter("order-service")
    
    svc := &Service{
        db:               db,
        productService:   productSvc,
        inventoryService: inventorySvc,
        paymentService:   paymentSvc,
        tracer:           tracer,
        meter:            meter,
    }
    
    var err error
    
    // åˆ›å»ºè®¢å•è®¡æ•°å™¨
    svc.createCounter, err = meter.Int64Counter(
        "order.create.count",
        metric.WithDescription("Order creation count"),
    )
    if err != nil {
        return nil, err
    }
    
    // è®¢å•çŠ¶æ€è®¡æ•°å™¨
    svc.statusCounter, err = meter.Int64Counter(
        "order.status.count",
        metric.WithDescription("Order status count"),
    )
    if err != nil {
        return nil, err
    }
    
    // å¤„ç†æ—¶é•¿
    svc.processDuration, err = meter.Float64Histogram(
        "order.process.duration",
        metric.WithDescription("Order processing duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    return svc, nil
}

// Create åˆ›å»ºè®¢å•ï¼ˆä½¿ç”¨ Saga æ¨¡å¼ï¼‰
func (s *Service) Create(ctx context.Context, req *CreateOrderRequest) (*Order, error) {
    ctx, span := s.tracer.Start(ctx, "order.create",
        trace.WithSpanKind(trace.SpanKindServer),
        trace.WithAttributes(
            attribute.String("user.id", req.UserID.String()),
            attribute.Int("items.count", len(req.Items)),
        ),
    )
    defer span.End()
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        s.processDuration.Record(ctx, float64(duration.Milliseconds()),
            metric.WithAttributes(attribute.String("operation", "create")),
        )
    }()
    
    // æ·»åŠ  Baggageï¼šè®¢å•ID ä¼ æ’­åˆ°æ‰€æœ‰ä¸‹æ¸¸æœåŠ¡
    orderID := uuid.New()
    member, _ := baggage.NewMember("order.id", orderID.String())
    bag, _ := baggage.New(member)
    ctx = baggage.ContextWithBaggage(ctx, bag)
    
    span.SetAttributes(attribute.String("order.id", orderID.String()))
    
    // æ‰§è¡Œ Saga ç¼–æ’
    saga := NewOrderSaga(s, orderID, req)
    order, err := saga.Execute(ctx)
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        s.createCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("status", "failed"),
            ),
        )
        return nil, err
    }
    
    span.SetStatus(codes.Ok, "")
    s.createCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("status", "success"),
        ),
    )
    
    return order, nil
}

// GetByID è·å–è®¢å•
func (s *Service) GetByID(ctx context.Context, orderID string) (*Order, error) {
    ctx, span := s.tracer.Start(ctx, "order.get_by_id",
        trace.WithAttributes(
            attribute.String("order.id", orderID),
        ),
    )
    defer span.End()
    
    var order Order
    if err := s.db.WithContext(ctx).
        Preload("Items").
        Where("id = ?", orderID).
        First(&order).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            span.SetStatus(codes.Error, "order not found")
            return nil, errors.New("order not found")
        }
        span.RecordError(err)
        span.SetStatus(codes.Error, "database error")
        return nil, err
    }
    
    span.SetStatus(codes.Ok, "")
    return &order, nil
}

// UpdateStatus æ›´æ–°è®¢å•çŠ¶æ€
func (s *Service) UpdateStatus(ctx context.Context, orderID string, status string) error {
    ctx, span := s.tracer.Start(ctx, "order.update_status",
        trace.WithAttributes(
            attribute.String("order.id", orderID),
            attribute.String("status", status),
        ),
    )
    defer span.End()
    
    result := s.db.WithContext(ctx).
        Model(&Order{}).
        Where("id = ?", orderID).
        Update("status", status)
    
    if result.Error != nil {
        span.RecordError(result.Error)
        span.SetStatus(codes.Error, "database error")
        return result.Error
    }
    
    if result.RowsAffected == 0 {
        err := errors.New("order not found")
        span.SetStatus(codes.Error, "order not found")
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    s.statusCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("status", status),
        ),
    )
    
    return nil
}

// CreateOrderRequest åˆ›å»ºè®¢å•è¯·æ±‚
type CreateOrderRequest struct {
    UserID        uuid.UUID           `json:"user_id" binding:"required"`
    Items         []CreateOrderItem   `json:"items" binding:"required,min=1"`
    PaymentMethod string              `json:"payment_method" binding:"required"`
}

// CreateOrderItem åˆ›å»ºè®¢å•é¡¹
type CreateOrderItem struct {
    ProductID uuid.UUID `json:"product_id" binding:"required"`
    Quantity  int       `json:"quantity" binding:"required,min=1"`
}
```

---

## 2. æ”¯ä»˜æœåŠ¡

### 2.1 æ•°æ®æ¨¡å‹

```go
package payment

import (
    "time"
    
    "github.com/google/uuid"
    "gorm.io/gorm"
)

// Payment æ”¯ä»˜è®°å½•
type Payment struct {
    ID              uuid.UUID      `gorm:"type:uuid;primary_key" json:"id"`
    OrderID         uuid.UUID      `gorm:"type:uuid;not null;uniqueIndex" json:"order_id"`
    UserID          uuid.UUID      `gorm:"type:uuid;not null;index" json:"user_id"`
    Amount          float64        `gorm:"not null" json:"amount"`
    Method          string         `gorm:"not null" json:"method"` // credit_card, debit_card, paypal, alipay, wechat
    Status          string         `gorm:"not null;index" json:"status"` // pending, processing, success, failed, refunded
    TransactionID   string         `gorm:"uniqueIndex" json:"transaction_id,omitempty"`
    GatewayResponse string         `gorm:"type:text" json:"gateway_response,omitempty"`
    FailureReason   string         `json:"failure_reason,omitempty"`
    CreatedAt       time.Time      `json:"created_at"`
    UpdatedAt       time.Time      `json:"updated_at"`
    DeletedAt       gorm.DeletedAt `gorm:"index" json:"-"`
}

// BeforeCreate Hook
func (p *Payment) BeforeCreate(tx *gorm.DB) error {
    if p.ID == uuid.Nil {
        p.ID = uuid.New()
    }
    return nil
}
```

### 2.2 æ”¯ä»˜æœåŠ¡å®ç°

```go
package payment

import (
    "context"
    "errors"
    "fmt"
    "time"
    
    "github.com/google/uuid"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
    "gorm.io/gorm"
)

// Service æ”¯ä»˜æœåŠ¡
type Service struct {
    db     *gorm.DB
    tracer trace.Tracer
    meter  metric.Meter
    
    // Metrics
    processCounter   metric.Int64Counter
    amountHistogram  metric.Float64Histogram
    successRate      metric.Float64ObservableGauge
    
    // ç»Ÿè®¡
    totalProcessed   int64
    totalSuccess     int64
}

// NewService åˆ›å»ºæ”¯ä»˜æœåŠ¡
func NewService(db *gorm.DB) (*Service, error) {
    tracer := otel.Tracer("payment-service")
    meter := otel.Meter("payment-service")
    
    svc := &Service{
        db:     db,
        tracer: tracer,
        meter:  meter,
    }
    
    var err error
    
    // å¤„ç†è®¡æ•°å™¨
    svc.processCounter, err = meter.Int64Counter(
        "payment.process.count",
        metric.WithDescription("Payment processing count"),
    )
    if err != nil {
        return nil, err
    }
    
    // é‡‘é¢ç›´æ–¹å›¾
    svc.amountHistogram, err = meter.Float64Histogram(
        "payment.amount",
        metric.WithDescription("Payment amount"),
        metric.WithUnit("USD"),
    )
    if err != nil {
        return nil, err
    }
    
    // æˆåŠŸç‡
    svc.successRate, err = meter.Float64ObservableGauge(
        "payment.success.rate",
        metric.WithDescription("Payment success rate"),
        metric.WithUnit("%"),
        metric.WithFloat64Callback(func(ctx context.Context, observer metric.Float64Observer) error {
            var rate float64
            if svc.totalProcessed > 0 {
                rate = float64(svc.totalSuccess) / float64(svc.totalProcessed) * 100
            }
            observer.Observe(rate)
            return nil
        }),
    )
    if err != nil {
        return nil, err
    }
    
    return svc, nil
}

// Process å¤„ç†æ”¯ä»˜
func (s *Service) Process(ctx context.Context, req *ProcessPaymentRequest) (*Payment, error) {
    ctx, span := s.tracer.Start(ctx, "payment.process",
        trace.WithSpanKind(trace.SpanKindServer),
        trace.WithAttributes(
            attribute.String("order.id", req.OrderID.String()),
            attribute.String("user.id", req.UserID.String()),
            attribute.Float64("amount", req.Amount),
            attribute.String("method", req.Method),
        ),
    )
    defer span.End()
    
    // åˆ›å»ºæ”¯ä»˜è®°å½•
    payment := &Payment{
        OrderID: req.OrderID,
        UserID:  req.UserID,
        Amount:  req.Amount,
        Method:  req.Method,
        Status:  "pending",
    }
    
    if err := s.db.WithContext(ctx).Create(payment).Error; err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "failed to create payment record")
        return nil, err
    }
    
    span.SetAttributes(attribute.String("payment.id", payment.ID.String()))
    
    // æ›´æ–°ä¸ºå¤„ç†ä¸­
    payment.Status = "processing"
    s.db.WithContext(ctx).Save(payment)
    
    // è°ƒç”¨æ”¯ä»˜ç½‘å…³ï¼ˆæ¨¡æ‹Ÿï¼‰
    gatewaySpan := trace.SpanFromContext(ctx)
    gatewaySpan.AddEvent("calling payment gateway")
    
    transactionID, err := s.callPaymentGateway(ctx, req)
    
    if err != nil {
        // æ”¯ä»˜å¤±è´¥
        payment.Status = "failed"
        payment.FailureReason = err.Error()
        s.db.WithContext(ctx).Save(payment)
        
        span.RecordError(err)
        span.SetStatus(codes.Error, "payment failed")
        
        s.processCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("status", "failed"),
                attribute.String("method", req.Method),
            ),
        )
        s.totalProcessed++
        
        return nil, err
    }
    
    // æ”¯ä»˜æˆåŠŸ
    payment.Status = "success"
    payment.TransactionID = transactionID
    s.db.WithContext(ctx).Save(payment)
    
    span.SetAttributes(
        attribute.String("transaction.id", transactionID),
        attribute.String("payment.status", "success"),
    )
    span.SetStatus(codes.Ok, "")
    
    s.processCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("status", "success"),
            attribute.String("method", req.Method),
        ),
    )
    s.amountHistogram.Record(ctx, req.Amount,
        metric.WithAttributes(
            attribute.String("method", req.Method),
        ),
    )
    
    s.totalProcessed++
    s.totalSuccess++
    
    return payment, nil
}

// callPaymentGateway è°ƒç”¨æ”¯ä»˜ç½‘å…³ï¼ˆæ¨¡æ‹Ÿï¼‰
func (s *Service) callPaymentGateway(ctx context.Context, req *ProcessPaymentRequest) (string, error) {
    ctx, span := s.tracer.Start(ctx, "payment.gateway.call",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            attribute.String("gateway.method", req.Method),
            attribute.Float64("gateway.amount", req.Amount),
        ),
    )
    defer span.End()
    
    // æ¨¡æ‹Ÿç½‘å…³å»¶è¿Ÿ
    time.Sleep(100 * time.Millisecond)
    
    // æ¨¡æ‹Ÿ 95% æˆåŠŸç‡
    if time.Now().UnixNano()%100 < 95 {
        transactionID := fmt.Sprintf("TXN-%d", time.Now().UnixNano())
        span.SetAttributes(attribute.String("transaction.id", transactionID))
        span.SetStatus(codes.Ok, "")
        return transactionID, nil
    }
    
    err := errors.New("payment gateway error")
    span.RecordError(err)
    span.SetStatus(codes.Error, "gateway error")
    return "", err
}

// Refund é€€æ¬¾
func (s *Service) Refund(ctx context.Context, paymentID string) error {
    ctx, span := s.tracer.Start(ctx, "payment.refund",
        trace.WithAttributes(
            attribute.String("payment.id", paymentID),
        ),
    )
    defer span.End()
    
    var payment Payment
    if err := s.db.WithContext(ctx).Where("id = ?", paymentID).First(&payment).Error; err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "payment not found")
        return err
    }
    
    if payment.Status != "success" {
        err := errors.New("can only refund successful payments")
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    // æ‰§è¡Œé€€æ¬¾ï¼ˆæ¨¡æ‹Ÿï¼‰
    payment.Status = "refunded"
    if err := s.db.WithContext(ctx).Save(&payment).Error; err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "database error")
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// ProcessPaymentRequest å¤„ç†æ”¯ä»˜è¯·æ±‚
type ProcessPaymentRequest struct {
    OrderID uuid.UUID `json:"order_id" binding:"required"`
    UserID  uuid.UUID `json:"user_id" binding:"required"`
    Amount  float64   `json:"amount" binding:"required,gt=0"`
    Method  string    `json:"method" binding:"required"`
}
```

---

## 3. åº“å­˜æœåŠ¡

### 3.1 æ•°æ®æ¨¡å‹

```go
package inventory

import (
    "time"
    
    "github.com/google/uuid"
    "gorm.io/gorm"
)

// Inventory åº“å­˜è®°å½•
type Inventory struct {
    ID            uuid.UUID      `gorm:"type:uuid;primary_key" json:"id"`
    ProductID     uuid.UUID      `gorm:"type:uuid;not null;uniqueIndex" json:"product_id"`
    SKU           string         `gorm:"not null;uniqueIndex" json:"sku"`
    Available     int            `gorm:"not null" json:"available"`
    Reserved      int            `gorm:"not null;default:0" json:"reserved"`
    Total         int            `gorm:"not null" json:"total"`
    WarehouseCode string         `gorm:"not null;index" json:"warehouse_code"`
    CreatedAt     time.Time      `json:"created_at"`
    UpdatedAt     time.Time      `json:"updated_at"`
    DeletedAt     gorm.DeletedAt `gorm:"index" json:"-"`
}

// InventoryReservation åº“å­˜é¢„ç•™
type InventoryReservation struct {
    ID          uuid.UUID      `gorm:"type:uuid;primary_key" json:"id"`
    OrderID     uuid.UUID      `gorm:"type:uuid;not null;uniqueIndex" json:"order_id"`
    ProductID   uuid.UUID      `gorm:"type:uuid;not null;index" json:"product_id"`
    Quantity    int            `gorm:"not null" json:"quantity"`
    Status      string         `gorm:"not null;index" json:"status"` // reserved, confirmed, released
    ExpiresAt   time.Time      `gorm:"not null;index" json:"expires_at"`
    CreatedAt   time.Time      `json:"created_at"`
    UpdatedAt   time.Time      `json:"updated_at"`
    DeletedAt   gorm.DeletedAt `gorm:"index" json:"-"`
}

// BeforeCreate Hooks
func (i *Inventory) BeforeCreate(tx *gorm.DB) error {
    if i.ID == uuid.Nil {
        i.ID = uuid.New()
    }
    return nil
}

func (ir *InventoryReservation) BeforeCreate(tx *gorm.DB) error {
    if ir.ID == uuid.Nil {
        ir.ID = uuid.New()
    }
    return nil
}
```

### 3.2 åº“å­˜æœåŠ¡å®ç°

```go
package inventory

import (
    "context"
    "errors"
    "time"
    
    "github.com/google/uuid"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
    "gorm.io/gorm"
    "gorm.io/gorm/clause"
)

// Service åº“å­˜æœåŠ¡
type Service struct {
    db     *gorm.DB
    tracer trace.Tracer
    meter  metric.Meter
    
    // Metrics
    reserveCounter  metric.Int64Counter
    confirmCounter  metric.Int64Counter
    releaseCounter  metric.Int64Counter
    stockGauge      metric.Int64ObservableGauge
}

// NewService åˆ›å»ºåº“å­˜æœåŠ¡
func NewService(db *gorm.DB) (*Service, error) {
    tracer := otel.Tracer("inventory-service")
    meter := otel.Meter("inventory-service")
    
    svc := &Service{
        db:     db,
        tracer: tracer,
        meter:  meter,
    }
    
    var err error
    
    // é¢„ç•™è®¡æ•°å™¨
    svc.reserveCounter, err = meter.Int64Counter(
        "inventory.reserve.count",
        metric.WithDescription("Inventory reservation count"),
    )
    if err != nil {
        return nil, err
    }
    
    // ç¡®è®¤è®¡æ•°å™¨
    svc.confirmCounter, err = meter.Int64Counter(
        "inventory.confirm.count",
        metric.WithDescription("Inventory confirmation count"),
    )
    if err != nil {
        return nil, err
    }
    
    // é‡Šæ”¾è®¡æ•°å™¨
    svc.releaseCounter, err = meter.Int64Counter(
        "inventory.release.count",
        metric.WithDescription("Inventory release count"),
    )
    if err != nil {
        return nil, err
    }
    
    // åº“å­˜æ°´ä½
    svc.stockGauge, err = meter.Int64ObservableGauge(
        "inventory.stock.level",
        metric.WithDescription("Current inventory stock level"),
        metric.WithInt64Callback(func(ctx context.Context, observer metric.Int64Observer) error {
            var result struct {
                TotalAvailable int64
                TotalReserved  int64
            }
            
            db.WithContext(ctx).Model(&Inventory{}).
                Select("SUM(available) as total_available, SUM(reserved) as total_reserved").
                Scan(&result)
            
            observer.Observe(result.TotalAvailable,
                metric.WithAttributes(attribute.String("type", "available")),
            )
            observer.Observe(result.TotalReserved,
                metric.WithAttributes(attribute.String("type", "reserved")),
            )
            
            return nil
        }),
    )
    if err != nil {
        return nil, err
    }
    
    return svc, nil
}

// Reserve é¢„ç•™åº“å­˜
func (s *Service) Reserve(ctx context.Context, req *ReserveRequest) error {
    ctx, span := s.tracer.Start(ctx, "inventory.reserve",
        trace.WithSpanKind(trace.SpanKindServer),
        trace.WithAttributes(
            attribute.String("order.id", req.OrderID.String()),
            attribute.String("product.id", req.ProductID.String()),
            attribute.Int("quantity", req.Quantity),
        ),
    )
    defer span.End()
    
    err := s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        // é”å®šåº“å­˜è¡Œ
        var inventory Inventory
        if err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).
            Where("product_id = ?", req.ProductID).
            First(&inventory).Error; err != nil {
            if errors.Is(err, gorm.ErrRecordNotFound) {
                return errors.New("product not found in inventory")
            }
            return err
        }
        
        span.SetAttributes(
            attribute.Int("inventory.available", inventory.Available),
            attribute.Int("inventory.reserved", inventory.Reserved),
        )
        
        // æ£€æŸ¥å¯ç”¨åº“å­˜
        if inventory.Available < req.Quantity {
            span.SetStatus(codes.Error, "insufficient inventory")
            return errors.New("insufficient inventory")
        }
        
        // æ›´æ–°åº“å­˜ï¼ˆå‡å°‘å¯ç”¨ï¼Œå¢åŠ é¢„ç•™ï¼‰
        if err := tx.Model(&inventory).Updates(map[string]interface{}{
            "available": gorm.Expr("available - ?", req.Quantity),
            "reserved":  gorm.Expr("reserved + ?", req.Quantity),
        }).Error; err != nil {
            return err
        }
        
        // åˆ›å»ºé¢„ç•™è®°å½•
        reservation := &InventoryReservation{
            OrderID:   req.OrderID,
            ProductID: req.ProductID,
            Quantity:  req.Quantity,
            Status:    "reserved",
            ExpiresAt: time.Now().Add(15 * time.Minute), // 15åˆ†é’Ÿåè¿‡æœŸ
        }
        
        if err := tx.Create(reservation).Error; err != nil {
            return err
        }
        
        span.SetAttributes(attribute.String("reservation.id", reservation.ID.String()))
        
        return nil
    })
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        s.reserveCounter.Add(ctx, 1,
            metric.WithAttributes(attribute.String("status", "failed")),
        )
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    s.reserveCounter.Add(ctx, 1,
        metric.WithAttributes(attribute.String("status", "success")),
    )
    
    return nil
}

// Confirm ç¡®è®¤åº“å­˜æ‰£å‡
func (s *Service) Confirm(ctx context.Context, orderID uuid.UUID) error {
    ctx, span := s.tracer.Start(ctx, "inventory.confirm",
        trace.WithAttributes(
            attribute.String("order.id", orderID.String()),
        ),
    )
    defer span.End()
    
    err := s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        // æŸ¥æ‰¾é¢„ç•™è®°å½•
        var reservations []InventoryReservation
        if err := tx.Where("order_id = ? AND status = ?", orderID, "reserved").
            Find(&reservations).Error; err != nil {
            return err
        }
        
        if len(reservations) == 0 {
            return errors.New("no reservations found for order")
        }
        
        span.SetAttributes(attribute.Int("reservations.count", len(reservations)))
        
        // ç¡®è®¤æ‰€æœ‰é¢„ç•™
        for _, reservation := range reservations {
            // æ›´æ–°é¢„ç•™çŠ¶æ€
            if err := tx.Model(&reservation).Update("status", "confirmed").Error; err != nil {
                return err
            }
            
            // æ›´æ–°åº“å­˜ï¼ˆå‡å°‘é¢„ç•™å’Œæ€»é‡ï¼‰
            if err := tx.Model(&Inventory{}).
                Where("product_id = ?", reservation.ProductID).
                Updates(map[string]interface{}{
                    "reserved": gorm.Expr("reserved - ?", reservation.Quantity),
                    "total":    gorm.Expr("total - ?", reservation.Quantity),
                }).Error; err != nil {
                return err
            }
        }
        
        return nil
    })
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        s.confirmCounter.Add(ctx, 1,
            metric.WithAttributes(attribute.String("status", "failed")),
        )
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    s.confirmCounter.Add(ctx, 1,
        metric.WithAttributes(attribute.String("status", "success")),
    )
    
    return nil
}

// Release é‡Šæ”¾åº“å­˜ï¼ˆå›æ»šï¼‰
func (s *Service) Release(ctx context.Context, orderID uuid.UUID) error {
    ctx, span := s.tracer.Start(ctx, "inventory.release",
        trace.WithAttributes(
            attribute.String("order.id", orderID.String()),
        ),
    )
    defer span.End()
    
    err := s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        // æŸ¥æ‰¾é¢„ç•™è®°å½•
        var reservations []InventoryReservation
        if err := tx.Where("order_id = ? AND status = ?", orderID, "reserved").
            Find(&reservations).Error; err != nil {
            return err
        }
        
        if len(reservations) == 0 {
            return errors.New("no reservations found for order")
        }
        
        span.SetAttributes(attribute.Int("reservations.count", len(reservations)))
        
        // é‡Šæ”¾æ‰€æœ‰é¢„ç•™
        for _, reservation := range reservations {
            // æ›´æ–°é¢„ç•™çŠ¶æ€
            if err := tx.Model(&reservation).Update("status", "released").Error; err != nil {
                return err
            }
            
            // æ¢å¤åº“å­˜ï¼ˆå‡å°‘é¢„ç•™ï¼Œå¢åŠ å¯ç”¨ï¼‰
            if err := tx.Model(&Inventory{}).
                Where("product_id = ?", reservation.ProductID).
                Updates(map[string]interface{}{
                    "reserved":  gorm.Expr("reserved - ?", reservation.Quantity),
                    "available": gorm.Expr("available + ?", reservation.Quantity),
                }).Error; err != nil {
                return err
            }
        }
        
        return nil
    })
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        s.releaseCounter.Add(ctx, 1,
            metric.WithAttributes(attribute.String("status", "failed")),
        )
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    s.releaseCounter.Add(ctx, 1,
        metric.WithAttributes(attribute.String("status", "success")),
    )
    
    return nil
}

// ReserveRequest é¢„ç•™è¯·æ±‚
type ReserveRequest struct {
    OrderID   uuid.UUID `json:"order_id" binding:"required"`
    ProductID uuid.UUID `json:"product_id" binding:"required"`
    Quantity  int       `json:"quantity" binding:"required,gt=0"`
}
```

---

## 4. Saga åˆ†å¸ƒå¼äº‹åŠ¡

### 4.1 Saga ç¼–æ’å™¨

```go
package order

import (
    "context"
    "fmt"
    
    "github.com/google/uuid"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// OrderSaga è®¢å• Saga ç¼–æ’
type OrderSaga struct {
    service  *Service
    orderID  uuid.UUID
    request  *CreateOrderRequest
    tracer   trace.Tracer
    
    // çŠ¶æ€è·Ÿè¸ª
    inventoryReserved bool
    orderCreated      bool
    paymentProcessed  bool
}

// NewOrderSaga åˆ›å»º Saga ç¼–æ’å™¨
func NewOrderSaga(service *Service, orderID uuid.UUID, req *CreateOrderRequest) *OrderSaga {
    return &OrderSaga{
        service: service,
        orderID: orderID,
        request: req,
        tracer:  otel.Tracer("order-saga"),
    }
}

// Execute æ‰§è¡Œ Saga æµç¨‹
func (s *OrderSaga) Execute(ctx context.Context) (*Order, error) {
    ctx, span := s.tracer.Start(ctx, "saga.order.execute",
        trace.WithSpanKind(trace.SpanKindInternal),
        trace.WithAttributes(
            attribute.String("order.id", s.orderID.String()),
        ),
    )
    defer span.End()
    
    // æ­¥éª¤ 1: éªŒè¯å•†å“å¹¶è®¡ç®—æ€»ä»·
    totalAmount, err := s.validateAndCalculate(ctx)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "validation failed")
        return nil, err
    }
    
    span.AddEvent("validation completed",
        trace.WithAttributes(attribute.Float64("total_amount", totalAmount)),
    )
    
    // æ­¥éª¤ 2: é¢„ç•™åº“å­˜
    if err := s.reserveInventory(ctx); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "inventory reservation failed")
        return nil, err
    }
    s.inventoryReserved = true
    span.AddEvent("inventory reserved")
    
    // æ­¥éª¤ 3: åˆ›å»ºè®¢å•
    order, err := s.createOrder(ctx, totalAmount)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "order creation failed")
        // å›æ»šï¼šé‡Šæ”¾åº“å­˜
        s.rollback(ctx)
        return nil, err
    }
    s.orderCreated = true
    span.AddEvent("order created")
    
    // æ­¥éª¤ 4: å¤„ç†æ”¯ä»˜
    payment, err := s.processPayment(ctx, totalAmount)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "payment failed")
        // å›æ»šï¼šåˆ é™¤è®¢å•ã€é‡Šæ”¾åº“å­˜
        s.rollback(ctx)
        return nil, err
    }
    s.paymentProcessed = true
    span.AddEvent("payment processed",
        trace.WithAttributes(attribute.String("payment.id", payment.ID.String())),
    )
    
    // æ­¥éª¤ 5: ç¡®è®¤åº“å­˜æ‰£å‡
    if err := s.confirmInventory(ctx); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "inventory confirmation failed")
        // å›æ»šï¼šé€€æ¬¾ã€åˆ é™¤è®¢å•ã€é‡Šæ”¾åº“å­˜
        s.rollback(ctx)
        return nil, err
    }
    span.AddEvent("inventory confirmed")
    
    // æ­¥éª¤ 6: æ›´æ–°è®¢å•çŠ¶æ€ä¸ºå·²ç¡®è®¤
    if err := s.service.UpdateStatus(ctx, s.orderID.String(), "confirmed"); err != nil {
        span.RecordError(err)
        // æ­¤æ—¶åªè®°å½•é”™è¯¯ï¼Œä¸å›æ»šï¼ˆå› ä¸ºæ”¯ä»˜å·²å®Œæˆï¼‰
        span.AddEvent("order status update failed (non-critical)")
    }
    
    order.Status = "confirmed"
    order.PaymentID = &payment.ID
    
    span.SetStatus(codes.Ok, "")
    return order, nil
}

// validateAndCalculate éªŒè¯å•†å“å¹¶è®¡ç®—æ€»ä»·
func (s *OrderSaga) validateAndCalculate(ctx context.Context) (float64, error) {
    ctx, span := s.tracer.Start(ctx, "saga.validate_and_calculate")
    defer span.End()
    
    var totalAmount float64
    
    for _, item := range s.request.Items {
        // æŸ¥è¯¢å•†å“ä¿¡æ¯
        product, err := s.service.productService.GetByID(ctx, item.ProductID.String())
        if err != nil {
            return 0, fmt.Errorf("product %s not found: %w", item.ProductID, err)
        }
        
        if product.Status != "active" {
            return 0, fmt.Errorf("product %s is not available", item.ProductID)
        }
        
        totalAmount += product.Price * float64(item.Quantity)
    }
    
    span.SetAttributes(attribute.Float64("total_amount", totalAmount))
    return totalAmount, nil
}

// reserveInventory é¢„ç•™åº“å­˜
func (s *OrderSaga) reserveInventory(ctx context.Context) error {
    ctx, span := s.tracer.Start(ctx, "saga.reserve_inventory")
    defer span.End()
    
    for _, item := range s.request.Items {
        if err := s.service.inventoryService.Reserve(ctx, &ReserveRequest{
            OrderID:   s.orderID,
            ProductID: item.ProductID,
            Quantity:  item.Quantity,
        }); err != nil {
            return err
        }
    }
    
    return nil
}

// createOrder åˆ›å»ºè®¢å•
func (s *OrderSaga) createOrder(ctx context.Context, totalAmount float64) (*Order, error) {
    ctx, span := s.tracer.Start(ctx, "saga.create_order")
    defer span.End()
    
    order := &Order{
        ID:            s.orderID,
        UserID:        s.request.UserID,
        Status:        "pending",
        TotalAmount:   totalAmount,
        PaymentMethod: s.request.PaymentMethod,
    }
    
    // åˆ›å»ºè®¢å•é¡¹
    for _, item := range s.request.Items {
        product, _ := s.service.productService.GetByID(ctx, item.ProductID.String())
        
        orderItem := OrderItem{
            OrderID:   s.orderID,
            ProductID: item.ProductID,
            SKU:       product.SKU,
            Name:      product.Name,
            Price:     product.Price,
            Quantity:  item.Quantity,
            Subtotal:  product.Price * float64(item.Quantity),
        }
        
        order.Items = append(order.Items, orderItem)
    }
    
    // ä¿å­˜åˆ°æ•°æ®åº“
    if err := s.service.db.WithContext(ctx).Create(order).Error; err != nil {
        return nil, err
    }
    
    return order, nil
}

// processPayment å¤„ç†æ”¯ä»˜
func (s *OrderSaga) processPayment(ctx context.Context, amount float64) (*Payment, error) {
    ctx, span := s.tracer.Start(ctx, "saga.process_payment")
    defer span.End()
    
    payment, err := s.service.paymentService.Process(ctx, &ProcessPaymentRequest{
        OrderID: s.orderID,
        UserID:  s.request.UserID,
        Amount:  amount,
        Method:  s.request.PaymentMethod,
    })
    
    if err != nil {
        return nil, err
    }
    
    return payment, nil
}

// confirmInventory ç¡®è®¤åº“å­˜æ‰£å‡
func (s *OrderSaga) confirmInventory(ctx context.Context) error {
    ctx, span := s.tracer.Start(ctx, "saga.confirm_inventory")
    defer span.End()
    
    return s.service.inventoryService.Confirm(ctx, s.orderID)
}

// rollback å›æ»šæ“ä½œ
func (s *OrderSaga) rollback(ctx context.Context) {
    ctx, span := s.tracer.Start(ctx, "saga.rollback")
    defer span.End()
    
    span.AddEvent("starting rollback")
    
    // å›æ»šé¡ºåºï¼šæ”¯ä»˜ -> è®¢å• -> åº“å­˜
    
    // 1. å¦‚æœæ”¯ä»˜å·²å¤„ç†ï¼Œæ‰§è¡Œé€€æ¬¾
    if s.paymentProcessed {
        span.AddEvent("refunding payment")
        // è¿™é‡Œåº”è°ƒç”¨æ”¯ä»˜æœåŠ¡çš„ Refund æ–¹æ³•
        // s.service.paymentService.Refund(ctx, paymentID)
    }
    
    // 2. å¦‚æœè®¢å•å·²åˆ›å»ºï¼Œæ›´æ–°çŠ¶æ€ä¸ºå·²å–æ¶ˆ
    if s.orderCreated {
        span.AddEvent("cancelling order")
        s.service.UpdateStatus(ctx, s.orderID.String(), "cancelled")
    }
    
    // 3. å¦‚æœåº“å­˜å·²é¢„ç•™ï¼Œé‡Šæ”¾åº“å­˜
    if s.inventoryReserved {
        span.AddEvent("releasing inventory")
        s.service.inventoryService.Release(ctx, s.orderID)
    }
    
    span.AddEvent("rollback completed")
}
```

---

## 5. æœåŠ¡ç¼–æ’

### 5.1 å®Œæ•´æµç¨‹ç¤ºä¾‹

```go
// è®¢å•åˆ›å»ºå®Œæ•´æµç¨‹
func CreateOrderFlow(ctx context.Context, req *CreateOrderRequest) (*Order, error) {
    // 1. ç”¨æˆ·è®¤è¯ï¼ˆä» JWT è·å– UserIDï¼‰
    // 2. è°ƒç”¨è®¢å•æœåŠ¡åˆ›å»ºè®¢å•ï¼ˆå†…éƒ¨è§¦å‘ Sagaï¼‰
    //    - éªŒè¯å•†å“
    //    - é¢„ç•™åº“å­˜
    //    - åˆ›å»ºè®¢å•
    //    - å¤„ç†æ”¯ä»˜
    //    - ç¡®è®¤åº“å­˜
    // 3. è¿”å›è®¢å•ä¿¡æ¯
}
```

---

## 6. æ€»ç»“

æœ¬æ–‡æ¡£å±•ç¤ºäº†ç”µå•†ç³»ç»Ÿä¸­è®¢å•ã€æ”¯ä»˜ã€åº“å­˜ä¸‰ä¸ªæ ¸å¿ƒæœåŠ¡çš„å®Œæ•´å®ç°ï¼Œä»¥åŠä½¿ç”¨ **Saga æ¨¡å¼**å®ç°åˆ†å¸ƒå¼äº‹åŠ¡ã€‚

### æ ¸å¿ƒç‰¹æ€§

âœ… **å®Œæ•´çš„ OTLP é›†æˆ**

- Traceï¼šå®Œæ•´çš„åˆ†å¸ƒå¼è¿½è¸ªé“¾è·¯
- Metricsï¼šä¸šåŠ¡æŒ‡æ ‡å’Œç³»ç»ŸæŒ‡æ ‡
- Baggageï¼šè·¨æœåŠ¡çš„ä¸Šä¸‹æ–‡ä¼ æ’­

âœ… **Saga åˆ†å¸ƒå¼äº‹åŠ¡**

- æ­£å‘æµç¨‹ï¼šéªŒè¯ â†’ é¢„ç•™ â†’ åˆ›å»º â†’ æ”¯ä»˜ â†’ ç¡®è®¤
- å›æ»šæµç¨‹ï¼šé€€æ¬¾ â†’ å–æ¶ˆ â†’ é‡Šæ”¾
- è¡¥å¿æœºåˆ¶ï¼šç¡®ä¿æ•°æ®ä¸€è‡´æ€§

âœ… **é«˜å¹¶å‘å¤„ç†**

- æ‚²è§‚é”ï¼šåº“å­˜è¡Œé”å®š
- ä¹è§‚é”ï¼šé¢„ç•™æœºåˆ¶
- è¶…æ—¶æ§åˆ¶ï¼šé¢„ç•™è¿‡æœŸè‡ªåŠ¨é‡Šæ”¾

âœ… **å¯è§‚æµ‹æ€§**

- å®Œæ•´çš„ Span é“¾è·¯
- ä¸šåŠ¡æŒ‡æ ‡ç›‘æ§
- æˆåŠŸç‡å’Œå»¶è¿Ÿç»Ÿè®¡

### ç›¸å…³æ–‡æ¡£

- [39_å®æˆ˜æ¡ˆä¾‹_ç”µå•†å¾®æœåŠ¡ç³»ç»Ÿ](./39_å®æˆ˜æ¡ˆä¾‹_ç”µå•†å¾®æœåŠ¡ç³»ç»Ÿ.md)
- [36_Goå¾®æœåŠ¡é—´é€šä¿¡ä¸åˆ†å¸ƒå¼è¿½è¸ª](./36_Goå¾®æœåŠ¡é—´é€šä¿¡ä¸åˆ†å¸ƒå¼è¿½è¸ª.md)
- [33_Goé«˜çº§é”™è¯¯å¤„ç†æ¨¡å¼ä¸Contextä¼ æ’­](./33_Goé«˜çº§é”™è¯¯å¤„ç†æ¨¡å¼ä¸Contextä¼ æ’­.md)
- [31_Goé«˜çº§å¹¶å‘æ¨¡å¼ä¸OTLPå®Œæ•´é›†æˆ](./31_Goé«˜çº§å¹¶å‘æ¨¡å¼ä¸OTLPå®Œæ•´é›†æˆ.md)
