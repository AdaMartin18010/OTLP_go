# Go 测试与基准测试完整指南

> **Go 版本**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0+  
> **最后更新**: 2025年10月8日

---

## 📋 目录

- [Go 测试与基准测试完整指南](#go-测试与基准测试完整指南)
  - [📋 目录](#-目录)
  - [单元测试](#单元测试)
    - [基础测试设置](#基础测试设置)
    - [表驱动测试](#表驱动测试)
  - [集成测试](#集成测试)
    - [HTTP 服务器测试](#http-服务器测试)
    - [数据库测试](#数据库测试)
  - [基准测试](#基准测试)
    - [Span 创建基准测试](#span-创建基准测试)
    - [导出器基准测试](#导出器基准测试)
  - [性能分析](#性能分析)
    - [CPU Profile](#cpu-profile)
    - [性能报告](#性能报告)
  - [Mock 和 Stub](#mock-和-stub)
    - [Mock Exporter](#mock-exporter)
  - [测试最佳实践](#测试最佳实践)
    - [1. 测试隔离](#1-测试隔离)
    - [2. 清理资源](#2-清理资源)
    - [3. 并发测试](#3-并发测试)
    - [4. 超时控制](#4-超时控制)

---

## 单元测试

### 基础测试设置

```go
package testing

import (
 "context"
 "testing"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/sdk/trace"
 "go.opentelemetry.io/otel/sdk/trace/tracetest"
)

// setupTest 测试设置
func setupTest(t *testing.T) (*trace.TracerProvider, *tracetest.SpanRecorder) {
 // 创建 Span Recorder
 spanRecorder := tracetest.NewSpanRecorder()
 
 // 创建 TracerProvider
 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(spanRecorder),
 )
 
 // 设置全局 TracerProvider
 otel.SetTracerProvider(tp)
 
 // 清理
 t.Cleanup(func() {
  _ = tp.Shutdown(context.Background())
 })
 
 return tp, spanRecorder
}

// TestBasicTracing 基本追踪测试
func TestBasicTracing(t *testing.T) {
 tp, spanRecorder := setupTest(t)
 
 tracer := tp.Tracer("test-tracer")
 ctx := context.Background()
 
 // 创建 span
 _, span := tracer.Start(ctx, "test-operation")
 span.End()
 
 // 验证 spans
 spans := spanRecorder.Ended()
 if len(spans) != 1 {
  t.Fatalf("expected 1 span, got %d", len(spans))
 }
 
 // 验证 span 名称
 if spans[0].Name() != "test-operation" {
  t.Errorf("expected span name 'test-operation', got '%s'", spans[0].Name())
 }
}

// TestSpanAttributes 测试 Span 属性
func TestSpanAttributes(t *testing.T) {
 tp, spanRecorder := setupTest(t)
 
 tracer := tp.Tracer("test-tracer")
 ctx := context.Background()
 
 // 创建带属性的 span
 _, span := tracer.Start(ctx, "test-operation")
 span.SetAttributes(
  attribute.String("key1", "value1"),
  attribute.Int("key2", 123),
 )
 span.End()
 
 // 验证属性
 spans := spanRecorder.Ended()
 if len(spans) != 1 {
  t.Fatalf("expected 1 span, got %d", len(spans))
 }
 
 attrs := spans[0].Attributes()
 
 // 验证属性数量
 if len(attrs) != 2 {
  t.Errorf("expected 2 attributes, got %d", len(attrs))
 }
 
 // 验证属性值
 for _, attr := range attrs {
  switch attr.Key {
  case "key1":
   if attr.Value.AsString() != "value1" {
    t.Errorf("expected key1='value1', got '%s'", attr.Value.AsString())
   }
  case "key2":
   if attr.Value.AsInt64() != 123 {
    t.Errorf("expected key2=123, got %d", attr.Value.AsInt64())
   }
  default:
   t.Errorf("unexpected attribute: %s", attr.Key)
  }
 }
}

// TestNestedSpans 测试嵌套 Spans
func TestNestedSpans(t *testing.T) {
 tp, spanRecorder := setupTest(t)
 
 tracer := tp.Tracer("test-tracer")
 ctx := context.Background()
 
 // 父 span
 ctx, parentSpan := tracer.Start(ctx, "parent")
 
 // 子 span
 _, childSpan := tracer.Start(ctx, "child")
 childSpan.End()
 
 parentSpan.End()
 
 // 验证 spans
 spans := spanRecorder.Ended()
 if len(spans) != 2 {
  t.Fatalf("expected 2 spans, got %d", len(spans))
 }
 
 // 验证父子关系
 childSpanData := spans[0]
 parentSpanData := spans[1]
 
 if childSpanData.Parent().SpanID() != parentSpanData.SpanContext().SpanID() {
  t.Error("child span's parent ID doesn't match parent span's ID")
 }
}

// TestSpanError 测试错误记录
func TestSpanError(t *testing.T) {
 tp, spanRecorder := setupTest(t)
 
 tracer := tp.Tracer("test-tracer")
 ctx := context.Background()
 
 _, span := tracer.Start(ctx, "error-operation")
 
 // 记录错误
 err := errors.New("test error")
 span.RecordError(err)
 span.SetStatus(codes.Error, err.Error())
 span.End()
 
 // 验证错误
 spans := spanRecorder.Ended()
 if len(spans) != 1 {
  t.Fatalf("expected 1 span, got %d", len(spans))
 }
 
 spanData := spans[0]
 
 // 验证状态
 if spanData.Status().Code != codes.Error {
  t.Errorf("expected Error status, got %v", spanData.Status().Code)
 }
 
 // 验证事件
 events := spanData.Events()
 foundError := false
 for _, event := range events {
  if event.Name == "exception" {
   foundError = true
   break
  }
 }
 
 if !foundError {
  t.Error("expected to find error event")
 }
}
```

### 表驱动测试

```go
package testing

import (
 "context"
 "testing"

 "go.opentelemetry.io/otel/attribute"
)

// TestSpanCreation 表驱动测试
func TestSpanCreation(t *testing.T) {
 tests := []struct {
  name       string
  spanName   string
  attributes []attribute.KeyValue
  wantErr    bool
 }{
  {
   name:     "simple span",
   spanName: "test-span",
   attributes: []attribute.KeyValue{
    attribute.String("key", "value"),
   },
   wantErr: false,
  },
  {
   name:       "span with multiple attributes",
   spanName:   "multi-attr-span",
   attributes: []attribute.KeyValue{
    attribute.String("string", "value"),
    attribute.Int("int", 123),
    attribute.Bool("bool", true),
   },
   wantErr: false,
  },
  {
   name:       "span with no attributes",
   spanName:   "no-attr-span",
   attributes: []attribute.KeyValue{},
   wantErr:    false,
  },
 }

 for _, tt := range tests {
  t.Run(tt.name, func(t *testing.T) {
   tp, spanRecorder := setupTest(t)
   
   tracer := tp.Tracer("test-tracer")
   ctx := context.Background()
   
   _, span := tracer.Start(ctx, tt.spanName)
   span.SetAttributes(tt.attributes...)
   span.End()
   
   spans := spanRecorder.Ended()
   if len(spans) != 1 {
    t.Fatalf("expected 1 span, got %d", len(spans))
   }
   
   spanData := spans[0]
   
   // 验证 span 名称
   if spanData.Name() != tt.spanName {
    t.Errorf("expected span name '%s', got '%s'", tt.spanName, spanData.Name())
   }
   
   // 验证属性数量
   attrs := spanData.Attributes()
   if len(attrs) != len(tt.attributes) {
    t.Errorf("expected %d attributes, got %d", len(tt.attributes), len(attrs))
   }
  })
 }
}
```

---

## 集成测试

### HTTP 服务器测试

```go
package integration

import (
 "context"
 "net/http"
 "net/http/httptest"
 "testing"

 "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/sdk/trace"
 "go.opentelemetry.io/otel/sdk/trace/tracetest"
)

// TestHTTPHandler 测试 HTTP 处理器
func TestHTTPHandler(t *testing.T) {
 // 设置追踪
 spanRecorder := tracetest.NewSpanRecorder()
 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(spanRecorder),
 )
 otel.SetTracerProvider(tp)
 defer tp.Shutdown(context.Background())

 // 创建处理器
 handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  w.WriteHeader(http.StatusOK)
  w.Write([]byte("OK"))
 })

 // 包装 otelhttp 中间件
 wrappedHandler := otelhttp.NewHandler(handler, "test-handler")

 // 创建测试服务器
 server := httptest.NewServer(wrappedHandler)
 defer server.Close()

 // 发送请求
 resp, err := http.Get(server.URL)
 if err != nil {
  t.Fatalf("failed to send request: %v", err)
 }
 defer resp.Body.Close()

 // 验证响应
 if resp.StatusCode != http.StatusOK {
  t.Errorf("expected status 200, got %d", resp.StatusCode)
 }

 // 验证追踪
 spans := spanRecorder.Ended()
 if len(spans) == 0 {
  t.Error("expected at least one span")
 }

 // 验证 span 名称和类型
 foundServerSpan := false
 for _, span := range spans {
  if span.SpanKind() == trace.SpanKindServer {
   foundServerSpan = true
   break
  }
 }

 if !foundServerSpan {
  t.Error("expected to find server span")
 }
}

// TestHTTPClientServer 测试客户端-服务器追踪
func TestHTTPClientServer(t *testing.T) {
 spanRecorder := tracetest.NewSpanRecorder()
 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(spanRecorder),
 )
 otel.SetTracerProvider(tp)
 defer tp.Shutdown(context.Background())

 // 创建服务器
 serverHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  w.WriteHeader(http.StatusOK)
  w.Write([]byte("OK"))
 })
 wrappedHandler := otelhttp.NewHandler(serverHandler, "server")
 server := httptest.NewServer(wrappedHandler)
 defer server.Close()

 // 创建客户端
 client := &http.Client{
  Transport: otelhttp.NewTransport(http.DefaultTransport),
 }

 // 发送请求
 req, _ := http.NewRequestWithContext(context.Background(), "GET", server.URL, nil)
 resp, err := client.Do(req)
 if err != nil {
  t.Fatalf("failed to send request: %v", err)
 }
 defer resp.Body.Close()

 // 等待 spans 完成
 time.Sleep(100 * time.Millisecond)

 // 验证追踪
 spans := spanRecorder.Ended()
 
 // 应该有客户端和服务器两个 spans
 if len(spans) < 2 {
  t.Errorf("expected at least 2 spans, got %d", len(spans))
 }

 // 验证 span 类型
 hasClient := false
 hasServer := false
 for _, span := range spans {
  switch span.SpanKind() {
  case trace.SpanKindClient:
   hasClient = true
  case trace.SpanKindServer:
   hasServer = true
  }
 }

 if !hasClient {
  t.Error("expected to find client span")
 }
 if !hasServer {
  t.Error("expected to find server span")
 }
}
```

### 数据库测试

```go
package integration

import (
 "context"
 "database/sql"
 "testing"

 "go.opentelemetry.io/contrib/instrumentation/database/sql/otelsql"
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/sdk/trace"
 "go.opentelemetry.io/otel/sdk/trace/tracetest"
 semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// TestDatabaseQuery 测试数据库查询追踪
func TestDatabaseQuery(t *testing.T) {
 spanRecorder := tracetest.NewSpanRecorder()
 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(spanRecorder),
 )
 otel.SetTracerProvider(tp)
 defer tp.Shutdown(context.Background())

 // 注册 otelsql 驱动
 driverName, err := otelsql.Register("sqlite3",
  otelsql.WithAttributes(
   semconv.DBSystemSqlite,
  ),
 )
 if err != nil {
  t.Fatalf("failed to register driver: %v", err)
 }

 // 打开数据库
 db, err := sql.Open(driverName, ":memory:")
 if err != nil {
  t.Fatalf("failed to open database: %v", err)
 }
 defer db.Close()

 // 执行查询
 ctx := context.Background()
 rows, err := db.QueryContext(ctx, "SELECT 1")
 if err != nil {
  t.Fatalf("query failed: %v", err)
 }
 rows.Close()

 // 验证追踪
 spans := spanRecorder.Ended()
 if len(spans) == 0 {
  t.Error("expected at least one span")
 }

 // 验证 span 属性
 for _, span := range spans {
  attrs := span.Attributes()
  foundDBSystem := false
  
  for _, attr := range attrs {
   if string(attr.Key) == string(semconv.DBSystemKey) {
    foundDBSystem = true
    break
   }
  }
  
  if !foundDBSystem {
   t.Error("expected to find db.system attribute")
  }
 }
}
```

---

## 基准测试

### Span 创建基准测试

```go
package benchmark

import (
 "context"
 "testing"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/sdk/trace"
 "go.opentelemetry.io/otel/sdk/trace/tracetest"
)

// BenchmarkSpanCreation Span 创建基准测试
func BenchmarkSpanCreation(b *testing.B) {
 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(tracetest.NewSpanRecorder()),
 )
 otel.SetTracerProvider(tp)
 defer tp.Shutdown(context.Background())

 tracer := tp.Tracer("benchmark")
 ctx := context.Background()

 b.ResetTimer()
 b.ReportAllocs()

 for i := 0; i < b.N; i++ {
  _, span := tracer.Start(ctx, "benchmark-span")
  span.End()
 }
}

// BenchmarkSpanWithAttributes 带属性的 Span 基准测试
func BenchmarkSpanWithAttributes(b *testing.B) {
 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(tracetest.NewSpanRecorder()),
 )
 otel.SetTracerProvider(tp)
 defer tp.Shutdown(context.Background())

 tracer := tp.Tracer("benchmark")
 ctx := context.Background()

 attrs := []attribute.KeyValue{
  attribute.String("key1", "value1"),
  attribute.Int("key2", 123),
  attribute.Bool("key3", true),
 }

 b.ResetTimer()
 b.ReportAllocs()

 for i := 0; i < b.N; i++ {
  _, span := tracer.Start(ctx, "benchmark-span")
  span.SetAttributes(attrs...)
  span.End()
 }
}

// BenchmarkNestedSpans 嵌套 Span 基准测试
func BenchmarkNestedSpans(b *testing.B) {
 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(tracetest.NewSpanRecorder()),
 )
 otel.SetTracerProvider(tp)
 defer tp.Shutdown(context.Background())

 tracer := tp.Tracer("benchmark")
 ctx := context.Background()

 b.ResetTimer()
 b.ReportAllocs()

 for i := 0; i < b.N; i++ {
  ctx, parentSpan := tracer.Start(ctx, "parent")
  
  _, childSpan1 := tracer.Start(ctx, "child1")
  childSpan1.End()
  
  _, childSpan2 := tracer.Start(ctx, "child2")
  childSpan2.End()
  
  parentSpan.End()
 }
}

// BenchmarkSampledVsUnsampled 采样 vs 未采样对比
func BenchmarkSampledVsUnsampled(b *testing.B) {
 tests := []struct {
  name    string
  sampler trace.Sampler
 }{
  {
   name:    "AlwaysSample",
   sampler: trace.AlwaysSample(),
  },
  {
   name:    "NeverSample",
   sampler: trace.NeverSample(),
  },
  {
   name:    "TraceIDRatioBased-10%",
   sampler: trace.TraceIDRatioBased(0.1),
  },
 }

 for _, tt := range tests {
  b.Run(tt.name, func(b *testing.B) {
   tp := trace.NewTracerProvider(
    trace.WithSampler(tt.sampler),
    trace.WithSpanProcessor(tracetest.NewSpanRecorder()),
   )
   otel.SetTracerProvider(tp)
   defer tp.Shutdown(context.Background())

   tracer := tp.Tracer("benchmark")
   ctx := context.Background()

   b.ResetTimer()
   b.ReportAllocs()

   for i := 0; i < b.N; i++ {
    _, span := tracer.Start(ctx, "benchmark-span")
    span.End()
   }
  })
 }
}

// BenchmarkConcurrentSpans 并发 Span 创建
func BenchmarkConcurrentSpans(b *testing.B) {
 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(tracetest.NewSpanRecorder()),
 )
 otel.SetTracerProvider(tp)
 defer tp.Shutdown(context.Background())

 tracer := tp.Tracer("benchmark")
 ctx := context.Background()

 b.ResetTimer()
 b.ReportAllocs()

 b.RunParallel(func(pb *testing.PB) {
  for pb.Next() {
   _, span := tracer.Start(ctx, "concurrent-span")
   span.End()
  }
 })
}

// BenchmarkAttributeCreation 属性创建基准测试
func BenchmarkAttributeCreation(b *testing.B) {
 tests := []struct {
  name  string
  count int
 }{
  {"1-attr", 1},
  {"5-attrs", 5},
  {"10-attrs", 10},
  {"20-attrs", 20},
 }

 for _, tt := range tests {
  b.Run(tt.name, func(b *testing.B) {
   b.ReportAllocs()

   for i := 0; i < b.N; i++ {
    attrs := make([]attribute.KeyValue, 0, tt.count)
    for j := 0; j < tt.count; j++ {
     attrs = append(attrs, attribute.Int("key", j))
    }
    _ = attrs
   }
  })
 }
}

// BenchmarkMetricRecording Metric 记录基准测试
func BenchmarkMetricRecording(b *testing.B) {
 meter := otel.Meter("benchmark")
 
 counter, _ := meter.Int64Counter("test.counter")
 histogram, _ := meter.Float64Histogram("test.histogram")

 ctx := context.Background()
 attrs := metric.WithAttributes(
  attribute.String("key", "value"),
 )

 b.Run("Counter", func(b *testing.B) {
  b.ReportAllocs()
  for i := 0; i < b.N; i++ {
   counter.Add(ctx, 1, attrs)
  }
 })

 b.Run("Histogram", func(b *testing.B) {
  b.ReportAllocs()
  for i := 0; i < b.N; i++ {
   histogram.Record(ctx, float64(i), attrs)
  }
 })
}
```

### 导出器基准测试

```go
package benchmark

import (
 "context"
 "testing"

 "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
 "go.opentelemetry.io/otel/sdk/trace"
 "go.opentelemetry.io/otel/sdk/trace/tracetest"
)

// BenchmarkBatchExport 批量导出基准测试
func BenchmarkBatchExport(b *testing.B) {
 tests := []struct {
  name      string
  batchSize int
 }{
  {"batch-100", 100},
  {"batch-500", 500},
  {"batch-1000", 1000},
 }

 for _, tt := range tests {
  b.Run(tt.name, func(b *testing.B) {
   // 创建测试导出器
   exporter := tracetest.NewInMemoryExporter()
   
   // 创建 spans
   spans := make([]trace.ReadOnlySpan, tt.batchSize)
   for i := 0; i < tt.batchSize; i++ {
    spans[i] = createTestSpan()
   }

   ctx := context.Background()

   b.ResetTimer()
   b.ReportAllocs()

   for i := 0; i < b.N; i++ {
    _ = exporter.ExportSpans(ctx, spans)
   }
  })
 }
}

// BenchmarkExporterTypes 不同导出器类型对比
func BenchmarkExporterTypes(b *testing.B) {
 b.Run("InMemory", func(b *testing.B) {
  exporter := tracetest.NewInMemoryExporter()
  benchmarkExporter(b, exporter)
 })

 // 注意: 这需要运行的 OTLP Collector
 // b.Run("OTLP-gRPC", func(b *testing.B) {
 //     exporter, _ := otlptracegrpc.New(context.Background())
 //     benchmarkExporter(b, exporter)
 // })
}

func benchmarkExporter(b *testing.B, exporter trace.SpanExporter) {
 spans := []trace.ReadOnlySpan{createTestSpan()}
 ctx := context.Background()

 b.ResetTimer()
 b.ReportAllocs()

 for i := 0; i < b.N; i++ {
  _ = exporter.ExportSpans(ctx, spans)
 }
}

func createTestSpan() trace.ReadOnlySpan {
 // 创建测试 span
 // 实际实现需要创建一个有效的 ReadOnlySpan
 return nil
}
```

---

## 性能分析

### CPU Profile

```go
package profiling

import (
 "context"
 "os"
 "runtime/pprof"
 "testing"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/sdk/trace"
 "go.opentelemetry.io/otel/sdk/trace/tracetest"
)

// TestWithCPUProfile CPU 性能分析
func TestWithCPUProfile(t *testing.T) {
 if testing.Short() {
  t.Skip("skipping profile test in short mode")
 }

 // 创建 CPU profile 文件
 f, err := os.Create("cpu.prof")
 if err != nil {
  t.Fatal(err)
 }
 defer f.Close()

 // 开始 CPU profiling
 if err := pprof.StartCPUProfile(f); err != nil {
  t.Fatal(err)
 }
 defer pprof.StopCPUProfile()

 // 设置追踪
 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(tracetest.NewSpanRecorder()),
 )
 otel.SetTracerProvider(tp)
 defer tp.Shutdown(context.Background())

 tracer := tp.Tracer("profile")
 ctx := context.Background()

 // 执行大量操作
 for i := 0; i < 100000; i++ {
  _, span := tracer.Start(ctx, "operation")
  span.End()
 }

 // CPU profile 将在 defer 时写入文件
 // 分析: go tool pprof cpu.prof
}

// TestWithMemoryProfile 内存性能分析
func TestWithMemoryProfile(t *testing.T) {
 if testing.Short() {
  t.Skip("skipping profile test in short mode")
 }

 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(tracetest.NewSpanRecorder()),
 )
 otel.SetTracerProvider(tp)
 defer tp.Shutdown(context.Background())

 tracer := tp.Tracer("profile")
 ctx := context.Background()

 // 执行操作
 for i := 0; i < 100000; i++ {
  _, span := tracer.Start(ctx, "operation")
  span.End()
 }

 // 写入内存 profile
 f, err := os.Create("mem.prof")
 if err != nil {
  t.Fatal(err)
 }
 defer f.Close()

 if err := pprof.WriteHeapProfile(f); err != nil {
  t.Fatal(err)
 }

 // 分析: go tool pprof mem.prof
}
```

### 性能报告

```bash
# CPU Profile
go test -cpuprofile=cpu.prof -bench=.
go tool pprof cpu.prof

# Memory Profile
go test -memprofile=mem.prof -bench=.
go tool pprof mem.prof

# Benchmark with Memory Stats
go test -bench=. -benchmem

# Trace
go test -trace=trace.out
go tool trace trace.out

# 示例输出:
# BenchmarkSpanCreation-8           1000000    1234 ns/op    256 B/op    8 allocs/op
#                                   ^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^   ^^^^^^^^^^^^^
#                                   iterations  ns/operation  bytes/op    allocs/op
```

---

## Mock 和 Stub

### Mock Exporter

```go
package mocking

import (
 "context"
 "sync"

 "go.opentelemetry.io/otel/sdk/trace"
)

// MockExporter Mock 导出器
type MockExporter struct {
 mu    sync.Mutex
 spans []trace.ReadOnlySpan
 
 // 控制行为
 shouldFail bool
 failError  error
}

// NewMockExporter 创建 Mock 导出器
func NewMockExporter() *MockExporter {
 return &MockExporter{
  spans: make([]trace.ReadOnlySpan, 0),
 }
}

// ExportSpans 导出 spans
func (m *MockExporter) ExportSpans(ctx context.Context, spans []trace.ReadOnlySpan) error {
 if m.shouldFail {
  return m.failError
 }

 m.mu.Lock()
 defer m.mu.Unlock()

 m.spans = append(m.spans, spans...)
 return nil
}

// Shutdown 关闭
func (m *MockExporter) Shutdown(ctx context.Context) error {
 return nil
}

// GetSpans 获取收集的 spans
func (m *MockExporter) GetSpans() []trace.ReadOnlySpan {
 m.mu.Lock()
 defer m.mu.Unlock()

 // 返回副本
 result := make([]trace.ReadOnlySpan, len(m.spans))
 copy(result, m.spans)
 return result
}

// Reset 重置
func (m *MockExporter) Reset() {
 m.mu.Lock()
 defer m.mu.Unlock()

 m.spans = m.spans[:0]
}

// SetShouldFail 设置失败行为
func (m *MockExporter) SetShouldFail(fail bool, err error) {
 m.shouldFail = fail
 m.failError = err
}

// 使用示例
func TestWithMockExporter(t *testing.T) {
 mockExporter := NewMockExporter()
 
 tp := trace.NewTracerProvider(
  trace.WithSyncer(mockExporter),
 )
 otel.SetTracerProvider(tp)
 defer tp.Shutdown(context.Background())

 tracer := tp.Tracer("test")
 ctx := context.Background()

 _, span := tracer.Start(ctx, "test-operation")
 span.End()

 // 验证
 spans := mockExporter.GetSpans()
 if len(spans) != 1 {
  t.Errorf("expected 1 span, got %d", len(spans))
 }
}
```

---

## 测试最佳实践

### 1. 测试隔离

```go
// ✅ 好: 每个测试使用独立的 TracerProvider
func TestIsolated(t *testing.T) {
 tp := trace.NewTracerProvider(/* ... */)
 defer tp.Shutdown(context.Background())
 
 // 不设置全局，而是直接使用
 tracer := tp.Tracer("test")
 // ...
}

// ❌ 坏: 测试之间共享全局状态
var globalTP *trace.TracerProvider

func TestNotIsolated(t *testing.T) {
 if globalTP == nil {
  globalTP = trace.NewTracerProvider(/* ... */)
 }
 // 测试可能相互影响
}
```

### 2. 清理资源

```go
func TestWithCleanup(t *testing.T) {
 tp := trace.NewTracerProvider(/* ... */)
 
 // 使用 t.Cleanup 确保清理
 t.Cleanup(func() {
  ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
  defer cancel()
  
  if err := tp.Shutdown(ctx); err != nil {
   t.Logf("warning: shutdown failed: %v", err)
  }
 })
 
 // 测试代码...
}
```

### 3. 并发测试

```go
func TestConcurrent(t *testing.T) {
 tp, spanRecorder := setupTest(t)
 
 tracer := tp.Tracer("test")
 ctx := context.Background()

 // 并发创建 spans
 var wg sync.WaitGroup
 numGoroutines := 100
 
 for i := 0; i < numGoroutines; i++ {
  wg.Add(1)
  go func(id int) {
   defer wg.Done()
   
   _, span := tracer.Start(ctx, fmt.Sprintf("span-%d", id))
   span.End()
  }(i)
 }
 
 wg.Wait()
 
 // 验证
 spans := spanRecorder.Ended()
 if len(spans) != numGoroutines {
  t.Errorf("expected %d spans, got %d", numGoroutines, len(spans))
 }
}
```

### 4. 超时控制

```go
func TestWithTimeout(t *testing.T) {
 ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
 defer cancel()

 tp := trace.NewTracerProvider(/* ... */)
 defer tp.Shutdown(ctx)

 // 测试代码...
 
 // 如果超过 5 秒，测试会因为 context 取消而失败
}
```

这个文档提供了全面的Go测试指南，包括：

1. **单元测试** - 基础测试、表驱动测试
2. **集成测试** - HTTP、数据库集成
3. **基准测试** - Span创建、并发、导出器对比
4. **性能分析** - CPU/Memory Profiling
5. **Mock/Stub** - 测试替身
6. **最佳实践** - 隔离、清理、并发、超时

让我继续完成剩余的任务...
