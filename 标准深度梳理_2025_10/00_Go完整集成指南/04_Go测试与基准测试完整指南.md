# Go æµ‹è¯•ä¸åŸºå‡†æµ‹è¯•å®Œæ•´æŒ‡å—

> **Go ç‰ˆæœ¬**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0+  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ8æ—¥

---

## ğŸ“‹ ç›®å½•

- [Go æµ‹è¯•ä¸åŸºå‡†æµ‹è¯•å®Œæ•´æŒ‡å—](#go-æµ‹è¯•ä¸åŸºå‡†æµ‹è¯•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [å•å…ƒæµ‹è¯•](#å•å…ƒæµ‹è¯•)
    - [åŸºç¡€æµ‹è¯•è®¾ç½®](#åŸºç¡€æµ‹è¯•è®¾ç½®)
    - [è¡¨é©±åŠ¨æµ‹è¯•](#è¡¨é©±åŠ¨æµ‹è¯•)
  - [é›†æˆæµ‹è¯•](#é›†æˆæµ‹è¯•)
    - [HTTP æœåŠ¡å™¨æµ‹è¯•](#http-æœåŠ¡å™¨æµ‹è¯•)
    - [æ•°æ®åº“æµ‹è¯•](#æ•°æ®åº“æµ‹è¯•)
  - [åŸºå‡†æµ‹è¯•](#åŸºå‡†æµ‹è¯•)
    - [Span åˆ›å»ºåŸºå‡†æµ‹è¯•](#span-åˆ›å»ºåŸºå‡†æµ‹è¯•)
    - [å¯¼å‡ºå™¨åŸºå‡†æµ‹è¯•](#å¯¼å‡ºå™¨åŸºå‡†æµ‹è¯•)
  - [æ€§èƒ½åˆ†æ](#æ€§èƒ½åˆ†æ)
    - [CPU Profile](#cpu-profile)
    - [æ€§èƒ½æŠ¥å‘Š](#æ€§èƒ½æŠ¥å‘Š)
  - [Mock å’Œ Stub](#mock-å’Œ-stub)
    - [Mock Exporter](#mock-exporter)
  - [æµ‹è¯•æœ€ä½³å®è·µ](#æµ‹è¯•æœ€ä½³å®è·µ)
    - [1. æµ‹è¯•éš”ç¦»](#1-æµ‹è¯•éš”ç¦»)
    - [2. æ¸…ç†èµ„æº](#2-æ¸…ç†èµ„æº)
    - [3. å¹¶å‘æµ‹è¯•](#3-å¹¶å‘æµ‹è¯•)
    - [4. è¶…æ—¶æ§åˆ¶](#4-è¶…æ—¶æ§åˆ¶)

---

## å•å…ƒæµ‹è¯•

### åŸºç¡€æµ‹è¯•è®¾ç½®

```go
package testing

import (
 "context"
 "testing"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/sdk/trace"
 "go.opentelemetry.io/otel/sdk/trace/tracetest"
)

// setupTest æµ‹è¯•è®¾ç½®
func setupTest(t *testing.T) (*trace.TracerProvider, *tracetest.SpanRecorder) {
 // åˆ›å»º Span Recorder
 spanRecorder := tracetest.NewSpanRecorder()
 
 // åˆ›å»º TracerProvider
 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(spanRecorder),
 )
 
 // è®¾ç½®å…¨å±€ TracerProvider
 otel.SetTracerProvider(tp)
 
 // æ¸…ç†
 t.Cleanup(func() {
  _ = tp.Shutdown(context.Background())
 })
 
 return tp, spanRecorder
}

// TestBasicTracing åŸºæœ¬è¿½è¸ªæµ‹è¯•
func TestBasicTracing(t *testing.T) {
 tp, spanRecorder := setupTest(t)
 
 tracer := tp.Tracer("test-tracer")
 ctx := context.Background()
 
 // åˆ›å»º span
 _, span := tracer.Start(ctx, "test-operation")
 span.End()
 
 // éªŒè¯ spans
 spans := spanRecorder.Ended()
 if len(spans) != 1 {
  t.Fatalf("expected 1 span, got %d", len(spans))
 }
 
 // éªŒè¯ span åç§°
 if spans[0].Name() != "test-operation" {
  t.Errorf("expected span name 'test-operation', got '%s'", spans[0].Name())
 }
}

// TestSpanAttributes æµ‹è¯• Span å±æ€§
func TestSpanAttributes(t *testing.T) {
 tp, spanRecorder := setupTest(t)
 
 tracer := tp.Tracer("test-tracer")
 ctx := context.Background()
 
 // åˆ›å»ºå¸¦å±æ€§çš„ span
 _, span := tracer.Start(ctx, "test-operation")
 span.SetAttributes(
  attribute.String("key1", "value1"),
  attribute.Int("key2", 123),
 )
 span.End()
 
 // éªŒè¯å±æ€§
 spans := spanRecorder.Ended()
 if len(spans) != 1 {
  t.Fatalf("expected 1 span, got %d", len(spans))
 }
 
 attrs := spans[0].Attributes()
 
 // éªŒè¯å±æ€§æ•°é‡
 if len(attrs) != 2 {
  t.Errorf("expected 2 attributes, got %d", len(attrs))
 }
 
 // éªŒè¯å±æ€§å€¼
 for _, attr := range attrs {
  switch attr.Key {
  case "key1":
   if attr.Value.AsString() != "value1" {
    t.Errorf("expected key1='value1', got '%s'", attr.Value.AsString())
   }
  case "key2":
   if attr.Value.AsInt64() != 123 {
    t.Errorf("expected key2=123, got %d", attr.Value.AsInt64())
   }
  default:
   t.Errorf("unexpected attribute: %s", attr.Key)
  }
 }
}

// TestNestedSpans æµ‹è¯•åµŒå¥— Spans
func TestNestedSpans(t *testing.T) {
 tp, spanRecorder := setupTest(t)
 
 tracer := tp.Tracer("test-tracer")
 ctx := context.Background()
 
 // çˆ¶ span
 ctx, parentSpan := tracer.Start(ctx, "parent")
 
 // å­ span
 _, childSpan := tracer.Start(ctx, "child")
 childSpan.End()
 
 parentSpan.End()
 
 // éªŒè¯ spans
 spans := spanRecorder.Ended()
 if len(spans) != 2 {
  t.Fatalf("expected 2 spans, got %d", len(spans))
 }
 
 // éªŒè¯çˆ¶å­å…³ç³»
 childSpanData := spans[0]
 parentSpanData := spans[1]
 
 if childSpanData.Parent().SpanID() != parentSpanData.SpanContext().SpanID() {
  t.Error("child span's parent ID doesn't match parent span's ID")
 }
}

// TestSpanError æµ‹è¯•é”™è¯¯è®°å½•
func TestSpanError(t *testing.T) {
 tp, spanRecorder := setupTest(t)
 
 tracer := tp.Tracer("test-tracer")
 ctx := context.Background()
 
 _, span := tracer.Start(ctx, "error-operation")
 
 // è®°å½•é”™è¯¯
 err := errors.New("test error")
 span.RecordError(err)
 span.SetStatus(codes.Error, err.Error())
 span.End()
 
 // éªŒè¯é”™è¯¯
 spans := spanRecorder.Ended()
 if len(spans) != 1 {
  t.Fatalf("expected 1 span, got %d", len(spans))
 }
 
 spanData := spans[0]
 
 // éªŒè¯çŠ¶æ€
 if spanData.Status().Code != codes.Error {
  t.Errorf("expected Error status, got %v", spanData.Status().Code)
 }
 
 // éªŒè¯äº‹ä»¶
 events := spanData.Events()
 foundError := false
 for _, event := range events {
  if event.Name == "exception" {
   foundError = true
   break
  }
 }
 
 if !foundError {
  t.Error("expected to find error event")
 }
}
```

### è¡¨é©±åŠ¨æµ‹è¯•

```go
package testing

import (
 "context"
 "testing"

 "go.opentelemetry.io/otel/attribute"
)

// TestSpanCreation è¡¨é©±åŠ¨æµ‹è¯•
func TestSpanCreation(t *testing.T) {
 tests := []struct {
  name       string
  spanName   string
  attributes []attribute.KeyValue
  wantErr    bool
 }{
  {
   name:     "simple span",
   spanName: "test-span",
   attributes: []attribute.KeyValue{
    attribute.String("key", "value"),
   },
   wantErr: false,
  },
  {
   name:       "span with multiple attributes",
   spanName:   "multi-attr-span",
   attributes: []attribute.KeyValue{
    attribute.String("string", "value"),
    attribute.Int("int", 123),
    attribute.Bool("bool", true),
   },
   wantErr: false,
  },
  {
   name:       "span with no attributes",
   spanName:   "no-attr-span",
   attributes: []attribute.KeyValue{},
   wantErr:    false,
  },
 }

 for _, tt := range tests {
  t.Run(tt.name, func(t *testing.T) {
   tp, spanRecorder := setupTest(t)
   
   tracer := tp.Tracer("test-tracer")
   ctx := context.Background()
   
   _, span := tracer.Start(ctx, tt.spanName)
   span.SetAttributes(tt.attributes...)
   span.End()
   
   spans := spanRecorder.Ended()
   if len(spans) != 1 {
    t.Fatalf("expected 1 span, got %d", len(spans))
   }
   
   spanData := spans[0]
   
   // éªŒè¯ span åç§°
   if spanData.Name() != tt.spanName {
    t.Errorf("expected span name '%s', got '%s'", tt.spanName, spanData.Name())
   }
   
   // éªŒè¯å±æ€§æ•°é‡
   attrs := spanData.Attributes()
   if len(attrs) != len(tt.attributes) {
    t.Errorf("expected %d attributes, got %d", len(tt.attributes), len(attrs))
   }
  })
 }
}
```

---

## é›†æˆæµ‹è¯•

### HTTP æœåŠ¡å™¨æµ‹è¯•

```go
package integration

import (
 "context"
 "net/http"
 "net/http/httptest"
 "testing"

 "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/sdk/trace"
 "go.opentelemetry.io/otel/sdk/trace/tracetest"
)

// TestHTTPHandler æµ‹è¯• HTTP å¤„ç†å™¨
func TestHTTPHandler(t *testing.T) {
 // è®¾ç½®è¿½è¸ª
 spanRecorder := tracetest.NewSpanRecorder()
 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(spanRecorder),
 )
 otel.SetTracerProvider(tp)
 defer tp.Shutdown(context.Background())

 // åˆ›å»ºå¤„ç†å™¨
 handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  w.WriteHeader(http.StatusOK)
  w.Write([]byte("OK"))
 })

 // åŒ…è£… otelhttp ä¸­é—´ä»¶
 wrappedHandler := otelhttp.NewHandler(handler, "test-handler")

 // åˆ›å»ºæµ‹è¯•æœåŠ¡å™¨
 server := httptest.NewServer(wrappedHandler)
 defer server.Close()

 // å‘é€è¯·æ±‚
 resp, err := http.Get(server.URL)
 if err != nil {
  t.Fatalf("failed to send request: %v", err)
 }
 defer resp.Body.Close()

 // éªŒè¯å“åº”
 if resp.StatusCode != http.StatusOK {
  t.Errorf("expected status 200, got %d", resp.StatusCode)
 }

 // éªŒè¯è¿½è¸ª
 spans := spanRecorder.Ended()
 if len(spans) == 0 {
  t.Error("expected at least one span")
 }

 // éªŒè¯ span åç§°å’Œç±»å‹
 foundServerSpan := false
 for _, span := range spans {
  if span.SpanKind() == trace.SpanKindServer {
   foundServerSpan = true
   break
  }
 }

 if !foundServerSpan {
  t.Error("expected to find server span")
 }
}

// TestHTTPClientServer æµ‹è¯•å®¢æˆ·ç«¯-æœåŠ¡å™¨è¿½è¸ª
func TestHTTPClientServer(t *testing.T) {
 spanRecorder := tracetest.NewSpanRecorder()
 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(spanRecorder),
 )
 otel.SetTracerProvider(tp)
 defer tp.Shutdown(context.Background())

 // åˆ›å»ºæœåŠ¡å™¨
 serverHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  w.WriteHeader(http.StatusOK)
  w.Write([]byte("OK"))
 })
 wrappedHandler := otelhttp.NewHandler(serverHandler, "server")
 server := httptest.NewServer(wrappedHandler)
 defer server.Close()

 // åˆ›å»ºå®¢æˆ·ç«¯
 client := &http.Client{
  Transport: otelhttp.NewTransport(http.DefaultTransport),
 }

 // å‘é€è¯·æ±‚
 req, _ := http.NewRequestWithContext(context.Background(), "GET", server.URL, nil)
 resp, err := client.Do(req)
 if err != nil {
  t.Fatalf("failed to send request: %v", err)
 }
 defer resp.Body.Close()

 // ç­‰å¾… spans å®Œæˆ
 time.Sleep(100 * time.Millisecond)

 // éªŒè¯è¿½è¸ª
 spans := spanRecorder.Ended()
 
 // åº”è¯¥æœ‰å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ä¸¤ä¸ª spans
 if len(spans) < 2 {
  t.Errorf("expected at least 2 spans, got %d", len(spans))
 }

 // éªŒè¯ span ç±»å‹
 hasClient := false
 hasServer := false
 for _, span := range spans {
  switch span.SpanKind() {
  case trace.SpanKindClient:
   hasClient = true
  case trace.SpanKindServer:
   hasServer = true
  }
 }

 if !hasClient {
  t.Error("expected to find client span")
 }
 if !hasServer {
  t.Error("expected to find server span")
 }
}
```

### æ•°æ®åº“æµ‹è¯•

```go
package integration

import (
 "context"
 "database/sql"
 "testing"

 "go.opentelemetry.io/contrib/instrumentation/database/sql/otelsql"
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/sdk/trace"
 "go.opentelemetry.io/otel/sdk/trace/tracetest"
 semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// TestDatabaseQuery æµ‹è¯•æ•°æ®åº“æŸ¥è¯¢è¿½è¸ª
func TestDatabaseQuery(t *testing.T) {
 spanRecorder := tracetest.NewSpanRecorder()
 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(spanRecorder),
 )
 otel.SetTracerProvider(tp)
 defer tp.Shutdown(context.Background())

 // æ³¨å†Œ otelsql é©±åŠ¨
 driverName, err := otelsql.Register("sqlite3",
  otelsql.WithAttributes(
   semconv.DBSystemSqlite,
  ),
 )
 if err != nil {
  t.Fatalf("failed to register driver: %v", err)
 }

 // æ‰“å¼€æ•°æ®åº“
 db, err := sql.Open(driverName, ":memory:")
 if err != nil {
  t.Fatalf("failed to open database: %v", err)
 }
 defer db.Close()

 // æ‰§è¡ŒæŸ¥è¯¢
 ctx := context.Background()
 rows, err := db.QueryContext(ctx, "SELECT 1")
 if err != nil {
  t.Fatalf("query failed: %v", err)
 }
 rows.Close()

 // éªŒè¯è¿½è¸ª
 spans := spanRecorder.Ended()
 if len(spans) == 0 {
  t.Error("expected at least one span")
 }

 // éªŒè¯ span å±æ€§
 for _, span := range spans {
  attrs := span.Attributes()
  foundDBSystem := false
  
  for _, attr := range attrs {
   if string(attr.Key) == string(semconv.DBSystemKey) {
    foundDBSystem = true
    break
   }
  }
  
  if !foundDBSystem {
   t.Error("expected to find db.system attribute")
  }
 }
}
```

---

## åŸºå‡†æµ‹è¯•

### Span åˆ›å»ºåŸºå‡†æµ‹è¯•

```go
package benchmark

import (
 "context"
 "testing"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/sdk/trace"
 "go.opentelemetry.io/otel/sdk/trace/tracetest"
)

// BenchmarkSpanCreation Span åˆ›å»ºåŸºå‡†æµ‹è¯•
func BenchmarkSpanCreation(b *testing.B) {
 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(tracetest.NewSpanRecorder()),
 )
 otel.SetTracerProvider(tp)
 defer tp.Shutdown(context.Background())

 tracer := tp.Tracer("benchmark")
 ctx := context.Background()

 b.ResetTimer()
 b.ReportAllocs()

 for i := 0; i < b.N; i++ {
  _, span := tracer.Start(ctx, "benchmark-span")
  span.End()
 }
}

// BenchmarkSpanWithAttributes å¸¦å±æ€§çš„ Span åŸºå‡†æµ‹è¯•
func BenchmarkSpanWithAttributes(b *testing.B) {
 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(tracetest.NewSpanRecorder()),
 )
 otel.SetTracerProvider(tp)
 defer tp.Shutdown(context.Background())

 tracer := tp.Tracer("benchmark")
 ctx := context.Background()

 attrs := []attribute.KeyValue{
  attribute.String("key1", "value1"),
  attribute.Int("key2", 123),
  attribute.Bool("key3", true),
 }

 b.ResetTimer()
 b.ReportAllocs()

 for i := 0; i < b.N; i++ {
  _, span := tracer.Start(ctx, "benchmark-span")
  span.SetAttributes(attrs...)
  span.End()
 }
}

// BenchmarkNestedSpans åµŒå¥— Span åŸºå‡†æµ‹è¯•
func BenchmarkNestedSpans(b *testing.B) {
 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(tracetest.NewSpanRecorder()),
 )
 otel.SetTracerProvider(tp)
 defer tp.Shutdown(context.Background())

 tracer := tp.Tracer("benchmark")
 ctx := context.Background()

 b.ResetTimer()
 b.ReportAllocs()

 for i := 0; i < b.N; i++ {
  ctx, parentSpan := tracer.Start(ctx, "parent")
  
  _, childSpan1 := tracer.Start(ctx, "child1")
  childSpan1.End()
  
  _, childSpan2 := tracer.Start(ctx, "child2")
  childSpan2.End()
  
  parentSpan.End()
 }
}

// BenchmarkSampledVsUnsampled é‡‡æ · vs æœªé‡‡æ ·å¯¹æ¯”
func BenchmarkSampledVsUnsampled(b *testing.B) {
 tests := []struct {
  name    string
  sampler trace.Sampler
 }{
  {
   name:    "AlwaysSample",
   sampler: trace.AlwaysSample(),
  },
  {
   name:    "NeverSample",
   sampler: trace.NeverSample(),
  },
  {
   name:    "TraceIDRatioBased-10%",
   sampler: trace.TraceIDRatioBased(0.1),
  },
 }

 for _, tt := range tests {
  b.Run(tt.name, func(b *testing.B) {
   tp := trace.NewTracerProvider(
    trace.WithSampler(tt.sampler),
    trace.WithSpanProcessor(tracetest.NewSpanRecorder()),
   )
   otel.SetTracerProvider(tp)
   defer tp.Shutdown(context.Background())

   tracer := tp.Tracer("benchmark")
   ctx := context.Background()

   b.ResetTimer()
   b.ReportAllocs()

   for i := 0; i < b.N; i++ {
    _, span := tracer.Start(ctx, "benchmark-span")
    span.End()
   }
  })
 }
}

// BenchmarkConcurrentSpans å¹¶å‘ Span åˆ›å»º
func BenchmarkConcurrentSpans(b *testing.B) {
 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(tracetest.NewSpanRecorder()),
 )
 otel.SetTracerProvider(tp)
 defer tp.Shutdown(context.Background())

 tracer := tp.Tracer("benchmark")
 ctx := context.Background()

 b.ResetTimer()
 b.ReportAllocs()

 b.RunParallel(func(pb *testing.PB) {
  for pb.Next() {
   _, span := tracer.Start(ctx, "concurrent-span")
   span.End()
  }
 })
}

// BenchmarkAttributeCreation å±æ€§åˆ›å»ºåŸºå‡†æµ‹è¯•
func BenchmarkAttributeCreation(b *testing.B) {
 tests := []struct {
  name  string
  count int
 }{
  {"1-attr", 1},
  {"5-attrs", 5},
  {"10-attrs", 10},
  {"20-attrs", 20},
 }

 for _, tt := range tests {
  b.Run(tt.name, func(b *testing.B) {
   b.ReportAllocs()

   for i := 0; i < b.N; i++ {
    attrs := make([]attribute.KeyValue, 0, tt.count)
    for j := 0; j < tt.count; j++ {
     attrs = append(attrs, attribute.Int("key", j))
    }
    _ = attrs
   }
  })
 }
}

// BenchmarkMetricRecording Metric è®°å½•åŸºå‡†æµ‹è¯•
func BenchmarkMetricRecording(b *testing.B) {
 meter := otel.Meter("benchmark")
 
 counter, _ := meter.Int64Counter("test.counter")
 histogram, _ := meter.Float64Histogram("test.histogram")

 ctx := context.Background()
 attrs := metric.WithAttributes(
  attribute.String("key", "value"),
 )

 b.Run("Counter", func(b *testing.B) {
  b.ReportAllocs()
  for i := 0; i < b.N; i++ {
   counter.Add(ctx, 1, attrs)
  }
 })

 b.Run("Histogram", func(b *testing.B) {
  b.ReportAllocs()
  for i := 0; i < b.N; i++ {
   histogram.Record(ctx, float64(i), attrs)
  }
 })
}
```

### å¯¼å‡ºå™¨åŸºå‡†æµ‹è¯•

```go
package benchmark

import (
 "context"
 "testing"

 "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
 "go.opentelemetry.io/otel/sdk/trace"
 "go.opentelemetry.io/otel/sdk/trace/tracetest"
)

// BenchmarkBatchExport æ‰¹é‡å¯¼å‡ºåŸºå‡†æµ‹è¯•
func BenchmarkBatchExport(b *testing.B) {
 tests := []struct {
  name      string
  batchSize int
 }{
  {"batch-100", 100},
  {"batch-500", 500},
  {"batch-1000", 1000},
 }

 for _, tt := range tests {
  b.Run(tt.name, func(b *testing.B) {
   // åˆ›å»ºæµ‹è¯•å¯¼å‡ºå™¨
   exporter := tracetest.NewInMemoryExporter()
   
   // åˆ›å»º spans
   spans := make([]trace.ReadOnlySpan, tt.batchSize)
   for i := 0; i < tt.batchSize; i++ {
    spans[i] = createTestSpan()
   }

   ctx := context.Background()

   b.ResetTimer()
   b.ReportAllocs()

   for i := 0; i < b.N; i++ {
    _ = exporter.ExportSpans(ctx, spans)
   }
  })
 }
}

// BenchmarkExporterTypes ä¸åŒå¯¼å‡ºå™¨ç±»å‹å¯¹æ¯”
func BenchmarkExporterTypes(b *testing.B) {
 b.Run("InMemory", func(b *testing.B) {
  exporter := tracetest.NewInMemoryExporter()
  benchmarkExporter(b, exporter)
 })

 // æ³¨æ„: è¿™éœ€è¦è¿è¡Œçš„ OTLP Collector
 // b.Run("OTLP-gRPC", func(b *testing.B) {
 //     exporter, _ := otlptracegrpc.New(context.Background())
 //     benchmarkExporter(b, exporter)
 // })
}

func benchmarkExporter(b *testing.B, exporter trace.SpanExporter) {
 spans := []trace.ReadOnlySpan{createTestSpan()}
 ctx := context.Background()

 b.ResetTimer()
 b.ReportAllocs()

 for i := 0; i < b.N; i++ {
  _ = exporter.ExportSpans(ctx, spans)
 }
}

func createTestSpan() trace.ReadOnlySpan {
 // åˆ›å»ºæµ‹è¯• span
 // å®é™…å®ç°éœ€è¦åˆ›å»ºä¸€ä¸ªæœ‰æ•ˆçš„ ReadOnlySpan
 return nil
}
```

---

## æ€§èƒ½åˆ†æ

### CPU Profile

```go
package profiling

import (
 "context"
 "os"
 "runtime/pprof"
 "testing"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/sdk/trace"
 "go.opentelemetry.io/otel/sdk/trace/tracetest"
)

// TestWithCPUProfile CPU æ€§èƒ½åˆ†æ
func TestWithCPUProfile(t *testing.T) {
 if testing.Short() {
  t.Skip("skipping profile test in short mode")
 }

 // åˆ›å»º CPU profile æ–‡ä»¶
 f, err := os.Create("cpu.prof")
 if err != nil {
  t.Fatal(err)
 }
 defer f.Close()

 // å¼€å§‹ CPU profiling
 if err := pprof.StartCPUProfile(f); err != nil {
  t.Fatal(err)
 }
 defer pprof.StopCPUProfile()

 // è®¾ç½®è¿½è¸ª
 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(tracetest.NewSpanRecorder()),
 )
 otel.SetTracerProvider(tp)
 defer tp.Shutdown(context.Background())

 tracer := tp.Tracer("profile")
 ctx := context.Background()

 // æ‰§è¡Œå¤§é‡æ“ä½œ
 for i := 0; i < 100000; i++ {
  _, span := tracer.Start(ctx, "operation")
  span.End()
 }

 // CPU profile å°†åœ¨ defer æ—¶å†™å…¥æ–‡ä»¶
 // åˆ†æ: go tool pprof cpu.prof
}

// TestWithMemoryProfile å†…å­˜æ€§èƒ½åˆ†æ
func TestWithMemoryProfile(t *testing.T) {
 if testing.Short() {
  t.Skip("skipping profile test in short mode")
 }

 tp := trace.NewTracerProvider(
  trace.WithSpanProcessor(tracetest.NewSpanRecorder()),
 )
 otel.SetTracerProvider(tp)
 defer tp.Shutdown(context.Background())

 tracer := tp.Tracer("profile")
 ctx := context.Background()

 // æ‰§è¡Œæ“ä½œ
 for i := 0; i < 100000; i++ {
  _, span := tracer.Start(ctx, "operation")
  span.End()
 }

 // å†™å…¥å†…å­˜ profile
 f, err := os.Create("mem.prof")
 if err != nil {
  t.Fatal(err)
 }
 defer f.Close()

 if err := pprof.WriteHeapProfile(f); err != nil {
  t.Fatal(err)
 }

 // åˆ†æ: go tool pprof mem.prof
}
```

### æ€§èƒ½æŠ¥å‘Š

```bash
# CPU Profile
go test -cpuprofile=cpu.prof -bench=.
go tool pprof cpu.prof

# Memory Profile
go test -memprofile=mem.prof -bench=.
go tool pprof mem.prof

# Benchmark with Memory Stats
go test -bench=. -benchmem

# Trace
go test -trace=trace.out
go tool trace trace.out

# ç¤ºä¾‹è¾“å‡º:
# BenchmarkSpanCreation-8           1000000    1234 ns/op    256 B/op    8 allocs/op
#                                   ^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^   ^^^^^^^^^^^^^
#                                   iterations  ns/operation  bytes/op    allocs/op
```

---

## Mock å’Œ Stub

### Mock Exporter

```go
package mocking

import (
 "context"
 "sync"

 "go.opentelemetry.io/otel/sdk/trace"
)

// MockExporter Mock å¯¼å‡ºå™¨
type MockExporter struct {
 mu    sync.Mutex
 spans []trace.ReadOnlySpan
 
 // æ§åˆ¶è¡Œä¸º
 shouldFail bool
 failError  error
}

// NewMockExporter åˆ›å»º Mock å¯¼å‡ºå™¨
func NewMockExporter() *MockExporter {
 return &MockExporter{
  spans: make([]trace.ReadOnlySpan, 0),
 }
}

// ExportSpans å¯¼å‡º spans
func (m *MockExporter) ExportSpans(ctx context.Context, spans []trace.ReadOnlySpan) error {
 if m.shouldFail {
  return m.failError
 }

 m.mu.Lock()
 defer m.mu.Unlock()

 m.spans = append(m.spans, spans...)
 return nil
}

// Shutdown å…³é—­
func (m *MockExporter) Shutdown(ctx context.Context) error {
 return nil
}

// GetSpans è·å–æ”¶é›†çš„ spans
func (m *MockExporter) GetSpans() []trace.ReadOnlySpan {
 m.mu.Lock()
 defer m.mu.Unlock()

 // è¿”å›å‰¯æœ¬
 result := make([]trace.ReadOnlySpan, len(m.spans))
 copy(result, m.spans)
 return result
}

// Reset é‡ç½®
func (m *MockExporter) Reset() {
 m.mu.Lock()
 defer m.mu.Unlock()

 m.spans = m.spans[:0]
}

// SetShouldFail è®¾ç½®å¤±è´¥è¡Œä¸º
func (m *MockExporter) SetShouldFail(fail bool, err error) {
 m.shouldFail = fail
 m.failError = err
}

// ä½¿ç”¨ç¤ºä¾‹
func TestWithMockExporter(t *testing.T) {
 mockExporter := NewMockExporter()
 
 tp := trace.NewTracerProvider(
  trace.WithSyncer(mockExporter),
 )
 otel.SetTracerProvider(tp)
 defer tp.Shutdown(context.Background())

 tracer := tp.Tracer("test")
 ctx := context.Background()

 _, span := tracer.Start(ctx, "test-operation")
 span.End()

 // éªŒè¯
 spans := mockExporter.GetSpans()
 if len(spans) != 1 {
  t.Errorf("expected 1 span, got %d", len(spans))
 }
}
```

---

## æµ‹è¯•æœ€ä½³å®è·µ

### 1. æµ‹è¯•éš”ç¦»

```go
// âœ… å¥½: æ¯ä¸ªæµ‹è¯•ä½¿ç”¨ç‹¬ç«‹çš„ TracerProvider
func TestIsolated(t *testing.T) {
 tp := trace.NewTracerProvider(/* ... */)
 defer tp.Shutdown(context.Background())
 
 // ä¸è®¾ç½®å…¨å±€ï¼Œè€Œæ˜¯ç›´æ¥ä½¿ç”¨
 tracer := tp.Tracer("test")
 // ...
}

// âŒ å: æµ‹è¯•ä¹‹é—´å…±äº«å…¨å±€çŠ¶æ€
var globalTP *trace.TracerProvider

func TestNotIsolated(t *testing.T) {
 if globalTP == nil {
  globalTP = trace.NewTracerProvider(/* ... */)
 }
 // æµ‹è¯•å¯èƒ½ç›¸äº’å½±å“
}
```

### 2. æ¸…ç†èµ„æº

```go
func TestWithCleanup(t *testing.T) {
 tp := trace.NewTracerProvider(/* ... */)
 
 // ä½¿ç”¨ t.Cleanup ç¡®ä¿æ¸…ç†
 t.Cleanup(func() {
  ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
  defer cancel()
  
  if err := tp.Shutdown(ctx); err != nil {
   t.Logf("warning: shutdown failed: %v", err)
  }
 })
 
 // æµ‹è¯•ä»£ç ...
}
```

### 3. å¹¶å‘æµ‹è¯•

```go
func TestConcurrent(t *testing.T) {
 tp, spanRecorder := setupTest(t)
 
 tracer := tp.Tracer("test")
 ctx := context.Background()

 // å¹¶å‘åˆ›å»º spans
 var wg sync.WaitGroup
 numGoroutines := 100
 
 for i := 0; i < numGoroutines; i++ {
  wg.Add(1)
  go func(id int) {
   defer wg.Done()
   
   _, span := tracer.Start(ctx, fmt.Sprintf("span-%d", id))
   span.End()
  }(i)
 }
 
 wg.Wait()
 
 // éªŒè¯
 spans := spanRecorder.Ended()
 if len(spans) != numGoroutines {
  t.Errorf("expected %d spans, got %d", numGoroutines, len(spans))
 }
}
```

### 4. è¶…æ—¶æ§åˆ¶

```go
func TestWithTimeout(t *testing.T) {
 ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
 defer cancel()

 tp := trace.NewTracerProvider(/* ... */)
 defer tp.Shutdown(ctx)

 // æµ‹è¯•ä»£ç ...
 
 // å¦‚æœè¶…è¿‡ 5 ç§’ï¼Œæµ‹è¯•ä¼šå› ä¸º context å–æ¶ˆè€Œå¤±è´¥
}
```

è¿™ä¸ªæ–‡æ¡£æä¾›äº†å…¨é¢çš„Goæµ‹è¯•æŒ‡å—ï¼ŒåŒ…æ‹¬ï¼š

1. **å•å…ƒæµ‹è¯•** - åŸºç¡€æµ‹è¯•ã€è¡¨é©±åŠ¨æµ‹è¯•
2. **é›†æˆæµ‹è¯•** - HTTPã€æ•°æ®åº“é›†æˆ
3. **åŸºå‡†æµ‹è¯•** - Spanåˆ›å»ºã€å¹¶å‘ã€å¯¼å‡ºå™¨å¯¹æ¯”
4. **æ€§èƒ½åˆ†æ** - CPU/Memory Profiling
5. **Mock/Stub** - æµ‹è¯•æ›¿èº«
6. **æœ€ä½³å®è·µ** - éš”ç¦»ã€æ¸…ç†ã€å¹¶å‘ã€è¶…æ—¶

è®©æˆ‘ç»§ç»­å®Œæˆå‰©ä½™çš„ä»»åŠ¡...
