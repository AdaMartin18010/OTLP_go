# Go æµ‹è¯•ä¸å¯è§‚æµ‹æ€§æœ€ä½³å®è·µå®Œæ•´æŒ‡å—

## ğŸ“‹ ç›®å½•

- [Go æµ‹è¯•ä¸å¯è§‚æµ‹æ€§æœ€ä½³å®è·µå®Œæ•´æŒ‡å—](#go-æµ‹è¯•ä¸å¯è§‚æµ‹æ€§æœ€ä½³å®è·µå®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ–‡æ¡£æ¦‚è¿°](#æ–‡æ¡£æ¦‚è¿°)
    - [æ ¸å¿ƒä»·å€¼](#æ ¸å¿ƒä»·å€¼)
    - [ä¾èµ–ç‰ˆæœ¬](#ä¾èµ–ç‰ˆæœ¬)
  - [å•å…ƒæµ‹è¯•è¿½è¸ª](#å•å…ƒæµ‹è¯•è¿½è¸ª)
    - [æµ‹è¯•è¿½è¸ªå™¨](#æµ‹è¯•è¿½è¸ªå™¨)
    - [Mock Exporter](#mock-exporter)
    - [Span æ–­è¨€](#span-æ–­è¨€)
  - [é›†æˆæµ‹è¯•è¿½è¸ª](#é›†æˆæµ‹è¯•è¿½è¸ª)
    - [æµ‹è¯•å®¹å™¨](#æµ‹è¯•å®¹å™¨)
    - [ç«¯åˆ°ç«¯æµ‹è¯•](#ç«¯åˆ°ç«¯æµ‹è¯•)
    - [æµ‹è¯•æ•°æ®ç®¡ç†](#æµ‹è¯•æ•°æ®ç®¡ç†)
  - [æ€§èƒ½æµ‹è¯•](#æ€§èƒ½æµ‹è¯•)
    - [åŸºå‡†æµ‹è¯•è¿½è¸ª](#åŸºå‡†æµ‹è¯•è¿½è¸ª)
    - [è´Ÿè½½æµ‹è¯•](#è´Ÿè½½æµ‹è¯•)
    - [å‹åŠ›æµ‹è¯•](#å‹åŠ›æµ‹è¯•)
  - [å¯è§‚æµ‹æ€§æ¨¡å¼](#å¯è§‚æµ‹æ€§æ¨¡å¼)
    - [æ—¥å¿—ã€æŒ‡æ ‡ã€è¿½è¸ªå…³è”](#æ—¥å¿—æŒ‡æ ‡è¿½è¸ªå…³è”)
    - [å‘Šè­¦è§„åˆ™](#å‘Šè­¦è§„åˆ™)
    - [Dashboard è®¾è®¡](#dashboard-è®¾è®¡)
  - [æ•…éšœæ³¨å…¥](#æ•…éšœæ³¨å…¥)
    - [æ··æ²Œå·¥ç¨‹](#æ··æ²Œå·¥ç¨‹)
    - [é”™è¯¯æ¨¡æ‹Ÿ](#é”™è¯¯æ¨¡æ‹Ÿ)
    - [å»¶è¿Ÿæ³¨å…¥](#å»¶è¿Ÿæ³¨å…¥)
  - [è¿½è¸ªæ•°æ®åˆ†æ](#è¿½è¸ªæ•°æ®åˆ†æ)
    - [Trace èšåˆ](#trace-èšåˆ)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [1. æµ‹è¯•éš”ç¦»](#1-æµ‹è¯•éš”ç¦»)
    - [2. è¿½è¸ªéªŒè¯](#2-è¿½è¸ªéªŒè¯)
    - [3. æ€§èƒ½åŸºå‡†](#3-æ€§èƒ½åŸºå‡†)
    - [4. å¯è§‚æµ‹æ€§å…³è”](#4-å¯è§‚æµ‹æ€§å…³è”)
  - [å®Œæ•´ç¤ºä¾‹](#å®Œæ•´ç¤ºä¾‹)
  - [æ€»ç»“](#æ€»ç»“)
    - [å…³é”®è¦ç‚¹](#å…³é”®è¦ç‚¹)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)

---

## æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç» Go åº”ç”¨æµ‹è¯•å’Œå¯è§‚æµ‹æ€§çš„æœ€ä½³å®è·µï¼Œæ¶µç›–å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€æ€§èƒ½æµ‹è¯•å’Œå¯è§‚æµ‹æ€§æ¨¡å¼ã€‚

### æ ¸å¿ƒä»·å€¼

âœ… **å®Œæ•´çš„æµ‹è¯•è¦†ç›–** - å•å…ƒã€é›†æˆã€æ€§èƒ½æµ‹è¯•  
âœ… **è¿½è¸ªæµ‹è¯•** - éªŒè¯è¿½è¸ªæ•°æ®çš„æ­£ç¡®æ€§  
âœ… **å¯è§‚æµ‹æ€§å…³è”** - æ—¥å¿—ã€æŒ‡æ ‡ã€è¿½è¸ªä¸‰ä½ä¸€ä½“  
âœ… **æ•…éšœæ³¨å…¥** - æ··æ²Œå·¥ç¨‹å’Œé”™è¯¯æ¨¡æ‹Ÿ  
âœ… **æ€§èƒ½åˆ†æ** - è¿½è¸ªæ•°æ®é©±åŠ¨çš„æ€§èƒ½ä¼˜åŒ–

### ä¾èµ–ç‰ˆæœ¬

```go
go.opentelemetry.io/otel v1.32.0
go.opentelemetry.io/otel/sdk v1.32.0
go.opentelemetry.io/otel/sdk/metric v1.32.0
github.com/stretchr/testify v1.10.0
github.com/testcontainers/testcontainers-go v0.34.0
```

---

## å•å…ƒæµ‹è¯•è¿½è¸ª

### æµ‹è¯•è¿½è¸ªå™¨

**åˆ›å»ºæµ‹è¯•ä¸“ç”¨çš„è¿½è¸ªå™¨ï¼š**

```go
package testing

import (
    "context"
    "testing"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    "go.opentelemetry.io/otel/sdk/trace/tracetest"
    semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
)

// TestTracerProvider æµ‹è¯•ç”¨è¿½è¸ªå™¨
type TestTracerProvider struct {
    provider *sdktrace.TracerProvider
    exporter *tracetest.InMemoryExporter
}

// NewTestTracerProvider åˆ›å»ºæµ‹è¯•è¿½è¸ªå™¨
func NewTestTracerProvider(t *testing.T) *TestTracerProvider {
    exporter := tracetest.NewInMemoryExporter()
    
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithSyncer(exporter),
        sdktrace.WithResource(resource.NewWithAttributes(
            semconv.SchemaURL,
            semconv.ServiceName("test-service"),
        )),
    )
    
    otel.SetTracerProvider(tp)
    
    ttp := &TestTracerProvider{
        provider: tp,
        exporter: exporter,
    }
    
    // æ¸…ç†
    t.Cleanup(func() {
        if err := tp.Shutdown(context.Background()); err != nil {
            t.Errorf("failed to shutdown tracer provider: %v", err)
        }
    })
    
    return ttp
}

// GetSpans è·å–æ‰€æœ‰ Span
func (ttp *TestTracerProvider) GetSpans() []sdktrace.ReadOnlySpan {
    return ttp.exporter.GetSpans()
}

// Reset é‡ç½® Exporter
func (ttp *TestTracerProvider) Reset() {
    ttp.exporter.Reset()
}

// Provider è·å– TracerProvider
func (ttp *TestTracerProvider) Provider() *sdktrace.TracerProvider {
    return ttp.provider
}
```

### Mock Exporter

**Mock Exporter å®ç°ï¼š**

```go
package testing

import (
    "context"
    "sync"
    
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
)

// MockExporter Mock Exporter
type MockExporter struct {
    mu     sync.Mutex
    spans  []sdktrace.ReadOnlySpan
    errors []error
}

// NewMockExporter åˆ›å»º Mock Exporter
func NewMockExporter() *MockExporter {
    return &MockExporter{
        spans:  make([]sdktrace.ReadOnlySpan, 0),
        errors: make([]error, 0),
    }
}

// ExportSpans å¯¼å‡º Spans
func (me *MockExporter) ExportSpans(ctx context.Context, spans []sdktrace.ReadOnlySpan) error {
    me.mu.Lock()
    defer me.mu.Unlock()
    
    me.spans = append(me.spans, spans...)
    return nil
}

// Shutdown å…³é—­
func (me *MockExporter) Shutdown(ctx context.Context) error {
    return nil
}

// GetSpans è·å–æ‰€æœ‰ Span
func (me *MockExporter) GetSpans() []sdktrace.ReadOnlySpan {
    me.mu.Lock()
    defer me.mu.Unlock()
    
    result := make([]sdktrace.ReadOnlySpan, len(me.spans))
    copy(result, me.spans)
    return result
}

// Reset é‡ç½®
func (me *MockExporter) Reset() {
    me.mu.Lock()
    defer me.mu.Unlock()
    
    me.spans = make([]sdktrace.ReadOnlySpan, 0)
    me.errors = make([]error, 0)
}

// GetSpansByName æ ¹æ®åç§°è·å– Span
func (me *MockExporter) GetSpansByName(name string) []sdktrace.ReadOnlySpan {
    me.mu.Lock()
    defer me.mu.Unlock()
    
    result := make([]sdktrace.ReadOnlySpan, 0)
    for _, span := range me.spans {
        if span.Name() == name {
            result = append(result, span)
        }
    }
    return result
}
```

### Span æ–­è¨€

**Span æ–­è¨€å·¥å…·ï¼š**

```go
package testing

import (
    "testing"
    
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    "go.opentelemetry.io/otel/trace"
)

// SpanAssertion Span æ–­è¨€
type SpanAssertion struct {
    t    *testing.T
    span sdktrace.ReadOnlySpan
}

// NewSpanAssertion åˆ›å»º Span æ–­è¨€
func NewSpanAssertion(t *testing.T, span sdktrace.ReadOnlySpan) *SpanAssertion {
    return &SpanAssertion{
        t:    t,
        span: span,
    }
}

// AssertName æ–­è¨€åç§°
func (sa *SpanAssertion) AssertName(expected string) *SpanAssertion {
    assert.Equal(sa.t, expected, sa.span.Name(), "span name mismatch")
    return sa
}

// AssertStatus æ–­è¨€çŠ¶æ€
func (sa *SpanAssertion) AssertStatus(expectedCode codes.Code, expectedMessage string) *SpanAssertion {
    status := sa.span.Status()
    assert.Equal(sa.t, expectedCode, status.Code, "span status code mismatch")
    if expectedMessage != "" {
        assert.Equal(sa.t, expectedMessage, status.Description, "span status message mismatch")
    }
    return sa
}

// AssertAttribute æ–­è¨€å±æ€§
func (sa *SpanAssertion) AssertAttribute(key string, value interface{}) *SpanAssertion {
    attrs := sa.span.Attributes()
    
    found := false
    for _, attr := range attrs {
        if string(attr.Key) == key {
            found = true
            switch v := value.(type) {
            case string:
                assert.Equal(sa.t, v, attr.Value.AsString(), "attribute value mismatch for key %s", key)
            case int:
                assert.Equal(sa.t, int64(v), attr.Value.AsInt64(), "attribute value mismatch for key %s", key)
            case int64:
                assert.Equal(sa.t, v, attr.Value.AsInt64(), "attribute value mismatch for key %s", key)
            case bool:
                assert.Equal(sa.t, v, attr.Value.AsBool(), "attribute value mismatch for key %s", key)
            case float64:
                assert.Equal(sa.t, v, attr.Value.AsFloat64(), "attribute value mismatch for key %s", key)
            }
            break
        }
    }
    
    assert.True(sa.t, found, "attribute %s not found", key)
    return sa
}

// AssertHasAttributes æ–­è¨€åŒ…å«å±æ€§
func (sa *SpanAssertion) AssertHasAttributes(keys ...string) *SpanAssertion {
    attrs := sa.span.Attributes()
    attrMap := make(map[string]bool)
    
    for _, attr := range attrs {
        attrMap[string(attr.Key)] = true
    }
    
    for _, key := range keys {
        assert.True(sa.t, attrMap[key], "attribute %s not found", key)
    }
    
    return sa
}

// AssertSpanKind æ–­è¨€ Span ç±»å‹
func (sa *SpanAssertion) AssertSpanKind(expected trace.SpanKind) *SpanAssertion {
    assert.Equal(sa.t, expected, sa.span.SpanKind(), "span kind mismatch")
    return sa
}

// AssertParent æ–­è¨€çˆ¶ Span
func (sa *SpanAssertion) AssertParent(expectedParentSpanID trace.SpanID) *SpanAssertion {
    assert.Equal(sa.t, expectedParentSpanID, sa.span.Parent().SpanID(), "parent span ID mismatch")
    return sa
}

// AssertEvents æ–­è¨€äº‹ä»¶
func (sa *SpanAssertion) AssertEvents(eventNames ...string) *SpanAssertion {
    events := sa.span.Events()
    assert.Equal(sa.t, len(eventNames), len(events), "event count mismatch")
    
    for i, expected := range eventNames {
        assert.Equal(sa.t, expected, events[i].Name, "event name mismatch at index %d", i)
    }
    
    return sa
}

// AssertNoErrors æ–­è¨€æ²¡æœ‰é”™è¯¯
func (sa *SpanAssertion) AssertNoErrors() *SpanAssertion {
    status := sa.span.Status()
    assert.NotEqual(sa.t, codes.Error, status.Code, "span should not have error status")
    return sa
}

// AssertDuration æ–­è¨€æŒç»­æ—¶é—´
func (sa *SpanAssertion) AssertDuration(minMs, maxMs int64) *SpanAssertion {
    duration := sa.span.EndTime().Sub(sa.span.StartTime()).Milliseconds()
    assert.GreaterOrEqual(sa.t, duration, minMs, "span duration too short")
    assert.LessOrEqual(sa.t, duration, maxMs, "span duration too long")
    return sa
}
```

**ä½¿ç”¨ç¤ºä¾‹ï¼š**

```go
package service

import (
    "context"
    "testing"
    
    "github.com/stretchr/testify/require"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

func TestUserService_GetUser(t *testing.T) {
    // 1. åˆ›å»ºæµ‹è¯•è¿½è¸ªå™¨
    ttp := NewTestTracerProvider(t)
    
    // 2. åˆ›å»ºæœåŠ¡
    service := NewUserService()
    
    // 3. æ‰§è¡Œæ“ä½œ
    ctx := context.Background()
    user, err := service.GetUser(ctx, "123")
    require.NoError(t, err)
    require.NotNil(t, user)
    
    // 4. éªŒè¯ Spans
    spans := ttp.GetSpans()
    require.Len(t, spans, 1)
    
    // 5. æ–­è¨€ Span å±æ€§
    NewSpanAssertion(t, spans[0]).
        AssertName("get-user").
        AssertStatus(codes.Ok, "").
        AssertAttribute("user.id", "123").
        AssertHasAttributes("user.name", "user.email").
        AssertSpanKind(trace.SpanKindInternal).
        AssertNoErrors().
        AssertDuration(0, 1000)
}

func TestUserService_GetUser_NotFound(t *testing.T) {
    ttp := NewTestTracerProvider(t)
    service := NewUserService()
    
    ctx := context.Background()
    user, err := service.GetUser(ctx, "999")
    require.Error(t, err)
    require.Nil(t, user)
    
    spans := ttp.GetSpans()
    require.Len(t, spans, 1)
    
    NewSpanAssertion(t, spans[0]).
        AssertName("get-user").
        AssertStatus(codes.Error, "user not found").
        AssertAttribute("user.id", "999")
}
```

---

## é›†æˆæµ‹è¯•è¿½è¸ª

### æµ‹è¯•å®¹å™¨

**ä½¿ç”¨ Testcontainers è¿›è¡Œé›†æˆæµ‹è¯•ï¼š**

```go
package integration

import (
    "context"
    "testing"
    "time"
    
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/wait"
)

// TestEnvironment æµ‹è¯•ç¯å¢ƒ
type TestEnvironment struct {
    PostgresContainer testcontainers.Container
    RedisContainer    testcontainers.Container
    OTLPContainer     testcontainers.Container
    
    PostgresURL string
    RedisURL    string
    OTLPURL     string
}

// SetupTestEnvironment è®¾ç½®æµ‹è¯•ç¯å¢ƒ
func SetupTestEnvironment(t *testing.T) *TestEnvironment {
    ctx := context.Background()
    
    env := &TestEnvironment{}
    
    // 1. PostgreSQL
    postgresReq := testcontainers.ContainerRequest{
        Image:        "postgres:16",
        ExposedPorts: []string{"5432/tcp"},
        Env: map[string]string{
            "POSTGRES_PASSWORD": "test",
            "POSTGRES_DB":       "testdb",
        },
        WaitingFor: wait.ForLog("database system is ready to accept connections").
            WithStartupTimeout(60 * time.Second),
    }
    
    postgresContainer, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
        ContainerRequest: postgresReq,
        Started:          true,
    })
    if err != nil {
        t.Fatal(err)
    }
    
    postgresHost, _ := postgresContainer.Host(ctx)
    postgresPort, _ := postgresContainer.MappedPort(ctx, "5432")
    env.PostgresURL = fmt.Sprintf("postgresql://postgres:test@%s:%s/testdb?sslmode=disable", 
        postgresHost, postgresPort.Port())
    env.PostgresContainer = postgresContainer
    
    // 2. Redis
    redisReq := testcontainers.ContainerRequest{
        Image:        "redis:7",
        ExposedPorts: []string{"6379/tcp"},
        WaitingFor:   wait.ForLog("Ready to accept connections"),
    }
    
    redisContainer, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
        ContainerRequest: redisReq,
        Started:          true,
    })
    if err != nil {
        t.Fatal(err)
    }
    
    redisHost, _ := redisContainer.Host(ctx)
    redisPort, _ := redisContainer.MappedPort(ctx, "6379")
    env.RedisURL = fmt.Sprintf("%s:%s", redisHost, redisPort.Port())
    env.RedisContainer = redisContainer
    
    // 3. OTLP Collector
    otlpReq := testcontainers.ContainerRequest{
        Image:        "otel/opentelemetry-collector:latest",
        ExposedPorts: []string{"4317/tcp", "4318/tcp"},
        WaitingFor:   wait.ForLog("Everything is ready"),
    }
    
    otlpContainer, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
        ContainerRequest: otlpReq,
        Started:          true,
    })
    if err != nil {
        t.Fatal(err)
    }
    
    otlpHost, _ := otlpContainer.Host(ctx)
    otlpPort, _ := otlpContainer.MappedPort(ctx, "4317")
    env.OTLPURL = fmt.Sprintf("%s:%s", otlpHost, otlpPort.Port())
    env.OTLPContainer = otlpContainer
    
    // æ¸…ç†
    t.Cleanup(func() {
        env.Cleanup(context.Background())
    })
    
    return env
}

// Cleanup æ¸…ç†æµ‹è¯•ç¯å¢ƒ
func (env *TestEnvironment) Cleanup(ctx context.Context) {
    if env.PostgresContainer != nil {
        env.PostgresContainer.Terminate(ctx)
    }
    if env.RedisContainer != nil {
        env.RedisContainer.Terminate(ctx)
    }
    if env.OTLPContainer != nil {
        env.OTLPContainer.Terminate(ctx)
    }
}
```

### ç«¯åˆ°ç«¯æµ‹è¯•

**ç«¯åˆ°ç«¯æµ‹è¯•ç¤ºä¾‹ï¼š**

```go
package integration

import (
    "context"
    "testing"
    "time"
    
    "github.com/stretchr/testify/require"
)

func TestUserService_E2E(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping integration test")
    }
    
    // 1. è®¾ç½®æµ‹è¯•ç¯å¢ƒ
    env := SetupTestEnvironment(t)
    
    // 2. åˆå§‹åŒ–æœåŠ¡
    db, err := NewTracedDB("postgres", env.PostgresURL)
    require.NoError(t, err)
    defer db.Close()
    
    redis, err := NewTracedRedis(env.RedisURL)
    require.NoError(t, err)
    defer redis.Close()
    
    // 3. åˆå§‹åŒ– OTLP
    tp, err := initTracing(context.Background(), env.OTLPURL)
    require.NoError(t, err)
    defer tp.Shutdown(context.Background())
    
    // 4. åˆ›å»ºæœåŠ¡
    userService := NewUserService(db, redis)
    
    // 5. æµ‹è¯•åˆ›å»ºç”¨æˆ·
    ctx := context.Background()
    user := &User{
        Name:  "Test User",
        Email: "test@example.com",
    }
    
    err = userService.CreateUser(ctx, user)
    require.NoError(t, err)
    require.NotZero(t, user.ID)
    
    // 6. æµ‹è¯•è·å–ç”¨æˆ·
    retrievedUser, err := userService.GetUser(ctx, user.ID)
    require.NoError(t, err)
    require.Equal(t, user.Name, retrievedUser.Name)
    require.Equal(t, user.Email, retrievedUser.Email)
    
    // 7. æµ‹è¯•ç¼“å­˜
    start := time.Now()
    cachedUser, err := userService.GetUser(ctx, user.ID)
    duration := time.Since(start)
    require.NoError(t, err)
    require.Equal(t, user.Name, cachedUser.Name)
    require.Less(t, duration, 10*time.Millisecond, "should be served from cache")
    
    // 8. æµ‹è¯•æ›´æ–°ç”¨æˆ·
    user.Name = "Updated User"
    err = userService.UpdateUser(ctx, user)
    require.NoError(t, err)
    
    // 9. éªŒè¯æ›´æ–°
    updatedUser, err := userService.GetUser(ctx, user.ID)
    require.NoError(t, err)
    require.Equal(t, "Updated User", updatedUser.Name)
    
    // 10. æµ‹è¯•åˆ é™¤ç”¨æˆ·
    err = userService.DeleteUser(ctx, user.ID)
    require.NoError(t, err)
    
    // 11. éªŒè¯åˆ é™¤
    _, err = userService.GetUser(ctx, user.ID)
    require.Error(t, err)
}
```

### æµ‹è¯•æ•°æ®ç®¡ç†

**æµ‹è¯•æ•°æ®å·¥å‚ï¼š**

```go
package testing

import (
    "context"
    "database/sql"
    "testing"
)

// TestDataFactory æµ‹è¯•æ•°æ®å·¥å‚
type TestDataFactory struct {
    db *sql.DB
    t  *testing.T
}

// NewTestDataFactory åˆ›å»ºæµ‹è¯•æ•°æ®å·¥å‚
func NewTestDataFactory(t *testing.T, db *sql.DB) *TestDataFactory {
    return &TestDataFactory{
        db: db,
        t:  t,
    }
}

// CreateUser åˆ›å»ºæµ‹è¯•ç”¨æˆ·
func (tdf *TestDataFactory) CreateUser(ctx context.Context, name, email string) *User {
    user := &User{
        Name:  name,
        Email: email,
    }
    
    query := `INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id`
    err := tdf.db.QueryRowContext(ctx, query, user.Name, user.Email).Scan(&user.ID)
    if err != nil {
        tdf.t.Fatal(err)
    }
    
    // æ³¨å†Œæ¸…ç†
    tdf.t.Cleanup(func() {
        tdf.db.ExecContext(context.Background(), "DELETE FROM users WHERE id = $1", user.ID)
    })
    
    return user
}

// CreateUsers æ‰¹é‡åˆ›å»ºæµ‹è¯•ç”¨æˆ·
func (tdf *TestDataFactory) CreateUsers(ctx context.Context, count int) []*User {
    users := make([]*User, count)
    
    for i := 0; i < count; i++ {
        users[i] = tdf.CreateUser(ctx, 
            fmt.Sprintf("User %d", i), 
            fmt.Sprintf("user%d@example.com", i))
    }
    
    return users
}

// CleanupAll æ¸…ç†æ‰€æœ‰æµ‹è¯•æ•°æ®
func (tdf *TestDataFactory) CleanupAll(ctx context.Context) {
    tables := []string{"orders", "users", "products"}
    
    for _, table := range tables {
        _, err := tdf.db.ExecContext(ctx, fmt.Sprintf("DELETE FROM %s", table))
        if err != nil {
            tdf.t.Logf("failed to cleanup table %s: %v", table, err)
        }
    }
}
```

---

## æ€§èƒ½æµ‹è¯•

### åŸºå‡†æµ‹è¯•è¿½è¸ª

**åŸºå‡†æµ‹è¯•é›†æˆï¼š**

```go
package benchmark

import (
    "context"
    "testing"
    
    "go.opentelemetry.io/otel"
)

func BenchmarkUserService_GetUser(b *testing.B) {
    // 1. è®¾ç½®
    ttp := NewTestTracerProvider(&testing.T{})
    service := NewUserService()
    ctx := context.Background()
    
    // 2. é¢„çƒ­
    service.GetUser(ctx, "123")
    
    // 3. é‡ç½®è¿½è¸ªå™¨
    ttp.Reset()
    
    // 4. åŸºå‡†æµ‹è¯•
    b.ResetTimer()
    b.ReportAllocs()
    
    for i := 0; i < b.N; i++ {
        service.GetUser(ctx, "123")
    }
    
    b.StopTimer()
    
    // 5. æŠ¥å‘Šè¿½è¸ªç»Ÿè®¡
    spans := ttp.GetSpans()
    b.ReportMetric(float64(len(spans)), "spans")
    
    if len(spans) > 0 {
        totalDuration := int64(0)
        for _, span := range spans {
            totalDuration += span.EndTime().Sub(span.StartTime()).Microseconds()
        }
        avgDuration := totalDuration / int64(len(spans))
        b.ReportMetric(float64(avgDuration), "span_Î¼s/op")
    }
}

func BenchmarkWithTracingOverhead(b *testing.B) {
    ctx := context.Background()
    tracer := otel.Tracer("benchmark")
    
    b.Run("without-tracing", func(b *testing.B) {
        for i := 0; i < b.N; i++ {
            doWork()
        }
    })
    
    b.Run("with-tracing", func(b *testing.B) {
        for i := 0; i < b.N; i++ {
            _, span := tracer.Start(ctx, "do-work")
            doWork()
            span.End()
        }
    })
}

func doWork() {
    // æ¨¡æ‹Ÿå·¥ä½œè´Ÿè½½
    sum := 0
    for i := 0; i < 1000; i++ {
        sum += i
    }
}
```

### è´Ÿè½½æµ‹è¯•

**è´Ÿè½½æµ‹è¯•å·¥å…·ï¼š**

```go
package loadtest

import (
    "context"
    "sync"
    "sync/atomic"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// LoadTester è´Ÿè½½æµ‹è¯•å™¨
type LoadTester struct {
    target      func(context.Context) error
    concurrency int
    duration    time.Duration
    tracer      trace.Tracer
    
    // ç»Ÿè®¡
    totalRequests   int64
    successRequests int64
    failedRequests  int64
    totalDuration   int64
}

// NewLoadTester åˆ›å»ºè´Ÿè½½æµ‹è¯•å™¨
func NewLoadTester(target func(context.Context) error, concurrency int, duration time.Duration) *LoadTester {
    return &LoadTester{
        target:      target,
        concurrency: concurrency,
        duration:    duration,
        tracer:      otel.Tracer("load-tester"),
    }
}

// Run æ‰§è¡Œè´Ÿè½½æµ‹è¯•
func (lt *LoadTester) Run(ctx context.Context) *LoadTestResult {
    ctx, span := lt.tracer.Start(ctx, "load-test",
        trace.WithAttributes(
            attribute.Int("load_test.concurrency", lt.concurrency),
            attribute.Int64("load_test.duration_sec", int64(lt.duration.Seconds())),
        ),
    )
    defer span.End()
    
    var wg sync.WaitGroup
    stopCh := make(chan struct{})
    
    // å¯åŠ¨ worker
    for i := 0; i < lt.concurrency; i++ {
        wg.Add(1)
        go func(workerID int) {
            defer wg.Done()
            lt.worker(ctx, workerID, stopCh)
        }(i)
    }
    
    // ç­‰å¾…æµ‹è¯•å®Œæˆ
    time.Sleep(lt.duration)
    close(stopCh)
    wg.Wait()
    
    // è®¡ç®—ç»“æœ
    result := &LoadTestResult{
        TotalRequests:   atomic.LoadInt64(&lt.totalRequests),
        SuccessRequests: atomic.LoadInt64(&lt.successRequests),
        FailedRequests:  atomic.LoadInt64(&lt.failedRequests),
        Duration:        lt.duration,
        Concurrency:     lt.concurrency,
    }
    
    if result.TotalRequests > 0 {
        result.RPS = float64(result.TotalRequests) / lt.duration.Seconds()
        result.AvgDuration = time.Duration(atomic.LoadInt64(&lt.totalDuration) / result.TotalRequests)
        result.SuccessRate = float64(result.SuccessRequests) / float64(result.TotalRequests) * 100
    }
    
    // è®°å½•ç»“æœåˆ° Span
    span.SetAttributes(
        attribute.Int64("load_test.total_requests", result.TotalRequests),
        attribute.Int64("load_test.success_requests", result.SuccessRequests),
        attribute.Int64("load_test.failed_requests", result.FailedRequests),
        attribute.Float64("load_test.rps", result.RPS),
        attribute.Float64("load_test.success_rate", result.SuccessRate),
    )
    
    return result
}

// worker å·¥ä½œåç¨‹
func (lt *LoadTester) worker(ctx context.Context, workerID int, stopCh <-chan struct{}) {
    for {
        select {
        case <-stopCh:
            return
        default:
            start := time.Now()
            err := lt.target(ctx)
            duration := time.Since(start)
            
            atomic.AddInt64(&lt.totalRequests, 1)
            atomic.AddInt64(&lt.totalDuration, int64(duration))
            
            if err != nil {
                atomic.AddInt64(&lt.failedRequests, 1)
            } else {
                atomic.AddInt64(&lt.successRequests, 1)
            }
        }
    }
}

// LoadTestResult è´Ÿè½½æµ‹è¯•ç»“æœ
type LoadTestResult struct {
    TotalRequests   int64
    SuccessRequests int64
    FailedRequests  int64
    Duration        time.Duration
    Concurrency     int
    RPS             float64
    AvgDuration     time.Duration
    SuccessRate     float64
}

// Print æ‰“å°ç»“æœ
func (r *LoadTestResult) Print() {
    fmt.Printf("Load Test Results:\n")
    fmt.Printf("  Duration:        %v\n", r.Duration)
    fmt.Printf("  Concurrency:     %d\n", r.Concurrency)
    fmt.Printf("  Total Requests:  %d\n", r.TotalRequests)
    fmt.Printf("  Success:         %d (%.2f%%)\n", r.SuccessRequests, r.SuccessRate)
    fmt.Printf("  Failed:          %d\n", r.FailedRequests)
    fmt.Printf("  RPS:             %.2f\n", r.RPS)
    fmt.Printf("  Avg Duration:    %v\n", r.AvgDuration)
}
```

**ä½¿ç”¨ç¤ºä¾‹ï¼š**

```go
func TestLoadTest(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping load test")
    }
    
    // åˆ›å»ºæœåŠ¡
    service := NewUserService()
    
    // å®šä¹‰æµ‹è¯•ç›®æ ‡
    target := func(ctx context.Context) error {
        _, err := service.GetUser(ctx, "123")
        return err
    }
    
    // æ‰§è¡Œè´Ÿè½½æµ‹è¯•
    tester := NewLoadTester(target, 100, 30*time.Second)
    result := tester.Run(context.Background())
    
    // æ‰“å°ç»“æœ
    result.Print()
    
    // æ–­è¨€
    require.Greater(t, result.SuccessRate, 95.0, "success rate should be > 95%")
    require.Greater(t, result.RPS, 1000.0, "RPS should be > 1000")
}
```

### å‹åŠ›æµ‹è¯•

**å‹åŠ›æµ‹è¯•å™¨ï¼š**

```go
package loadtest

import (
    "context"
    "time"
)

// StressTester å‹åŠ›æµ‹è¯•å™¨
type StressTester struct {
    target         func(context.Context) error
    startConcurrency int
    maxConcurrency   int
    stepDuration     time.Duration
    step             int
}

// NewStressTester åˆ›å»ºå‹åŠ›æµ‹è¯•å™¨
func NewStressTester(target func(context.Context) error, startConcurrency, maxConcurrency, step int, stepDuration time.Duration) *StressTester {
    return &StressTester{
        target:           target,
        startConcurrency: startConcurrency,
        maxConcurrency:   maxConcurrency,
        step:             step,
        stepDuration:     stepDuration,
    }
}

// Run æ‰§è¡Œå‹åŠ›æµ‹è¯•
func (st *StressTester) Run(ctx context.Context) []*LoadTestResult {
    results := make([]*LoadTestResult, 0)
    
    for concurrency := st.startConcurrency; concurrency <= st.maxConcurrency; concurrency += st.step {
        fmt.Printf("Testing with concurrency: %d\n", concurrency)
        
        tester := NewLoadTester(st.target, concurrency, st.stepDuration)
        result := tester.Run(ctx)
        result.Print()
        
        results = append(results, result)
        
        // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°é¥±å’Œç‚¹
        if result.SuccessRate < 90.0 {
            fmt.Printf("Saturation point reached at concurrency: %d\n", concurrency)
            break
        }
        
        // çŸ­æš‚ä¼‘æ¯
        time.Sleep(5 * time.Second)
    }
    
    return results
}
```

---

## å¯è§‚æµ‹æ€§æ¨¡å¼

### æ—¥å¿—ã€æŒ‡æ ‡ã€è¿½è¸ªå…³è”

**å…³è” ID ä¼ æ’­ï¼š**

```go
package observability

import (
    "context"
    "log/slog"
    
    "go.opentelemetry.io/otel/trace"
)

// ContextLogger å¸¦ Context çš„æ—¥å¿—è®°å½•å™¨
type ContextLogger struct {
    logger *slog.Logger
}

// NewContextLogger åˆ›å»º Context æ—¥å¿—è®°å½•å™¨
func NewContextLogger(logger *slog.Logger) *ContextLogger {
    return &ContextLogger{
        logger: logger,
    }
}

// Info è®°å½• Info æ—¥å¿—
func (cl *ContextLogger) Info(ctx context.Context, msg string, args ...any) {
    cl.logWithTrace(ctx, slog.LevelInfo, msg, args...)
}

// Error è®°å½• Error æ—¥å¿—
func (cl *ContextLogger) Error(ctx context.Context, msg string, args ...any) {
    cl.logWithTrace(ctx, slog.LevelError, msg, args...)
}

// logWithTrace è®°å½•å¸¦è¿½è¸ªä¿¡æ¯çš„æ—¥å¿—
func (cl *ContextLogger) logWithTrace(ctx context.Context, level slog.Level, msg string, args ...any) {
    span := trace.SpanFromContext(ctx)
    spanContext := span.SpanContext()
    
    // æ·»åŠ è¿½è¸ªä¿¡æ¯
    enrichedArgs := append(args,
        slog.String("trace_id", spanContext.TraceID().String()),
        slog.String("span_id", spanContext.SpanID().String()),
    )
    
    cl.logger.Log(ctx, level, msg, enrichedArgs...)
}
```

**ç»Ÿä¸€å¯è§‚æµ‹æ€§ä¸Šä¸‹æ–‡ï¼š**

```go
package observability

import (
    "context"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
)

// ObservabilityContext å¯è§‚æµ‹æ€§ä¸Šä¸‹æ–‡
type ObservabilityContext struct {
    ctx    context.Context
    tracer trace.Tracer
    meter  metric.Meter
    logger *ContextLogger
}

// NewObservabilityContext åˆ›å»ºå¯è§‚æµ‹æ€§ä¸Šä¸‹æ–‡
func NewObservabilityContext(ctx context.Context, serviceName string) *ObservabilityContext {
    return &ObservabilityContext{
        ctx:    ctx,
        tracer: otel.Tracer(serviceName),
        meter:  otel.Meter(serviceName),
        logger: NewContextLogger(slog.Default()),
    }
}

// StartOperation å¼€å§‹æ“ä½œ
func (oc *ObservabilityContext) StartOperation(operationName string, attrs ...attribute.KeyValue) *Operation {
    ctx, span := oc.tracer.Start(oc.ctx, operationName,
        trace.WithAttributes(attrs...),
    )
    
    return &Operation{
        ctx:    ctx,
        span:   span,
        meter:  oc.meter,
        logger: oc.logger,
        start:  time.Now(),
    }
}

// Operation æ“ä½œ
type Operation struct {
    ctx    context.Context
    span   trace.Span
    meter  metric.Meter
    logger *ContextLogger
    start  time.Time
}

// End ç»“æŸæ“ä½œ
func (op *Operation) End(err error) {
    duration := time.Since(op.start)
    
    // 1. è®°å½•è¿½è¸ª
    if err != nil {
        op.span.RecordError(err)
        op.span.SetStatus(codes.Error, err.Error())
    } else {
        op.span.SetStatus(codes.Ok, "")
    }
    op.span.End()
    
    // 2. è®°å½•æŒ‡æ ‡
    counter, _ := op.meter.Int64Counter("operations.total")
    histogram, _ := op.meter.Float64Histogram("operations.duration")
    
    attrs := []attribute.KeyValue{
        attribute.String("operation", op.span.Name()),
    }
    
    if err != nil {
        attrs = append(attrs, attribute.Bool("error", true))
    } else {
        attrs = append(attrs, attribute.Bool("error", false))
    }
    
    counter.Add(op.ctx, 1, metric.WithAttributes(attrs...))
    histogram.Record(op.ctx, float64(duration.Milliseconds()), metric.WithAttributes(attrs...))
    
    // 3. è®°å½•æ—¥å¿—
    if err != nil {
        op.logger.Error(op.ctx, "operation failed",
            slog.String("operation", op.span.Name()),
            slog.Duration("duration", duration),
            slog.Any("error", err),
        )
    } else {
        op.logger.Info(op.ctx, "operation completed",
            slog.String("operation", op.span.Name()),
            slog.Duration("duration", duration),
        )
    }
}

// Context è·å– Context
func (op *Operation) Context() context.Context {
    return op.ctx
}
```

### å‘Šè­¦è§„åˆ™

**Prometheus å‘Šè­¦è§„åˆ™ï¼š**

```yaml
# alerts.yaml
groups:
- name: application_alerts
  interval: 30s
  rules:
  # é”™è¯¯ç‡å‘Šè­¦
  - alert: HighErrorRate
    expr: |
      sum(rate(operations_total{error="true"}[5m])) / 
      sum(rate(operations_total[5m])) > 0.05
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "High error rate detected"
      description: "Error rate is {{ $value | humanizePercentage }} (threshold: 5%)"
  
  # å»¶è¿Ÿå‘Šè­¦
  - alert: HighLatency
    expr: |
      histogram_quantile(0.95, 
        rate(operations_duration_bucket[5m])
      ) > 1000
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "High latency detected"
      description: "P95 latency is {{ $value }}ms (threshold: 1000ms)"
  
  # æ…¢æŸ¥è¯¢å‘Šè­¦
  - alert: SlowQuery
    expr: |
      rate(db_query_duration_sum[5m]) / 
      rate(db_query_duration_count[5m]) > 100
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "Slow database queries detected"
      description: "Average query time is {{ $value }}ms (threshold: 100ms)"
  
  # æ•°æ®åº“è¿æ¥æ± å‘Šè­¦
  - alert: DatabaseConnectionPoolExhausted
    expr: db_connections_active >= db_connections_max * 0.9
    for: 5m
    labels:
      severity: critical
    annotations:
      summary: "Database connection pool nearly exhausted"
      description: "Active connections: {{ $value }} ({{ $value | humanizePercentage }} of max)"
  
  # ç¼“å­˜å‘½ä¸­ç‡å‘Šè­¦
  - alert: LowCacheHitRate
    expr: |
      sum(rate(cache_hit[5m])) / 
      (sum(rate(cache_hit[5m])) + sum(rate(cache_miss[5m]))) < 0.8
    for: 10m
    labels:
      severity: warning
    annotations:
      summary: "Low cache hit rate"
      description: "Cache hit rate is {{ $value | humanizePercentage }} (threshold: 80%)"
```

### Dashboard è®¾è®¡

**Grafana Dashboard JSONï¼š**

```json
{
  "dashboard": {
    "title": "Go Application Observability",
    "panels": [
      {
        "title": "Request Rate",
        "targets": [
          {
            "expr": "sum(rate(http_server_requests_total[5m])) by (http_route)"
          }
        ]
      },
      {
        "title": "Error Rate",
        "targets": [
          {
            "expr": "sum(rate(http_server_requests_total{error=\"true\"}[5m])) / sum(rate(http_server_requests_total[5m]))"
          }
        ]
      },
      {
        "title": "Latency Percentiles",
        "targets": [
          {
            "expr": "histogram_quantile(0.50, rate(http_server_duration_bucket[5m]))",
            "legendFormat": "p50"
          },
          {
            "expr": "histogram_quantile(0.95, rate(http_server_duration_bucket[5m]))",
            "legendFormat": "p95"
          },
          {
            "expr": "histogram_quantile(0.99, rate(http_server_duration_bucket[5m]))",
            "legendFormat": "p99"
          }
        ]
      },
      {
        "title": "Database Query Duration",
        "targets": [
          {
            "expr": "rate(db_query_duration_sum[5m]) / rate(db_query_duration_count[5m])"
          }
        ]
      },
      {
        "title": "Cache Hit Rate",
        "targets": [
          {
            "expr": "sum(rate(cache_hit[5m])) / (sum(rate(cache_hit[5m])) + sum(rate(cache_miss[5m])))"
          }
        ]
      },
      {
        "title": "Database Connection Pool",
        "targets": [
          {
            "expr": "db_connections_active",
            "legendFormat": "active"
          },
          {
            "expr": "db_connections_idle",
            "legendFormat": "idle"
          },
          {
            "expr": "db_connections_max",
            "legendFormat": "max"
          }
        ]
      }
    ]
  }
}
```

---

## æ•…éšœæ³¨å…¥

### æ··æ²Œå·¥ç¨‹

**æ··æ²Œå·¥ç¨‹å·¥å…·ï¼š**

```go
package chaos

import (
    "context"
    "errors"
    "math/rand"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// ChaosInjector æ··æ²Œæ³¨å…¥å™¨
type ChaosInjector struct {
    errorRate    float64  // é”™è¯¯ç‡ (0.0 - 1.0)
    latencyMin   time.Duration
    latencyMax   time.Duration
    latencyRate  float64  // å»¶è¿Ÿæ³¨å…¥ç‡ (0.0 - 1.0)
    tracer       trace.Tracer
    enabled      bool
}

// NewChaosInjector åˆ›å»ºæ··æ²Œæ³¨å…¥å™¨
func NewChaosInjector(errorRate, latencyRate float64, latencyMin, latencyMax time.Duration) *ChaosInjector {
    return &ChaosInjector{
        errorRate:   errorRate,
        latencyMin:  latencyMin,
        latencyMax:  latencyMax,
        latencyRate: latencyRate,
        tracer:      otel.Tracer("chaos-injector"),
        enabled:     true,
    }
}

// Execute æ‰§è¡Œæ“ä½œï¼ˆå¸¦æ··æ²Œæ³¨å…¥ï¼‰
func (ci *ChaosInjector) Execute(ctx context.Context, operation func(context.Context) error) error {
    if !ci.enabled {
        return operation(ctx)
    }
    
    ctx, span := ci.tracer.Start(ctx, "chaos-injection")
    defer span.End()
    
    // 1. æ³¨å…¥å»¶è¿Ÿ
    if rand.Float64() < ci.latencyRate {
        latency := ci.latencyMin + time.Duration(rand.Int63n(int64(ci.latencyMax-ci.latencyMin)))
        
        span.AddEvent("injecting latency",
            trace.WithAttributes(
                attribute.Int64("latency_ms", latency.Milliseconds()),
            ),
        )
        
        select {
        case <-time.After(latency):
        case <-ctx.Done():
            return ctx.Err()
        }
    }
    
    // 2. æ³¨å…¥é”™è¯¯
    if rand.Float64() < ci.errorRate {
        err := errors.New("chaos: injected error")
        
        span.AddEvent("injecting error")
        span.RecordError(err)
        
        return err
    }
    
    // 3. æ­£å¸¸æ‰§è¡Œ
    return operation(ctx)
}

// Enable å¯ç”¨æ··æ²Œæ³¨å…¥
func (ci *ChaosInjector) Enable() {
    ci.enabled = true
}

// Disable ç¦ç”¨æ··æ²Œæ³¨å…¥
func (ci *ChaosInjector) Disable() {
    ci.enabled = false
}
```

**ä½¿ç”¨ç¤ºä¾‹ï¼š**

```go
func TestWithChaos(t *testing.T) {
    // åˆ›å»ºæ··æ²Œæ³¨å…¥å™¨
    chaos := NewChaosInjector(
        0.1,           // 10% é”™è¯¯ç‡
        0.2,           // 20% å»¶è¿Ÿæ³¨å…¥ç‡
        100*time.Millisecond,
        500*time.Millisecond,
    )
    
    // åˆ›å»ºæœåŠ¡
    service := NewUserService()
    
    // æ‰§è¡Œå¤šæ¬¡æµ‹è¯•
    successCount := 0
    errorCount := 0
    
    for i := 0; i < 100; i++ {
        err := chaos.Execute(context.Background(), func(ctx context.Context) error {
            _, err := service.GetUser(ctx, "123")
            return err
        })
        
        if err != nil {
            errorCount++
        } else {
            successCount++
        }
    }
    
    fmt.Printf("Success: %d, Errors: %d\n", successCount, errorCount)
    
    // éªŒè¯é”™è¯¯ç‡åœ¨é¢„æœŸèŒƒå›´å†…
    actualErrorRate := float64(errorCount) / 100.0
    require.InDelta(t, 0.1, actualErrorRate, 0.05, "error rate should be close to 10%")
}
```

### é”™è¯¯æ¨¡æ‹Ÿ

**é”™è¯¯æ¨¡æ‹Ÿå™¨ï¼š**

```go
package chaos

import (
    "context"
    "database/sql"
    "errors"
    "math/rand"
)

// ErrorSimulator é”™è¯¯æ¨¡æ‹Ÿå™¨
type ErrorSimulator struct {
    scenarios []ErrorScenario
}

// ErrorScenario é”™è¯¯åœºæ™¯
type ErrorScenario struct {
    Name        string
    Probability float64
    Error       error
}

// NewErrorSimulator åˆ›å»ºé”™è¯¯æ¨¡æ‹Ÿå™¨
func NewErrorSimulator() *ErrorSimulator {
    return &ErrorSimulator{
        scenarios: []ErrorScenario{
            {
                Name:        "database_connection_lost",
                Probability: 0.01,
                Error:       sql.ErrConnDone,
            },
            {
                Name:        "context_deadline_exceeded",
                Probability: 0.02,
                Error:       context.DeadlineExceeded,
            },
            {
                Name:        "context_canceled",
                Probability: 0.01,
                Error:       context.Canceled,
            },
            {
                Name:        "network_timeout",
                Probability: 0.03,
                Error:       errors.New("network timeout"),
            },
        },
    }
}

// SimulateError æ¨¡æ‹Ÿé”™è¯¯
func (es *ErrorSimulator) SimulateError() error {
    for _, scenario := range es.scenarios {
        if rand.Float64() < scenario.Probability {
            return scenario.Error
        }
    }
    return nil
}
```

### å»¶è¿Ÿæ³¨å…¥

**å»¶è¿Ÿæ³¨å…¥å™¨ï¼š**

```go
package chaos

import (
    "context"
    "math/rand"
    "time"
)

// LatencyInjector å»¶è¿Ÿæ³¨å…¥å™¨
type LatencyInjector struct {
    patterns []LatencyPattern
}

// LatencyPattern å»¶è¿Ÿæ¨¡å¼
type LatencyPattern struct {
    Name        string
    Probability float64
    MinLatency  time.Duration
    MaxLatency  time.Duration
}

// NewLatencyInjector åˆ›å»ºå»¶è¿Ÿæ³¨å…¥å™¨
func NewLatencyInjector() *LatencyInjector {
    return &LatencyInjector{
        patterns: []LatencyPattern{
            {
                Name:        "normal",
                Probability: 0.7,
                MinLatency:  10 * time.Millisecond,
                MaxLatency:  50 * time.Millisecond,
            },
            {
                Name:        "slow",
                Probability: 0.2,
                MinLatency:  100 * time.Millisecond,
                MaxLatency:  500 * time.Millisecond,
            },
            {
                Name:        "very_slow",
                Probability: 0.1,
                MinLatency:  500 * time.Millisecond,
                MaxLatency:  2 * time.Second,
            },
        },
    }
}

// InjectLatency æ³¨å…¥å»¶è¿Ÿ
func (li *LatencyInjector) InjectLatency(ctx context.Context) error {
    pattern := li.selectPattern()
    
    latency := pattern.MinLatency + 
        time.Duration(rand.Int63n(int64(pattern.MaxLatency-pattern.MinLatency)))
    
    select {
    case <-time.After(latency):
        return nil
    case <-ctx.Done():
        return ctx.Err()
    }
}

// selectPattern é€‰æ‹©å»¶è¿Ÿæ¨¡å¼
func (li *LatencyInjector) selectPattern() LatencyPattern {
    r := rand.Float64()
    cumulative := 0.0
    
    for _, pattern := range li.patterns {
        cumulative += pattern.Probability
        if r <= cumulative {
            return pattern
        }
    }
    
    return li.patterns[0]
}
```

---

## è¿½è¸ªæ•°æ®åˆ†æ

### Trace èšåˆ

**Trace åˆ†æå™¨ï¼š**

```go
package analysis

import (
    "sort"
    "time"
    
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
)

// TraceAnalyzer Trace åˆ†æå™¨
type TraceAnalyzer struct {
    spans []sdktrace.ReadOnlySpan
}

// NewTraceAnalyzer åˆ›å»º Trace åˆ†æå™¨
func NewTraceAnalyzer(spans []sdktrace.ReadOnlySpan) *TraceAnalyzer {
    return &TraceAnalyzer{
        spans: spans,
    }
}

// GetStatistics è·å–ç»Ÿè®¡ä¿¡æ¯
func (ta *TraceAnalyzer) GetStatistics() *TraceStatistics {
    if len(ta.spans) == 0 {
        return &TraceStatistics{}
    }
    
    durations := make([]int64, len(ta.spans))
    errorCount := 0
    
    for i, span := range ta.spans {
        duration := span.EndTime().Sub(span.StartTime()).Milliseconds()
        durations[i] = duration
        
        if span.Status().Code == codes.Error {
            errorCount++
        }
    }
    
    sort.Slice(durations, func(i, j int) bool {
        return durations[i] < durations[j]
    })
    
    return &TraceStatistics{
        TotalSpans:  len(ta.spans),
        ErrorCount:  errorCount,
        MinDuration: time.Duration(durations[0]) * time.Millisecond,
        MaxDuration: time.Duration(durations[len(durations)-1]) * time.Millisecond,
        AvgDuration: time.Duration(average(durations)) * time.Millisecond,
        P50Duration: time.Duration(percentile(durations, 0.50)) * time.Millisecond,
        P95Duration: time.Duration(percentile(durations, 0.95)) * time.Millisecond,
        P99Duration: time.Duration(percentile(durations, 0.99)) * time.Millisecond,
        ErrorRate:   float64(errorCount) / float64(len(ta.spans)) * 100,
    }
}

// TraceStatistics Trace ç»Ÿè®¡
type TraceStatistics struct {
    TotalSpans  int
    ErrorCount  int
    MinDuration time.Duration
    MaxDuration time.Duration
    AvgDuration time.Duration
    P50Duration time.Duration
    P95Duration time.Duration
    P99Duration time.Duration
    ErrorRate   float64
}

// average è®¡ç®—å¹³å‡å€¼
func average(values []int64) int64 {
    sum := int64(0)
    for _, v := range values {
        sum += v
    }
    return sum / int64(len(values))
}

// percentile è®¡ç®—ç™¾åˆ†ä½æ•°
func percentile(values []int64, p float64) int64 {
    index := int(float64(len(values)) * p)
    if index >= len(values) {
        index = len(values) - 1
    }
    return values[index]
}
```

---

## æœ€ä½³å®è·µ

### 1. æµ‹è¯•éš”ç¦»

âœ… **ä½¿ç”¨ç‹¬ç«‹çš„æµ‹è¯•ç¯å¢ƒ**

```go
// âœ… Good
func TestIntegration(t *testing.T) {
    env := SetupTestEnvironment(t)
    defer env.Cleanup()
    
    // æµ‹è¯•é€»è¾‘
}

// âŒ Bad
func TestIntegration(t *testing.T) {
    // ä½¿ç”¨å…±äº«çš„å¼€å‘ç¯å¢ƒ
}
```

### 2. è¿½è¸ªéªŒè¯

âœ… **éªŒè¯è¿½è¸ªæ•°æ®çš„æ­£ç¡®æ€§**

```go
// âœ… Good
spans := ttp.GetSpans()
require.Len(t, spans, 1)
NewSpanAssertion(t, spans[0]).
    AssertName("expected-operation").
    AssertNoErrors()
```

### 3. æ€§èƒ½åŸºå‡†

âœ… **å»ºç«‹æ€§èƒ½åŸºå‡†**

```go
// âœ… Good
func BenchmarkOperation(b *testing.B) {
    b.ResetTimer()
    b.ReportAllocs()
    
    for i := 0; i < b.N; i++ {
        operation()
    }
}
```

### 4. å¯è§‚æµ‹æ€§å…³è”

âœ… **å…³è”æ—¥å¿—ã€æŒ‡æ ‡å’Œè¿½è¸ª**

```go
// âœ… Good
logger.Info(ctx, "operation completed",
    slog.String("trace_id", spanContext.TraceID().String()),
    slog.String("span_id", spanContext.SpanID().String()),
)
```

---

## å®Œæ•´ç¤ºä¾‹

```go
package main

import (
    "context"
    "testing"
    
    "github.com/stretchr/testify/require"
)

func TestUserService_Complete(t *testing.T) {
    // 1. è®¾ç½®æµ‹è¯•ç¯å¢ƒ
    ttp := NewTestTracerProvider(t)
    env := SetupTestEnvironment(t)
    defer env.Cleanup(context.Background())
    
    // 2. åˆ›å»ºæœåŠ¡
    db, _ := NewTracedDB("postgres", env.PostgresURL)
    redis, _ := NewTracedRedis(env.RedisURL)
    service := NewUserService(db, redis)
    
    // 3. åˆ›å»ºæµ‹è¯•æ•°æ®
    factory := NewTestDataFactory(t, db.DB())
    user := factory.CreateUser(context.Background(), "Test User", "test@example.com")
    
    // 4. æ‰§è¡Œæ“ä½œ
    ctx := context.Background()
    retrievedUser, err := service.GetUser(ctx, user.ID)
    
    // 5. éªŒè¯ç»“æœ
    require.NoError(t, err)
    require.Equal(t, user.Name, retrievedUser.Name)
    
    // 6. éªŒè¯è¿½è¸ª
    spans := ttp.GetSpans()
    require.NotEmpty(t, spans)
    
    for _, span := range spans {
        NewSpanAssertion(t, span).AssertNoErrors()
    }
    
    // 7. åˆ†ææ€§èƒ½
    analyzer := NewTraceAnalyzer(spans)
    stats := analyzer.GetStatistics()
    require.Less(t, stats.P95Duration.Milliseconds(), int64(100), "P95 latency should be < 100ms")
}
```

---

## æ€»ç»“

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº† Go åº”ç”¨æµ‹è¯•å’Œå¯è§‚æµ‹æ€§çš„æœ€ä½³å®è·µï¼Œæ¶µç›–ï¼š

âœ… **å•å…ƒæµ‹è¯•è¿½è¸ª** - æµ‹è¯•è¿½è¸ªå™¨ã€Mock Exporterã€Span æ–­è¨€  
âœ… **é›†æˆæµ‹è¯•è¿½è¸ª** - æµ‹è¯•å®¹å™¨ã€ç«¯åˆ°ç«¯æµ‹è¯•ã€æµ‹è¯•æ•°æ®ç®¡ç†  
âœ… **æ€§èƒ½æµ‹è¯•** - åŸºå‡†æµ‹è¯•ã€è´Ÿè½½æµ‹è¯•ã€å‹åŠ›æµ‹è¯•  
âœ… **å¯è§‚æµ‹æ€§æ¨¡å¼** - æ—¥å¿—/æŒ‡æ ‡/è¿½è¸ªå…³è”ã€å‘Šè­¦è§„åˆ™ã€Dashboard  
âœ… **æ•…éšœæ³¨å…¥** - æ··æ²Œå·¥ç¨‹ã€é”™è¯¯æ¨¡æ‹Ÿã€å»¶è¿Ÿæ³¨å…¥  
âœ… **è¿½è¸ªæ•°æ®åˆ†æ** - Trace èšåˆã€æ€§èƒ½åˆ†æã€ä¾èµ–åˆ†æ

### å…³é”®è¦ç‚¹

1. **å®Œæ•´çš„æµ‹è¯•è¦†ç›–** - å•å…ƒã€é›†æˆã€æ€§èƒ½æµ‹è¯•å…¨è¦†ç›–
2. **è¿½è¸ªéªŒè¯** - éªŒè¯è¿½è¸ªæ•°æ®çš„æ­£ç¡®æ€§å’Œå®Œæ•´æ€§
3. **ä¸‰ä½ä¸€ä½“** - æ—¥å¿—ã€æŒ‡æ ‡ã€è¿½è¸ªå…³è”
4. **æ··æ²Œå·¥ç¨‹** - é€šè¿‡æ•…éšœæ³¨å…¥éªŒè¯ç³»ç»ŸéŸ§æ€§
5. **æ•°æ®é©±åŠ¨** - ä½¿ç”¨è¿½è¸ªæ•°æ®é©±åŠ¨æ€§èƒ½ä¼˜åŒ–

### ç›¸å…³æ–‡æ¡£

- [31_Goé«˜çº§å¹¶å‘æ¨¡å¼ä¸OTLPå®Œæ•´é›†æˆ](./31_Goé«˜çº§å¹¶å‘æ¨¡å¼ä¸OTLPå®Œæ•´é›†æˆ.md)
- [34_Goå†…å­˜ç®¡ç†ä¸æ€§èƒ½è°ƒä¼˜å®æˆ˜](./34_Goå†…å­˜ç®¡ç†ä¸æ€§èƒ½è°ƒä¼˜å®æˆ˜.md)
- [35_Goç”Ÿäº§çº§éƒ¨ç½²æ¨¡å¼ä¸åæ¨¡å¼](./35_Goç”Ÿäº§çº§éƒ¨ç½²æ¨¡å¼ä¸åæ¨¡å¼.md)

---

**æœ€åæ›´æ–°ï¼š** 2025-10-09  
**ç‰ˆæœ¬ï¼š** v1.0.0  
**ä½œè€…ï¼š** OTLP Go Integration Team
