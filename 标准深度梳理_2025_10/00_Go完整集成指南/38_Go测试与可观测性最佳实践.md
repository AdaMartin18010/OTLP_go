# Go 测试与可观测性最佳实践完整指南

## 📋 目录

- [Go 测试与可观测性最佳实践完整指南](#go-测试与可观测性最佳实践完整指南)
  - [📋 目录](#-目录)
  - [文档概述](#文档概述)
    - [核心价值](#核心价值)
    - [依赖版本](#依赖版本)
  - [单元测试追踪](#单元测试追踪)
    - [测试追踪器](#测试追踪器)
    - [Mock Exporter](#mock-exporter)
    - [Span 断言](#span-断言)
  - [集成测试追踪](#集成测试追踪)
    - [测试容器](#测试容器)
    - [端到端测试](#端到端测试)
    - [测试数据管理](#测试数据管理)
  - [性能测试](#性能测试)
    - [基准测试追踪](#基准测试追踪)
    - [负载测试](#负载测试)
    - [压力测试](#压力测试)
  - [可观测性模式](#可观测性模式)
    - [日志、指标、追踪关联](#日志指标追踪关联)
    - [告警规则](#告警规则)
    - [Dashboard 设计](#dashboard-设计)
  - [故障注入](#故障注入)
    - [混沌工程](#混沌工程)
    - [错误模拟](#错误模拟)
    - [延迟注入](#延迟注入)
  - [追踪数据分析](#追踪数据分析)
    - [Trace 聚合](#trace-聚合)
  - [最佳实践](#最佳实践)
    - [1. 测试隔离](#1-测试隔离)
    - [2. 追踪验证](#2-追踪验证)
    - [3. 性能基准](#3-性能基准)
    - [4. 可观测性关联](#4-可观测性关联)
  - [完整示例](#完整示例)
  - [总结](#总结)
    - [关键要点](#关键要点)
    - [相关文档](#相关文档)

---

## 文档概述

本文档详细介绍 Go 应用测试和可观测性的最佳实践，涵盖单元测试、集成测试、性能测试和可观测性模式。

### 核心价值

✅ **完整的测试覆盖** - 单元、集成、性能测试  
✅ **追踪测试** - 验证追踪数据的正确性  
✅ **可观测性关联** - 日志、指标、追踪三位一体  
✅ **故障注入** - 混沌工程和错误模拟  
✅ **性能分析** - 追踪数据驱动的性能优化

### 依赖版本

```go
go.opentelemetry.io/otel v1.32.0
go.opentelemetry.io/otel/sdk v1.32.0
go.opentelemetry.io/otel/sdk/metric v1.32.0
github.com/stretchr/testify v1.10.0
github.com/testcontainers/testcontainers-go v0.34.0
```

---

## 单元测试追踪

### 测试追踪器

**创建测试专用的追踪器：**

```go
package testing

import (
    "context"
    "testing"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    "go.opentelemetry.io/otel/sdk/trace/tracetest"
    semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
)

// TestTracerProvider 测试用追踪器
type TestTracerProvider struct {
    provider *sdktrace.TracerProvider
    exporter *tracetest.InMemoryExporter
}

// NewTestTracerProvider 创建测试追踪器
func NewTestTracerProvider(t *testing.T) *TestTracerProvider {
    exporter := tracetest.NewInMemoryExporter()
    
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithSyncer(exporter),
        sdktrace.WithResource(resource.NewWithAttributes(
            semconv.SchemaURL,
            semconv.ServiceName("test-service"),
        )),
    )
    
    otel.SetTracerProvider(tp)
    
    ttp := &TestTracerProvider{
        provider: tp,
        exporter: exporter,
    }
    
    // 清理
    t.Cleanup(func() {
        if err := tp.Shutdown(context.Background()); err != nil {
            t.Errorf("failed to shutdown tracer provider: %v", err)
        }
    })
    
    return ttp
}

// GetSpans 获取所有 Span
func (ttp *TestTracerProvider) GetSpans() []sdktrace.ReadOnlySpan {
    return ttp.exporter.GetSpans()
}

// Reset 重置 Exporter
func (ttp *TestTracerProvider) Reset() {
    ttp.exporter.Reset()
}

// Provider 获取 TracerProvider
func (ttp *TestTracerProvider) Provider() *sdktrace.TracerProvider {
    return ttp.provider
}
```

### Mock Exporter

**Mock Exporter 实现：**

```go
package testing

import (
    "context"
    "sync"
    
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
)

// MockExporter Mock Exporter
type MockExporter struct {
    mu     sync.Mutex
    spans  []sdktrace.ReadOnlySpan
    errors []error
}

// NewMockExporter 创建 Mock Exporter
func NewMockExporter() *MockExporter {
    return &MockExporter{
        spans:  make([]sdktrace.ReadOnlySpan, 0),
        errors: make([]error, 0),
    }
}

// ExportSpans 导出 Spans
func (me *MockExporter) ExportSpans(ctx context.Context, spans []sdktrace.ReadOnlySpan) error {
    me.mu.Lock()
    defer me.mu.Unlock()
    
    me.spans = append(me.spans, spans...)
    return nil
}

// Shutdown 关闭
func (me *MockExporter) Shutdown(ctx context.Context) error {
    return nil
}

// GetSpans 获取所有 Span
func (me *MockExporter) GetSpans() []sdktrace.ReadOnlySpan {
    me.mu.Lock()
    defer me.mu.Unlock()
    
    result := make([]sdktrace.ReadOnlySpan, len(me.spans))
    copy(result, me.spans)
    return result
}

// Reset 重置
func (me *MockExporter) Reset() {
    me.mu.Lock()
    defer me.mu.Unlock()
    
    me.spans = make([]sdktrace.ReadOnlySpan, 0)
    me.errors = make([]error, 0)
}

// GetSpansByName 根据名称获取 Span
func (me *MockExporter) GetSpansByName(name string) []sdktrace.ReadOnlySpan {
    me.mu.Lock()
    defer me.mu.Unlock()
    
    result := make([]sdktrace.ReadOnlySpan, 0)
    for _, span := range me.spans {
        if span.Name() == name {
            result = append(result, span)
        }
    }
    return result
}
```

### Span 断言

**Span 断言工具：**

```go
package testing

import (
    "testing"
    
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    "go.opentelemetry.io/otel/trace"
)

// SpanAssertion Span 断言
type SpanAssertion struct {
    t    *testing.T
    span sdktrace.ReadOnlySpan
}

// NewSpanAssertion 创建 Span 断言
func NewSpanAssertion(t *testing.T, span sdktrace.ReadOnlySpan) *SpanAssertion {
    return &SpanAssertion{
        t:    t,
        span: span,
    }
}

// AssertName 断言名称
func (sa *SpanAssertion) AssertName(expected string) *SpanAssertion {
    assert.Equal(sa.t, expected, sa.span.Name(), "span name mismatch")
    return sa
}

// AssertStatus 断言状态
func (sa *SpanAssertion) AssertStatus(expectedCode codes.Code, expectedMessage string) *SpanAssertion {
    status := sa.span.Status()
    assert.Equal(sa.t, expectedCode, status.Code, "span status code mismatch")
    if expectedMessage != "" {
        assert.Equal(sa.t, expectedMessage, status.Description, "span status message mismatch")
    }
    return sa
}

// AssertAttribute 断言属性
func (sa *SpanAssertion) AssertAttribute(key string, value interface{}) *SpanAssertion {
    attrs := sa.span.Attributes()
    
    found := false
    for _, attr := range attrs {
        if string(attr.Key) == key {
            found = true
            switch v := value.(type) {
            case string:
                assert.Equal(sa.t, v, attr.Value.AsString(), "attribute value mismatch for key %s", key)
            case int:
                assert.Equal(sa.t, int64(v), attr.Value.AsInt64(), "attribute value mismatch for key %s", key)
            case int64:
                assert.Equal(sa.t, v, attr.Value.AsInt64(), "attribute value mismatch for key %s", key)
            case bool:
                assert.Equal(sa.t, v, attr.Value.AsBool(), "attribute value mismatch for key %s", key)
            case float64:
                assert.Equal(sa.t, v, attr.Value.AsFloat64(), "attribute value mismatch for key %s", key)
            }
            break
        }
    }
    
    assert.True(sa.t, found, "attribute %s not found", key)
    return sa
}

// AssertHasAttributes 断言包含属性
func (sa *SpanAssertion) AssertHasAttributes(keys ...string) *SpanAssertion {
    attrs := sa.span.Attributes()
    attrMap := make(map[string]bool)
    
    for _, attr := range attrs {
        attrMap[string(attr.Key)] = true
    }
    
    for _, key := range keys {
        assert.True(sa.t, attrMap[key], "attribute %s not found", key)
    }
    
    return sa
}

// AssertSpanKind 断言 Span 类型
func (sa *SpanAssertion) AssertSpanKind(expected trace.SpanKind) *SpanAssertion {
    assert.Equal(sa.t, expected, sa.span.SpanKind(), "span kind mismatch")
    return sa
}

// AssertParent 断言父 Span
func (sa *SpanAssertion) AssertParent(expectedParentSpanID trace.SpanID) *SpanAssertion {
    assert.Equal(sa.t, expectedParentSpanID, sa.span.Parent().SpanID(), "parent span ID mismatch")
    return sa
}

// AssertEvents 断言事件
func (sa *SpanAssertion) AssertEvents(eventNames ...string) *SpanAssertion {
    events := sa.span.Events()
    assert.Equal(sa.t, len(eventNames), len(events), "event count mismatch")
    
    for i, expected := range eventNames {
        assert.Equal(sa.t, expected, events[i].Name, "event name mismatch at index %d", i)
    }
    
    return sa
}

// AssertNoErrors 断言没有错误
func (sa *SpanAssertion) AssertNoErrors() *SpanAssertion {
    status := sa.span.Status()
    assert.NotEqual(sa.t, codes.Error, status.Code, "span should not have error status")
    return sa
}

// AssertDuration 断言持续时间
func (sa *SpanAssertion) AssertDuration(minMs, maxMs int64) *SpanAssertion {
    duration := sa.span.EndTime().Sub(sa.span.StartTime()).Milliseconds()
    assert.GreaterOrEqual(sa.t, duration, minMs, "span duration too short")
    assert.LessOrEqual(sa.t, duration, maxMs, "span duration too long")
    return sa
}
```

**使用示例：**

```go
package service

import (
    "context"
    "testing"
    
    "github.com/stretchr/testify/require"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

func TestUserService_GetUser(t *testing.T) {
    // 1. 创建测试追踪器
    ttp := NewTestTracerProvider(t)
    
    // 2. 创建服务
    service := NewUserService()
    
    // 3. 执行操作
    ctx := context.Background()
    user, err := service.GetUser(ctx, "123")
    require.NoError(t, err)
    require.NotNil(t, user)
    
    // 4. 验证 Spans
    spans := ttp.GetSpans()
    require.Len(t, spans, 1)
    
    // 5. 断言 Span 属性
    NewSpanAssertion(t, spans[0]).
        AssertName("get-user").
        AssertStatus(codes.Ok, "").
        AssertAttribute("user.id", "123").
        AssertHasAttributes("user.name", "user.email").
        AssertSpanKind(trace.SpanKindInternal).
        AssertNoErrors().
        AssertDuration(0, 1000)
}

func TestUserService_GetUser_NotFound(t *testing.T) {
    ttp := NewTestTracerProvider(t)
    service := NewUserService()
    
    ctx := context.Background()
    user, err := service.GetUser(ctx, "999")
    require.Error(t, err)
    require.Nil(t, user)
    
    spans := ttp.GetSpans()
    require.Len(t, spans, 1)
    
    NewSpanAssertion(t, spans[0]).
        AssertName("get-user").
        AssertStatus(codes.Error, "user not found").
        AssertAttribute("user.id", "999")
}
```

---

## 集成测试追踪

### 测试容器

**使用 Testcontainers 进行集成测试：**

```go
package integration

import (
    "context"
    "testing"
    "time"
    
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/wait"
)

// TestEnvironment 测试环境
type TestEnvironment struct {
    PostgresContainer testcontainers.Container
    RedisContainer    testcontainers.Container
    OTLPContainer     testcontainers.Container
    
    PostgresURL string
    RedisURL    string
    OTLPURL     string
}

// SetupTestEnvironment 设置测试环境
func SetupTestEnvironment(t *testing.T) *TestEnvironment {
    ctx := context.Background()
    
    env := &TestEnvironment{}
    
    // 1. PostgreSQL
    postgresReq := testcontainers.ContainerRequest{
        Image:        "postgres:16",
        ExposedPorts: []string{"5432/tcp"},
        Env: map[string]string{
            "POSTGRES_PASSWORD": "test",
            "POSTGRES_DB":       "testdb",
        },
        WaitingFor: wait.ForLog("database system is ready to accept connections").
            WithStartupTimeout(60 * time.Second),
    }
    
    postgresContainer, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
        ContainerRequest: postgresReq,
        Started:          true,
    })
    if err != nil {
        t.Fatal(err)
    }
    
    postgresHost, _ := postgresContainer.Host(ctx)
    postgresPort, _ := postgresContainer.MappedPort(ctx, "5432")
    env.PostgresURL = fmt.Sprintf("postgresql://postgres:test@%s:%s/testdb?sslmode=disable", 
        postgresHost, postgresPort.Port())
    env.PostgresContainer = postgresContainer
    
    // 2. Redis
    redisReq := testcontainers.ContainerRequest{
        Image:        "redis:7",
        ExposedPorts: []string{"6379/tcp"},
        WaitingFor:   wait.ForLog("Ready to accept connections"),
    }
    
    redisContainer, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
        ContainerRequest: redisReq,
        Started:          true,
    })
    if err != nil {
        t.Fatal(err)
    }
    
    redisHost, _ := redisContainer.Host(ctx)
    redisPort, _ := redisContainer.MappedPort(ctx, "6379")
    env.RedisURL = fmt.Sprintf("%s:%s", redisHost, redisPort.Port())
    env.RedisContainer = redisContainer
    
    // 3. OTLP Collector
    otlpReq := testcontainers.ContainerRequest{
        Image:        "otel/opentelemetry-collector:latest",
        ExposedPorts: []string{"4317/tcp", "4318/tcp"},
        WaitingFor:   wait.ForLog("Everything is ready"),
    }
    
    otlpContainer, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
        ContainerRequest: otlpReq,
        Started:          true,
    })
    if err != nil {
        t.Fatal(err)
    }
    
    otlpHost, _ := otlpContainer.Host(ctx)
    otlpPort, _ := otlpContainer.MappedPort(ctx, "4317")
    env.OTLPURL = fmt.Sprintf("%s:%s", otlpHost, otlpPort.Port())
    env.OTLPContainer = otlpContainer
    
    // 清理
    t.Cleanup(func() {
        env.Cleanup(context.Background())
    })
    
    return env
}

// Cleanup 清理测试环境
func (env *TestEnvironment) Cleanup(ctx context.Context) {
    if env.PostgresContainer != nil {
        env.PostgresContainer.Terminate(ctx)
    }
    if env.RedisContainer != nil {
        env.RedisContainer.Terminate(ctx)
    }
    if env.OTLPContainer != nil {
        env.OTLPContainer.Terminate(ctx)
    }
}
```

### 端到端测试

**端到端测试示例：**

```go
package integration

import (
    "context"
    "testing"
    "time"
    
    "github.com/stretchr/testify/require"
)

func TestUserService_E2E(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping integration test")
    }
    
    // 1. 设置测试环境
    env := SetupTestEnvironment(t)
    
    // 2. 初始化服务
    db, err := NewTracedDB("postgres", env.PostgresURL)
    require.NoError(t, err)
    defer db.Close()
    
    redis, err := NewTracedRedis(env.RedisURL)
    require.NoError(t, err)
    defer redis.Close()
    
    // 3. 初始化 OTLP
    tp, err := initTracing(context.Background(), env.OTLPURL)
    require.NoError(t, err)
    defer tp.Shutdown(context.Background())
    
    // 4. 创建服务
    userService := NewUserService(db, redis)
    
    // 5. 测试创建用户
    ctx := context.Background()
    user := &User{
        Name:  "Test User",
        Email: "test@example.com",
    }
    
    err = userService.CreateUser(ctx, user)
    require.NoError(t, err)
    require.NotZero(t, user.ID)
    
    // 6. 测试获取用户
    retrievedUser, err := userService.GetUser(ctx, user.ID)
    require.NoError(t, err)
    require.Equal(t, user.Name, retrievedUser.Name)
    require.Equal(t, user.Email, retrievedUser.Email)
    
    // 7. 测试缓存
    start := time.Now()
    cachedUser, err := userService.GetUser(ctx, user.ID)
    duration := time.Since(start)
    require.NoError(t, err)
    require.Equal(t, user.Name, cachedUser.Name)
    require.Less(t, duration, 10*time.Millisecond, "should be served from cache")
    
    // 8. 测试更新用户
    user.Name = "Updated User"
    err = userService.UpdateUser(ctx, user)
    require.NoError(t, err)
    
    // 9. 验证更新
    updatedUser, err := userService.GetUser(ctx, user.ID)
    require.NoError(t, err)
    require.Equal(t, "Updated User", updatedUser.Name)
    
    // 10. 测试删除用户
    err = userService.DeleteUser(ctx, user.ID)
    require.NoError(t, err)
    
    // 11. 验证删除
    _, err = userService.GetUser(ctx, user.ID)
    require.Error(t, err)
}
```

### 测试数据管理

**测试数据工厂：**

```go
package testing

import (
    "context"
    "database/sql"
    "testing"
)

// TestDataFactory 测试数据工厂
type TestDataFactory struct {
    db *sql.DB
    t  *testing.T
}

// NewTestDataFactory 创建测试数据工厂
func NewTestDataFactory(t *testing.T, db *sql.DB) *TestDataFactory {
    return &TestDataFactory{
        db: db,
        t:  t,
    }
}

// CreateUser 创建测试用户
func (tdf *TestDataFactory) CreateUser(ctx context.Context, name, email string) *User {
    user := &User{
        Name:  name,
        Email: email,
    }
    
    query := `INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id`
    err := tdf.db.QueryRowContext(ctx, query, user.Name, user.Email).Scan(&user.ID)
    if err != nil {
        tdf.t.Fatal(err)
    }
    
    // 注册清理
    tdf.t.Cleanup(func() {
        tdf.db.ExecContext(context.Background(), "DELETE FROM users WHERE id = $1", user.ID)
    })
    
    return user
}

// CreateUsers 批量创建测试用户
func (tdf *TestDataFactory) CreateUsers(ctx context.Context, count int) []*User {
    users := make([]*User, count)
    
    for i := 0; i < count; i++ {
        users[i] = tdf.CreateUser(ctx, 
            fmt.Sprintf("User %d", i), 
            fmt.Sprintf("user%d@example.com", i))
    }
    
    return users
}

// CleanupAll 清理所有测试数据
func (tdf *TestDataFactory) CleanupAll(ctx context.Context) {
    tables := []string{"orders", "users", "products"}
    
    for _, table := range tables {
        _, err := tdf.db.ExecContext(ctx, fmt.Sprintf("DELETE FROM %s", table))
        if err != nil {
            tdf.t.Logf("failed to cleanup table %s: %v", table, err)
        }
    }
}
```

---

## 性能测试

### 基准测试追踪

**基准测试集成：**

```go
package benchmark

import (
    "context"
    "testing"
    
    "go.opentelemetry.io/otel"
)

func BenchmarkUserService_GetUser(b *testing.B) {
    // 1. 设置
    ttp := NewTestTracerProvider(&testing.T{})
    service := NewUserService()
    ctx := context.Background()
    
    // 2. 预热
    service.GetUser(ctx, "123")
    
    // 3. 重置追踪器
    ttp.Reset()
    
    // 4. 基准测试
    b.ResetTimer()
    b.ReportAllocs()
    
    for i := 0; i < b.N; i++ {
        service.GetUser(ctx, "123")
    }
    
    b.StopTimer()
    
    // 5. 报告追踪统计
    spans := ttp.GetSpans()
    b.ReportMetric(float64(len(spans)), "spans")
    
    if len(spans) > 0 {
        totalDuration := int64(0)
        for _, span := range spans {
            totalDuration += span.EndTime().Sub(span.StartTime()).Microseconds()
        }
        avgDuration := totalDuration / int64(len(spans))
        b.ReportMetric(float64(avgDuration), "span_μs/op")
    }
}

func BenchmarkWithTracingOverhead(b *testing.B) {
    ctx := context.Background()
    tracer := otel.Tracer("benchmark")
    
    b.Run("without-tracing", func(b *testing.B) {
        for i := 0; i < b.N; i++ {
            doWork()
        }
    })
    
    b.Run("with-tracing", func(b *testing.B) {
        for i := 0; i < b.N; i++ {
            _, span := tracer.Start(ctx, "do-work")
            doWork()
            span.End()
        }
    })
}

func doWork() {
    // 模拟工作负载
    sum := 0
    for i := 0; i < 1000; i++ {
        sum += i
    }
}
```

### 负载测试

**负载测试工具：**

```go
package loadtest

import (
    "context"
    "sync"
    "sync/atomic"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// LoadTester 负载测试器
type LoadTester struct {
    target      func(context.Context) error
    concurrency int
    duration    time.Duration
    tracer      trace.Tracer
    
    // 统计
    totalRequests   int64
    successRequests int64
    failedRequests  int64
    totalDuration   int64
}

// NewLoadTester 创建负载测试器
func NewLoadTester(target func(context.Context) error, concurrency int, duration time.Duration) *LoadTester {
    return &LoadTester{
        target:      target,
        concurrency: concurrency,
        duration:    duration,
        tracer:      otel.Tracer("load-tester"),
    }
}

// Run 执行负载测试
func (lt *LoadTester) Run(ctx context.Context) *LoadTestResult {
    ctx, span := lt.tracer.Start(ctx, "load-test",
        trace.WithAttributes(
            attribute.Int("load_test.concurrency", lt.concurrency),
            attribute.Int64("load_test.duration_sec", int64(lt.duration.Seconds())),
        ),
    )
    defer span.End()
    
    var wg sync.WaitGroup
    stopCh := make(chan struct{})
    
    // 启动 worker
    for i := 0; i < lt.concurrency; i++ {
        wg.Add(1)
        go func(workerID int) {
            defer wg.Done()
            lt.worker(ctx, workerID, stopCh)
        }(i)
    }
    
    // 等待测试完成
    time.Sleep(lt.duration)
    close(stopCh)
    wg.Wait()
    
    // 计算结果
    result := &LoadTestResult{
        TotalRequests:   atomic.LoadInt64(&lt.totalRequests),
        SuccessRequests: atomic.LoadInt64(&lt.successRequests),
        FailedRequests:  atomic.LoadInt64(&lt.failedRequests),
        Duration:        lt.duration,
        Concurrency:     lt.concurrency,
    }
    
    if result.TotalRequests > 0 {
        result.RPS = float64(result.TotalRequests) / lt.duration.Seconds()
        result.AvgDuration = time.Duration(atomic.LoadInt64(&lt.totalDuration) / result.TotalRequests)
        result.SuccessRate = float64(result.SuccessRequests) / float64(result.TotalRequests) * 100
    }
    
    // 记录结果到 Span
    span.SetAttributes(
        attribute.Int64("load_test.total_requests", result.TotalRequests),
        attribute.Int64("load_test.success_requests", result.SuccessRequests),
        attribute.Int64("load_test.failed_requests", result.FailedRequests),
        attribute.Float64("load_test.rps", result.RPS),
        attribute.Float64("load_test.success_rate", result.SuccessRate),
    )
    
    return result
}

// worker 工作协程
func (lt *LoadTester) worker(ctx context.Context, workerID int, stopCh <-chan struct{}) {
    for {
        select {
        case <-stopCh:
            return
        default:
            start := time.Now()
            err := lt.target(ctx)
            duration := time.Since(start)
            
            atomic.AddInt64(&lt.totalRequests, 1)
            atomic.AddInt64(&lt.totalDuration, int64(duration))
            
            if err != nil {
                atomic.AddInt64(&lt.failedRequests, 1)
            } else {
                atomic.AddInt64(&lt.successRequests, 1)
            }
        }
    }
}

// LoadTestResult 负载测试结果
type LoadTestResult struct {
    TotalRequests   int64
    SuccessRequests int64
    FailedRequests  int64
    Duration        time.Duration
    Concurrency     int
    RPS             float64
    AvgDuration     time.Duration
    SuccessRate     float64
}

// Print 打印结果
func (r *LoadTestResult) Print() {
    fmt.Printf("Load Test Results:\n")
    fmt.Printf("  Duration:        %v\n", r.Duration)
    fmt.Printf("  Concurrency:     %d\n", r.Concurrency)
    fmt.Printf("  Total Requests:  %d\n", r.TotalRequests)
    fmt.Printf("  Success:         %d (%.2f%%)\n", r.SuccessRequests, r.SuccessRate)
    fmt.Printf("  Failed:          %d\n", r.FailedRequests)
    fmt.Printf("  RPS:             %.2f\n", r.RPS)
    fmt.Printf("  Avg Duration:    %v\n", r.AvgDuration)
}
```

**使用示例：**

```go
func TestLoadTest(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping load test")
    }
    
    // 创建服务
    service := NewUserService()
    
    // 定义测试目标
    target := func(ctx context.Context) error {
        _, err := service.GetUser(ctx, "123")
        return err
    }
    
    // 执行负载测试
    tester := NewLoadTester(target, 100, 30*time.Second)
    result := tester.Run(context.Background())
    
    // 打印结果
    result.Print()
    
    // 断言
    require.Greater(t, result.SuccessRate, 95.0, "success rate should be > 95%")
    require.Greater(t, result.RPS, 1000.0, "RPS should be > 1000")
}
```

### 压力测试

**压力测试器：**

```go
package loadtest

import (
    "context"
    "time"
)

// StressTester 压力测试器
type StressTester struct {
    target         func(context.Context) error
    startConcurrency int
    maxConcurrency   int
    stepDuration     time.Duration
    step             int
}

// NewStressTester 创建压力测试器
func NewStressTester(target func(context.Context) error, startConcurrency, maxConcurrency, step int, stepDuration time.Duration) *StressTester {
    return &StressTester{
        target:           target,
        startConcurrency: startConcurrency,
        maxConcurrency:   maxConcurrency,
        step:             step,
        stepDuration:     stepDuration,
    }
}

// Run 执行压力测试
func (st *StressTester) Run(ctx context.Context) []*LoadTestResult {
    results := make([]*LoadTestResult, 0)
    
    for concurrency := st.startConcurrency; concurrency <= st.maxConcurrency; concurrency += st.step {
        fmt.Printf("Testing with concurrency: %d\n", concurrency)
        
        tester := NewLoadTester(st.target, concurrency, st.stepDuration)
        result := tester.Run(ctx)
        result.Print()
        
        results = append(results, result)
        
        // 检查是否达到饱和点
        if result.SuccessRate < 90.0 {
            fmt.Printf("Saturation point reached at concurrency: %d\n", concurrency)
            break
        }
        
        // 短暂休息
        time.Sleep(5 * time.Second)
    }
    
    return results
}
```

---

## 可观测性模式

### 日志、指标、追踪关联

**关联 ID 传播：**

```go
package observability

import (
    "context"
    "log/slog"
    
    "go.opentelemetry.io/otel/trace"
)

// ContextLogger 带 Context 的日志记录器
type ContextLogger struct {
    logger *slog.Logger
}

// NewContextLogger 创建 Context 日志记录器
func NewContextLogger(logger *slog.Logger) *ContextLogger {
    return &ContextLogger{
        logger: logger,
    }
}

// Info 记录 Info 日志
func (cl *ContextLogger) Info(ctx context.Context, msg string, args ...any) {
    cl.logWithTrace(ctx, slog.LevelInfo, msg, args...)
}

// Error 记录 Error 日志
func (cl *ContextLogger) Error(ctx context.Context, msg string, args ...any) {
    cl.logWithTrace(ctx, slog.LevelError, msg, args...)
}

// logWithTrace 记录带追踪信息的日志
func (cl *ContextLogger) logWithTrace(ctx context.Context, level slog.Level, msg string, args ...any) {
    span := trace.SpanFromContext(ctx)
    spanContext := span.SpanContext()
    
    // 添加追踪信息
    enrichedArgs := append(args,
        slog.String("trace_id", spanContext.TraceID().String()),
        slog.String("span_id", spanContext.SpanID().String()),
    )
    
    cl.logger.Log(ctx, level, msg, enrichedArgs...)
}
```

**统一可观测性上下文：**

```go
package observability

import (
    "context"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
)

// ObservabilityContext 可观测性上下文
type ObservabilityContext struct {
    ctx    context.Context
    tracer trace.Tracer
    meter  metric.Meter
    logger *ContextLogger
}

// NewObservabilityContext 创建可观测性上下文
func NewObservabilityContext(ctx context.Context, serviceName string) *ObservabilityContext {
    return &ObservabilityContext{
        ctx:    ctx,
        tracer: otel.Tracer(serviceName),
        meter:  otel.Meter(serviceName),
        logger: NewContextLogger(slog.Default()),
    }
}

// StartOperation 开始操作
func (oc *ObservabilityContext) StartOperation(operationName string, attrs ...attribute.KeyValue) *Operation {
    ctx, span := oc.tracer.Start(oc.ctx, operationName,
        trace.WithAttributes(attrs...),
    )
    
    return &Operation{
        ctx:    ctx,
        span:   span,
        meter:  oc.meter,
        logger: oc.logger,
        start:  time.Now(),
    }
}

// Operation 操作
type Operation struct {
    ctx    context.Context
    span   trace.Span
    meter  metric.Meter
    logger *ContextLogger
    start  time.Time
}

// End 结束操作
func (op *Operation) End(err error) {
    duration := time.Since(op.start)
    
    // 1. 记录追踪
    if err != nil {
        op.span.RecordError(err)
        op.span.SetStatus(codes.Error, err.Error())
    } else {
        op.span.SetStatus(codes.Ok, "")
    }
    op.span.End()
    
    // 2. 记录指标
    counter, _ := op.meter.Int64Counter("operations.total")
    histogram, _ := op.meter.Float64Histogram("operations.duration")
    
    attrs := []attribute.KeyValue{
        attribute.String("operation", op.span.Name()),
    }
    
    if err != nil {
        attrs = append(attrs, attribute.Bool("error", true))
    } else {
        attrs = append(attrs, attribute.Bool("error", false))
    }
    
    counter.Add(op.ctx, 1, metric.WithAttributes(attrs...))
    histogram.Record(op.ctx, float64(duration.Milliseconds()), metric.WithAttributes(attrs...))
    
    // 3. 记录日志
    if err != nil {
        op.logger.Error(op.ctx, "operation failed",
            slog.String("operation", op.span.Name()),
            slog.Duration("duration", duration),
            slog.Any("error", err),
        )
    } else {
        op.logger.Info(op.ctx, "operation completed",
            slog.String("operation", op.span.Name()),
            slog.Duration("duration", duration),
        )
    }
}

// Context 获取 Context
func (op *Operation) Context() context.Context {
    return op.ctx
}
```

### 告警规则

**Prometheus 告警规则：**

```yaml
# alerts.yaml
groups:
- name: application_alerts
  interval: 30s
  rules:
  # 错误率告警
  - alert: HighErrorRate
    expr: |
      sum(rate(operations_total{error="true"}[5m])) / 
      sum(rate(operations_total[5m])) > 0.05
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "High error rate detected"
      description: "Error rate is {{ $value | humanizePercentage }} (threshold: 5%)"
  
  # 延迟告警
  - alert: HighLatency
    expr: |
      histogram_quantile(0.95, 
        rate(operations_duration_bucket[5m])
      ) > 1000
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "High latency detected"
      description: "P95 latency is {{ $value }}ms (threshold: 1000ms)"
  
  # 慢查询告警
  - alert: SlowQuery
    expr: |
      rate(db_query_duration_sum[5m]) / 
      rate(db_query_duration_count[5m]) > 100
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "Slow database queries detected"
      description: "Average query time is {{ $value }}ms (threshold: 100ms)"
  
  # 数据库连接池告警
  - alert: DatabaseConnectionPoolExhausted
    expr: db_connections_active >= db_connections_max * 0.9
    for: 5m
    labels:
      severity: critical
    annotations:
      summary: "Database connection pool nearly exhausted"
      description: "Active connections: {{ $value }} ({{ $value | humanizePercentage }} of max)"
  
  # 缓存命中率告警
  - alert: LowCacheHitRate
    expr: |
      sum(rate(cache_hit[5m])) / 
      (sum(rate(cache_hit[5m])) + sum(rate(cache_miss[5m]))) < 0.8
    for: 10m
    labels:
      severity: warning
    annotations:
      summary: "Low cache hit rate"
      description: "Cache hit rate is {{ $value | humanizePercentage }} (threshold: 80%)"
```

### Dashboard 设计

**Grafana Dashboard JSON：**

```json
{
  "dashboard": {
    "title": "Go Application Observability",
    "panels": [
      {
        "title": "Request Rate",
        "targets": [
          {
            "expr": "sum(rate(http_server_requests_total[5m])) by (http_route)"
          }
        ]
      },
      {
        "title": "Error Rate",
        "targets": [
          {
            "expr": "sum(rate(http_server_requests_total{error=\"true\"}[5m])) / sum(rate(http_server_requests_total[5m]))"
          }
        ]
      },
      {
        "title": "Latency Percentiles",
        "targets": [
          {
            "expr": "histogram_quantile(0.50, rate(http_server_duration_bucket[5m]))",
            "legendFormat": "p50"
          },
          {
            "expr": "histogram_quantile(0.95, rate(http_server_duration_bucket[5m]))",
            "legendFormat": "p95"
          },
          {
            "expr": "histogram_quantile(0.99, rate(http_server_duration_bucket[5m]))",
            "legendFormat": "p99"
          }
        ]
      },
      {
        "title": "Database Query Duration",
        "targets": [
          {
            "expr": "rate(db_query_duration_sum[5m]) / rate(db_query_duration_count[5m])"
          }
        ]
      },
      {
        "title": "Cache Hit Rate",
        "targets": [
          {
            "expr": "sum(rate(cache_hit[5m])) / (sum(rate(cache_hit[5m])) + sum(rate(cache_miss[5m])))"
          }
        ]
      },
      {
        "title": "Database Connection Pool",
        "targets": [
          {
            "expr": "db_connections_active",
            "legendFormat": "active"
          },
          {
            "expr": "db_connections_idle",
            "legendFormat": "idle"
          },
          {
            "expr": "db_connections_max",
            "legendFormat": "max"
          }
        ]
      }
    ]
  }
}
```

---

## 故障注入

### 混沌工程

**混沌工程工具：**

```go
package chaos

import (
    "context"
    "errors"
    "math/rand"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// ChaosInjector 混沌注入器
type ChaosInjector struct {
    errorRate    float64  // 错误率 (0.0 - 1.0)
    latencyMin   time.Duration
    latencyMax   time.Duration
    latencyRate  float64  // 延迟注入率 (0.0 - 1.0)
    tracer       trace.Tracer
    enabled      bool
}

// NewChaosInjector 创建混沌注入器
func NewChaosInjector(errorRate, latencyRate float64, latencyMin, latencyMax time.Duration) *ChaosInjector {
    return &ChaosInjector{
        errorRate:   errorRate,
        latencyMin:  latencyMin,
        latencyMax:  latencyMax,
        latencyRate: latencyRate,
        tracer:      otel.Tracer("chaos-injector"),
        enabled:     true,
    }
}

// Execute 执行操作（带混沌注入）
func (ci *ChaosInjector) Execute(ctx context.Context, operation func(context.Context) error) error {
    if !ci.enabled {
        return operation(ctx)
    }
    
    ctx, span := ci.tracer.Start(ctx, "chaos-injection")
    defer span.End()
    
    // 1. 注入延迟
    if rand.Float64() < ci.latencyRate {
        latency := ci.latencyMin + time.Duration(rand.Int63n(int64(ci.latencyMax-ci.latencyMin)))
        
        span.AddEvent("injecting latency",
            trace.WithAttributes(
                attribute.Int64("latency_ms", latency.Milliseconds()),
            ),
        )
        
        select {
        case <-time.After(latency):
        case <-ctx.Done():
            return ctx.Err()
        }
    }
    
    // 2. 注入错误
    if rand.Float64() < ci.errorRate {
        err := errors.New("chaos: injected error")
        
        span.AddEvent("injecting error")
        span.RecordError(err)
        
        return err
    }
    
    // 3. 正常执行
    return operation(ctx)
}

// Enable 启用混沌注入
func (ci *ChaosInjector) Enable() {
    ci.enabled = true
}

// Disable 禁用混沌注入
func (ci *ChaosInjector) Disable() {
    ci.enabled = false
}
```

**使用示例：**

```go
func TestWithChaos(t *testing.T) {
    // 创建混沌注入器
    chaos := NewChaosInjector(
        0.1,           // 10% 错误率
        0.2,           // 20% 延迟注入率
        100*time.Millisecond,
        500*time.Millisecond,
    )
    
    // 创建服务
    service := NewUserService()
    
    // 执行多次测试
    successCount := 0
    errorCount := 0
    
    for i := 0; i < 100; i++ {
        err := chaos.Execute(context.Background(), func(ctx context.Context) error {
            _, err := service.GetUser(ctx, "123")
            return err
        })
        
        if err != nil {
            errorCount++
        } else {
            successCount++
        }
    }
    
    fmt.Printf("Success: %d, Errors: %d\n", successCount, errorCount)
    
    // 验证错误率在预期范围内
    actualErrorRate := float64(errorCount) / 100.0
    require.InDelta(t, 0.1, actualErrorRate, 0.05, "error rate should be close to 10%")
}
```

### 错误模拟

**错误模拟器：**

```go
package chaos

import (
    "context"
    "database/sql"
    "errors"
    "math/rand"
)

// ErrorSimulator 错误模拟器
type ErrorSimulator struct {
    scenarios []ErrorScenario
}

// ErrorScenario 错误场景
type ErrorScenario struct {
    Name        string
    Probability float64
    Error       error
}

// NewErrorSimulator 创建错误模拟器
func NewErrorSimulator() *ErrorSimulator {
    return &ErrorSimulator{
        scenarios: []ErrorScenario{
            {
                Name:        "database_connection_lost",
                Probability: 0.01,
                Error:       sql.ErrConnDone,
            },
            {
                Name:        "context_deadline_exceeded",
                Probability: 0.02,
                Error:       context.DeadlineExceeded,
            },
            {
                Name:        "context_canceled",
                Probability: 0.01,
                Error:       context.Canceled,
            },
            {
                Name:        "network_timeout",
                Probability: 0.03,
                Error:       errors.New("network timeout"),
            },
        },
    }
}

// SimulateError 模拟错误
func (es *ErrorSimulator) SimulateError() error {
    for _, scenario := range es.scenarios {
        if rand.Float64() < scenario.Probability {
            return scenario.Error
        }
    }
    return nil
}
```

### 延迟注入

**延迟注入器：**

```go
package chaos

import (
    "context"
    "math/rand"
    "time"
)

// LatencyInjector 延迟注入器
type LatencyInjector struct {
    patterns []LatencyPattern
}

// LatencyPattern 延迟模式
type LatencyPattern struct {
    Name        string
    Probability float64
    MinLatency  time.Duration
    MaxLatency  time.Duration
}

// NewLatencyInjector 创建延迟注入器
func NewLatencyInjector() *LatencyInjector {
    return &LatencyInjector{
        patterns: []LatencyPattern{
            {
                Name:        "normal",
                Probability: 0.7,
                MinLatency:  10 * time.Millisecond,
                MaxLatency:  50 * time.Millisecond,
            },
            {
                Name:        "slow",
                Probability: 0.2,
                MinLatency:  100 * time.Millisecond,
                MaxLatency:  500 * time.Millisecond,
            },
            {
                Name:        "very_slow",
                Probability: 0.1,
                MinLatency:  500 * time.Millisecond,
                MaxLatency:  2 * time.Second,
            },
        },
    }
}

// InjectLatency 注入延迟
func (li *LatencyInjector) InjectLatency(ctx context.Context) error {
    pattern := li.selectPattern()
    
    latency := pattern.MinLatency + 
        time.Duration(rand.Int63n(int64(pattern.MaxLatency-pattern.MinLatency)))
    
    select {
    case <-time.After(latency):
        return nil
    case <-ctx.Done():
        return ctx.Err()
    }
}

// selectPattern 选择延迟模式
func (li *LatencyInjector) selectPattern() LatencyPattern {
    r := rand.Float64()
    cumulative := 0.0
    
    for _, pattern := range li.patterns {
        cumulative += pattern.Probability
        if r <= cumulative {
            return pattern
        }
    }
    
    return li.patterns[0]
}
```

---

## 追踪数据分析

### Trace 聚合

**Trace 分析器：**

```go
package analysis

import (
    "sort"
    "time"
    
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
)

// TraceAnalyzer Trace 分析器
type TraceAnalyzer struct {
    spans []sdktrace.ReadOnlySpan
}

// NewTraceAnalyzer 创建 Trace 分析器
func NewTraceAnalyzer(spans []sdktrace.ReadOnlySpan) *TraceAnalyzer {
    return &TraceAnalyzer{
        spans: spans,
    }
}

// GetStatistics 获取统计信息
func (ta *TraceAnalyzer) GetStatistics() *TraceStatistics {
    if len(ta.spans) == 0 {
        return &TraceStatistics{}
    }
    
    durations := make([]int64, len(ta.spans))
    errorCount := 0
    
    for i, span := range ta.spans {
        duration := span.EndTime().Sub(span.StartTime()).Milliseconds()
        durations[i] = duration
        
        if span.Status().Code == codes.Error {
            errorCount++
        }
    }
    
    sort.Slice(durations, func(i, j int) bool {
        return durations[i] < durations[j]
    })
    
    return &TraceStatistics{
        TotalSpans:  len(ta.spans),
        ErrorCount:  errorCount,
        MinDuration: time.Duration(durations[0]) * time.Millisecond,
        MaxDuration: time.Duration(durations[len(durations)-1]) * time.Millisecond,
        AvgDuration: time.Duration(average(durations)) * time.Millisecond,
        P50Duration: time.Duration(percentile(durations, 0.50)) * time.Millisecond,
        P95Duration: time.Duration(percentile(durations, 0.95)) * time.Millisecond,
        P99Duration: time.Duration(percentile(durations, 0.99)) * time.Millisecond,
        ErrorRate:   float64(errorCount) / float64(len(ta.spans)) * 100,
    }
}

// TraceStatistics Trace 统计
type TraceStatistics struct {
    TotalSpans  int
    ErrorCount  int
    MinDuration time.Duration
    MaxDuration time.Duration
    AvgDuration time.Duration
    P50Duration time.Duration
    P95Duration time.Duration
    P99Duration time.Duration
    ErrorRate   float64
}

// average 计算平均值
func average(values []int64) int64 {
    sum := int64(0)
    for _, v := range values {
        sum += v
    }
    return sum / int64(len(values))
}

// percentile 计算百分位数
func percentile(values []int64, p float64) int64 {
    index := int(float64(len(values)) * p)
    if index >= len(values) {
        index = len(values) - 1
    }
    return values[index]
}
```

---

## 最佳实践

### 1. 测试隔离

✅ **使用独立的测试环境**

```go
// ✅ Good
func TestIntegration(t *testing.T) {
    env := SetupTestEnvironment(t)
    defer env.Cleanup()
    
    // 测试逻辑
}

// ❌ Bad
func TestIntegration(t *testing.T) {
    // 使用共享的开发环境
}
```

### 2. 追踪验证

✅ **验证追踪数据的正确性**

```go
// ✅ Good
spans := ttp.GetSpans()
require.Len(t, spans, 1)
NewSpanAssertion(t, spans[0]).
    AssertName("expected-operation").
    AssertNoErrors()
```

### 3. 性能基准

✅ **建立性能基准**

```go
// ✅ Good
func BenchmarkOperation(b *testing.B) {
    b.ResetTimer()
    b.ReportAllocs()
    
    for i := 0; i < b.N; i++ {
        operation()
    }
}
```

### 4. 可观测性关联

✅ **关联日志、指标和追踪**

```go
// ✅ Good
logger.Info(ctx, "operation completed",
    slog.String("trace_id", spanContext.TraceID().String()),
    slog.String("span_id", spanContext.SpanID().String()),
)
```

---

## 完整示例

```go
package main

import (
    "context"
    "testing"
    
    "github.com/stretchr/testify/require"
)

func TestUserService_Complete(t *testing.T) {
    // 1. 设置测试环境
    ttp := NewTestTracerProvider(t)
    env := SetupTestEnvironment(t)
    defer env.Cleanup(context.Background())
    
    // 2. 创建服务
    db, _ := NewTracedDB("postgres", env.PostgresURL)
    redis, _ := NewTracedRedis(env.RedisURL)
    service := NewUserService(db, redis)
    
    // 3. 创建测试数据
    factory := NewTestDataFactory(t, db.DB())
    user := factory.CreateUser(context.Background(), "Test User", "test@example.com")
    
    // 4. 执行操作
    ctx := context.Background()
    retrievedUser, err := service.GetUser(ctx, user.ID)
    
    // 5. 验证结果
    require.NoError(t, err)
    require.Equal(t, user.Name, retrievedUser.Name)
    
    // 6. 验证追踪
    spans := ttp.GetSpans()
    require.NotEmpty(t, spans)
    
    for _, span := range spans {
        NewSpanAssertion(t, span).AssertNoErrors()
    }
    
    // 7. 分析性能
    analyzer := NewTraceAnalyzer(spans)
    stats := analyzer.GetStatistics()
    require.Less(t, stats.P95Duration.Milliseconds(), int64(100), "P95 latency should be < 100ms")
}
```

---

## 总结

本文档详细介绍了 Go 应用测试和可观测性的最佳实践，涵盖：

✅ **单元测试追踪** - 测试追踪器、Mock Exporter、Span 断言  
✅ **集成测试追踪** - 测试容器、端到端测试、测试数据管理  
✅ **性能测试** - 基准测试、负载测试、压力测试  
✅ **可观测性模式** - 日志/指标/追踪关联、告警规则、Dashboard  
✅ **故障注入** - 混沌工程、错误模拟、延迟注入  
✅ **追踪数据分析** - Trace 聚合、性能分析、依赖分析

### 关键要点

1. **完整的测试覆盖** - 单元、集成、性能测试全覆盖
2. **追踪验证** - 验证追踪数据的正确性和完整性
3. **三位一体** - 日志、指标、追踪关联
4. **混沌工程** - 通过故障注入验证系统韧性
5. **数据驱动** - 使用追踪数据驱动性能优化

### 相关文档

- [31_Go高级并发模式与OTLP完整集成](./31_Go高级并发模式与OTLP完整集成.md)
- [34_Go内存管理与性能调优实战](./34_Go内存管理与性能调优实战.md)
- [35_Go生产级部署模式与反模式](./35_Go生产级部署模式与反模式.md)

---

**最后更新：** 2025-10-09  
**版本：** v1.0.0  
**作者：** OTLP Go Integration Team
