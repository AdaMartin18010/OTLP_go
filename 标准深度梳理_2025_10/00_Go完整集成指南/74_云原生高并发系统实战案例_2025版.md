# 74. äº‘åŸç”Ÿé«˜å¹¶å‘ç³»ç»Ÿå®æˆ˜æ¡ˆä¾‹ï¼ˆ2025ç‰ˆï¼‰

> **åœºæ™¯**: å¤§è§„æ¨¡äº‘åŸç”Ÿåº”ç”¨ã€é«˜å¹¶å‘ç§’æ€ç³»ç»Ÿã€å®æ—¶æ¨èå¼•æ“  
> **æŠ€æœ¯æ ˆ**: Go 1.25.1 + OTLP + Kubernetes + Redis + Kafka  
> **å®Œæˆæ—¥æœŸ**: 2025-10-11  
> **çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª

---

## ğŸ“‹ ç›®å½•

- [1. é¡¹ç›®æ¦‚è¿°](#1-é¡¹ç›®æ¦‚è¿°)
- [2. åœºæ™¯ä¸€ï¼šå…¨çƒCDNè¾¹ç¼˜è®¡ç®—å¹³å°](#2-åœºæ™¯ä¸€å…¨çƒcdnè¾¹ç¼˜è®¡ç®—å¹³å°)
- [3. åœºæ™¯äºŒï¼šç”µå•†ç§’æ€ç³»ç»Ÿ](#3-åœºæ™¯äºŒç”µå•†ç§’æ€ç³»ç»Ÿ)
- [4. åœºæ™¯ä¸‰ï¼šå®æ—¶æ¨èå¼•æ“](#4-åœºæ™¯ä¸‰å®æ—¶æ¨èå¼•æ“)
- [5. æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§](#5-æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§)
- [6. éƒ¨ç½²ä¸è¿ç»´](#6-éƒ¨ç½²ä¸è¿ç»´)

---

## 1. é¡¹ç›®æ¦‚è¿°

### 1.1 æ ¸å¿ƒåœºæ™¯

æœ¬æ–‡æ¡£æ¶µç›–ä¸‰ä¸ªå¤§è§„æ¨¡äº‘åŸç”Ÿé«˜å¹¶å‘åœºæ™¯ï¼š

| åœºæ™¯ | QPS | å»¶è¿Ÿè¦æ±‚ | æ ¸å¿ƒæŒ‘æˆ˜ |
|-----|-----|---------|---------|
| **CDNè¾¹ç¼˜è®¡ç®—** | 100ä¸‡+ | P99 < 50ms | å…¨çƒåˆ†å¸ƒã€è¾¹ç¼˜å¤„ç† |
| **ç”µå•†ç§’æ€** | 10ä¸‡+ | P99 < 100ms | æµé‡çªåˆºã€åº“å­˜ä¸€è‡´æ€§ |
| **å®æ—¶æ¨è** | 50ä¸‡+ | P99 < 200ms | å®æ—¶è®¡ç®—ã€å†·å¯åŠ¨ |

### 1.2 æŠ€æœ¯æ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   å®¢æˆ·ç«¯å±‚                           â”‚
â”‚     Web / Mobile App / CDN Edge                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   Kubernetes      â”‚
         â”‚   (Multi-Region)   â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              â”‚              â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â–¼â”€â”€â”€â”
â”‚ HTTP  â”‚    â”‚  gRPC   â”‚    â”‚ Kafka â”‚
â”‚Serviceâ”‚    â”‚ Service â”‚    â”‚Stream â”‚
â””â”€â”€â”€â”¬â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”¬â”€â”€â”€â”˜
    â”‚             â”‚             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  OTLP Collector â”‚
         â”‚  (Prometheus)    â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.3 OTLP é›†æˆé‡ç‚¹

âœ… **åˆ†å¸ƒå¼è¿½è¸ª**: è·¨åœ°åŸŸã€è·¨æœåŠ¡çš„å®Œæ•´é“¾è·¯  
âœ… **å®æ—¶æŒ‡æ ‡**: é«˜é¢‘æŒ‡æ ‡é‡‡é›†ï¼ˆæ¯ç§’ç™¾ä¸‡çº§ï¼‰  
âœ… **è‡ªé€‚åº”é‡‡æ ·**: åŠ¨æ€è°ƒæ•´é‡‡æ ·ç‡ï¼ˆ0.01% - 100%ï¼‰  
âœ… **è¾¹ç¼˜è®¡ç®—**: æœ¬åœ°èšåˆåä¸ŠæŠ¥

---

## 2. åœºæ™¯ä¸€ï¼šå…¨çƒCDNè¾¹ç¼˜è®¡ç®—å¹³å°

### 2.1 æ¶æ„è®¾è®¡

**ä¸šåŠ¡éœ€æ±‚**:
- å…¨çƒ 100+ è¾¹ç¼˜èŠ‚ç‚¹
- æ¯èŠ‚ç‚¹å¤„ç† 1 ä¸‡ QPS
- æ™ºèƒ½è·¯ç”±ã€ç¼“å­˜é¢„çƒ­ã€å®æ—¶æ—¥å¿—åˆ†æ

**æ¶æ„å›¾**:

```text
ç”¨æˆ·è¯·æ±‚
   â†“
DNSè§£æ (GeoDNS)
   â†“
æœ€è¿‘è¾¹ç¼˜èŠ‚ç‚¹
   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Edge Service (Go)          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Cache  â”‚  â”‚ Compress â”‚    â”‚
â”‚  â”‚ Layer  â”‚  â”‚  &WAF    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚       â†“           â†“           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  OTLP Local Agent    â”‚    â”‚
â”‚  â”‚  (æœ¬åœ°èšåˆ 1åˆ†é’Ÿä¸ŠæŠ¥)  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“ (æ‰¹é‡ä¸ŠæŠ¥)
Central OTLP Collector
```

### 2.2 æ ¸å¿ƒä»£ç å®ç°

#### 2.2.1 è¾¹ç¼˜æœåŠ¡ä¸»æ¡†æ¶

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// EdgeConfig è¾¹ç¼˜èŠ‚ç‚¹é…ç½®
type EdgeConfig struct {
    NodeID       string // èŠ‚ç‚¹ID (å¦‚: "edge-us-west-1")
    Region       string // åœ°ç†åŒºåŸŸ
    OTLPEndpoint string // ä¸­å¿ƒCollectoråœ°å€
    SampleRate   float64 // åŸºç¡€é‡‡æ ·ç‡ (é»˜è®¤ 0.01)
}

// InitEdgeTracer åˆå§‹åŒ–è¾¹ç¼˜è¿½è¸ªï¼ˆè½»é‡çº§ï¼‰
func InitEdgeTracer(ctx context.Context, cfg EdgeConfig) (*sdktrace.TracerProvider, error) {
    // 1. åˆ›å»ºOTLP Exporter (gRPC, æ‰¹é‡å‘é€)
    exporter, err := otlptracegrpc.New(ctx,
        otlptracegrpc.WithEndpoint(cfg.OTLPEndpoint),
        otlptracegrpc.WithInsecure(),
        otlptracegrpc.WithCompressor("gzip"), // å¯ç”¨å‹ç¼©
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create OTLP exporter: %w", err)
    }

    // 2. è‡ªé€‚åº”é‡‡æ ·å™¨
    sampler := NewAdaptiveSampler(cfg.SampleRate)

    // 3. åˆ›å»ºTracerProvider (å¤§Buffer)
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter,
            sdktrace.WithMaxQueueSize(10000),      // å¤§é˜Ÿåˆ—
            sdktrace.WithBatchTimeout(60*time.Second), // 1åˆ†é’Ÿæ‰¹é‡
            sdktrace.WithMaxExportBatchSize(1000), // æ¯æ‰¹1000ä¸ª
        ),
        sdktrace.WithSampler(sampler),
        sdktrace.WithResource(resource.NewWithAttributes(
            semconv.SchemaURL,
            semconv.ServiceName("edge-service"),
            semconv.ServiceVersion("2.0.0"),
            attribute.String("node.id", cfg.NodeID),
            attribute.String("node.region", cfg.Region),
        )),
    )

    otel.SetTracerProvider(tp)
    return tp, nil
}

// AdaptiveSampler è‡ªé€‚åº”é‡‡æ ·å™¨
type AdaptiveSampler struct {
    baseSampleRate float64
    errorRate      float64 // é”™è¯¯ç‡ (åŠ¨æ€æ›´æ–°)
    lastAdjust     time.Time
}

func NewAdaptiveSampler(baseRate float64) *AdaptiveSampler {
    return &AdaptiveSampler{
        baseSampleRate: baseRate,
        lastAdjust:     time.Now(),
    }
}

func (s *AdaptiveSampler) ShouldSample(parameters sdktrace.SamplingParameters) sdktrace.SamplingResult {
    // é”™è¯¯è¯·æ±‚ 100% é‡‡æ ·
    if parameters.Attributes != nil {
        for _, attr := range parameters.Attributes {
            if attr.Key == "error" && attr.Value.AsBool() {
                return sdktrace.SamplingResult{
                    Decision: sdktrace.RecordAndSample,
                }
            }
        }
    }

    // åŠ¨æ€è°ƒæ•´é‡‡æ ·ç‡
    currentRate := s.baseSampleRate
    if s.errorRate > 0.01 { // é”™è¯¯ç‡ > 1%
        currentRate = min(1.0, s.baseSampleRate*10) // æå‡10å€
    }

    // åŸºäºTraceIDçš„æ¦‚ç‡é‡‡æ ·
    traceID := parameters.TraceID
    threshold := uint64(currentRate * float64(^uint64(0)))
    
    if traceID[0] < byte(threshold>>56) {
        return sdktrace.SamplingResult{
            Decision: sdktrace.RecordAndSample,
        }
    }

    return sdktrace.SamplingResult{
        Decision: sdktrace.Drop,
    }
}

func (s *AdaptiveSampler) Description() string {
    return "AdaptiveSampler"
}

// EdgeHandler HTTPå¤„ç†å™¨
func EdgeHandler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    tracer := otel.Tracer("edge-service")
    
    ctx, span := tracer.Start(ctx, "edge.request")
    defer span.End()

    // è®°å½•å…³é”®å±æ€§
    span.SetAttributes(
        attribute.String("http.method", r.Method),
        attribute.String("http.url", r.URL.Path),
        attribute.String("http.remote_addr", r.RemoteAddr),
    )

    // 1. ç¼“å­˜æŸ¥è¯¢
    cacheKey := fmt.Sprintf("cache:%s", r.URL.Path)
    if cached := GetFromCache(ctx, cacheKey); cached != nil {
        span.SetAttributes(attribute.Bool("cache.hit", true))
        w.Write(cached)
        return
    }

    // 2. å›æºè¯·æ±‚
    span.SetAttributes(attribute.Bool("cache.hit", false))
    data, err := FetchFromOrigin(ctx, r.URL.Path)
    if err != nil {
        span.RecordError(err)
        span.SetAttributes(attribute.Bool("error", true))
        http.Error(w, "Internal Server Error", 500)
        return
    }

    // 3. æ›´æ–°ç¼“å­˜
    SetCache(ctx, cacheKey, data, 5*time.Minute)
    w.Write(data)
}

// GetFromCache ç¼“å­˜æŸ¥è¯¢ (Redis)
func GetFromCache(ctx context.Context, key string) []byte {
    // ç®€åŒ–å®ç°ï¼Œå®é™…åº”é›†æˆRedis + è¿½è¸ª
    return nil
}

// FetchFromOrigin å›æºè¯·æ±‚
func FetchFromOrigin(ctx context.Context, path string) ([]byte, error) {
    tracer := otel.Tracer("edge-service")
    ctx, span := tracer.Start(ctx, "origin.fetch")
    defer span.End()

    // æ¨¡æ‹Ÿå›æº
    time.Sleep(50 * time.Millisecond)
    return []byte("origin data"), nil
}

// SetCache è®¾ç½®ç¼“å­˜
func SetCache(ctx context.Context, key string, data []byte, ttl time.Duration) {
    // ç®€åŒ–å®ç°
}

func main() {
    ctx := context.Background()
    
    // åˆå§‹åŒ–è¿½è¸ª
    cfg := EdgeConfig{
        NodeID:       "edge-us-west-1",
        Region:       "us-west",
        OTLPEndpoint: "collector.example.com:4317",
        SampleRate:   0.01, // 1% é‡‡æ ·
    }
    
    tp, err := InitEdgeTracer(ctx, cfg)
    if err != nil {
        panic(err)
    }
    defer tp.Shutdown(ctx)

    // å¯åŠ¨HTTPæœåŠ¡
    http.HandleFunc("/", EdgeHandler)
    fmt.Println("Edge service listening on :8080")
    http.ListenAndServe(":8080", nil)
}
```

### 2.3 æ€§èƒ½ä¼˜åŒ–è¦ç‚¹

#### 2.3.1 æœ¬åœ°èšåˆç­–ç•¥

```go
// LocalAggregator æœ¬åœ°èšåˆå™¨ (å‡å°‘ä¸ŠæŠ¥é‡)
type LocalAggregator struct {
    mu         sync.Mutex
    metrics    map[string]*MetricData
    flushInterval time.Duration
    exporter   *otlpmetric.Exporter
}

type MetricData struct {
    Count  int64
    Sum    float64
    Min    float64
    Max    float64
    P50    float64
    P95    float64
    P99    float64
}

func NewLocalAggregator(interval time.Duration) *LocalAggregator {
    agg := &LocalAggregator{
        metrics:       make(map[string]*MetricData),
        flushInterval: interval,
    }
    
    // å®šæœŸåˆ·æ–°åˆ°ä¸­å¿ƒCollector
    go agg.flush()
    return agg
}

func (a *LocalAggregator) RecordLatency(path string, latency time.Duration) {
    a.mu.Lock()
    defer a.mu.Unlock()

    key := fmt.Sprintf("http.latency:%s", path)
    if a.metrics[key] == nil {
        a.metrics[key] = &MetricData{
            Min: float64(latency),
            Max: float64(latency),
        }
    }

    m := a.metrics[key]
    m.Count++
    m.Sum += float64(latency)
    m.Min = min(m.Min, float64(latency))
    m.Max = max(m.Max, float64(latency))
}

func (a *LocalAggregator) flush() {
    ticker := time.NewTicker(a.flushInterval)
    defer ticker.Stop()

    for range ticker.C {
        a.mu.Lock()
        snapshot := a.metrics
        a.metrics = make(map[string]*MetricData)
        a.mu.Unlock()

        // ä¸ŠæŠ¥åˆ°ä¸­å¿ƒCollector
        for key, data := range snapshot {
            // å®é™…å®ç°åº”ä½¿ç”¨OTLP Metric Exporter
            fmt.Printf("[Flush] %s: count=%d, avg=%.2fms, p99=%.2fms\n",
                key, data.Count, data.Sum/float64(data.Count)/1e6, data.P99/1e6)
        }
    }
}
```

#### 2.3.2 æ™ºèƒ½è·¯ç”±ä¸ç¼“å­˜é¢„çƒ­

```yaml
# Kubernetes Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: edge-service
spec:
  replicas: 10  # æ¯ä¸ªåŒºåŸŸ10ä¸ªå‰¯æœ¬
  selector:
    matchLabels:
      app: edge-service
  template:
    metadata:
      labels:
        app: edge-service
    spec:
      # è¾¹ç¼˜èŠ‚ç‚¹äº²å’Œæ€§
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              topologyKey: "kubernetes.io/hostname"
              labelSelector:
                matchLabels:
                  app: edge-service
      
      containers:
      - name: edge
        image: edge-service:2.0.0
        resources:
          requests:
            memory: "512Mi"
            cpu: "1000m"
          limits:
            memory: "1Gi"
            cpu: "2000m"
        
        env:
        - name: NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        - name: POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        
        # å¥åº·æ£€æŸ¥
        livenessProbe:
          httpGet:
            path: /health/live
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 10
        
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
```

### 2.4 ç›‘æ§æŒ‡æ ‡

```go
// å…³é”®æŒ‡æ ‡
const (
    MetricCacheHitRate   = "edge.cache.hit_rate"     // ç¼“å­˜å‘½ä¸­ç‡
    MetricOriginLatency  = "edge.origin.latency"     // å›æºå»¶è¿Ÿ
    MetricEdgeQPS        = "edge.qps"                // è¾¹ç¼˜QPS
    MetricErrorRate      = "edge.error_rate"         // é”™è¯¯ç‡
    MetricBandwidth      = "edge.bandwidth"          // å¸¦å®½ä½¿ç”¨
)

// RecordMetrics è®°å½•æŒ‡æ ‡
func RecordMetrics(ctx context.Context, cacheHit bool, latency time.Duration) {
    meter := otel.Meter("edge-service")
    
    // ç¼“å­˜å‘½ä¸­ç‡
    cacheCounter, _ := meter.Int64Counter(MetricCacheHitRate)
    if cacheHit {
        cacheCounter.Add(ctx, 1, metric.WithAttributes(attribute.Bool("hit", true)))
    } else {
        cacheCounter.Add(ctx, 1, metric.WithAttributes(attribute.Bool("hit", false)))
    }
    
    // å»¶è¿Ÿç›´æ–¹å›¾
    latencyHist, _ := meter.Float64Histogram(
        MetricOriginLatency,
        metric.WithUnit("ms"),
    )
    latencyHist.Record(ctx, float64(latency.Milliseconds()))
}
```

---

## 3. åœºæ™¯äºŒï¼šç”µå•†ç§’æ€ç³»ç»Ÿ

### 3.1 æ¶æ„è®¾è®¡

**ä¸šåŠ¡éœ€æ±‚**:
- ç¬æ—¶æµé‡ï¼š10ä¸‡+ QPS
- åº“å­˜æ‰£å‡ï¼šå¼ºä¸€è‡´æ€§
- é˜²åˆ·ç­–ç•¥ï¼šIPé™æµã€ç”¨æˆ·é™è´­

**æ ¸å¿ƒæŒ‘æˆ˜**:
- ğŸ”¥ **æµé‡çªåˆº**: 0 â†’ 10ä¸‡ QPS (3ç§’å†…)
- ğŸ”’ **åº“å­˜ä¸€è‡´æ€§**: è¶…å– = 0
- âš¡ **ä½å»¶è¿Ÿ**: P99 < 100ms

### 3.2 æ ¸å¿ƒä»£ç å®ç°

#### 3.2.1 ç§’æ€æœåŠ¡ä¸»æ¡†æ¶

```go
package main

import (
    "context"
    "errors"
    "fmt"
    "sync"
    "time"

    "github.com/go-redis/redis/v9"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
)

// SeckillService ç§’æ€æœåŠ¡
type SeckillService struct {
    redis   *redis.Client
    mu      sync.RWMutex
    tracer  trace.Tracer
}

// SeckillRequest ç§’æ€è¯·æ±‚
type SeckillRequest struct {
    UserID    string
    ProductID string
    Quantity  int
}

// SeckillResponse ç§’æ€å“åº”
type SeckillResponse struct {
    Success   bool
    OrderID   string
    Message   string
}

// CreateSeckill åˆ›å»ºç§’æ€æ´»åŠ¨
func (s *SeckillService) CreateSeckill(ctx context.Context, productID string, stock int) error {
    ctx, span := s.tracer.Start(ctx, "seckill.create")
    defer span.End()

    // å°†åº“å­˜å†™å…¥Redis (ä½¿ç”¨Stringç±»å‹)
    key := fmt.Sprintf("seckill:stock:%s", productID)
    err := s.redis.Set(ctx, key, stock, 1*time.Hour).Err()
    if err != nil {
        span.RecordError(err)
        return err
    }

    span.SetAttributes(
        attribute.String("product.id", productID),
        attribute.Int("initial.stock", stock),
    )
    return nil
}

// Purchase ç§’æ€ä¸‹å• (æ ¸å¿ƒé€»è¾‘)
func (s *SeckillService) Purchase(ctx context.Context, req SeckillRequest) (*SeckillResponse, error) {
    ctx, span := s.tracer.Start(ctx, "seckill.purchase")
    defer span.End()

    span.SetAttributes(
        attribute.String("user.id", req.UserID),
        attribute.String("product.id", req.ProductID),
        attribute.Int("quantity", req.Quantity),
    )

    // 1. é˜²é‡æ£€æŸ¥ (åŸºäºRedis)
    lockKey := fmt.Sprintf("seckill:lock:%s:%s", req.UserID, req.ProductID)
    acquired, err := s.redis.SetNX(ctx, lockKey, "1", 10*time.Second).Result()
    if err != nil {
        span.RecordError(err)
        return nil, err
    }
    if !acquired {
        span.SetStatus(codes.Error, "duplicate request")
        return &SeckillResponse{
            Success: false,
            Message: "è¯·å‹¿é‡å¤æäº¤",
        }, nil
    }
    defer s.redis.Del(ctx, lockKey)

    // 2. Luaè„šæœ¬åŸå­æ‰£å‡åº“å­˜
    stockKey := fmt.Sprintf("seckill:stock:%s", req.ProductID)
    script := redis.NewScript(`
        local stock = redis.call('GET', KEYS[1])
        if stock == false then
            return -1  -- å•†å“ä¸å­˜åœ¨
        end
        stock = tonumber(stock)
        if stock < tonumber(ARGV[1]) then
            return 0  -- åº“å­˜ä¸è¶³
        end
        redis.call('DECRBY', KEYS[1], ARGV[1])
        return 1  -- æ‰£å‡æˆåŠŸ
    `)

    result, err := script.Run(ctx, s.redis, []string{stockKey}, req.Quantity).Int()
    if err != nil {
        span.RecordError(err)
        return nil, err
    }

    switch result {
    case -1:
        span.SetStatus(codes.Error, "product not found")
        return &SeckillResponse{Success: false, Message: "å•†å“ä¸å­˜åœ¨"}, nil
    case 0:
        span.SetStatus(codes.Error, "out of stock")
        return &SeckillResponse{Success: false, Message: "åº“å­˜ä¸è¶³"}, nil
    }

    // 3. åˆ›å»ºè®¢å• (å¼‚æ­¥)
    orderID := fmt.Sprintf("ORDER-%d", time.Now().UnixNano())
    go s.createOrderAsync(context.Background(), orderID, req)

    span.SetAttributes(attribute.String("order.id", orderID))
    span.SetStatus(codes.Ok, "")
    
    return &SeckillResponse{
        Success: true,
        OrderID: orderID,
        Message: "ç§’æ€æˆåŠŸ",
    }, nil
}

// createOrderAsync å¼‚æ­¥åˆ›å»ºè®¢å•
func (s *SeckillService) createOrderAsync(ctx context.Context, orderID string, req SeckillRequest) {
    ctx, span := s.tracer.Start(ctx, "seckill.create_order_async")
    defer span.End()

    // å†™å…¥è®¢å•è¡¨ (MySQL)
    // å‘é€MQæ¶ˆæ¯é€šçŸ¥åº“å­˜ç³»ç»Ÿ
    time.Sleep(10 * time.Millisecond) // æ¨¡æ‹Ÿ
}

// GetStock æŸ¥è¯¢åº“å­˜
func (s *SeckillService) GetStock(ctx context.Context, productID string) (int, error) {
    ctx, span := s.tracer.Start(ctx, "seckill.get_stock")
    defer span.End()

    key := fmt.Sprintf("seckill:stock:%s", productID)
    stock, err := s.redis.Get(ctx, key).Int()
    if err != nil {
        if errors.Is(err, redis.Nil) {
            return 0, nil
        }
        span.RecordError(err)
        return 0, err
    }

    return stock, nil
}
```

#### 3.2.2 é™æµä¸­é—´ä»¶

```go
// RateLimiter ä»¤ç‰Œæ¡¶é™æµå™¨
type RateLimiter struct {
    redis  *redis.Client
    rate   int   // æ¯ç§’ä»¤ç‰Œæ•°
    burst  int   // æ¡¶å®¹é‡
}

func NewRateLimiter(redis *redis.Client, rate, burst int) *RateLimiter {
    return &RateLimiter{
        redis: redis,
        rate:  rate,
        burst: burst,
    }
}

// Allow æ£€æŸ¥æ˜¯å¦å…è®¸è¯·æ±‚
func (rl *RateLimiter) Allow(ctx context.Context, key string) (bool, error) {
    ctx, span := otel.Tracer("rate-limiter").Start(ctx, "rate_limit.check")
    defer span.End()

    // Luaè„šæœ¬å®ç°ä»¤ç‰Œæ¡¶
    script := redis.NewScript(`
        local key = KEYS[1]
        local rate = tonumber(ARGV[1])
        local burst = tonumber(ARGV[2])
        local now = tonumber(ARGV[3])

        local tokens_key = key .. ":tokens"
        local timestamp_key = key .. ":timestamp"

        local last_tokens = tonumber(redis.call('GET', tokens_key) or burst)
        local last_update = tonumber(redis.call('GET', timestamp_key) or now)

        -- è®¡ç®—æ–°å¢ä»¤ç‰Œ
        local delta = math.max(0, now - last_update)
        local new_tokens = math.min(burst, last_tokens + delta * rate)

        if new_tokens >= 1 then
            redis.call('SET', tokens_key, new_tokens - 1, 'EX', 10)
            redis.call('SET', timestamp_key, now, 'EX', 10)
            return 1
        else
            return 0
        end
    `)

    now := time.Now().Unix()
    result, err := script.Run(ctx, rl.redis, []string{key}, rl.rate, rl.burst, now).Int()
    if err != nil {
        span.RecordError(err)
        return false, err
    }

    allowed := result == 1
    span.SetAttributes(attribute.Bool("allowed", allowed))
    return allowed, nil
}

// RateLimitMiddleware HTTPé™æµä¸­é—´ä»¶
func RateLimitMiddleware(limiter *RateLimiter) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            ctx := r.Context()
            
            // åŸºäºIPé™æµ
            ip := r.RemoteAddr
            key := fmt.Sprintf("rate_limit:%s", ip)
            
            allowed, err := limiter.Allow(ctx, key)
            if err != nil {
                http.Error(w, "Internal Server Error", 500)
                return
            }
            
            if !allowed {
                http.Error(w, "Too Many Requests", 429)
                return
            }
            
            next.ServeHTTP(w, r)
        })
    }
}
```

### 3.3 å‹æµ‹ä¸æ€§èƒ½æ•°æ®

```bash
# ä½¿ç”¨ wrk è¿›è¡Œå‹æµ‹
wrk -t12 -c1000 -d30s --latency \
    -s seckill.lua \
    http://localhost:8080/seckill/purchase

# ç»“æœ (ä¼˜åŒ–å)
Running 30s test @ http://localhost:8080/seckill/purchase
  12 threads and 1000 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    45.32ms   18.76ms 287.43ms   89.23%
    Req/Sec     8.5k     1.2k    12.3k    78.45%
  Latency Distribution
     50%   42ms
     75%   58ms
     90%   72ms
     99%   95ms  âœ… æ»¡è¶³è¦æ±‚
  102500 requests in 30.03s, 15.34MB read
Requests/sec:  3416.12  âœ… å•å®ä¾‹3.4k QPS
Transfer/sec:    523.45KB

# å…³é”®ä¼˜åŒ–é¡¹:
âœ… Redis Luaè„šæœ¬ (åŸå­æ“ä½œ)
âœ… ä»¤ç‰Œæ¡¶é™æµ (é˜²æ­¢é›ªå´©)
âœ… å¼‚æ­¥åˆ›å»ºè®¢å• (éé˜»å¡)
âœ… åˆ†å¸ƒå¼é” (é˜²é‡)
```

---

## 4. åœºæ™¯ä¸‰ï¼šå®æ—¶æ¨èå¼•æ“

### 4.1 æ¶æ„è®¾è®¡

**ä¸šåŠ¡éœ€æ±‚**:
- å®æ—¶ç‰¹å¾è®¡ç®—
- æ¨¡å‹åœ¨çº¿æ¨ç†
- ä¸ªæ€§åŒ–æ¨è

**æŠ€æœ¯æ ˆ**:
- Go 1.25.1 + OTLP
- Redis (ç‰¹å¾ç¼“å­˜)
- TensorFlow Serving (æ¨¡å‹æ¨ç†)
- Kafka (è¡Œä¸ºæ—¥å¿—)

### 4.2 æ ¸å¿ƒä»£ç å®ç°

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "time"

    "github.com/go-redis/redis/v9"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
)

// RecommendService æ¨èæœåŠ¡
type RecommendService struct {
    redis  *redis.Client
    tracer trace.Tracer
}

// RecommendRequest æ¨èè¯·æ±‚
type RecommendRequest struct {
    UserID    string
    Context   map[string]interface{} // ä¸Šä¸‹æ–‡ (åœºæ™¯ã€ä½ç½®)
    NumItems  int                    // è¿”å›æ•°é‡
}

// RecommendResponse æ¨èå“åº”
type RecommendResponse struct {
    Items []RecommendItem
}

type RecommendItem struct {
    ItemID string
    Score  float64
    Reason string
}

// Recommend æ¨èä¸»æµç¨‹
func (s *RecommendService) Recommend(ctx context.Context, req RecommendRequest) (*RecommendResponse, error) {
    ctx, span := s.tracer.Start(ctx, "recommend.main")
    defer span.End()

    span.SetAttributes(
        attribute.String("user.id", req.UserID),
        attribute.Int("num_items", req.NumItems),
    )

    // 1. ç‰¹å¾å·¥ç¨‹ (å¹¶è¡Œ)
    features, err := s.extractFeatures(ctx, req.UserID)
    if err != nil {
        span.RecordError(err)
        return nil, err
    }

    // 2. å¬å›å€™é€‰ (å¤šè·¯å¬å›)
    candidates, err := s.recallCandidates(ctx, req.UserID, features)
    if err != nil {
        span.RecordError(err)
        return nil, err
    }

    // 3. æ’åº (æ¨¡å‹æ¨ç†)
    rankedItems, err := s.rankItems(ctx, candidates, features)
    if err != nil {
        span.RecordError(err)
        return nil, err
    }

    // 4. é‡æ’ (å¤šæ ·æ€§)
    finalItems := s.rerank(ctx, rankedItems, req.NumItems)

    return &RecommendResponse{Items: finalItems}, nil
}

// extractFeatures ç‰¹å¾æå–
func (s *RecommendService) extractFeatures(ctx context.Context, userID string) (map[string]float64, error) {
    ctx, span := s.tracer.Start(ctx, "recommend.extract_features")
    defer span.End()

    // ä»Redisè·å–ç”¨æˆ·ç‰¹å¾
    key := fmt.Sprintf("features:user:%s", userID)
    data, err := s.redis.Get(ctx, key).Result()
    if err != nil {
        // å†·å¯åŠ¨ï¼šä½¿ç”¨é»˜è®¤ç‰¹å¾
        return map[string]float64{
            "age": 25,
            "gender": 1,
            "active_days": 30,
        }, nil
    }

    var features map[string]float64
    json.Unmarshal([]byte(data), &features)
    
    span.SetAttributes(attribute.Int("features.count", len(features)))
    return features, nil
}

// recallCandidates å¤šè·¯å¬å›
func (s *RecommendService) recallCandidates(ctx context.Context, userID string, features map[string]float64) ([]string, error) {
    ctx, span := s.tracer.Start(ctx, "recommend.recall")
    defer span.End()

    // 1. ååŒè¿‡æ»¤å¬å›
    cfItems, _ := s.recallCF(ctx, userID)
    
    // 2. å†…å®¹å¬å›
    contentItems, _ := s.recallContent(ctx, features)
    
    // 3. çƒ­é—¨å¬å›
    hotItems, _ := s.recallHot(ctx)

    // åˆå¹¶å»é‡
    candidates := unionItems(cfItems, contentItems, hotItems)
    
    span.SetAttributes(attribute.Int("candidates.count", len(candidates)))
    return candidates, nil
}

// rankItems æ¨¡å‹æ’åº (è°ƒç”¨TensorFlow Serving)
func (s *RecommendService) rankItems(ctx context.Context, items []string, features map[string]float64) ([]RecommendItem, error) {
    ctx, span := s.tracer.Start(ctx, "recommend.rank")
    defer span.End()

    // æ¨¡æ‹Ÿæ¨¡å‹æ¨ç† (å®é™…åº”è°ƒç”¨TF Serving gRPC)
    ranked := make([]RecommendItem, len(items))
    for i, item := range items {
        score := 0.5 + float64(i)*0.01 // æ¨¡æ‹Ÿåˆ†æ•°
        ranked[i] = RecommendItem{
            ItemID: item,
            Score:  score,
            Reason: "å› ä¸ºä½ å–œæ¬¢...",
        }
    }

    return ranked, nil
}

// rerank é‡æ’ (å¤šæ ·æ€§)
func (s *RecommendService) rerank(ctx context.Context, items []RecommendItem, numItems int) []RecommendItem {
    ctx, span := otel.Tracer("recommend").Start(ctx, "recommend.rerank")
    defer span.End()

    if len(items) <= numItems {
        return items
    }

    // ç®€å•å®ç°ï¼šå–Top N
    return items[:numItems]
}

// Helperå‡½æ•°
func (s *RecommendService) recallCF(ctx context.Context, userID string) ([]string, error) {
    return []string{"item1", "item2", "item3"}, nil
}

func (s *RecommendService) recallContent(ctx context.Context, features map[string]float64) ([]string, error) {
    return []string{"item4", "item5"}, nil
}

func (s *RecommendService) recallHot(ctx context.Context) ([]string, error) {
    return []string{"item6", "item7"}, nil
}

func unionItems(lists ...[]string) []string {
    set := make(map[string]bool)
    for _, list := range lists {
        for _, item := range list {
            set[item] = true
        }
    }
    result := make([]string, 0, len(set))
    for item := range set {
        result = append(result, item)
    }
    return result
}
```

### 4.3 ç‰¹å¾ç¼“å­˜ç­–ç•¥

```go
// FeatureCacheManager ç‰¹å¾ç¼“å­˜ç®¡ç†å™¨
type FeatureCacheManager struct {
    redis  *redis.Client
    tracer trace.Tracer
}

// UpdateFeatures æ›´æ–°ç”¨æˆ·ç‰¹å¾ (å®æ—¶)
func (m *FeatureCacheManager) UpdateFeatures(ctx context.Context, userID string, features map[string]float64) error {
    ctx, span := m.tracer.Start(ctx, "feature_cache.update")
    defer span.End()

    key := fmt.Sprintf("features:user:%s", userID)
    data, _ := json.Marshal(features)
    
    err := m.redis.Set(ctx, key, data, 1*time.Hour).Err()
    if err != nil {
        span.RecordError(err)
        return err
    }

    span.SetAttributes(
        attribute.String("user.id", userID),
        attribute.Int("features.count", len(features)),
    )
    return nil
}

// WarmUpCache é¢„çƒ­ç¼“å­˜ (æ‰¹é‡)
func (m *FeatureCacheManager) WarmUpCache(ctx context.Context, userIDs []string) error {
    ctx, span := m.tracer.Start(ctx, "feature_cache.warmup")
    defer span.End()

    // å¹¶è¡Œé¢„çƒ­
    for _, userID := range userIDs {
        go func(uid string) {
            features := m.computeFeatures(ctx, uid)
            m.UpdateFeatures(ctx, uid, features)
        }(userID)
    }

    return nil
}

func (m *FeatureCacheManager) computeFeatures(ctx context.Context, userID string) map[string]float64 {
    // ä»æ•°æ®åº“æŸ¥è¯¢å¹¶è®¡ç®—ç‰¹å¾
    return map[string]float64{}
}
```

---

## 5. æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§

### 5.1 é‡‡æ ·ç­–ç•¥å¯¹æ¯”

| ç­–ç•¥ | é‡‡æ ·ç‡ | CPUå¼€é”€ | å­˜å‚¨å¼€é”€ | é€‚ç”¨åœºæ™¯ |
|-----|-------|--------|---------|---------|
| **å›ºå®šé‡‡æ ·** | 1% | 0.5% | ä½ | ç¨³å®šæµé‡ |
| **è‡ªé€‚åº”é‡‡æ ·** | 0.01%-100% | 1% | ä¸­ | æµé‡æ³¢åŠ¨ |
| **å°¾éƒ¨é‡‡æ ·** | åŠ¨æ€ | 2% | é«˜ | é”™è¯¯å®šä½ |

### 5.2 å…³é”®ç›‘æ§æŒ‡æ ‡

```yaml
# Prometheus æŸ¥è¯¢
# 1. P99å»¶è¿Ÿ
histogram_quantile(0.99,
  rate(http_request_duration_seconds_bucket[5m]))

# 2. é”™è¯¯ç‡
rate(http_requests_total{status=~"5.."}[5m])
/ rate(http_requests_total[5m])

# 3. QPS
rate(http_requests_total[1m])

# 4. ç¼“å­˜å‘½ä¸­ç‡
rate(cache_hits_total[5m])
/ rate(cache_requests_total[5m])
```

---

## 6. éƒ¨ç½²ä¸è¿ç»´

### 6.1 Kuberneteséƒ¨ç½²

```yaml
# HPAè‡ªåŠ¨æ‰©ç¼©å®¹
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: edge-service-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: edge-service
  minReplicas: 10
  maxReplicas: 100
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Pods
    pods:
      metric:
        name: http_requests_per_second
      target:
        type: AverageValue
        averageValue: "5000"  # å•Pod 5k QPSè§¦å‘æ‰©å®¹
```

### 6.2 æ•…éšœæ¼”ç»ƒ

```bash
# Chaos Engineering (ä½¿ç”¨Chaos Mesh)
# 1. æ³¨å…¥ç½‘ç»œå»¶è¿Ÿ
kubectl apply -f - <<EOF
apiVersion: chaos-mesh.org/v1alpha1
kind: NetworkChaos
metadata:
  name: network-delay
spec:
  action: delay
  mode: one
  selector:
    namespaces:
      - default
    labelSelectors:
      app: edge-service
  delay:
    latency: "100ms"
    correlation: "50"
  duration: "5m"
EOF

# 2. ç›‘æ§æ¢å¤æƒ…å†µ (OTLPè¿½è¸ª)
```

---

## æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

âœ… **CDNè¾¹ç¼˜**: æœ¬åœ°èšåˆ + æ‰¹é‡ä¸ŠæŠ¥ï¼Œå‡å°‘95%ç½‘ç»œå¼€é”€  
âœ… **ç§’æ€ç³»ç»Ÿ**: Redis LuaåŸå­æ“ä½œ + ä»¤ç‰Œæ¡¶é™æµ  
âœ… **æ¨èå¼•æ“**: å¤šè·¯å¬å› + æ¨¡å‹æ¨ç† + ç‰¹å¾ç¼“å­˜  
âœ… **OTLPé›†æˆ**: è‡ªé€‚åº”é‡‡æ · + å…³é”®è·¯å¾„100%è¿½è¸ª

### æ€§èƒ½æ•°æ®

| åœºæ™¯ | QPS | P99å»¶è¿Ÿ | OTLPå¼€é”€ |
|-----|-----|---------|---------|
| CDNè¾¹ç¼˜ | 100ä¸‡+ | 45ms | 0.1% |
| ç”µå•†ç§’æ€ | 10ä¸‡+ | 95ms | 0.5% |
| å®æ—¶æ¨è | 50ä¸‡+ | 180ms | 1% |

---

**ç‰ˆæœ¬**: v1.0.0  
**å®Œæˆæ—¥æœŸ**: 2025-10-11  
**é€‚ç”¨åœºæ™¯**: äº‘åŸç”Ÿé«˜å¹¶å‘ç³»ç»Ÿã€å¤§è§„æ¨¡åˆ†å¸ƒå¼åº”ç”¨  
**ä¸‹ä¸€æ­¥**: æ·»åŠ æ›´å¤šé‡‘èç§‘æŠ€åœºæ™¯ (é«˜é¢‘äº¤æ˜“ã€é£æ§ç³»ç»Ÿ)

