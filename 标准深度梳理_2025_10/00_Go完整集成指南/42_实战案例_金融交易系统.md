# 42. å®æˆ˜æ¡ˆä¾‹ï¼šé‡‘èäº¤æ˜“ç³»ç»Ÿåˆ†å¸ƒå¼è¿½è¸ª

## ğŸ“š ç›®å½•

- [1. ç³»ç»Ÿæ¶æ„](#1-ç³»ç»Ÿæ¶æ„)
- [2. æ ¸å¿ƒæœåŠ¡](#2-æ ¸å¿ƒæœåŠ¡)
- [3. è´¦æˆ·æœåŠ¡](#3-è´¦æˆ·æœåŠ¡)
- [4. äº¤æ˜“æœåŠ¡](#4-äº¤æ˜“æœåŠ¡)
- [5. é£æ§æœåŠ¡](#5-é£æ§æœåŠ¡)
- [6. å¯¹è´¦æœåŠ¡](#6-å¯¹è´¦æœåŠ¡)
- [7. åˆ†å¸ƒå¼äº‹åŠ¡ï¼ˆ2PCï¼‰](#7-åˆ†å¸ƒå¼äº‹åŠ¡2pc)
- [8. å®¡è®¡æ—¥å¿—](#8-å®¡è®¡æ—¥å¿—)
- [9. æ€»ç»“](#9-æ€»ç»“)

---

## 1. ç³»ç»Ÿæ¶æ„

### 1.1 æ¶æ„å›¾

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚    Client    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ API Gateway  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                  â”‚                  â”‚
        â–¼                  â–¼                  â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚   Account   â”‚    â”‚ Transaction â”‚   â”‚ Risk Controlâ”‚
 â”‚   Service   â”‚    â”‚   Service   â”‚   â”‚   Service   â”‚
 â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
        â”‚                  â”‚                  â”‚
        â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
        â”‚         â”‚                 â”‚         â”‚
        â–¼         â–¼                 â–¼         â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Account DB  â”‚ â”‚Transaction  â”‚ â”‚  Risk DB    â”‚
 â”‚(PostgreSQL) â”‚ â”‚DB(PostgreSQLâ”‚ â”‚(PostgreSQL) â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Audit Log Service (Event Store)â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Reconciliation Service (Cron)  â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   OTLP Backend (Jaeger/Tempo)   â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ ¸å¿ƒç‰¹æ€§

- **å¼ºä¸€è‡´æ€§**: ä½¿ç”¨ 2PC ä¿è¯äº¤æ˜“ä¸€è‡´æ€§
- **å®¡è®¡è¿½è¸ª**: æ‰€æœ‰æ“ä½œå®Œæ•´è®°å½•
- **é£é™©æ§åˆ¶**: å®æ—¶äº¤æ˜“é£æ§
- **å¯¹è´¦æœºåˆ¶**: å®šæ—¶å¯¹è´¦ï¼Œç¡®ä¿è´¦åŠ¡å‡†ç¡®
- **é«˜å¯ç”¨**: æœåŠ¡å†—ä½™å’Œæ•…éšœæ¢å¤

---

## 2. æ ¸å¿ƒæœåŠ¡

### 2.1 æœåŠ¡åˆ—è¡¨

| æœåŠ¡åç§° | èŒè´£ | ç«¯å£ | æ•°æ®åº“ |
|---------|------|------|--------|
| Account Service | è´¦æˆ·ç®¡ç†ã€ä½™é¢æŸ¥è¯¢ | 9101 | PostgreSQL |
| Transaction Service | äº¤æ˜“å¤„ç†ã€æµæ°´è®°å½• | 9102 | PostgreSQL |
| Risk Control Service | é£é™©è¯„ä¼°ã€åæ¬ºè¯ˆ | 9103 | PostgreSQL |
| Audit Log Service | å®¡è®¡æ—¥å¿—ã€äº‹ä»¶å­˜å‚¨ | 9104 | Event Store |
| Reconciliation Service | å¯¹è´¦ã€æ•°æ®æ ¡éªŒ | 9105 | PostgreSQL |

### 2.2 æŠ€æœ¯æ ˆ

```go
// go.mod
module financial-system

go 1.25.1

require (
    // OpenTelemetry
    go.opentelemetry.io/otel v1.32.0
    go.opentelemetry.io/otel/sdk v1.32.0
    go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.32.0
    
    // gRPC
    google.golang.org/grpc v1.69.2
    google.golang.org/protobuf v1.36.0
    
    // æ•°æ®åº“
    gorm.io/gorm v1.25.12
    gorm.io/driver/postgres v1.5.11
    
    // åˆ†å¸ƒå¼äº‹åŠ¡
    github.com/dtm-labs/dtm v1.18.0
    
    // å·¥å…·
    github.com/google/uuid v1.6.0
    github.com/shopspring/decimal v1.4.0  // ç²¾ç¡®çš„è´§å¸è®¡ç®—
    golang.org/x/sync v0.10.0
)
```

---

## 3. è´¦æˆ·æœåŠ¡

### 3.1 æ•°æ®æ¨¡å‹

```go
package account

import (
    "time"
    
    "github.com/google/uuid"
    "github.com/shopspring/decimal"
    "gorm.io/gorm"
)

// Account è´¦æˆ·
type Account struct {
    ID            uuid.UUID       `gorm:"type:uuid;primary_key" json:"id"`
    UserID        uuid.UUID       `gorm:"type:uuid;not null;uniqueIndex" json:"user_id"`
    AccountNumber string          `gorm:"uniqueIndex;not null" json:"account_number"`
    AccountType   string          `gorm:"not null" json:"account_type"` // savings, checking, investment
    Currency      string          `gorm:"not null;default:'USD'" json:"currency"`
    Balance       decimal.Decimal `gorm:"type:decimal(20,2);not null" json:"balance"`
    AvailableBalance decimal.Decimal `gorm:"type:decimal(20,2);not null" json:"available_balance"`
    FrozenBalance decimal.Decimal `gorm:"type:decimal(20,2);not null;default:0" json:"frozen_balance"`
    Status        string          `gorm:"not null;default:'active'" json:"status"` // active, frozen, closed
    CreatedAt     time.Time       `json:"created_at"`
    UpdatedAt     time.Time       `json:"updated_at"`
    Version       int             `gorm:"not null;default:0" json:"version"` // ä¹è§‚é”ç‰ˆæœ¬å·
}

// AccountOperation è´¦æˆ·æ“ä½œè®°å½•
type AccountOperation struct {
    ID            uuid.UUID       `gorm:"type:uuid;primary_key" json:"id"`
    AccountID     uuid.UUID       `gorm:"type:uuid;not null;index" json:"account_id"`
    TransactionID uuid.UUID       `gorm:"type:uuid;not null;index" json:"transaction_id"`
    OperationType string          `gorm:"not null" json:"operation_type"` // debit, credit, freeze, unfreeze
    Amount        decimal.Decimal `gorm:"type:decimal(20,2);not null" json:"amount"`
    BalanceBefore decimal.Decimal `gorm:"type:decimal(20,2);not null" json:"balance_before"`
    BalanceAfter  decimal.Decimal `gorm:"type:decimal(20,2);not null" json:"balance_after"`
    Status        string          `gorm:"not null" json:"status"` // pending, completed, failed
    CreatedAt     time.Time       `json:"created_at"`
}

// BeforeCreate Hooks
func (a *Account) BeforeCreate(tx *gorm.DB) error {
    if a.ID == uuid.Nil {
        a.ID = uuid.New()
    }
    if a.AccountNumber == "" {
        a.AccountNumber = generateAccountNumber()
    }
    return nil
}

func (ao *AccountOperation) BeforeCreate(tx *gorm.DB) error {
    if ao.ID == uuid.Nil {
        ao.ID = uuid.New()
    }
    return nil
}

// generateAccountNumber ç”Ÿæˆè´¦å·
func generateAccountNumber() string {
    return fmt.Sprintf("ACC%d%04d", time.Now().Unix(), rand.Intn(10000))
}
```

### 3.2 è´¦æˆ·æœåŠ¡å®ç°

```go
package account

import (
    "context"
    "errors"
    "fmt"
    
    "github.com/shopspring/decimal"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
    "gorm.io/gorm"
    "gorm.io/gorm/clause"
)

// Service è´¦æˆ·æœåŠ¡
type Service struct {
    db     *gorm.DB
    tracer trace.Tracer
    meter  metric.Meter
    
    // Metrics
    balanceGauge       metric.Float64ObservableGauge
    operationCounter   metric.Int64Counter
    operationDuration  metric.Float64Histogram
}

// NewService åˆ›å»ºè´¦æˆ·æœåŠ¡
func NewService(db *gorm.DB) (*Service, error) {
    tracer := otel.Tracer("account-service")
    meter := otel.Meter("account-service")
    
    svc := &Service{
        db:     db,
        tracer: tracer,
        meter:  meter,
    }
    
    var err error
    
    // è´¦æˆ·ä½™é¢
    svc.balanceGauge, err = meter.Float64ObservableGauge(
        "account.balance",
        metric.WithDescription("Account balance"),
        metric.WithFloat64Callback(func(ctx context.Context, observer metric.Float64Observer) error {
            var accounts []Account
            if err := db.WithContext(ctx).Where("status = ?", "active").Find(&accounts).Error; err != nil {
                return err
            }
            
            for _, account := range accounts {
                balance, _ := account.Balance.Float64()
                observer.Observe(balance,
                    metric.WithAttributes(
                        attribute.String("account.id", account.ID.String()),
                        attribute.String("account.type", account.AccountType),
                        attribute.String("currency", account.Currency),
                    ),
                )
            }
            
            return nil
        }),
    )
    if err != nil {
        return nil, err
    }
    
    // æ“ä½œè®¡æ•°å™¨
    svc.operationCounter, err = meter.Int64Counter(
        "account.operation.count",
        metric.WithDescription("Account operation count"),
    )
    if err != nil {
        return nil, err
    }
    
    // æ“ä½œå»¶è¿Ÿ
    svc.operationDuration, err = meter.Float64Histogram(
        "account.operation.duration",
        metric.WithDescription("Account operation duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    return svc, nil
}

// Debit æ‰£æ¬¾ï¼ˆå€Ÿè®°ï¼‰
func (s *Service) Debit(ctx context.Context, accountID uuid.UUID, amount decimal.Decimal, txID uuid.UUID) error {
    ctx, span := s.tracer.Start(ctx, "account.debit",
        trace.WithAttributes(
            attribute.String("account.id", accountID.String()),
            attribute.String("amount", amount.String()),
            attribute.String("transaction.id", txID.String()),
        ),
    )
    defer span.End()
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        s.operationDuration.Record(ctx, float64(duration.Milliseconds()),
            metric.WithAttributes(attribute.String("operation", "debit")),
        )
    }()
    
    err := s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        // é”å®šè´¦æˆ·ï¼ˆè¡Œé” + ä¹è§‚é”ï¼‰
        var account Account
        if err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).
            Where("id = ?", accountID).
            First(&account).Error; err != nil {
            return fmt.Errorf("account not found: %w", err)
        }
        
        if account.Status != "active" {
            return errors.New("account is not active")
        }
        
        span.SetAttributes(
            attribute.String("account.number", account.AccountNumber),
            attribute.String("balance.before", account.Balance.String()),
        )
        
        // æ£€æŸ¥ä½™é¢
        if account.AvailableBalance.LessThan(amount) {
            span.SetStatus(codes.Error, "insufficient balance")
            return errors.New("insufficient balance")
        }
        
        // æ‰£æ¬¾
        newBalance := account.Balance.Sub(amount)
        newAvailableBalance := account.AvailableBalance.Sub(amount)
        
        // æ›´æ–°è´¦æˆ·ï¼ˆä¹è§‚é”ï¼‰
        result := tx.Model(&account).
            Where("version = ?", account.Version).
            Updates(map[string]interface{}{
                "balance":           newBalance,
                "available_balance": newAvailableBalance,
                "version":           account.Version + 1,
            })
        
        if result.Error != nil {
            return result.Error
        }
        
        if result.RowsAffected == 0 {
            return errors.New("concurrent update conflict")
        }
        
        span.SetAttributes(attribute.String("balance.after", newBalance.String()))
        
        // è®°å½•æ“ä½œ
        operation := &AccountOperation{
            AccountID:     accountID,
            TransactionID: txID,
            OperationType: "debit",
            Amount:        amount,
            BalanceBefore: account.Balance,
            BalanceAfter:  newBalance,
            Status:        "completed",
        }
        
        if err := tx.Create(operation).Error; err != nil {
            return err
        }
        
        return nil
    })
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        s.operationCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("operation", "debit"),
                attribute.String("status", "failed"),
            ),
        )
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    s.operationCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("operation", "debit"),
            attribute.String("status", "success"),
        ),
    )
    
    return nil
}

// Credit å­˜æ¬¾ï¼ˆè´·è®°ï¼‰
func (s *Service) Credit(ctx context.Context, accountID uuid.UUID, amount decimal.Decimal, txID uuid.UUID) error {
    ctx, span := s.tracer.Start(ctx, "account.credit",
        trace.WithAttributes(
            attribute.String("account.id", accountID.String()),
            attribute.String("amount", amount.String()),
            attribute.String("transaction.id", txID.String()),
        ),
    )
    defer span.End()
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        s.operationDuration.Record(ctx, float64(duration.Milliseconds()),
            metric.WithAttributes(attribute.String("operation", "credit")),
        )
    }()
    
    err := s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        // é”å®šè´¦æˆ·
        var account Account
        if err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).
            Where("id = ?", accountID).
            First(&account).Error; err != nil {
            return fmt.Errorf("account not found: %w", err)
        }
        
        if account.Status != "active" {
            return errors.New("account is not active")
        }
        
        span.SetAttributes(
            attribute.String("account.number", account.AccountNumber),
            attribute.String("balance.before", account.Balance.String()),
        )
        
        // å­˜æ¬¾
        newBalance := account.Balance.Add(amount)
        newAvailableBalance := account.AvailableBalance.Add(amount)
        
        // æ›´æ–°è´¦æˆ·
        result := tx.Model(&account).
            Where("version = ?", account.Version).
            Updates(map[string]interface{}{
                "balance":           newBalance,
                "available_balance": newAvailableBalance,
                "version":           account.Version + 1,
            })
        
        if result.Error != nil {
            return result.Error
        }
        
        if result.RowsAffected == 0 {
            return errors.New("concurrent update conflict")
        }
        
        span.SetAttributes(attribute.String("balance.after", newBalance.String()))
        
        // è®°å½•æ“ä½œ
        operation := &AccountOperation{
            AccountID:     accountID,
            TransactionID: txID,
            OperationType: "credit",
            Amount:        amount,
            BalanceBefore: account.Balance,
            BalanceAfter:  newBalance,
            Status:        "completed",
        }
        
        if err := tx.Create(operation).Error; err != nil {
            return err
        }
        
        return nil
    })
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        s.operationCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("operation", "credit"),
                attribute.String("status", "failed"),
            ),
        )
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    s.operationCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("operation", "credit"),
            attribute.String("status", "success"),
        ),
    )
    
    return nil
}

// Freeze å†»ç»“èµ„é‡‘
func (s *Service) Freeze(ctx context.Context, accountID uuid.UUID, amount decimal.Decimal, txID uuid.UUID) error {
    ctx, span := s.tracer.Start(ctx, "account.freeze",
        trace.WithAttributes(
            attribute.String("account.id", accountID.String()),
            attribute.String("amount", amount.String()),
            attribute.String("transaction.id", txID.String()),
        ),
    )
    defer span.End()
    
    err := s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        var account Account
        if err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).
            Where("id = ?", accountID).
            First(&account).Error; err != nil {
            return err
        }
        
        // æ£€æŸ¥å¯ç”¨ä½™é¢
        if account.AvailableBalance.LessThan(amount) {
            return errors.New("insufficient available balance")
        }
        
        // å†»ç»“ï¼ˆå‡å°‘å¯ç”¨ï¼Œå¢åŠ å†»ç»“ï¼‰
        newAvailableBalance := account.AvailableBalance.Sub(amount)
        newFrozenBalance := account.FrozenBalance.Add(amount)
        
        result := tx.Model(&account).
            Where("version = ?", account.Version).
            Updates(map[string]interface{}{
                "available_balance": newAvailableBalance,
                "frozen_balance":    newFrozenBalance,
                "version":           account.Version + 1,
            })
        
        if result.Error != nil {
            return result.Error
        }
        
        if result.RowsAffected == 0 {
            return errors.New("concurrent update conflict")
        }
        
        // è®°å½•æ“ä½œ
        operation := &AccountOperation{
            AccountID:     accountID,
            TransactionID: txID,
            OperationType: "freeze",
            Amount:        amount,
            BalanceBefore: account.Balance,
            BalanceAfter:  account.Balance, // æ€»ä½™é¢ä¸å˜
            Status:        "completed",
        }
        
        return tx.Create(operation).Error
    })
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// Unfreeze è§£å†»èµ„é‡‘
func (s *Service) Unfreeze(ctx context.Context, accountID uuid.UUID, amount decimal.Decimal, txID uuid.UUID) error {
    ctx, span := s.tracer.Start(ctx, "account.unfreeze",
        trace.WithAttributes(
            attribute.String("account.id", accountID.String()),
            attribute.String("amount", amount.String()),
            attribute.String("transaction.id", txID.String()),
        ),
    )
    defer span.End()
    
    err := s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        var account Account
        if err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).
            Where("id = ?", accountID).
            First(&account).Error; err != nil {
            return err
        }
        
        // æ£€æŸ¥å†»ç»“ä½™é¢
        if account.FrozenBalance.LessThan(amount) {
            return errors.New("insufficient frozen balance")
        }
        
        // è§£å†»ï¼ˆå¢åŠ å¯ç”¨ï¼Œå‡å°‘å†»ç»“ï¼‰
        newAvailableBalance := account.AvailableBalance.Add(amount)
        newFrozenBalance := account.FrozenBalance.Sub(amount)
        
        result := tx.Model(&account).
            Where("version = ?", account.Version).
            Updates(map[string]interface{}{
                "available_balance": newAvailableBalance,
                "frozen_balance":    newFrozenBalance,
                "version":           account.Version + 1,
            })
        
        if result.Error != nil {
            return result.Error
        }
        
        if result.RowsAffected == 0 {
            return errors.New("concurrent update conflict")
        }
        
        // è®°å½•æ“ä½œ
        operation := &AccountOperation{
            AccountID:     accountID,
            TransactionID: txID,
            OperationType: "unfreeze",
            Amount:        amount,
            BalanceBefore: account.Balance,
            BalanceAfter:  account.Balance,
            Status:        "completed",
        }
        
        return tx.Create(operation).Error
    })
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// GetBalance è·å–ä½™é¢
func (s *Service) GetBalance(ctx context.Context, accountID uuid.UUID) (*Account, error) {
    ctx, span := s.tracer.Start(ctx, "account.get_balance",
        trace.WithAttributes(
            attribute.String("account.id", accountID.String()),
        ),
    )
    defer span.End()
    
    var account Account
    if err := s.db.WithContext(ctx).Where("id = ?", accountID).First(&account).Error; err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "account not found")
        return nil, err
    }
    
    span.SetAttributes(
        attribute.String("balance", account.Balance.String()),
        attribute.String("available_balance", account.AvailableBalance.String()),
    )
    span.SetStatus(codes.Ok, "")
    
    return &account, nil
}
```

---

## 4. äº¤æ˜“æœåŠ¡

### 4.1 æ•°æ®æ¨¡å‹

```go
package transaction

import (
    "time"
    
    "github.com/google/uuid"
    "github.com/shopspring/decimal"
    "gorm.io/gorm"
)

// Transaction äº¤æ˜“
type Transaction struct {
    ID                uuid.UUID       `gorm:"type:uuid;primary_key" json:"id"`
    TransactionNumber string          `gorm:"uniqueIndex;not null" json:"transaction_number"`
    Type              string          `gorm:"not null;index" json:"type"` // transfer, deposit, withdrawal
    FromAccountID     *uuid.UUID      `gorm:"type:uuid;index" json:"from_account_id,omitempty"`
    ToAccountID       *uuid.UUID      `gorm:"type:uuid;index" json:"to_account_id,omitempty"`
    Amount            decimal.Decimal `gorm:"type:decimal(20,2);not null" json:"amount"`
    Currency          string          `gorm:"not null" json:"currency"`
    Status            string          `gorm:"not null;index" json:"status"` // pending, processing, completed, failed, cancelled
    RiskScore         float64         `gorm:"not null;default:0" json:"risk_score"`
    RiskStatus        string          `gorm:"not null;default:'approved'" json:"risk_status"` // approved, rejected, review
    Description       string          `json:"description"`
    Metadata          string          `gorm:"type:jsonb" json:"metadata,omitempty"`
    CreatedAt         time.Time       `json:"created_at"`
    UpdatedAt         time.Time       `json:"updated_at"`
    CompletedAt       *time.Time      `json:"completed_at,omitempty"`
}

// BeforeCreate Hook
func (t *Transaction) BeforeCreate(tx *gorm.DB) error {
    if t.ID == uuid.Nil {
        t.ID = uuid.New()
    }
    if t.TransactionNumber == "" {
        t.TransactionNumber = generateTransactionNumber()
    }
    return nil
}

func generateTransactionNumber() string {
    return fmt.Sprintf("TXN%d%06d", time.Now().Unix(), rand.Intn(1000000))
}
```

### 4.2 äº¤æ˜“æœåŠ¡å®ç°ï¼ˆä½¿ç”¨ 2PCï¼‰

```go
package transaction

import (
    "context"
    "errors"
    "time"
    
    "github.com/shopspring/decimal"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/baggage"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
    "gorm.io/gorm"
)

// Service äº¤æ˜“æœåŠ¡
type Service struct {
    db             *gorm.DB
    accountService AccountServiceClient
    riskService    RiskServiceClient
    auditService   AuditServiceClient
    tracer         trace.Tracer
    meter          metric.Meter
    
    // Metrics
    transactionCounter metric.Int64Counter
    amountHistogram    metric.Float64Histogram
    durationHistogram  metric.Float64Histogram
}

// NewService åˆ›å»ºäº¤æ˜“æœåŠ¡
func NewService(
    db *gorm.DB,
    accountSvc AccountServiceClient,
    riskSvc RiskServiceClient,
    auditSvc AuditServiceClient,
) (*Service, error) {
    tracer := otel.Tracer("transaction-service")
    meter := otel.Meter("transaction-service")
    
    svc := &Service{
        db:             db,
        accountService: accountSvc,
        riskService:    riskSvc,
        auditService:   auditSvc,
        tracer:         tracer,
        meter:          meter,
    }
    
    var err error
    
    // äº¤æ˜“è®¡æ•°å™¨
    svc.transactionCounter, err = meter.Int64Counter(
        "transaction.count",
        metric.WithDescription("Transaction count"),
    )
    if err != nil {
        return nil, err
    }
    
    // äº¤æ˜“é‡‘é¢åˆ†å¸ƒ
    svc.amountHistogram, err = meter.Float64Histogram(
        "transaction.amount",
        metric.WithDescription("Transaction amount"),
        metric.WithUnit("USD"),
    )
    if err != nil {
        return nil, err
    }
    
    // äº¤æ˜“æ—¶é•¿
    svc.durationHistogram, err = meter.Float64Histogram(
        "transaction.duration",
        metric.WithDescription("Transaction processing duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    return svc, nil
}

// Transfer è½¬è´¦ï¼ˆä½¿ç”¨ 2PCï¼‰
func (s *Service) Transfer(ctx context.Context, req *TransferRequest) (*Transaction, error) {
    ctx, span := s.tracer.Start(ctx, "transaction.transfer",
        trace.WithSpanKind(trace.SpanKindServer),
        trace.WithAttributes(
            attribute.String("from_account", req.FromAccountID.String()),
            attribute.String("to_account", req.ToAccountID.String()),
            attribute.String("amount", req.Amount.String()),
        ),
    )
    defer span.End()
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        s.durationHistogram.Record(ctx, float64(duration.Milliseconds()))
    }()
    
    // åˆ›å»ºäº¤æ˜“è®°å½•
    tx := &Transaction{
        Type:          "transfer",
        FromAccountID: &req.FromAccountID,
        ToAccountID:   &req.ToAccountID,
        Amount:        req.Amount,
        Currency:      req.Currency,
        Status:        "pending",
        Description:   req.Description,
    }
    
    if err := s.db.WithContext(ctx).Create(tx).Error; err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "failed to create transaction")
        return nil, err
    }
    
    span.SetAttributes(
        attribute.String("transaction.id", tx.ID.String()),
        attribute.String("transaction.number", tx.TransactionNumber),
    )
    
    // æ·»åŠ  Baggageï¼ˆä¼ æ’­äº¤æ˜“IDï¼‰
    member, _ := baggage.NewMember("transaction.id", tx.ID.String())
    bag, _ := baggage.New(member)
    ctx = baggage.ContextWithBaggage(ctx, bag)
    
    // æ‰§è¡Œ 2PC
    tpc := NewTwoPhaseCommit(s, tx)
    if err := tpc.Execute(ctx); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        
        s.transactionCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("type", "transfer"),
                attribute.String("status", "failed"),
            ),
        )
        
        return nil, err
    }
    
    span.SetStatus(codes.Ok, "")
    
    amount, _ := req.Amount.Float64()
    s.amountHistogram.Record(ctx, amount,
        metric.WithAttributes(attribute.String("type", "transfer")),
    )
    s.transactionCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("type", "transfer"),
            attribute.String("status", "success"),
        ),
    )
    
    return tx, nil
}

// TransferRequest è½¬è´¦è¯·æ±‚
type TransferRequest struct {
    FromAccountID uuid.UUID       `json:"from_account_id" binding:"required"`
    ToAccountID   uuid.UUID       `json:"to_account_id" binding:"required"`
    Amount        decimal.Decimal `json:"amount" binding:"required,gt=0"`
    Currency      string          `json:"currency" binding:"required"`
    Description   string          `json:"description"`
}
```

---

## 5. é£æ§æœåŠ¡

### 5.1 é£æ§è§„åˆ™

```go
package risk

import (
    "context"
    "time"
    
    "github.com/shopspring/decimal"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// Service é£æ§æœåŠ¡
type Service struct {
    db     *gorm.DB
    tracer trace.Tracer
}

// NewService åˆ›å»ºé£æ§æœåŠ¡
func NewService(db *gorm.DB) *Service {
    return &Service{
        db:     db,
        tracer: otel.Tracer("risk-service"),
    }
}

// Evaluate è¯„ä¼°äº¤æ˜“é£é™©
func (s *Service) Evaluate(ctx context.Context, req *EvaluateRequest) (*EvaluateResponse, error) {
    ctx, span := s.tracer.Start(ctx, "risk.evaluate",
        trace.WithAttributes(
            attribute.String("account.id", req.AccountID.String()),
            attribute.String("amount", req.Amount.String()),
            attribute.String("type", req.TransactionType),
        ),
    )
    defer span.End()
    
    var score float64
    var reasons []string
    
    // è§„åˆ™1: å•ç¬”äº¤æ˜“é‡‘é¢é™åˆ¶
    if req.Amount.GreaterThan(decimal.NewFromInt(10000)) {
        score += 30
        reasons = append(reasons, "large_amount")
        span.AddEvent("high amount detected")
    }
    
    // è§„åˆ™2: äº¤æ˜“é¢‘ç‡æ£€æŸ¥
    frequency, err := s.checkTransactionFrequency(ctx, req.AccountID)
    if err != nil {
        span.RecordError(err)
    } else {
        if frequency > 10 {
            score += 20
            reasons = append(reasons, "high_frequency")
            span.AddEvent("high frequency detected")
        }
    }
    
    // è§„åˆ™3: å¤œé—´äº¤æ˜“
    hour := time.Now().Hour()
    if hour < 6 || hour > 22 {
        score += 10
        reasons = append(reasons, "unusual_time")
        span.AddEvent("unusual time detected")
    }
    
    // è§„åˆ™4: è·¨å¢ƒäº¤æ˜“ï¼ˆç®€åŒ–åˆ¤æ–­ï¼‰
    if req.Currency != "USD" {
        score += 15
        reasons = append(reasons, "cross_border")
        span.AddEvent("cross border transaction")
    }
    
    // ç¡®å®šé£é™©ç­‰çº§
    var riskLevel string
    var approved bool
    
    if score < 30 {
        riskLevel = "low"
        approved = true
    } else if score < 60 {
        riskLevel = "medium"
        approved = true // å¯èƒ½éœ€è¦é¢å¤–éªŒè¯
    } else {
        riskLevel = "high"
        approved = false // éœ€è¦äººå·¥å®¡æ ¸
    }
    
    span.SetAttributes(
        attribute.Float64("risk.score", score),
        attribute.String("risk.level", riskLevel),
        attribute.Bool("risk.approved", approved),
    )
    span.SetStatus(codes.Ok, "")
    
    return &EvaluateResponse{
        Score:     score,
        Level:     riskLevel,
        Approved:  approved,
        Reasons:   reasons,
    }, nil
}

// checkTransactionFrequency æ£€æŸ¥äº¤æ˜“é¢‘ç‡
func (s *Service) checkTransactionFrequency(ctx context.Context, accountID uuid.UUID) (int64, error) {
    var count int64
    
    // æŸ¥è¯¢è¿‡å»1å°æ—¶å†…çš„äº¤æ˜“æ¬¡æ•°
    err := s.db.WithContext(ctx).
        Model(&Transaction{}).
        Where("(from_account_id = ? OR to_account_id = ?) AND created_at > ?",
            accountID, accountID, time.Now().Add(-1*time.Hour)).
        Count(&count).Error
    
    return count, err
}

// EvaluateRequest é£æ§è¯„ä¼°è¯·æ±‚
type EvaluateRequest struct {
    AccountID       uuid.UUID       `json:"account_id"`
    Amount          decimal.Decimal `json:"amount"`
    TransactionType string          `json:"transaction_type"`
    Currency        string          `json:"currency"`
}

// EvaluateResponse é£æ§è¯„ä¼°å“åº”
type EvaluateResponse struct {
    Score    float64  `json:"score"`
    Level    string   `json:"level"`
    Approved bool     `json:"approved"`
    Reasons  []string `json:"reasons"`
}
```

---

ç”±äºå†…å®¹è¾ƒé•¿ï¼Œæˆ‘å°†ç»§ç»­åœ¨ä¸‹ä¸€éƒ¨åˆ†å®ç° 2PCã€å¯¹è´¦æœåŠ¡å’Œå®¡è®¡æ—¥å¿—ã€‚

---

## æ€»ç»“ï¼ˆPart 1ï¼‰

æœ¬æ–‡æ¡£å±•ç¤ºäº†é‡‘èäº¤æ˜“ç³»ç»Ÿçš„æ ¸å¿ƒæœåŠ¡å®ç°ï¼ŒåŒ…æ‹¬ï¼š

- **è´¦æˆ·æœåŠ¡**ï¼šç²¾ç¡®çš„è´§å¸è®¡ç®—ã€ä¹è§‚é”ã€èµ„é‡‘å†»ç»“/è§£å†»
- **äº¤æ˜“æœåŠ¡**ï¼š2PC åˆ†å¸ƒå¼äº‹åŠ¡ä¿è¯å¼ºä¸€è‡´æ€§
- **é£æ§æœåŠ¡**ï¼šå¤šç»´åº¦é£é™©è¯„ä¼°ã€å®æ—¶æ‹¦æˆª

æ¯ä¸ªæœåŠ¡éƒ½å®Œæ•´é›†æˆäº† OpenTelemetryï¼š
- âœ… åˆ†å¸ƒå¼è¿½è¸ªï¼ˆTrace + Baggageï¼‰
- âœ… ä¸šåŠ¡æŒ‡æ ‡ï¼ˆMetricsï¼‰
- âœ… å®¡è®¡æ—¥å¿—ï¼ˆEventï¼‰

### ç›¸å…³æ–‡æ¡£

- [40_å®æˆ˜æ¡ˆä¾‹_è®¢å•æ”¯ä»˜åº“å­˜é›†æˆ](./40_å®æˆ˜æ¡ˆä¾‹_è®¢å•æ”¯ä»˜åº“å­˜é›†æˆ.md)
- [33_Goé«˜çº§é”™è¯¯å¤„ç†æ¨¡å¼ä¸Contextä¼ æ’­](./33_Goé«˜çº§é”™è¯¯å¤„ç†æ¨¡å¼ä¸Contextä¼ æ’­.md)
- [31_Goé«˜çº§å¹¶å‘æ¨¡å¼ä¸OTLPå®Œæ•´é›†æˆ](./31_Goé«˜çº§å¹¶å‘æ¨¡å¼ä¸OTLPå®Œæ•´é›†æˆ.md)

