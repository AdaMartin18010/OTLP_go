# 42. 实战案例：金融交易系统分布式追踪

## 📚 目录

- [1. 系统架构](#1-系统架构)
- [2. 核心服务](#2-核心服务)
- [3. 账户服务](#3-账户服务)
- [4. 交易服务](#4-交易服务)
- [5. 风控服务](#5-风控服务)
- [6. 对账服务](#6-对账服务)
- [7. 分布式事务（2PC）](#7-分布式事务2pc)
- [8. 审计日志](#8-审计日志)
- [9. 总结](#9-总结)

---

## 1. 系统架构

### 1.1 架构图

```
                    ┌──────────────┐
                    │    Client    │
                    └──────┬───────┘
                           │
                           ▼
                    ┌──────────────┐
                    │ API Gateway  │
                    └──────┬───────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
        ▼                  ▼                  ▼
 ┌─────────────┐    ┌─────────────┐   ┌─────────────┐
 │   Account   │    │ Transaction │   │ Risk Control│
 │   Service   │    │   Service   │   │   Service   │
 └──────┬──────┘    └──────┬──────┘   └──────┬──────┘
        │                  │                  │
        │         ┌────────┴────────┐        │
        │         │                 │         │
        ▼         ▼                 ▼         ▼
 ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
 │ Account DB  │ │Transaction  │ │  Risk DB    │
 │(PostgreSQL) │ │DB(PostgreSQL│ │(PostgreSQL) │
 └─────────────┘ └─────────────┘ └─────────────┘

        ┌─────────────────────────────────┐
        │  Audit Log Service (Event Store)│
        └─────────────────────────────────┘

        ┌─────────────────────────────────┐
        │  Reconciliation Service (Cron)  │
        └─────────────────────────────────┘

        ┌─────────────────────────────────┐
        │   OTLP Backend (Jaeger/Tempo)   │
        └─────────────────────────────────┘
```

### 1.2 核心特性

- **强一致性**: 使用 2PC 保证交易一致性
- **审计追踪**: 所有操作完整记录
- **风险控制**: 实时交易风控
- **对账机制**: 定时对账，确保账务准确
- **高可用**: 服务冗余和故障恢复

---

## 2. 核心服务

### 2.1 服务列表

| 服务名称 | 职责 | 端口 | 数据库 |
|---------|------|------|--------|
| Account Service | 账户管理、余额查询 | 9101 | PostgreSQL |
| Transaction Service | 交易处理、流水记录 | 9102 | PostgreSQL |
| Risk Control Service | 风险评估、反欺诈 | 9103 | PostgreSQL |
| Audit Log Service | 审计日志、事件存储 | 9104 | Event Store |
| Reconciliation Service | 对账、数据校验 | 9105 | PostgreSQL |

### 2.2 技术栈

```go
// go.mod
module financial-system

go 1.25.1

require (
    // OpenTelemetry
    go.opentelemetry.io/otel v1.32.0
    go.opentelemetry.io/otel/sdk v1.32.0
    go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.32.0
    
    // gRPC
    google.golang.org/grpc v1.69.2
    google.golang.org/protobuf v1.36.0
    
    // 数据库
    gorm.io/gorm v1.25.12
    gorm.io/driver/postgres v1.5.11
    
    // 分布式事务
    github.com/dtm-labs/dtm v1.18.0
    
    // 工具
    github.com/google/uuid v1.6.0
    github.com/shopspring/decimal v1.4.0  // 精确的货币计算
    golang.org/x/sync v0.10.0
)
```

---

## 3. 账户服务

### 3.1 数据模型

```go
package account

import (
    "time"
    
    "github.com/google/uuid"
    "github.com/shopspring/decimal"
    "gorm.io/gorm"
)

// Account 账户
type Account struct {
    ID            uuid.UUID       `gorm:"type:uuid;primary_key" json:"id"`
    UserID        uuid.UUID       `gorm:"type:uuid;not null;uniqueIndex" json:"user_id"`
    AccountNumber string          `gorm:"uniqueIndex;not null" json:"account_number"`
    AccountType   string          `gorm:"not null" json:"account_type"` // savings, checking, investment
    Currency      string          `gorm:"not null;default:'USD'" json:"currency"`
    Balance       decimal.Decimal `gorm:"type:decimal(20,2);not null" json:"balance"`
    AvailableBalance decimal.Decimal `gorm:"type:decimal(20,2);not null" json:"available_balance"`
    FrozenBalance decimal.Decimal `gorm:"type:decimal(20,2);not null;default:0" json:"frozen_balance"`
    Status        string          `gorm:"not null;default:'active'" json:"status"` // active, frozen, closed
    CreatedAt     time.Time       `json:"created_at"`
    UpdatedAt     time.Time       `json:"updated_at"`
    Version       int             `gorm:"not null;default:0" json:"version"` // 乐观锁版本号
}

// AccountOperation 账户操作记录
type AccountOperation struct {
    ID            uuid.UUID       `gorm:"type:uuid;primary_key" json:"id"`
    AccountID     uuid.UUID       `gorm:"type:uuid;not null;index" json:"account_id"`
    TransactionID uuid.UUID       `gorm:"type:uuid;not null;index" json:"transaction_id"`
    OperationType string          `gorm:"not null" json:"operation_type"` // debit, credit, freeze, unfreeze
    Amount        decimal.Decimal `gorm:"type:decimal(20,2);not null" json:"amount"`
    BalanceBefore decimal.Decimal `gorm:"type:decimal(20,2);not null" json:"balance_before"`
    BalanceAfter  decimal.Decimal `gorm:"type:decimal(20,2);not null" json:"balance_after"`
    Status        string          `gorm:"not null" json:"status"` // pending, completed, failed
    CreatedAt     time.Time       `json:"created_at"`
}

// BeforeCreate Hooks
func (a *Account) BeforeCreate(tx *gorm.DB) error {
    if a.ID == uuid.Nil {
        a.ID = uuid.New()
    }
    if a.AccountNumber == "" {
        a.AccountNumber = generateAccountNumber()
    }
    return nil
}

func (ao *AccountOperation) BeforeCreate(tx *gorm.DB) error {
    if ao.ID == uuid.Nil {
        ao.ID = uuid.New()
    }
    return nil
}

// generateAccountNumber 生成账号
func generateAccountNumber() string {
    return fmt.Sprintf("ACC%d%04d", time.Now().Unix(), rand.Intn(10000))
}
```

### 3.2 账户服务实现

```go
package account

import (
    "context"
    "errors"
    "fmt"
    
    "github.com/shopspring/decimal"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
    "gorm.io/gorm"
    "gorm.io/gorm/clause"
)

// Service 账户服务
type Service struct {
    db     *gorm.DB
    tracer trace.Tracer
    meter  metric.Meter
    
    // Metrics
    balanceGauge       metric.Float64ObservableGauge
    operationCounter   metric.Int64Counter
    operationDuration  metric.Float64Histogram
}

// NewService 创建账户服务
func NewService(db *gorm.DB) (*Service, error) {
    tracer := otel.Tracer("account-service")
    meter := otel.Meter("account-service")
    
    svc := &Service{
        db:     db,
        tracer: tracer,
        meter:  meter,
    }
    
    var err error
    
    // 账户余额
    svc.balanceGauge, err = meter.Float64ObservableGauge(
        "account.balance",
        metric.WithDescription("Account balance"),
        metric.WithFloat64Callback(func(ctx context.Context, observer metric.Float64Observer) error {
            var accounts []Account
            if err := db.WithContext(ctx).Where("status = ?", "active").Find(&accounts).Error; err != nil {
                return err
            }
            
            for _, account := range accounts {
                balance, _ := account.Balance.Float64()
                observer.Observe(balance,
                    metric.WithAttributes(
                        attribute.String("account.id", account.ID.String()),
                        attribute.String("account.type", account.AccountType),
                        attribute.String("currency", account.Currency),
                    ),
                )
            }
            
            return nil
        }),
    )
    if err != nil {
        return nil, err
    }
    
    // 操作计数器
    svc.operationCounter, err = meter.Int64Counter(
        "account.operation.count",
        metric.WithDescription("Account operation count"),
    )
    if err != nil {
        return nil, err
    }
    
    // 操作延迟
    svc.operationDuration, err = meter.Float64Histogram(
        "account.operation.duration",
        metric.WithDescription("Account operation duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    return svc, nil
}

// Debit 扣款（借记）
func (s *Service) Debit(ctx context.Context, accountID uuid.UUID, amount decimal.Decimal, txID uuid.UUID) error {
    ctx, span := s.tracer.Start(ctx, "account.debit",
        trace.WithAttributes(
            attribute.String("account.id", accountID.String()),
            attribute.String("amount", amount.String()),
            attribute.String("transaction.id", txID.String()),
        ),
    )
    defer span.End()
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        s.operationDuration.Record(ctx, float64(duration.Milliseconds()),
            metric.WithAttributes(attribute.String("operation", "debit")),
        )
    }()
    
    err := s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        // 锁定账户（行锁 + 乐观锁）
        var account Account
        if err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).
            Where("id = ?", accountID).
            First(&account).Error; err != nil {
            return fmt.Errorf("account not found: %w", err)
        }
        
        if account.Status != "active" {
            return errors.New("account is not active")
        }
        
        span.SetAttributes(
            attribute.String("account.number", account.AccountNumber),
            attribute.String("balance.before", account.Balance.String()),
        )
        
        // 检查余额
        if account.AvailableBalance.LessThan(amount) {
            span.SetStatus(codes.Error, "insufficient balance")
            return errors.New("insufficient balance")
        }
        
        // 扣款
        newBalance := account.Balance.Sub(amount)
        newAvailableBalance := account.AvailableBalance.Sub(amount)
        
        // 更新账户（乐观锁）
        result := tx.Model(&account).
            Where("version = ?", account.Version).
            Updates(map[string]interface{}{
                "balance":           newBalance,
                "available_balance": newAvailableBalance,
                "version":           account.Version + 1,
            })
        
        if result.Error != nil {
            return result.Error
        }
        
        if result.RowsAffected == 0 {
            return errors.New("concurrent update conflict")
        }
        
        span.SetAttributes(attribute.String("balance.after", newBalance.String()))
        
        // 记录操作
        operation := &AccountOperation{
            AccountID:     accountID,
            TransactionID: txID,
            OperationType: "debit",
            Amount:        amount,
            BalanceBefore: account.Balance,
            BalanceAfter:  newBalance,
            Status:        "completed",
        }
        
        if err := tx.Create(operation).Error; err != nil {
            return err
        }
        
        return nil
    })
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        s.operationCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("operation", "debit"),
                attribute.String("status", "failed"),
            ),
        )
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    s.operationCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("operation", "debit"),
            attribute.String("status", "success"),
        ),
    )
    
    return nil
}

// Credit 存款（贷记）
func (s *Service) Credit(ctx context.Context, accountID uuid.UUID, amount decimal.Decimal, txID uuid.UUID) error {
    ctx, span := s.tracer.Start(ctx, "account.credit",
        trace.WithAttributes(
            attribute.String("account.id", accountID.String()),
            attribute.String("amount", amount.String()),
            attribute.String("transaction.id", txID.String()),
        ),
    )
    defer span.End()
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        s.operationDuration.Record(ctx, float64(duration.Milliseconds()),
            metric.WithAttributes(attribute.String("operation", "credit")),
        )
    }()
    
    err := s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        // 锁定账户
        var account Account
        if err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).
            Where("id = ?", accountID).
            First(&account).Error; err != nil {
            return fmt.Errorf("account not found: %w", err)
        }
        
        if account.Status != "active" {
            return errors.New("account is not active")
        }
        
        span.SetAttributes(
            attribute.String("account.number", account.AccountNumber),
            attribute.String("balance.before", account.Balance.String()),
        )
        
        // 存款
        newBalance := account.Balance.Add(amount)
        newAvailableBalance := account.AvailableBalance.Add(amount)
        
        // 更新账户
        result := tx.Model(&account).
            Where("version = ?", account.Version).
            Updates(map[string]interface{}{
                "balance":           newBalance,
                "available_balance": newAvailableBalance,
                "version":           account.Version + 1,
            })
        
        if result.Error != nil {
            return result.Error
        }
        
        if result.RowsAffected == 0 {
            return errors.New("concurrent update conflict")
        }
        
        span.SetAttributes(attribute.String("balance.after", newBalance.String()))
        
        // 记录操作
        operation := &AccountOperation{
            AccountID:     accountID,
            TransactionID: txID,
            OperationType: "credit",
            Amount:        amount,
            BalanceBefore: account.Balance,
            BalanceAfter:  newBalance,
            Status:        "completed",
        }
        
        if err := tx.Create(operation).Error; err != nil {
            return err
        }
        
        return nil
    })
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        s.operationCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("operation", "credit"),
                attribute.String("status", "failed"),
            ),
        )
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    s.operationCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("operation", "credit"),
            attribute.String("status", "success"),
        ),
    )
    
    return nil
}

// Freeze 冻结资金
func (s *Service) Freeze(ctx context.Context, accountID uuid.UUID, amount decimal.Decimal, txID uuid.UUID) error {
    ctx, span := s.tracer.Start(ctx, "account.freeze",
        trace.WithAttributes(
            attribute.String("account.id", accountID.String()),
            attribute.String("amount", amount.String()),
            attribute.String("transaction.id", txID.String()),
        ),
    )
    defer span.End()
    
    err := s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        var account Account
        if err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).
            Where("id = ?", accountID).
            First(&account).Error; err != nil {
            return err
        }
        
        // 检查可用余额
        if account.AvailableBalance.LessThan(amount) {
            return errors.New("insufficient available balance")
        }
        
        // 冻结（减少可用，增加冻结）
        newAvailableBalance := account.AvailableBalance.Sub(amount)
        newFrozenBalance := account.FrozenBalance.Add(amount)
        
        result := tx.Model(&account).
            Where("version = ?", account.Version).
            Updates(map[string]interface{}{
                "available_balance": newAvailableBalance,
                "frozen_balance":    newFrozenBalance,
                "version":           account.Version + 1,
            })
        
        if result.Error != nil {
            return result.Error
        }
        
        if result.RowsAffected == 0 {
            return errors.New("concurrent update conflict")
        }
        
        // 记录操作
        operation := &AccountOperation{
            AccountID:     accountID,
            TransactionID: txID,
            OperationType: "freeze",
            Amount:        amount,
            BalanceBefore: account.Balance,
            BalanceAfter:  account.Balance, // 总余额不变
            Status:        "completed",
        }
        
        return tx.Create(operation).Error
    })
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// Unfreeze 解冻资金
func (s *Service) Unfreeze(ctx context.Context, accountID uuid.UUID, amount decimal.Decimal, txID uuid.UUID) error {
    ctx, span := s.tracer.Start(ctx, "account.unfreeze",
        trace.WithAttributes(
            attribute.String("account.id", accountID.String()),
            attribute.String("amount", amount.String()),
            attribute.String("transaction.id", txID.String()),
        ),
    )
    defer span.End()
    
    err := s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        var account Account
        if err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).
            Where("id = ?", accountID).
            First(&account).Error; err != nil {
            return err
        }
        
        // 检查冻结余额
        if account.FrozenBalance.LessThan(amount) {
            return errors.New("insufficient frozen balance")
        }
        
        // 解冻（增加可用，减少冻结）
        newAvailableBalance := account.AvailableBalance.Add(amount)
        newFrozenBalance := account.FrozenBalance.Sub(amount)
        
        result := tx.Model(&account).
            Where("version = ?", account.Version).
            Updates(map[string]interface{}{
                "available_balance": newAvailableBalance,
                "frozen_balance":    newFrozenBalance,
                "version":           account.Version + 1,
            })
        
        if result.Error != nil {
            return result.Error
        }
        
        if result.RowsAffected == 0 {
            return errors.New("concurrent update conflict")
        }
        
        // 记录操作
        operation := &AccountOperation{
            AccountID:     accountID,
            TransactionID: txID,
            OperationType: "unfreeze",
            Amount:        amount,
            BalanceBefore: account.Balance,
            BalanceAfter:  account.Balance,
            Status:        "completed",
        }
        
        return tx.Create(operation).Error
    })
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// GetBalance 获取余额
func (s *Service) GetBalance(ctx context.Context, accountID uuid.UUID) (*Account, error) {
    ctx, span := s.tracer.Start(ctx, "account.get_balance",
        trace.WithAttributes(
            attribute.String("account.id", accountID.String()),
        ),
    )
    defer span.End()
    
    var account Account
    if err := s.db.WithContext(ctx).Where("id = ?", accountID).First(&account).Error; err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "account not found")
        return nil, err
    }
    
    span.SetAttributes(
        attribute.String("balance", account.Balance.String()),
        attribute.String("available_balance", account.AvailableBalance.String()),
    )
    span.SetStatus(codes.Ok, "")
    
    return &account, nil
}
```

---

## 4. 交易服务

### 4.1 数据模型

```go
package transaction

import (
    "time"
    
    "github.com/google/uuid"
    "github.com/shopspring/decimal"
    "gorm.io/gorm"
)

// Transaction 交易
type Transaction struct {
    ID                uuid.UUID       `gorm:"type:uuid;primary_key" json:"id"`
    TransactionNumber string          `gorm:"uniqueIndex;not null" json:"transaction_number"`
    Type              string          `gorm:"not null;index" json:"type"` // transfer, deposit, withdrawal
    FromAccountID     *uuid.UUID      `gorm:"type:uuid;index" json:"from_account_id,omitempty"`
    ToAccountID       *uuid.UUID      `gorm:"type:uuid;index" json:"to_account_id,omitempty"`
    Amount            decimal.Decimal `gorm:"type:decimal(20,2);not null" json:"amount"`
    Currency          string          `gorm:"not null" json:"currency"`
    Status            string          `gorm:"not null;index" json:"status"` // pending, processing, completed, failed, cancelled
    RiskScore         float64         `gorm:"not null;default:0" json:"risk_score"`
    RiskStatus        string          `gorm:"not null;default:'approved'" json:"risk_status"` // approved, rejected, review
    Description       string          `json:"description"`
    Metadata          string          `gorm:"type:jsonb" json:"metadata,omitempty"`
    CreatedAt         time.Time       `json:"created_at"`
    UpdatedAt         time.Time       `json:"updated_at"`
    CompletedAt       *time.Time      `json:"completed_at,omitempty"`
}

// BeforeCreate Hook
func (t *Transaction) BeforeCreate(tx *gorm.DB) error {
    if t.ID == uuid.Nil {
        t.ID = uuid.New()
    }
    if t.TransactionNumber == "" {
        t.TransactionNumber = generateTransactionNumber()
    }
    return nil
}

func generateTransactionNumber() string {
    return fmt.Sprintf("TXN%d%06d", time.Now().Unix(), rand.Intn(1000000))
}
```

### 4.2 交易服务实现（使用 2PC）

```go
package transaction

import (
    "context"
    "errors"
    "time"
    
    "github.com/shopspring/decimal"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/baggage"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
    "gorm.io/gorm"
)

// Service 交易服务
type Service struct {
    db             *gorm.DB
    accountService AccountServiceClient
    riskService    RiskServiceClient
    auditService   AuditServiceClient
    tracer         trace.Tracer
    meter          metric.Meter
    
    // Metrics
    transactionCounter metric.Int64Counter
    amountHistogram    metric.Float64Histogram
    durationHistogram  metric.Float64Histogram
}

// NewService 创建交易服务
func NewService(
    db *gorm.DB,
    accountSvc AccountServiceClient,
    riskSvc RiskServiceClient,
    auditSvc AuditServiceClient,
) (*Service, error) {
    tracer := otel.Tracer("transaction-service")
    meter := otel.Meter("transaction-service")
    
    svc := &Service{
        db:             db,
        accountService: accountSvc,
        riskService:    riskSvc,
        auditService:   auditSvc,
        tracer:         tracer,
        meter:          meter,
    }
    
    var err error
    
    // 交易计数器
    svc.transactionCounter, err = meter.Int64Counter(
        "transaction.count",
        metric.WithDescription("Transaction count"),
    )
    if err != nil {
        return nil, err
    }
    
    // 交易金额分布
    svc.amountHistogram, err = meter.Float64Histogram(
        "transaction.amount",
        metric.WithDescription("Transaction amount"),
        metric.WithUnit("USD"),
    )
    if err != nil {
        return nil, err
    }
    
    // 交易时长
    svc.durationHistogram, err = meter.Float64Histogram(
        "transaction.duration",
        metric.WithDescription("Transaction processing duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    return svc, nil
}

// Transfer 转账（使用 2PC）
func (s *Service) Transfer(ctx context.Context, req *TransferRequest) (*Transaction, error) {
    ctx, span := s.tracer.Start(ctx, "transaction.transfer",
        trace.WithSpanKind(trace.SpanKindServer),
        trace.WithAttributes(
            attribute.String("from_account", req.FromAccountID.String()),
            attribute.String("to_account", req.ToAccountID.String()),
            attribute.String("amount", req.Amount.String()),
        ),
    )
    defer span.End()
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        s.durationHistogram.Record(ctx, float64(duration.Milliseconds()))
    }()
    
    // 创建交易记录
    tx := &Transaction{
        Type:          "transfer",
        FromAccountID: &req.FromAccountID,
        ToAccountID:   &req.ToAccountID,
        Amount:        req.Amount,
        Currency:      req.Currency,
        Status:        "pending",
        Description:   req.Description,
    }
    
    if err := s.db.WithContext(ctx).Create(tx).Error; err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "failed to create transaction")
        return nil, err
    }
    
    span.SetAttributes(
        attribute.String("transaction.id", tx.ID.String()),
        attribute.String("transaction.number", tx.TransactionNumber),
    )
    
    // 添加 Baggage（传播交易ID）
    member, _ := baggage.NewMember("transaction.id", tx.ID.String())
    bag, _ := baggage.New(member)
    ctx = baggage.ContextWithBaggage(ctx, bag)
    
    // 执行 2PC
    tpc := NewTwoPhaseCommit(s, tx)
    if err := tpc.Execute(ctx); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        
        s.transactionCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("type", "transfer"),
                attribute.String("status", "failed"),
            ),
        )
        
        return nil, err
    }
    
    span.SetStatus(codes.Ok, "")
    
    amount, _ := req.Amount.Float64()
    s.amountHistogram.Record(ctx, amount,
        metric.WithAttributes(attribute.String("type", "transfer")),
    )
    s.transactionCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("type", "transfer"),
            attribute.String("status", "success"),
        ),
    )
    
    return tx, nil
}

// TransferRequest 转账请求
type TransferRequest struct {
    FromAccountID uuid.UUID       `json:"from_account_id" binding:"required"`
    ToAccountID   uuid.UUID       `json:"to_account_id" binding:"required"`
    Amount        decimal.Decimal `json:"amount" binding:"required,gt=0"`
    Currency      string          `json:"currency" binding:"required"`
    Description   string          `json:"description"`
}
```

---

## 5. 风控服务

### 5.1 风控规则

```go
package risk

import (
    "context"
    "time"
    
    "github.com/shopspring/decimal"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// Service 风控服务
type Service struct {
    db     *gorm.DB
    tracer trace.Tracer
}

// NewService 创建风控服务
func NewService(db *gorm.DB) *Service {
    return &Service{
        db:     db,
        tracer: otel.Tracer("risk-service"),
    }
}

// Evaluate 评估交易风险
func (s *Service) Evaluate(ctx context.Context, req *EvaluateRequest) (*EvaluateResponse, error) {
    ctx, span := s.tracer.Start(ctx, "risk.evaluate",
        trace.WithAttributes(
            attribute.String("account.id", req.AccountID.String()),
            attribute.String("amount", req.Amount.String()),
            attribute.String("type", req.TransactionType),
        ),
    )
    defer span.End()
    
    var score float64
    var reasons []string
    
    // 规则1: 单笔交易金额限制
    if req.Amount.GreaterThan(decimal.NewFromInt(10000)) {
        score += 30
        reasons = append(reasons, "large_amount")
        span.AddEvent("high amount detected")
    }
    
    // 规则2: 交易频率检查
    frequency, err := s.checkTransactionFrequency(ctx, req.AccountID)
    if err != nil {
        span.RecordError(err)
    } else {
        if frequency > 10 {
            score += 20
            reasons = append(reasons, "high_frequency")
            span.AddEvent("high frequency detected")
        }
    }
    
    // 规则3: 夜间交易
    hour := time.Now().Hour()
    if hour < 6 || hour > 22 {
        score += 10
        reasons = append(reasons, "unusual_time")
        span.AddEvent("unusual time detected")
    }
    
    // 规则4: 跨境交易（简化判断）
    if req.Currency != "USD" {
        score += 15
        reasons = append(reasons, "cross_border")
        span.AddEvent("cross border transaction")
    }
    
    // 确定风险等级
    var riskLevel string
    var approved bool
    
    if score < 30 {
        riskLevel = "low"
        approved = true
    } else if score < 60 {
        riskLevel = "medium"
        approved = true // 可能需要额外验证
    } else {
        riskLevel = "high"
        approved = false // 需要人工审核
    }
    
    span.SetAttributes(
        attribute.Float64("risk.score", score),
        attribute.String("risk.level", riskLevel),
        attribute.Bool("risk.approved", approved),
    )
    span.SetStatus(codes.Ok, "")
    
    return &EvaluateResponse{
        Score:     score,
        Level:     riskLevel,
        Approved:  approved,
        Reasons:   reasons,
    }, nil
}

// checkTransactionFrequency 检查交易频率
func (s *Service) checkTransactionFrequency(ctx context.Context, accountID uuid.UUID) (int64, error) {
    var count int64
    
    // 查询过去1小时内的交易次数
    err := s.db.WithContext(ctx).
        Model(&Transaction{}).
        Where("(from_account_id = ? OR to_account_id = ?) AND created_at > ?",
            accountID, accountID, time.Now().Add(-1*time.Hour)).
        Count(&count).Error
    
    return count, err
}

// EvaluateRequest 风控评估请求
type EvaluateRequest struct {
    AccountID       uuid.UUID       `json:"account_id"`
    Amount          decimal.Decimal `json:"amount"`
    TransactionType string          `json:"transaction_type"`
    Currency        string          `json:"currency"`
}

// EvaluateResponse 风控评估响应
type EvaluateResponse struct {
    Score    float64  `json:"score"`
    Level    string   `json:"level"`
    Approved bool     `json:"approved"`
    Reasons  []string `json:"reasons"`
}
```

---

由于内容较长，我将继续在下一部分实现 2PC、对账服务和审计日志。

---

## 总结（Part 1）

本文档展示了金融交易系统的核心服务实现，包括：

- **账户服务**：精确的货币计算、乐观锁、资金冻结/解冻
- **交易服务**：2PC 分布式事务保证强一致性
- **风控服务**：多维度风险评估、实时拦截

每个服务都完整集成了 OpenTelemetry：
- ✅ 分布式追踪（Trace + Baggage）
- ✅ 业务指标（Metrics）
- ✅ 审计日志（Event）

### 相关文档

- [40_实战案例_订单支付库存集成](./40_实战案例_订单支付库存集成.md)
- [33_Go高级错误处理模式与Context传播](./33_Go高级错误处理模式与Context传播.md)
- [31_Go高级并发模式与OTLP完整集成](./31_Go高级并发模式与OTLP完整集成.md)

