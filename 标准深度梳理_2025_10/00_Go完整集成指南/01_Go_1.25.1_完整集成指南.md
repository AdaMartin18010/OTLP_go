# Go 1.25.1 与 OpenTelemetry OTLP 完整集成指南

> **Go 版本**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0+  
> **OTLP Protocol**: v1.5.0  
> **最后更新**: 2025年10月8日

---

## 📋 目录

- [Go 1.25.1 与 OpenTelemetry OTLP 完整集成指南](#go-1251-与-opentelemetry-otlp-完整集成指南)
  - [📋 目录](#-目录)
  - [概述](#概述)
    - [为什么选择 Go + OpenTelemetry](#为什么选择-go--opentelemetry)
    - [架构概览](#架构概览)
  - [快速开始](#快速开始)
    - [5 分钟快速集成](#5-分钟快速集成)
    - [运行要求](#运行要求)
  - [核心依赖库](#核心依赖库)
    - [必需依赖](#必需依赖)
    - [可选依赖 (推荐)](#可选依赖-推荐)
    - [依赖库版本策略](#依赖库版本策略)
  - [初始化配置](#初始化配置)
    - [完整初始化代码](#完整初始化代码)
    - [使用示例](#使用示例)
  - [Traces 集成](#traces-集成)
    - [基本 Span 创建](#基本-span-创建)
    - [高级 Span 模式](#高级-span-模式)
  - [Metrics 集成](#metrics-集成)
    - [基本 Metrics 创建](#基本-metrics-创建)
  - [Context 传播](#context-传播)
    - [W3C Trace Context 传播](#w3c-trace-context-传播)
    - [gRPC 传播](#grpc-传播)
  - [中间件集成](#中间件集成)
    - [HTTP 中间件](#http-中间件)

---

## 概述

### 为什么选择 Go + OpenTelemetry

```text
✅ Go 语言优势:
   - CSP 并发模型天然适合分布式追踪
   - Goroutine 轻量级并发处理遥测数据
   - Channel 优雅的数据管道设计
   - 编译型语言高性能
   - 静态类型保证类型安全

✅ OpenTelemetry 优势:
   - 厂商中立的可观测性标准
   - 统一的 API 和 SDK
   - 丰富的生态系统
   - 强大的社区支持
   - 自动和手动插桩结合
```

### 架构概览

```text
┌─────────────────────────────────────────────────────────────┐
│                    Go Application                           │
│                                                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │   Tracer     │  │   Meter      │  │   Logger     │       │
│  │   Provider   │  │   Provider   │  │   Provider   │       │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘       │
│         │                 │                  │              │
│  ┌──────▼─────────────────▼──────────────────▼───────┐      │
│  │            Resource & Context Propagation         │      │
│  └──────┬──────────────────┬──────────────────┬──────┘      │
│         │                  │                  │             │
│  ┌──────▼───────┐  ┌──────▼───────┐  ┌──────▼───────┐       │
│  │  Batch Span  │  │   Periodic   │  │  Batch Log   │       │
│  │  Processor   │  │   Reader     │  │  Processor   │       │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘       │
│         │                 │                 │               │
│  ┌──────▼──────────────────▼─────────────────▼───────┐      │
│  │              OTLP Exporters (gRPC/HTTP)           │      │
│  └──────┬──────────────────┬──────────────────┬──────┘      │
└─────────┼──────────────────┼──────────────────┼─────────────┘
          │                  │                  │
          └─────────┬────────┴────────┬─────────┘
                    ▼                  ▼
          ┌──────────────┐  ┌──────────────┐
          │ OpenTelemetry│  │   Backend    │
          │  Collector   │  │  (Direct)    │
          └──────────────┘  └──────────────┘
```

---

## 快速开始

### 5 分钟快速集成

```go
package main

import (
    "context"
    "log"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
    "go.opentelemetry.io/otel/trace"
)

func main() {
    // 1. 初始化 TracerProvider
    shutdown, err := initTracer()
    if err != nil {
        log.Fatalf("初始化失败: %v", err)
    }
    defer shutdown(context.Background())

    // 2. 创建 Tracer
    tracer := otel.Tracer("quick-start")

    // 3. 创建 Span
    ctx, span := tracer.Start(context.Background(), "main-operation")
    defer span.End()

    // 4. 执行业务逻辑
    doWork(ctx, tracer)

    log.Println("完成!")
}

func initTracer() (func(context.Context) error, error) {
    ctx := context.Background()

    // 创建 OTLP gRPC Exporter
    exporter, err := otlptracegrpc.New(ctx,
        otlptracegrpc.WithEndpoint("localhost:4317"),
        otlptracegrpc.WithInsecure(),
    )
    if err != nil {
        return nil, err
    }

    // 创建 Resource
    res, err := resource.New(ctx,
        resource.WithAttributes(
        semconv.ServiceName("quick-start-service"),
        semconv.ServiceVersion("1.0.0"),
        ),
    )
    if err != nil {
    return nil, err
    }

    // 创建 TracerProvider
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter),
        sdktrace.WithResource(res),
        sdktrace.WithSampler(sdktrace.AlwaysSample()),
    )

    // 设置全局 TracerProvider
    otel.SetTracerProvider(tp)

    return tp.Shutdown, nil
}

func doWork(ctx context.Context, tracer trace.Tracer) {
 _, span := tracer.Start(ctx, "doWork")
 defer span.End()

 // 模拟工作
 time.Sleep(100 * time.Millisecond)
 span.AddEvent("工作完成")
}
```

### 运行要求

```bash
# 1. 启动 OpenTelemetry Collector
docker run -d --name otel-collector \
  -p 4317:4317 \
  -p 4318:4318 \
  otel/opentelemetry-collector:latest

# 2. 初始化 Go 模块
go mod init myapp

# 3. 安装依赖
go get go.opentelemetry.io/otel@v1.32.0
go get go.opentelemetry.io/otel/sdk@v1.32.0
go get go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc@v1.32.0

# 4. 运行应用
go run main.go
```

---

## 核心依赖库

### 必需依赖

```go
    // go.mod
    module myapp

    go 1.25

    require (
    // OpenTelemetry 核心 API
    go.opentelemetry.io/otel v1.32.0
    go.opentelemetry.io/otel/trace v1.32.0
    go.opentelemetry.io/otel/metric v1.32.0

    // OpenTelemetry SDK
    go.opentelemetry.io/otel/sdk v1.32.0
    go.opentelemetry.io/otel/sdk/metric v1.32.0

    // OTLP Exporters
    go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.32.0
    go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc v1.32.0
    
    // Protocol Buffers 定义
    go.opentelemetry.io/proto/otlp v1.5.0

    // gRPC (推荐最新稳定版)
    google.golang.org/grpc v1.71.0
    google.golang.org/protobuf v1.36.10
    )
```

### 可选依赖 (推荐)

```go
    require (
    // HTTP Instrumentation
    go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.58.0

    // gRPC Instrumentation
    go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.58.0

    // Database Instrumentation
    go.opentelemetry.io/contrib/instrumentation/database/sql/otelsql v0.58.0

    // HTTP 传输 (替代 gRPC)
    go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp v1.32.0
    
    // Stdout Exporter (调试用)
    go.opentelemetry.io/otel/exporters/stdout/stdouttrace v1.32.0
    go.opentelemetry.io/otel/exporters/stdout/stdoutmetric v1.32.0

    // 自动资源检测
    go.opentelemetry.io/contrib/detectors/aws/ec2 v1.33.0
    go.opentelemetry.io/contrib/detectors/gcp v1.33.0

    // Context Propagation
    go.opentelemetry.io/otel/propagation v1.32.0

    // 工具库
    github.com/google/uuid v1.6.0
    golang.org/x/sync v0.10.0
    )
```

### 依赖库版本策略

```text
    版本选择原则:
    ✅ 使用稳定版本 (v1.x.0)
    ✅ OpenTelemetry 核心库版本保持一致
    ✅ Contrib 库可以稍后于核心库
    ✅ 定期更新以获取性能改进和 Bug 修复

    推荐更新频率:
    - 核心库: 每 3 个月
    - Contrib 库: 每 6 个月
    - gRPC: 每 6 个月
    - Protobuf: 根据安全更新

    注意事项:
    ⚠️ v1.x 版本保证 API 稳定性
    ⚠️ Semantic Convention 可能变化
    ⚠️ 测试后再更新生产环境
```

---

## 初始化配置

### 完整初始化代码

```go
package otelsetup

import (
    "context"
    "errors"
    "fmt"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/sdk/metric"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
)

// Config 配置结构
type Config struct {
    ServiceName    string
    ServiceVersion string
    Environment    string
    CollectorURL   string
    EnableMetrics  bool
    EnableTraces   bool
    SampleRate     float64
    InsecureMode   bool
}

// OTelSetup OpenTelemetry 设置管理器
type OTelSetup struct {
    config           *Config
    tracerProvider   *sdktrace.TracerProvider
    meterProvider    *metric.MeterProvider
    shutdownFuncs    []func(context.Context) error
}

// Initialize 初始化 OpenTelemetry
func Initialize(ctx context.Context, cfg *Config) (*OTelSetup, error) {
    if err := validateConfig(cfg); err != nil {
        return nil, fmt.Errorf("配置验证失败: %w", err)
    }

    setup := &OTelSetup{
        config:        cfg,
        shutdownFuncs: make([]func(context.Context) error, 0),
    }

    // 1. 创建 Resource
    res, err := setup.createResource(ctx)
    if err != nil {
        return nil, fmt.Errorf("创建 Resource 失败: %w", err)
    }

    // 2. 设置 Text Map Propagator
    otel.SetTextMapPropagator(
        propagation.NewCompositeTextMapPropagator(
            propagation.TraceContext{},
            propagation.Baggage{},
        ),
    )

    // 3. 初始化 Traces
    if cfg.EnableTraces {
        if err := setup.initTraces(ctx, res); err != nil {
            return nil, fmt.Errorf("初始化 Traces 失败: %w", err)
        }
    }

    // 4. 初始化 Metrics
    if cfg.EnableMetrics {
        if err := setup.initMetrics(ctx, res); err != nil {
            return nil, fmt.Errorf("初始化 Metrics 失败: %w", err)
        }
    }

    return setup, nil
}

// createResource 创建服务资源
func (s *OTelSetup) createResource(ctx context.Context) (*resource.Resource, error) {
    return resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName(s.config.ServiceName),
            semconv.ServiceVersion(s.config.ServiceVersion),
            semconv.DeploymentEnvironment(s.config.Environment),
        ),
        // 自动检测运行时环境
        resource.WithFromEnv(),
        resource.WithProcess(),
        resource.WithOS(),
        resource.WithContainer(),
        resource.WithHost(),
    )
}

// initTraces 初始化 Traces
func (s *OTelSetup) initTraces(ctx context.Context, res *resource.Resource) error {
    // 创建 gRPC 连接选项
    opts := []otlptracegrpc.Option{
        otlptracegrpc.WithEndpoint(s.config.CollectorURL),
    }

    if s.config.InsecureMode {
        opts = append(opts, otlptracegrpc.WithInsecure())
    }

    // 添加重试和超时配置
    opts = append(opts,
        otlptracegrpc.WithTimeout(10*time.Second),
        otlptracegrpc.WithRetry(otlptracegrpc.RetryConfig{
            Enabled:         true,
            InitialInterval: 1 * time.Second,
            MaxInterval:     30 * time.Second,
            MaxElapsedTime:  5 * time.Minute,
        }),
        otlptracegrpc.WithDialOption(
            grpc.WithBlock(),
            grpc.WithTransportCredentials(insecure.NewCredentials()),
        ),
    )

    // 创建 Trace Exporter
    exporter, err := otlptracegrpc.New(ctx, opts...)
    if err != nil {
        return fmt.Errorf("创建 Trace Exporter 失败: %w", err)
    }

    // 创建 Sampler
    sampler := sdktrace.ParentBased(
        sdktrace.TraceIDRatioBased(s.config.SampleRate),
    )

    // 创建 TracerProvider
    s.tracerProvider = sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter,
            // 批处理配置
            sdktrace.WithBatchTimeout(5*time.Second),
            sdktrace.WithMaxExportBatchSize(512),
            sdktrace.WithMaxQueueSize(2048),
        ),
        sdktrace.WithResource(res),
        sdktrace.WithSampler(sampler),
    )

    // 设置全局 TracerProvider
    otel.SetTracerProvider(s.tracerProvider)

    // 注册关闭函数
    s.shutdownFuncs = append(s.shutdownFuncs, s.tracerProvider.Shutdown)

    return nil
}

// initMetrics 初始化 Metrics
func (s *OTelSetup) initMetrics(ctx context.Context, res *resource.Resource) error {
    // 创建 gRPC 连接选项
    opts := []otlpmetricgrpc.Option{
        otlpmetricgrpc.WithEndpoint(s.config.CollectorURL),
    }

    if s.config.InsecureMode {
        opts = append(opts, otlpmetricgrpc.WithInsecure())
    }

    opts = append(opts,
        otlpmetricgrpc.WithTimeout(10*time.Second),
    )

    // 创建 Metric Exporter
    exporter, err := otlpmetricgrpc.New(ctx, opts...)
    if err != nil {
        return fmt.Errorf("创建 Metric Exporter 失败: %w", err)
    }

    // 创建 Periodic Reader
    reader := metric.NewPeriodicReader(exporter,
        metric.WithInterval(30*time.Second),
    )

    // 创建 MeterProvider
    s.meterProvider = metric.NewMeterProvider(
        metric.WithResource(res),
        metric.WithReader(reader),
    )

    // 设置全局 MeterProvider
    otel.SetMeterProvider(s.meterProvider)

    // 注册关闭函数
    s.shutdownFuncs = append(s.shutdownFuncs, s.meterProvider.Shutdown)

    return nil
}

// Shutdown 优雅关闭
func (s *OTelSetup) Shutdown(ctx context.Context) error {
    var errs []error

    for _, fn := range s.shutdownFuncs {
        if err := fn(ctx); err != nil {
            errs = append(errs, err)
        }
    }

    if len(errs) > 0 {
        return errors.Join(errs...)
    }

    return nil
}

// validateConfig 验证配置
func validateConfig(cfg *Config) error {
    if cfg.ServiceName == "" {
        return errors.New("ServiceName 不能为空")
    }
    if cfg.CollectorURL == "" {
        return errors.New("CollectorURL 不能为空")
    }
    if cfg.SampleRate < 0 || cfg.SampleRate > 1 {
        return errors.New("SampleRate 必须在 0 到 1 之间")
    }
    return nil
}
```

### 使用示例

```go
package main

import (
 "context"
 "log"
 "os"
 "os/signal"
 "syscall"

 "myapp/otelsetup"
)

func main() {
    ctx := context.Background()

    // 创建配置
    cfg := &otelsetup.Config{
        ServiceName:    "my-service",
        ServiceVersion: "1.0.0",
        Environment:    getEnv("ENVIRONMENT", "development"),
        CollectorURL:   getEnv("OTEL_EXPORTER_OTLP_ENDPOINT", "localhost:4317"),
        EnableMetrics:  true,
        EnableTraces:   true,
        SampleRate:     0.1, // 10% 采样率
        InsecureMode:   true,
    }

    // 初始化 OpenTelemetry
    setup, err := otelsetup.Initialize(ctx, cfg)
    if err != nil {
        log.Fatalf("初始化失败: %v", err)
    }

    // 设置优雅关闭
    defer func() {
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()
    
        if err := setup.Shutdown(shutdownCtx); err != nil {
            log.Printf("关闭失败: %v", err)
        }
    }()

    // 等待中断信号
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

    log.Println("应用程序运行中...")
    <-sigChan
    log.Println("收到关闭信号")
}

func getEnv(key, fallback string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return fallback
}
```

---

## Traces 集成

### 基本 Span 创建

```go
package tracing

import (
 "context"
 "time"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/codes"
 "go.opentelemetry.io/otel/trace"
)

// TracingExample 追踪示例
type TracingExample struct {
 tracer trace.Tracer
}

// NewTracingExample 创建追踪示例
func NewTracingExample() *TracingExample {
 return &TracingExample{
  tracer: otel.Tracer("tracing-example"),
 }
}

// SimpleSpan 简单 Span 示例
func (t *TracingExample) SimpleSpan(ctx context.Context) {
 // 创建 Span
 ctx, span := t.tracer.Start(ctx, "simple-operation")
 defer span.End()

 // 添加属性
 span.SetAttributes(
  attribute.String("operation.type", "simple"),
  attribute.Int("operation.id", 123),
 )

 // 执行业务逻辑
 time.Sleep(100 * time.Millisecond)
}

// NestedSpans 嵌套 Span 示例
func (t *TracingExample) NestedSpans(ctx context.Context) {
 ctx, parentSpan := t.tracer.Start(ctx, "parent-operation")
 defer parentSpan.End()

 // 子操作 1
 t.childOperation1(ctx)

 // 子操作 2
 t.childOperation2(ctx)
}

func (t *TracingExample) childOperation1(ctx context.Context) {
 _, span := t.tracer.Start(ctx, "child-operation-1")
 defer span.End()

 time.Sleep(50 * time.Millisecond)
 span.AddEvent("子操作1完成")
}

func (t *TracingExample) childOperation2(ctx context.Context) {
 _, span := t.tracer.Start(ctx, "child-operation-2")
 defer span.End()

 time.Sleep(75 * time.Millisecond)
 span.AddEvent("子操作2完成")
}

// SpanWithError 错误处理示例
func (t *TracingExample) SpanWithError(ctx context.Context) error {
 ctx, span := t.tracer.Start(ctx, "operation-with-error")
 defer span.End()

 // 模拟错误
 err := someOperation()
 if err != nil {
  // 记录错误
  span.RecordError(err)
  span.SetStatus(codes.Error, err.Error())
  return err
 }

 span.SetStatus(codes.Ok, "成功")
 return nil
}

// SpanWithEvents Span 事件示例
func (t *TracingExample) SpanWithEvents(ctx context.Context) {
 ctx, span := t.tracer.Start(ctx, "operation-with-events")
 defer span.End()

 // 记录事件
 span.AddEvent("开始处理")

 time.Sleep(50 * time.Millisecond)
 span.AddEvent("中间检查点", trace.WithAttributes(
  attribute.Int("progress", 50),
 ))

 time.Sleep(50 * time.Millisecond)
 span.AddEvent("处理完成")
}

// SpanWithLink Span 链接示例
func (t *TracingExample) SpanWithLink(ctx context.Context, relatedSpanContext trace.SpanContext) {
 // 创建带链接的 Span
 _, span := t.tracer.Start(ctx, "operation-with-link",
  trace.WithLinks(trace.Link{
   SpanContext: relatedSpanContext,
   Attributes: []attribute.KeyValue{
    attribute.String("link.type", "related-operation"),
   },
  }),
 )
 defer span.End()

 // 执行业务逻辑
 time.Sleep(100 * time.Millisecond)
}

// AsyncOperation 异步操作追踪
func (t *TracingExample) AsyncOperation(ctx context.Context) {
 ctx, span := t.tracer.Start(ctx, "async-parent")
 defer span.End()

 // 启动异步任务
 resultChan := make(chan string)
 go t.asyncWorker(ctx, resultChan)

 // 等待结果
 result := <-resultChan
 span.SetAttributes(attribute.String("async.result", result))
}

func (t *TracingExample) asyncWorker(ctx context.Context, resultChan chan<- string) {
 _, span := t.tracer.Start(ctx, "async-worker")
 defer span.End()

 // 模拟异步工作
 time.Sleep(200 * time.Millisecond)
 resultChan <- "完成"
}

func someOperation() error {
 // 模拟业务逻辑
 return nil
}
```

### 高级 Span 模式

```go
package tracing

import (
 "context"
 "fmt"
 "time"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/codes"
 "go.opentelemetry.io/otel/trace"
)

// SpanKind 示例
func SpanKindExamples(ctx context.Context) {
 tracer := otel.Tracer("span-kind-example")

 // CLIENT span
 ctx, clientSpan := tracer.Start(ctx, "http-client-request",
  trace.WithSpanKind(trace.SpanKindClient),
 )
 clientSpan.SetAttributes(
  attribute.String("http.method", "GET"),
  attribute.String("http.url", "https://api.example.com/users"),
 )
 clientSpan.End()

 // SERVER span
 ctx, serverSpan := tracer.Start(ctx, "http-server-handler",
  trace.WithSpanKind(trace.SpanKindServer),
 )
 serverSpan.SetAttributes(
  attribute.String("http.method", "POST"),
  attribute.String("http.route", "/api/users"),
 )
 serverSpan.End()

 // PRODUCER span
 ctx, producerSpan := tracer.Start(ctx, "kafka-producer",
  trace.WithSpanKind(trace.SpanKindProducer),
 )
 producerSpan.SetAttributes(
  attribute.String("messaging.system", "kafka"),
  attribute.String("messaging.destination", "orders"),
 )
 producerSpan.End()

 // CONSUMER span
 ctx, consumerSpan := tracer.Start(ctx, "kafka-consumer",
  trace.WithSpanKind(trace.SpanKindConsumer),
 )
 consumerSpan.SetAttributes(
  attribute.String("messaging.system", "kafka"),
  attribute.String("messaging.source", "orders"),
 )
 consumerSpan.End()

 // INTERNAL span
 _, internalSpan := tracer.Start(ctx, "internal-processing",
  trace.WithSpanKind(trace.SpanKindInternal),
 )
 internalSpan.End()
}

// BatchProcessing 批处理追踪
func BatchProcessing(ctx context.Context, items []string) {
 tracer := otel.Tracer("batch-processor")

 ctx, batchSpan := tracer.Start(ctx, "process-batch")
 defer batchSpan.End()

 batchSpan.SetAttributes(
  attribute.Int("batch.size", len(items)),
  attribute.String("batch.type", "items"),
 )

 successCount := 0
 errorCount := 0

 for i, item := range items {
  _, itemSpan := tracer.Start(ctx, fmt.Sprintf("process-item-%d", i))
  
  if err := processItem(item); err != nil {
   itemSpan.RecordError(err)
   itemSpan.SetStatus(codes.Error, err.Error())
   errorCount++
  } else {
   successCount++
  }
  
  itemSpan.End()
 }

 batchSpan.SetAttributes(
  attribute.Int("batch.success_count", successCount),
  attribute.Int("batch.error_count", errorCount),
 )
}

// WorkerPool 工作池追踪
func WorkerPool(ctx context.Context, jobs []Job) {
 tracer := otel.Tracer("worker-pool")

 ctx, poolSpan := tracer.Start(ctx, "worker-pool-processing")
 defer poolSpan.End()

 numWorkers := 5
 jobChan := make(chan Job, len(jobs))
 resultChan := make(chan Result, len(jobs))

 // 启动 workers
 for i := 0; i < numWorkers; i++ {
  go func(workerID int) {
   for job := range jobChan {
    workerCtx, workerSpan := tracer.Start(ctx, 
     fmt.Sprintf("worker-%d", workerID),
     trace.WithAttributes(
      attribute.Int("worker.id", workerID),
      attribute.String("job.id", job.ID),
     ),
    )

    result := processJob(job)
    resultChan <- result

    workerSpan.End()
    _ = workerCtx
   }
  }(i)
 }

 // 发送任务
 for _, job := range jobs {
  jobChan <- job
 }
 close(jobChan)

 // 收集结果
 for range jobs {
  <-resultChan
 }
}

// ConditionalTracing 条件追踪
func ConditionalTracing(ctx context.Context, enableTracing bool) {
 tracer := otel.Tracer("conditional-tracer")

 var span trace.Span
 if enableTracing {
  ctx, span = tracer.Start(ctx, "conditional-operation")
  defer span.End()
 }

 // 业务逻辑
 doWork()

 if span != nil {
  span.AddEvent("工作完成")
 }
}

// Helper functions
type Job struct {
 ID   string
 Data string
}

type Result struct {
 JobID string
 Data  string
}

func processItem(item string) error {
 time.Sleep(10 * time.Millisecond)
 return nil
}

func processJob(job Job) Result {
 time.Sleep(50 * time.Millisecond)
 return Result{JobID: job.ID, Data: "processed"}
}

func doWork() {
 time.Sleep(100 * time.Millisecond)
}
```

---

## Metrics 集成

### 基本 Metrics 创建

```go
package metrics

import (
 "context"
 "time"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/metric"
)

// MetricsExample Metrics 示例
type MetricsExample struct {
 meter metric.Meter
}

// NewMetricsExample 创建 Metrics 示例
func NewMetricsExample() *MetricsExample {
 return &MetricsExample{
  meter: otel.Meter("metrics-example"),
 }
}

// CounterExample Counter 示例
func (m *MetricsExample) CounterExample(ctx context.Context) error {
 // 创建 Counter
 counter, err := m.meter.Int64Counter(
  "requests.total",
  metric.WithDescription("请求总数"),
  metric.WithUnit("1"),
 )
 if err != nil {
  return err
 }

 // 增加计数
 counter.Add(ctx, 1,
  metric.WithAttributes(
   attribute.String("method", "GET"),
   attribute.String("endpoint", "/api/users"),
   attribute.Int("status_code", 200),
  ),
 )

 return nil
}

// UpDownCounterExample UpDownCounter 示例
func (m *MetricsExample) UpDownCounterExample(ctx context.Context) error {
 // 创建 UpDownCounter
 activeConns, err := m.meter.Int64UpDownCounter(
  "connections.active",
  metric.WithDescription("活跃连接数"),
  metric.WithUnit("1"),
 )
 if err != nil {
  return err
 }

 // 增加连接
 activeConns.Add(ctx, 1,
  metric.WithAttributes(
   attribute.String("protocol", "http"),
  ),
 )

 // 模拟连接关闭
 time.Sleep(1 * time.Second)
 activeConns.Add(ctx, -1,
  metric.WithAttributes(
   attribute.String("protocol", "http"),
  ),
 )

 return nil
}

// HistogramExample Histogram 示例
func (m *MetricsExample) HistogramExample(ctx context.Context) error {
 // 创建 Histogram
 histogram, err := m.meter.Float64Histogram(
  "request.duration",
  metric.WithDescription("请求持续时间"),
  metric.WithUnit("ms"),
 )
 if err != nil {
  return err
 }

 start := time.Now()
 
 // 执行操作
 time.Sleep(100 * time.Millisecond)
 
 duration := float64(time.Since(start).Milliseconds())
 
 // 记录持续时间
 histogram.Record(ctx, duration,
  metric.WithAttributes(
   attribute.String("method", "POST"),
   attribute.String("endpoint", "/api/orders"),
  ),
 )

 return nil
}

// GaugeExample Gauge (通过 Callback) 示例
func (m *MetricsExample) GaugeExample(ctx context.Context) error {
 // 创建 Observable Gauge
 _, err := m.meter.Float64ObservableGauge(
  "system.memory.usage",
  metric.WithDescription("系统内存使用率"),
  metric.WithUnit("%"),
  metric.WithFloat64Callback(func(ctx context.Context, observer metric.Float64Observer) error {
   // 获取当前内存使用率
   usage := getMemoryUsage()
   observer.Observe(usage,
    metric.WithAttributes(
     attribute.String("host", "localhost"),
    ),
   )
   return nil
  }),
 )

 return err
}

// CompleteMetricsSetup 完整 Metrics 设置
type CompleteMetricsSetup struct {
 meter metric.Meter

 // Counters
 requestCounter    metric.Int64Counter
 errorCounter      metric.Int64Counter

 // UpDownCounters
 activeUsers       metric.Int64UpDownCounter
 connectionPool    metric.Int64UpDownCounter

 // Histograms
 requestDuration   metric.Float64Histogram
 payloadSize       metric.Int64Histogram

 // Gauges (Observable)
 cpuUsage          metric.Float64ObservableGauge
 memoryUsage       metric.Float64ObservableGauge
}

// NewCompleteMetricsSetup 创建完整 Metrics 设置
func NewCompleteMetricsSetup() (*CompleteMetricsSetup, error) {
 meter := otel.Meter("complete-metrics")
 setup := &CompleteMetricsSetup{meter: meter}

 var err error

 // 初始化 Counters
 setup.requestCounter, err = meter.Int64Counter(
  "http.server.request.count",
  metric.WithDescription("HTTP 请求总数"),
  metric.WithUnit("1"),
 )
 if err != nil {
  return nil, err
 }

 setup.errorCounter, err = meter.Int64Counter(
  "http.server.error.count",
  metric.WithDescription("HTTP 错误总数"),
  metric.WithUnit("1"),
 )
 if err != nil {
  return nil, err
 }

 // 初始化 UpDownCounters
 setup.activeUsers, err = meter.Int64UpDownCounter(
  "app.users.active",
  metric.WithDescription("活跃用户数"),
  metric.WithUnit("1"),
 )
 if err != nil {
  return nil, err
 }

 setup.connectionPool, err = meter.Int64UpDownCounter(
  "db.connection.pool",
  metric.WithDescription("数据库连接池大小"),
  metric.WithUnit("1"),
 )
 if err != nil {
  return nil, err
 }

 // 初始化 Histograms
 setup.requestDuration, err = meter.Float64Histogram(
  "http.server.request.duration",
  metric.WithDescription("HTTP 请求持续时间"),
  metric.WithUnit("ms"),
 )
 if err != nil {
  return nil, err
 }

 setup.payloadSize, err = meter.Int64Histogram(
  "http.server.request.size",
  metric.WithDescription("HTTP 请求大小"),
  metric.WithUnit("bytes"),
 )
 if err != nil {
  return nil, err
 }

 // 初始化 Gauges
 setup.cpuUsage, err = meter.Float64ObservableGauge(
  "system.cpu.usage",
  metric.WithDescription("CPU 使用率"),
  metric.WithUnit("%"),
  metric.WithFloat64Callback(func(ctx context.Context, observer metric.Float64Observer) error {
   usage := getCPUUsage()
   observer.Observe(usage)
   return nil
  }),
 )
 if err != nil {
  return nil, err
 }

 setup.memoryUsage, err = meter.Float64ObservableGauge(
  "system.memory.usage",
  metric.WithDescription("内存使用率"),
  metric.WithUnit("%"),
  metric.WithFloat64Callback(func(ctx context.Context, observer metric.Float64Observer) error {
   usage := getMemoryUsage()
   observer.Observe(usage)
   return nil
  }),
 )
 if err != nil {
  return nil, err
 }

 return setup, nil
}

// RecordHTTPRequest 记录 HTTP 请求
func (m *CompleteMetricsSetup) RecordHTTPRequest(
 ctx context.Context,
 method string,
 path string,
 statusCode int,
 duration time.Duration,
 payloadSize int64,
) {
 attrs := metric.WithAttributes(
  attribute.String("http.method", method),
  attribute.String("http.route", path),
  attribute.Int("http.status_code", statusCode),
 )

 // 记录请求数
 m.requestCounter.Add(ctx, 1, attrs)

 // 记录错误（如果有）
 if statusCode >= 400 {
  m.errorCounter.Add(ctx, 1, attrs)
 }

 // 记录持续时间
 m.requestDuration.Record(ctx, float64(duration.Milliseconds()), attrs)

 // 记录请求大小
 if payloadSize > 0 {
  m.payloadSize.Record(ctx, payloadSize, attrs)
 }
}

// Helper functions
func getMemoryUsage() float64 {
 // 实际实现应该获取真实的内存使用率
 return 75.5
}

func getCPUUsage() float64 {
 // 实际实现应该获取真实的 CPU 使用率
 return 45.2
}
```

继续下一部分...

---

## Context 传播

### W3C Trace Context 传播

```go
package propagation

import (
 "context"
 "net/http"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/propagation"
 "go.opentelemetry.io/otel/trace"
)

// HTTPPropagation HTTP 传播示例
type HTTPPropagation struct {
 propagator propagation.TextMapPropagator
 tracer     trace.Tracer
}

// NewHTTPPropagation 创建 HTTP 传播器
func NewHTTPPropagation() *HTTPPropagation {
 return &HTTPPropagation{
  propagator: otel.GetTextMapPropagator(),
  tracer:     otel.Tracer("http-propagation"),
 }
}

// ClientRequest 客户端请求 - 注入 Context
func (p *HTTPPropagation) ClientRequest(ctx context.Context, url string) error {
 // 创建 client span
 ctx, span := p.tracer.Start(ctx, "http-client-request")
 defer span.End()

 // 创建 HTTP 请求
 req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
 if err != nil {
  return err
 }

 // 注入 Trace Context 到 HTTP Headers
 p.propagator.Inject(ctx, propagation.HeaderCarrier(req.Header))

 // 发送请求
 client := &http.Client{}
 resp, err := client.Do(req)
 if err != nil {
  return err
 }
 defer resp.Body.Close()

 return nil
}

// ServerHandler 服务端处理 - 提取 Context
func (p *HTTPPropagation) ServerHandler(w http.ResponseWriter, r *http.Request) {
 // 从 HTTP Headers 提取 Trace Context
 ctx := p.propagator.Extract(r.Context(), propagation.HeaderCarrier(r.Header))

 // 创建 server span
 ctx, span := p.tracer.Start(ctx, "http-server-handler",
  trace.WithSpanKind(trace.SpanKindServer),
 )
 defer span.End()

 // 处理请求
 p.handleRequest(ctx)

 w.WriteHeader(http.StatusOK)
}

func (p *HTTPPropagation) handleRequest(ctx context.Context) {
 _, span := p.tracer.Start(ctx, "handle-request")
 defer span.End()

 // 业务逻辑
}
```

### gRPC 传播

```go
package propagation

import (
 "context"

 "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
 "google.golang.org/grpc"
 "google.golang.org/grpc/credentials/insecure"
)

// GRPCPropagation gRPC 传播示例
type GRPCPropagation struct{}

// CreateGRPCClient 创建 gRPC 客户端（自动传播）
func (g *GRPCPropagation) CreateGRPCClient(target string) (*grpc.ClientConn, error) {
 return grpc.NewClient(target,
  grpc.WithTransportCredentials(insecure.NewCredentials()),
  // 添加 OpenTelemetry 拦截器
  grpc.WithStatsHandler(otelgrpc.NewClientHandler()),
 )
}

// CreateGRPCServer 创建 gRPC 服务端（自动传播）
func (g *GRPCPropagation) CreateGRPCServer() *grpc.Server {
 return grpc.NewServer(
  // 添加 OpenTelemetry 拦截器
  grpc.StatsHandler(otelgrpc.NewServerHandler()),
 )
}
```

---

## 中间件集成

### HTTP 中间件

```go
package middleware

import (
 "net/http"
 "time"

 "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/metric"
 "go.opentelemetry.io/otel/trace"
)

// HTTPMiddleware HTTP 中间件
type HTTPMiddleware struct {
 meter   metric.Meter
 counter metric.Int64Counter
 histogram metric.Float64Histogram
}

// NewHTTPMiddleware 创建 HTTP 中间件
func NewHTTPMiddleware() *HTTPMiddleware {
 meter := otel.Meter("http-middleware")
 
 counter, _ := meter.Int64Counter("http.requests.total")
 histogram, _ := meter.Float64Histogram("http.request.duration")

 return &HTTPMiddleware{
  meter:     meter,
  counter:   counter,
  histogram: histogram,
 }
}

// Wrap 包装 HTTP Handler
func (m *HTTPMiddleware) Wrap(handler http.Handler, operation string) http.Handler {
 // 使用 otelhttp 自动插桩
 return otelhttp.NewHandler(handler, operation,
  otelhttp.WithSpanOptions(
   trace.WithSpanKind(trace.SpanKindServer),
  ),
  otelhttp.WithMessageEvents(otelhttp.ReadEvents, otelhttp.WriteEvents),
 )
}

// CustomMiddleware 自定义中间件
func (m *HTTPMiddleware) CustomMiddleware(next http.Handler) http.Handler {
 return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  start := time.Now()
  
  // 创建响应包装器以捕获状态码
  rw := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
  
  // 调用下一个处理器
  next.ServeHTTP(rw, r)
  
  // 记录指标
  duration := time.Since(start)
  attrs := metric.WithAttributes(
   attribute.String("http.method", r.Method),
   attribute.String("http.route", r.URL.Path),
   attribute.Int("http.status_code", rw.statusCode),
  )
  
  m.counter.Add(r.Context(), 1, attrs)
  m.histogram.Record(r.Context(), float64(duration.Milliseconds()), attrs)
 })
}

type responseWriter struct {
 http.ResponseWriter
 statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
 rw.statusCode = code
 rw.ResponseWriter.WriteHeader(code)
}
```

这是一个全面的 Go 1.25.1 与 OpenTelemetry OTLP 集成指南的第一部分。文档包含：

1. **完整的依赖配置** - 最新稳定版本
2. **生产级初始化代码** - 包含错误处理、重试、优雅关闭
3. **Traces 完整示例** - 基本到高级模式
4. **Metrics 完整示例** - 所有指标类型
5. **Context 传播** - HTTP 和 gRPC
6. **中间件集成** - 自动和手动插桩

让我继续创建剩余部分...
