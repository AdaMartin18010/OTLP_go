# Go 1.25.1 ä¸ OpenTelemetry OTLP å®Œæ•´é›†æˆæŒ‡å—

> **Go ç‰ˆæœ¬**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0+  
> **OTLP Protocol**: v1.5.0  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ8æ—¥

---

## ğŸ“‹ ç›®å½•

- [Go 1.25.1 ä¸ OpenTelemetry OTLP å®Œæ•´é›†æˆæŒ‡å—](#go-1251-ä¸-opentelemetry-otlp-å®Œæ•´é›†æˆæŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [ä¸ºä»€ä¹ˆé€‰æ‹© Go + OpenTelemetry](#ä¸ºä»€ä¹ˆé€‰æ‹©-go--opentelemetry)
    - [æ¶æ„æ¦‚è§ˆ](#æ¶æ„æ¦‚è§ˆ)
  - [å¿«é€Ÿå¼€å§‹](#å¿«é€Ÿå¼€å§‹)
    - [5 åˆ†é’Ÿå¿«é€Ÿé›†æˆ](#5-åˆ†é’Ÿå¿«é€Ÿé›†æˆ)
    - [è¿è¡Œè¦æ±‚](#è¿è¡Œè¦æ±‚)
  - [æ ¸å¿ƒä¾èµ–åº“](#æ ¸å¿ƒä¾èµ–åº“)
    - [å¿…éœ€ä¾èµ–](#å¿…éœ€ä¾èµ–)
    - [å¯é€‰ä¾èµ– (æ¨è)](#å¯é€‰ä¾èµ–-æ¨è)
    - [ä¾èµ–åº“ç‰ˆæœ¬ç­–ç•¥](#ä¾èµ–åº“ç‰ˆæœ¬ç­–ç•¥)
  - [åˆå§‹åŒ–é…ç½®](#åˆå§‹åŒ–é…ç½®)
    - [å®Œæ•´åˆå§‹åŒ–ä»£ç ](#å®Œæ•´åˆå§‹åŒ–ä»£ç )
    - [ä½¿ç”¨ç¤ºä¾‹](#ä½¿ç”¨ç¤ºä¾‹)
  - [Traces é›†æˆ](#traces-é›†æˆ)
    - [åŸºæœ¬ Span åˆ›å»º](#åŸºæœ¬-span-åˆ›å»º)
    - [é«˜çº§ Span æ¨¡å¼](#é«˜çº§-span-æ¨¡å¼)
  - [Metrics é›†æˆ](#metrics-é›†æˆ)
    - [åŸºæœ¬ Metrics åˆ›å»º](#åŸºæœ¬-metrics-åˆ›å»º)
  - [Context ä¼ æ’­](#context-ä¼ æ’­)
    - [W3C Trace Context ä¼ æ’­](#w3c-trace-context-ä¼ æ’­)
    - [gRPC ä¼ æ’­](#grpc-ä¼ æ’­)
  - [ä¸­é—´ä»¶é›†æˆ](#ä¸­é—´ä»¶é›†æˆ)
    - [HTTP ä¸­é—´ä»¶](#http-ä¸­é—´ä»¶)

---

## æ¦‚è¿°

### ä¸ºä»€ä¹ˆé€‰æ‹© Go + OpenTelemetry

```text
âœ… Go è¯­è¨€ä¼˜åŠ¿:
   - CSP å¹¶å‘æ¨¡å‹å¤©ç„¶é€‚åˆåˆ†å¸ƒå¼è¿½è¸ª
   - Goroutine è½»é‡çº§å¹¶å‘å¤„ç†é¥æµ‹æ•°æ®
   - Channel ä¼˜é›…çš„æ•°æ®ç®¡é“è®¾è®¡
   - ç¼–è¯‘å‹è¯­è¨€é«˜æ€§èƒ½
   - é™æ€ç±»å‹ä¿è¯ç±»å‹å®‰å…¨

âœ… OpenTelemetry ä¼˜åŠ¿:
   - å‚å•†ä¸­ç«‹çš„å¯è§‚æµ‹æ€§æ ‡å‡†
   - ç»Ÿä¸€çš„ API å’Œ SDK
   - ä¸°å¯Œçš„ç”Ÿæ€ç³»ç»Ÿ
   - å¼ºå¤§çš„ç¤¾åŒºæ”¯æŒ
   - è‡ªåŠ¨å’Œæ‰‹åŠ¨æ’æ¡©ç»“åˆ
```

### æ¶æ„æ¦‚è§ˆ

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Go Application                           â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚   Tracer     â”‚  â”‚   Meter      â”‚  â”‚   Logger     â”‚       â”‚
â”‚  â”‚   Provider   â”‚  â”‚   Provider   â”‚  â”‚   Provider   â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚         â”‚                 â”‚                  â”‚              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚            Resource & Context Propagation         â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚         â”‚                  â”‚                  â”‚             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  Batch Span  â”‚  â”‚   Periodic   â”‚  â”‚  Batch Log   â”‚       â”‚
â”‚  â”‚  Processor   â”‚  â”‚   Reader     â”‚  â”‚  Processor   â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚         â”‚                 â”‚                 â”‚               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚              OTLP Exporters (gRPC/HTTP)           â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                  â”‚                  â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â–¼                  â–¼
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚ OpenTelemetryâ”‚  â”‚   Backend    â”‚
          â”‚  Collector   â”‚  â”‚  (Direct)    â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## å¿«é€Ÿå¼€å§‹

### 5 åˆ†é’Ÿå¿«é€Ÿé›†æˆ

```go
package main

import (
    "context"
    "log"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
    "go.opentelemetry.io/otel/trace"
)

func main() {
    // 1. åˆå§‹åŒ– TracerProvider
    shutdown, err := initTracer()
    if err != nil {
        log.Fatalf("åˆå§‹åŒ–å¤±è´¥: %v", err)
    }
    defer shutdown(context.Background())

    // 2. åˆ›å»º Tracer
    tracer := otel.Tracer("quick-start")

    // 3. åˆ›å»º Span
    ctx, span := tracer.Start(context.Background(), "main-operation")
    defer span.End()

    // 4. æ‰§è¡Œä¸šåŠ¡é€»è¾‘
    doWork(ctx, tracer)

    log.Println("å®Œæˆ!")
}

func initTracer() (func(context.Context) error, error) {
    ctx := context.Background()

    // åˆ›å»º OTLP gRPC Exporter
    exporter, err := otlptracegrpc.New(ctx,
        otlptracegrpc.WithEndpoint("localhost:4317"),
        otlptracegrpc.WithInsecure(),
    )
    if err != nil {
        return nil, err
    }

    // åˆ›å»º Resource
    res, err := resource.New(ctx,
        resource.WithAttributes(
        semconv.ServiceName("quick-start-service"),
        semconv.ServiceVersion("1.0.0"),
        ),
    )
    if err != nil {
    return nil, err
    }

    // åˆ›å»º TracerProvider
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter),
        sdktrace.WithResource(res),
        sdktrace.WithSampler(sdktrace.AlwaysSample()),
    )

    // è®¾ç½®å…¨å±€ TracerProvider
    otel.SetTracerProvider(tp)

    return tp.Shutdown, nil
}

func doWork(ctx context.Context, tracer trace.Tracer) {
 _, span := tracer.Start(ctx, "doWork")
 defer span.End()

 // æ¨¡æ‹Ÿå·¥ä½œ
 time.Sleep(100 * time.Millisecond)
 span.AddEvent("å·¥ä½œå®Œæˆ")
}
```

### è¿è¡Œè¦æ±‚

```bash
# 1. å¯åŠ¨ OpenTelemetry Collector
docker run -d --name otel-collector \
  -p 4317:4317 \
  -p 4318:4318 \
  otel/opentelemetry-collector:latest

# 2. åˆå§‹åŒ– Go æ¨¡å—
go mod init myapp

# 3. å®‰è£…ä¾èµ–
go get go.opentelemetry.io/otel@v1.32.0
go get go.opentelemetry.io/otel/sdk@v1.32.0
go get go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc@v1.32.0

# 4. è¿è¡Œåº”ç”¨
go run main.go
```

---

## æ ¸å¿ƒä¾èµ–åº“

### å¿…éœ€ä¾èµ–

```go
    // go.mod
    module myapp

    go 1.25

    require (
    // OpenTelemetry æ ¸å¿ƒ API
    go.opentelemetry.io/otel v1.32.0
    go.opentelemetry.io/otel/trace v1.32.0
    go.opentelemetry.io/otel/metric v1.32.0

    // OpenTelemetry SDK
    go.opentelemetry.io/otel/sdk v1.32.0
    go.opentelemetry.io/otel/sdk/metric v1.32.0

    // OTLP Exporters
    go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.32.0
    go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc v1.32.0
    
    // Protocol Buffers å®šä¹‰
    go.opentelemetry.io/proto/otlp v1.5.0

    // gRPC (æ¨èæœ€æ–°ç¨³å®šç‰ˆ)
    google.golang.org/grpc v1.71.0
    google.golang.org/protobuf v1.36.10
    )
```

### å¯é€‰ä¾èµ– (æ¨è)

```go
    require (
    // HTTP Instrumentation
    go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.58.0

    // gRPC Instrumentation
    go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.58.0

    // Database Instrumentation
    go.opentelemetry.io/contrib/instrumentation/database/sql/otelsql v0.58.0

    // HTTP ä¼ è¾“ (æ›¿ä»£ gRPC)
    go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp v1.32.0
    
    // Stdout Exporter (è°ƒè¯•ç”¨)
    go.opentelemetry.io/otel/exporters/stdout/stdouttrace v1.32.0
    go.opentelemetry.io/otel/exporters/stdout/stdoutmetric v1.32.0

    // è‡ªåŠ¨èµ„æºæ£€æµ‹
    go.opentelemetry.io/contrib/detectors/aws/ec2 v1.33.0
    go.opentelemetry.io/contrib/detectors/gcp v1.33.0

    // Context Propagation
    go.opentelemetry.io/otel/propagation v1.32.0

    // å·¥å…·åº“
    github.com/google/uuid v1.6.0
    golang.org/x/sync v0.10.0
    )
```

### ä¾èµ–åº“ç‰ˆæœ¬ç­–ç•¥

```text
    ç‰ˆæœ¬é€‰æ‹©åŸåˆ™:
    âœ… ä½¿ç”¨ç¨³å®šç‰ˆæœ¬ (v1.x.0)
    âœ… OpenTelemetry æ ¸å¿ƒåº“ç‰ˆæœ¬ä¿æŒä¸€è‡´
    âœ… Contrib åº“å¯ä»¥ç¨åäºæ ¸å¿ƒåº“
    âœ… å®šæœŸæ›´æ–°ä»¥è·å–æ€§èƒ½æ”¹è¿›å’Œ Bug ä¿®å¤

    æ¨èæ›´æ–°é¢‘ç‡:
    - æ ¸å¿ƒåº“: æ¯ 3 ä¸ªæœˆ
    - Contrib åº“: æ¯ 6 ä¸ªæœˆ
    - gRPC: æ¯ 6 ä¸ªæœˆ
    - Protobuf: æ ¹æ®å®‰å…¨æ›´æ–°

    æ³¨æ„äº‹é¡¹:
    âš ï¸ v1.x ç‰ˆæœ¬ä¿è¯ API ç¨³å®šæ€§
    âš ï¸ Semantic Convention å¯èƒ½å˜åŒ–
    âš ï¸ æµ‹è¯•åå†æ›´æ–°ç”Ÿäº§ç¯å¢ƒ
```

---

## åˆå§‹åŒ–é…ç½®

### å®Œæ•´åˆå§‹åŒ–ä»£ç 

```go
package otelsetup

import (
    "context"
    "errors"
    "fmt"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/sdk/metric"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
)

// Config é…ç½®ç»“æ„
type Config struct {
    ServiceName    string
    ServiceVersion string
    Environment    string
    CollectorURL   string
    EnableMetrics  bool
    EnableTraces   bool
    SampleRate     float64
    InsecureMode   bool
}

// OTelSetup OpenTelemetry è®¾ç½®ç®¡ç†å™¨
type OTelSetup struct {
    config           *Config
    tracerProvider   *sdktrace.TracerProvider
    meterProvider    *metric.MeterProvider
    shutdownFuncs    []func(context.Context) error
}

// Initialize åˆå§‹åŒ– OpenTelemetry
func Initialize(ctx context.Context, cfg *Config) (*OTelSetup, error) {
    if err := validateConfig(cfg); err != nil {
        return nil, fmt.Errorf("é…ç½®éªŒè¯å¤±è´¥: %w", err)
    }

    setup := &OTelSetup{
        config:        cfg,
        shutdownFuncs: make([]func(context.Context) error, 0),
    }

    // 1. åˆ›å»º Resource
    res, err := setup.createResource(ctx)
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»º Resource å¤±è´¥: %w", err)
    }

    // 2. è®¾ç½® Text Map Propagator
    otel.SetTextMapPropagator(
        propagation.NewCompositeTextMapPropagator(
            propagation.TraceContext{},
            propagation.Baggage{},
        ),
    )

    // 3. åˆå§‹åŒ– Traces
    if cfg.EnableTraces {
        if err := setup.initTraces(ctx, res); err != nil {
            return nil, fmt.Errorf("åˆå§‹åŒ– Traces å¤±è´¥: %w", err)
        }
    }

    // 4. åˆå§‹åŒ– Metrics
    if cfg.EnableMetrics {
        if err := setup.initMetrics(ctx, res); err != nil {
            return nil, fmt.Errorf("åˆå§‹åŒ– Metrics å¤±è´¥: %w", err)
        }
    }

    return setup, nil
}

// createResource åˆ›å»ºæœåŠ¡èµ„æº
func (s *OTelSetup) createResource(ctx context.Context) (*resource.Resource, error) {
    return resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName(s.config.ServiceName),
            semconv.ServiceVersion(s.config.ServiceVersion),
            semconv.DeploymentEnvironment(s.config.Environment),
        ),
        // è‡ªåŠ¨æ£€æµ‹è¿è¡Œæ—¶ç¯å¢ƒ
        resource.WithFromEnv(),
        resource.WithProcess(),
        resource.WithOS(),
        resource.WithContainer(),
        resource.WithHost(),
    )
}

// initTraces åˆå§‹åŒ– Traces
func (s *OTelSetup) initTraces(ctx context.Context, res *resource.Resource) error {
    // åˆ›å»º gRPC è¿æ¥é€‰é¡¹
    opts := []otlptracegrpc.Option{
        otlptracegrpc.WithEndpoint(s.config.CollectorURL),
    }

    if s.config.InsecureMode {
        opts = append(opts, otlptracegrpc.WithInsecure())
    }

    // æ·»åŠ é‡è¯•å’Œè¶…æ—¶é…ç½®
    opts = append(opts,
        otlptracegrpc.WithTimeout(10*time.Second),
        otlptracegrpc.WithRetry(otlptracegrpc.RetryConfig{
            Enabled:         true,
            InitialInterval: 1 * time.Second,
            MaxInterval:     30 * time.Second,
            MaxElapsedTime:  5 * time.Minute,
        }),
        otlptracegrpc.WithDialOption(
            grpc.WithBlock(),
            grpc.WithTransportCredentials(insecure.NewCredentials()),
        ),
    )

    // åˆ›å»º Trace Exporter
    exporter, err := otlptracegrpc.New(ctx, opts...)
    if err != nil {
        return fmt.Errorf("åˆ›å»º Trace Exporter å¤±è´¥: %w", err)
    }

    // åˆ›å»º Sampler
    sampler := sdktrace.ParentBased(
        sdktrace.TraceIDRatioBased(s.config.SampleRate),
    )

    // åˆ›å»º TracerProvider
    s.tracerProvider = sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter,
            // æ‰¹å¤„ç†é…ç½®
            sdktrace.WithBatchTimeout(5*time.Second),
            sdktrace.WithMaxExportBatchSize(512),
            sdktrace.WithMaxQueueSize(2048),
        ),
        sdktrace.WithResource(res),
        sdktrace.WithSampler(sampler),
    )

    // è®¾ç½®å…¨å±€ TracerProvider
    otel.SetTracerProvider(s.tracerProvider)

    // æ³¨å†Œå…³é—­å‡½æ•°
    s.shutdownFuncs = append(s.shutdownFuncs, s.tracerProvider.Shutdown)

    return nil
}

// initMetrics åˆå§‹åŒ– Metrics
func (s *OTelSetup) initMetrics(ctx context.Context, res *resource.Resource) error {
    // åˆ›å»º gRPC è¿æ¥é€‰é¡¹
    opts := []otlpmetricgrpc.Option{
        otlpmetricgrpc.WithEndpoint(s.config.CollectorURL),
    }

    if s.config.InsecureMode {
        opts = append(opts, otlpmetricgrpc.WithInsecure())
    }

    opts = append(opts,
        otlpmetricgrpc.WithTimeout(10*time.Second),
    )

    // åˆ›å»º Metric Exporter
    exporter, err := otlpmetricgrpc.New(ctx, opts...)
    if err != nil {
        return fmt.Errorf("åˆ›å»º Metric Exporter å¤±è´¥: %w", err)
    }

    // åˆ›å»º Periodic Reader
    reader := metric.NewPeriodicReader(exporter,
        metric.WithInterval(30*time.Second),
    )

    // åˆ›å»º MeterProvider
    s.meterProvider = metric.NewMeterProvider(
        metric.WithResource(res),
        metric.WithReader(reader),
    )

    // è®¾ç½®å…¨å±€ MeterProvider
    otel.SetMeterProvider(s.meterProvider)

    // æ³¨å†Œå…³é—­å‡½æ•°
    s.shutdownFuncs = append(s.shutdownFuncs, s.meterProvider.Shutdown)

    return nil
}

// Shutdown ä¼˜é›…å…³é—­
func (s *OTelSetup) Shutdown(ctx context.Context) error {
    var errs []error

    for _, fn := range s.shutdownFuncs {
        if err := fn(ctx); err != nil {
            errs = append(errs, err)
        }
    }

    if len(errs) > 0 {
        return errors.Join(errs...)
    }

    return nil
}

// validateConfig éªŒè¯é…ç½®
func validateConfig(cfg *Config) error {
    if cfg.ServiceName == "" {
        return errors.New("ServiceName ä¸èƒ½ä¸ºç©º")
    }
    if cfg.CollectorURL == "" {
        return errors.New("CollectorURL ä¸èƒ½ä¸ºç©º")
    }
    if cfg.SampleRate < 0 || cfg.SampleRate > 1 {
        return errors.New("SampleRate å¿…é¡»åœ¨ 0 åˆ° 1 ä¹‹é—´")
    }
    return nil
}
```

### ä½¿ç”¨ç¤ºä¾‹

```go
package main

import (
 "context"
 "log"
 "os"
 "os/signal"
 "syscall"

 "myapp/otelsetup"
)

func main() {
    ctx := context.Background()

    // åˆ›å»ºé…ç½®
    cfg := &otelsetup.Config{
        ServiceName:    "my-service",
        ServiceVersion: "1.0.0",
        Environment:    getEnv("ENVIRONMENT", "development"),
        CollectorURL:   getEnv("OTEL_EXPORTER_OTLP_ENDPOINT", "localhost:4317"),
        EnableMetrics:  true,
        EnableTraces:   true,
        SampleRate:     0.1, // 10% é‡‡æ ·ç‡
        InsecureMode:   true,
    }

    // åˆå§‹åŒ– OpenTelemetry
    setup, err := otelsetup.Initialize(ctx, cfg)
    if err != nil {
        log.Fatalf("åˆå§‹åŒ–å¤±è´¥: %v", err)
    }

    // è®¾ç½®ä¼˜é›…å…³é—­
    defer func() {
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()
    
        if err := setup.Shutdown(shutdownCtx); err != nil {
            log.Printf("å…³é—­å¤±è´¥: %v", err)
        }
    }()

    // ç­‰å¾…ä¸­æ–­ä¿¡å·
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

    log.Println("åº”ç”¨ç¨‹åºè¿è¡Œä¸­...")
    <-sigChan
    log.Println("æ”¶åˆ°å…³é—­ä¿¡å·")
}

func getEnv(key, fallback string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return fallback
}
```

---

## Traces é›†æˆ

### åŸºæœ¬ Span åˆ›å»º

```go
package tracing

import (
 "context"
 "time"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/codes"
 "go.opentelemetry.io/otel/trace"
)

// TracingExample è¿½è¸ªç¤ºä¾‹
type TracingExample struct {
 tracer trace.Tracer
}

// NewTracingExample åˆ›å»ºè¿½è¸ªç¤ºä¾‹
func NewTracingExample() *TracingExample {
 return &TracingExample{
  tracer: otel.Tracer("tracing-example"),
 }
}

// SimpleSpan ç®€å• Span ç¤ºä¾‹
func (t *TracingExample) SimpleSpan(ctx context.Context) {
 // åˆ›å»º Span
 ctx, span := t.tracer.Start(ctx, "simple-operation")
 defer span.End()

 // æ·»åŠ å±æ€§
 span.SetAttributes(
  attribute.String("operation.type", "simple"),
  attribute.Int("operation.id", 123),
 )

 // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
 time.Sleep(100 * time.Millisecond)
}

// NestedSpans åµŒå¥— Span ç¤ºä¾‹
func (t *TracingExample) NestedSpans(ctx context.Context) {
 ctx, parentSpan := t.tracer.Start(ctx, "parent-operation")
 defer parentSpan.End()

 // å­æ“ä½œ 1
 t.childOperation1(ctx)

 // å­æ“ä½œ 2
 t.childOperation2(ctx)
}

func (t *TracingExample) childOperation1(ctx context.Context) {
 _, span := t.tracer.Start(ctx, "child-operation-1")
 defer span.End()

 time.Sleep(50 * time.Millisecond)
 span.AddEvent("å­æ“ä½œ1å®Œæˆ")
}

func (t *TracingExample) childOperation2(ctx context.Context) {
 _, span := t.tracer.Start(ctx, "child-operation-2")
 defer span.End()

 time.Sleep(75 * time.Millisecond)
 span.AddEvent("å­æ“ä½œ2å®Œæˆ")
}

// SpanWithError é”™è¯¯å¤„ç†ç¤ºä¾‹
func (t *TracingExample) SpanWithError(ctx context.Context) error {
 ctx, span := t.tracer.Start(ctx, "operation-with-error")
 defer span.End()

 // æ¨¡æ‹Ÿé”™è¯¯
 err := someOperation()
 if err != nil {
  // è®°å½•é”™è¯¯
  span.RecordError(err)
  span.SetStatus(codes.Error, err.Error())
  return err
 }

 span.SetStatus(codes.Ok, "æˆåŠŸ")
 return nil
}

// SpanWithEvents Span äº‹ä»¶ç¤ºä¾‹
func (t *TracingExample) SpanWithEvents(ctx context.Context) {
 ctx, span := t.tracer.Start(ctx, "operation-with-events")
 defer span.End()

 // è®°å½•äº‹ä»¶
 span.AddEvent("å¼€å§‹å¤„ç†")

 time.Sleep(50 * time.Millisecond)
 span.AddEvent("ä¸­é—´æ£€æŸ¥ç‚¹", trace.WithAttributes(
  attribute.Int("progress", 50),
 ))

 time.Sleep(50 * time.Millisecond)
 span.AddEvent("å¤„ç†å®Œæˆ")
}

// SpanWithLink Span é“¾æ¥ç¤ºä¾‹
func (t *TracingExample) SpanWithLink(ctx context.Context, relatedSpanContext trace.SpanContext) {
 // åˆ›å»ºå¸¦é“¾æ¥çš„ Span
 _, span := t.tracer.Start(ctx, "operation-with-link",
  trace.WithLinks(trace.Link{
   SpanContext: relatedSpanContext,
   Attributes: []attribute.KeyValue{
    attribute.String("link.type", "related-operation"),
   },
  }),
 )
 defer span.End()

 // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
 time.Sleep(100 * time.Millisecond)
}

// AsyncOperation å¼‚æ­¥æ“ä½œè¿½è¸ª
func (t *TracingExample) AsyncOperation(ctx context.Context) {
 ctx, span := t.tracer.Start(ctx, "async-parent")
 defer span.End()

 // å¯åŠ¨å¼‚æ­¥ä»»åŠ¡
 resultChan := make(chan string)
 go t.asyncWorker(ctx, resultChan)

 // ç­‰å¾…ç»“æœ
 result := <-resultChan
 span.SetAttributes(attribute.String("async.result", result))
}

func (t *TracingExample) asyncWorker(ctx context.Context, resultChan chan<- string) {
 _, span := t.tracer.Start(ctx, "async-worker")
 defer span.End()

 // æ¨¡æ‹Ÿå¼‚æ­¥å·¥ä½œ
 time.Sleep(200 * time.Millisecond)
 resultChan <- "å®Œæˆ"
}

func someOperation() error {
 // æ¨¡æ‹Ÿä¸šåŠ¡é€»è¾‘
 return nil
}
```

### é«˜çº§ Span æ¨¡å¼

```go
package tracing

import (
 "context"
 "fmt"
 "time"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/codes"
 "go.opentelemetry.io/otel/trace"
)

// SpanKind ç¤ºä¾‹
func SpanKindExamples(ctx context.Context) {
 tracer := otel.Tracer("span-kind-example")

 // CLIENT span
 ctx, clientSpan := tracer.Start(ctx, "http-client-request",
  trace.WithSpanKind(trace.SpanKindClient),
 )
 clientSpan.SetAttributes(
  attribute.String("http.method", "GET"),
  attribute.String("http.url", "https://api.example.com/users"),
 )
 clientSpan.End()

 // SERVER span
 ctx, serverSpan := tracer.Start(ctx, "http-server-handler",
  trace.WithSpanKind(trace.SpanKindServer),
 )
 serverSpan.SetAttributes(
  attribute.String("http.method", "POST"),
  attribute.String("http.route", "/api/users"),
 )
 serverSpan.End()

 // PRODUCER span
 ctx, producerSpan := tracer.Start(ctx, "kafka-producer",
  trace.WithSpanKind(trace.SpanKindProducer),
 )
 producerSpan.SetAttributes(
  attribute.String("messaging.system", "kafka"),
  attribute.String("messaging.destination", "orders"),
 )
 producerSpan.End()

 // CONSUMER span
 ctx, consumerSpan := tracer.Start(ctx, "kafka-consumer",
  trace.WithSpanKind(trace.SpanKindConsumer),
 )
 consumerSpan.SetAttributes(
  attribute.String("messaging.system", "kafka"),
  attribute.String("messaging.source", "orders"),
 )
 consumerSpan.End()

 // INTERNAL span
 _, internalSpan := tracer.Start(ctx, "internal-processing",
  trace.WithSpanKind(trace.SpanKindInternal),
 )
 internalSpan.End()
}

// BatchProcessing æ‰¹å¤„ç†è¿½è¸ª
func BatchProcessing(ctx context.Context, items []string) {
 tracer := otel.Tracer("batch-processor")

 ctx, batchSpan := tracer.Start(ctx, "process-batch")
 defer batchSpan.End()

 batchSpan.SetAttributes(
  attribute.Int("batch.size", len(items)),
  attribute.String("batch.type", "items"),
 )

 successCount := 0
 errorCount := 0

 for i, item := range items {
  _, itemSpan := tracer.Start(ctx, fmt.Sprintf("process-item-%d", i))
  
  if err := processItem(item); err != nil {
   itemSpan.RecordError(err)
   itemSpan.SetStatus(codes.Error, err.Error())
   errorCount++
  } else {
   successCount++
  }
  
  itemSpan.End()
 }

 batchSpan.SetAttributes(
  attribute.Int("batch.success_count", successCount),
  attribute.Int("batch.error_count", errorCount),
 )
}

// WorkerPool å·¥ä½œæ± è¿½è¸ª
func WorkerPool(ctx context.Context, jobs []Job) {
 tracer := otel.Tracer("worker-pool")

 ctx, poolSpan := tracer.Start(ctx, "worker-pool-processing")
 defer poolSpan.End()

 numWorkers := 5
 jobChan := make(chan Job, len(jobs))
 resultChan := make(chan Result, len(jobs))

 // å¯åŠ¨ workers
 for i := 0; i < numWorkers; i++ {
  go func(workerID int) {
   for job := range jobChan {
    workerCtx, workerSpan := tracer.Start(ctx, 
     fmt.Sprintf("worker-%d", workerID),
     trace.WithAttributes(
      attribute.Int("worker.id", workerID),
      attribute.String("job.id", job.ID),
     ),
    )

    result := processJob(job)
    resultChan <- result

    workerSpan.End()
    _ = workerCtx
   }
  }(i)
 }

 // å‘é€ä»»åŠ¡
 for _, job := range jobs {
  jobChan <- job
 }
 close(jobChan)

 // æ”¶é›†ç»“æœ
 for range jobs {
  <-resultChan
 }
}

// ConditionalTracing æ¡ä»¶è¿½è¸ª
func ConditionalTracing(ctx context.Context, enableTracing bool) {
 tracer := otel.Tracer("conditional-tracer")

 var span trace.Span
 if enableTracing {
  ctx, span = tracer.Start(ctx, "conditional-operation")
  defer span.End()
 }

 // ä¸šåŠ¡é€»è¾‘
 doWork()

 if span != nil {
  span.AddEvent("å·¥ä½œå®Œæˆ")
 }
}

// Helper functions
type Job struct {
 ID   string
 Data string
}

type Result struct {
 JobID string
 Data  string
}

func processItem(item string) error {
 time.Sleep(10 * time.Millisecond)
 return nil
}

func processJob(job Job) Result {
 time.Sleep(50 * time.Millisecond)
 return Result{JobID: job.ID, Data: "processed"}
}

func doWork() {
 time.Sleep(100 * time.Millisecond)
}
```

---

## Metrics é›†æˆ

### åŸºæœ¬ Metrics åˆ›å»º

```go
package metrics

import (
 "context"
 "time"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/metric"
)

// MetricsExample Metrics ç¤ºä¾‹
type MetricsExample struct {
 meter metric.Meter
}

// NewMetricsExample åˆ›å»º Metrics ç¤ºä¾‹
func NewMetricsExample() *MetricsExample {
 return &MetricsExample{
  meter: otel.Meter("metrics-example"),
 }
}

// CounterExample Counter ç¤ºä¾‹
func (m *MetricsExample) CounterExample(ctx context.Context) error {
 // åˆ›å»º Counter
 counter, err := m.meter.Int64Counter(
  "requests.total",
  metric.WithDescription("è¯·æ±‚æ€»æ•°"),
  metric.WithUnit("1"),
 )
 if err != nil {
  return err
 }

 // å¢åŠ è®¡æ•°
 counter.Add(ctx, 1,
  metric.WithAttributes(
   attribute.String("method", "GET"),
   attribute.String("endpoint", "/api/users"),
   attribute.Int("status_code", 200),
  ),
 )

 return nil
}

// UpDownCounterExample UpDownCounter ç¤ºä¾‹
func (m *MetricsExample) UpDownCounterExample(ctx context.Context) error {
 // åˆ›å»º UpDownCounter
 activeConns, err := m.meter.Int64UpDownCounter(
  "connections.active",
  metric.WithDescription("æ´»è·ƒè¿æ¥æ•°"),
  metric.WithUnit("1"),
 )
 if err != nil {
  return err
 }

 // å¢åŠ è¿æ¥
 activeConns.Add(ctx, 1,
  metric.WithAttributes(
   attribute.String("protocol", "http"),
  ),
 )

 // æ¨¡æ‹Ÿè¿æ¥å…³é—­
 time.Sleep(1 * time.Second)
 activeConns.Add(ctx, -1,
  metric.WithAttributes(
   attribute.String("protocol", "http"),
  ),
 )

 return nil
}

// HistogramExample Histogram ç¤ºä¾‹
func (m *MetricsExample) HistogramExample(ctx context.Context) error {
 // åˆ›å»º Histogram
 histogram, err := m.meter.Float64Histogram(
  "request.duration",
  metric.WithDescription("è¯·æ±‚æŒç»­æ—¶é—´"),
  metric.WithUnit("ms"),
 )
 if err != nil {
  return err
 }

 start := time.Now()
 
 // æ‰§è¡Œæ“ä½œ
 time.Sleep(100 * time.Millisecond)
 
 duration := float64(time.Since(start).Milliseconds())
 
 // è®°å½•æŒç»­æ—¶é—´
 histogram.Record(ctx, duration,
  metric.WithAttributes(
   attribute.String("method", "POST"),
   attribute.String("endpoint", "/api/orders"),
  ),
 )

 return nil
}

// GaugeExample Gauge (é€šè¿‡ Callback) ç¤ºä¾‹
func (m *MetricsExample) GaugeExample(ctx context.Context) error {
 // åˆ›å»º Observable Gauge
 _, err := m.meter.Float64ObservableGauge(
  "system.memory.usage",
  metric.WithDescription("ç³»ç»Ÿå†…å­˜ä½¿ç”¨ç‡"),
  metric.WithUnit("%"),
  metric.WithFloat64Callback(func(ctx context.Context, observer metric.Float64Observer) error {
   // è·å–å½“å‰å†…å­˜ä½¿ç”¨ç‡
   usage := getMemoryUsage()
   observer.Observe(usage,
    metric.WithAttributes(
     attribute.String("host", "localhost"),
    ),
   )
   return nil
  }),
 )

 return err
}

// CompleteMetricsSetup å®Œæ•´ Metrics è®¾ç½®
type CompleteMetricsSetup struct {
 meter metric.Meter

 // Counters
 requestCounter    metric.Int64Counter
 errorCounter      metric.Int64Counter

 // UpDownCounters
 activeUsers       metric.Int64UpDownCounter
 connectionPool    metric.Int64UpDownCounter

 // Histograms
 requestDuration   metric.Float64Histogram
 payloadSize       metric.Int64Histogram

 // Gauges (Observable)
 cpuUsage          metric.Float64ObservableGauge
 memoryUsage       metric.Float64ObservableGauge
}

// NewCompleteMetricsSetup åˆ›å»ºå®Œæ•´ Metrics è®¾ç½®
func NewCompleteMetricsSetup() (*CompleteMetricsSetup, error) {
 meter := otel.Meter("complete-metrics")
 setup := &CompleteMetricsSetup{meter: meter}

 var err error

 // åˆå§‹åŒ– Counters
 setup.requestCounter, err = meter.Int64Counter(
  "http.server.request.count",
  metric.WithDescription("HTTP è¯·æ±‚æ€»æ•°"),
  metric.WithUnit("1"),
 )
 if err != nil {
  return nil, err
 }

 setup.errorCounter, err = meter.Int64Counter(
  "http.server.error.count",
  metric.WithDescription("HTTP é”™è¯¯æ€»æ•°"),
  metric.WithUnit("1"),
 )
 if err != nil {
  return nil, err
 }

 // åˆå§‹åŒ– UpDownCounters
 setup.activeUsers, err = meter.Int64UpDownCounter(
  "app.users.active",
  metric.WithDescription("æ´»è·ƒç”¨æˆ·æ•°"),
  metric.WithUnit("1"),
 )
 if err != nil {
  return nil, err
 }

 setup.connectionPool, err = meter.Int64UpDownCounter(
  "db.connection.pool",
  metric.WithDescription("æ•°æ®åº“è¿æ¥æ± å¤§å°"),
  metric.WithUnit("1"),
 )
 if err != nil {
  return nil, err
 }

 // åˆå§‹åŒ– Histograms
 setup.requestDuration, err = meter.Float64Histogram(
  "http.server.request.duration",
  metric.WithDescription("HTTP è¯·æ±‚æŒç»­æ—¶é—´"),
  metric.WithUnit("ms"),
 )
 if err != nil {
  return nil, err
 }

 setup.payloadSize, err = meter.Int64Histogram(
  "http.server.request.size",
  metric.WithDescription("HTTP è¯·æ±‚å¤§å°"),
  metric.WithUnit("bytes"),
 )
 if err != nil {
  return nil, err
 }

 // åˆå§‹åŒ– Gauges
 setup.cpuUsage, err = meter.Float64ObservableGauge(
  "system.cpu.usage",
  metric.WithDescription("CPU ä½¿ç”¨ç‡"),
  metric.WithUnit("%"),
  metric.WithFloat64Callback(func(ctx context.Context, observer metric.Float64Observer) error {
   usage := getCPUUsage()
   observer.Observe(usage)
   return nil
  }),
 )
 if err != nil {
  return nil, err
 }

 setup.memoryUsage, err = meter.Float64ObservableGauge(
  "system.memory.usage",
  metric.WithDescription("å†…å­˜ä½¿ç”¨ç‡"),
  metric.WithUnit("%"),
  metric.WithFloat64Callback(func(ctx context.Context, observer metric.Float64Observer) error {
   usage := getMemoryUsage()
   observer.Observe(usage)
   return nil
  }),
 )
 if err != nil {
  return nil, err
 }

 return setup, nil
}

// RecordHTTPRequest è®°å½• HTTP è¯·æ±‚
func (m *CompleteMetricsSetup) RecordHTTPRequest(
 ctx context.Context,
 method string,
 path string,
 statusCode int,
 duration time.Duration,
 payloadSize int64,
) {
 attrs := metric.WithAttributes(
  attribute.String("http.method", method),
  attribute.String("http.route", path),
  attribute.Int("http.status_code", statusCode),
 )

 // è®°å½•è¯·æ±‚æ•°
 m.requestCounter.Add(ctx, 1, attrs)

 // è®°å½•é”™è¯¯ï¼ˆå¦‚æœæœ‰ï¼‰
 if statusCode >= 400 {
  m.errorCounter.Add(ctx, 1, attrs)
 }

 // è®°å½•æŒç»­æ—¶é—´
 m.requestDuration.Record(ctx, float64(duration.Milliseconds()), attrs)

 // è®°å½•è¯·æ±‚å¤§å°
 if payloadSize > 0 {
  m.payloadSize.Record(ctx, payloadSize, attrs)
 }
}

// Helper functions
func getMemoryUsage() float64 {
 // å®é™…å®ç°åº”è¯¥è·å–çœŸå®çš„å†…å­˜ä½¿ç”¨ç‡
 return 75.5
}

func getCPUUsage() float64 {
 // å®é™…å®ç°åº”è¯¥è·å–çœŸå®çš„ CPU ä½¿ç”¨ç‡
 return 45.2
}
```

ç»§ç»­ä¸‹ä¸€éƒ¨åˆ†...

---

## Context ä¼ æ’­

### W3C Trace Context ä¼ æ’­

```go
package propagation

import (
 "context"
 "net/http"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/propagation"
 "go.opentelemetry.io/otel/trace"
)

// HTTPPropagation HTTP ä¼ æ’­ç¤ºä¾‹
type HTTPPropagation struct {
 propagator propagation.TextMapPropagator
 tracer     trace.Tracer
}

// NewHTTPPropagation åˆ›å»º HTTP ä¼ æ’­å™¨
func NewHTTPPropagation() *HTTPPropagation {
 return &HTTPPropagation{
  propagator: otel.GetTextMapPropagator(),
  tracer:     otel.Tracer("http-propagation"),
 }
}

// ClientRequest å®¢æˆ·ç«¯è¯·æ±‚ - æ³¨å…¥ Context
func (p *HTTPPropagation) ClientRequest(ctx context.Context, url string) error {
 // åˆ›å»º client span
 ctx, span := p.tracer.Start(ctx, "http-client-request")
 defer span.End()

 // åˆ›å»º HTTP è¯·æ±‚
 req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
 if err != nil {
  return err
 }

 // æ³¨å…¥ Trace Context åˆ° HTTP Headers
 p.propagator.Inject(ctx, propagation.HeaderCarrier(req.Header))

 // å‘é€è¯·æ±‚
 client := &http.Client{}
 resp, err := client.Do(req)
 if err != nil {
  return err
 }
 defer resp.Body.Close()

 return nil
}

// ServerHandler æœåŠ¡ç«¯å¤„ç† - æå– Context
func (p *HTTPPropagation) ServerHandler(w http.ResponseWriter, r *http.Request) {
 // ä» HTTP Headers æå– Trace Context
 ctx := p.propagator.Extract(r.Context(), propagation.HeaderCarrier(r.Header))

 // åˆ›å»º server span
 ctx, span := p.tracer.Start(ctx, "http-server-handler",
  trace.WithSpanKind(trace.SpanKindServer),
 )
 defer span.End()

 // å¤„ç†è¯·æ±‚
 p.handleRequest(ctx)

 w.WriteHeader(http.StatusOK)
}

func (p *HTTPPropagation) handleRequest(ctx context.Context) {
 _, span := p.tracer.Start(ctx, "handle-request")
 defer span.End()

 // ä¸šåŠ¡é€»è¾‘
}
```

### gRPC ä¼ æ’­

```go
package propagation

import (
 "context"

 "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
 "google.golang.org/grpc"
 "google.golang.org/grpc/credentials/insecure"
)

// GRPCPropagation gRPC ä¼ æ’­ç¤ºä¾‹
type GRPCPropagation struct{}

// CreateGRPCClient åˆ›å»º gRPC å®¢æˆ·ç«¯ï¼ˆè‡ªåŠ¨ä¼ æ’­ï¼‰
func (g *GRPCPropagation) CreateGRPCClient(target string) (*grpc.ClientConn, error) {
 return grpc.NewClient(target,
  grpc.WithTransportCredentials(insecure.NewCredentials()),
  // æ·»åŠ  OpenTelemetry æ‹¦æˆªå™¨
  grpc.WithStatsHandler(otelgrpc.NewClientHandler()),
 )
}

// CreateGRPCServer åˆ›å»º gRPC æœåŠ¡ç«¯ï¼ˆè‡ªåŠ¨ä¼ æ’­ï¼‰
func (g *GRPCPropagation) CreateGRPCServer() *grpc.Server {
 return grpc.NewServer(
  // æ·»åŠ  OpenTelemetry æ‹¦æˆªå™¨
  grpc.StatsHandler(otelgrpc.NewServerHandler()),
 )
}
```

---

## ä¸­é—´ä»¶é›†æˆ

### HTTP ä¸­é—´ä»¶

```go
package middleware

import (
 "net/http"
 "time"

 "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/metric"
 "go.opentelemetry.io/otel/trace"
)

// HTTPMiddleware HTTP ä¸­é—´ä»¶
type HTTPMiddleware struct {
 meter   metric.Meter
 counter metric.Int64Counter
 histogram metric.Float64Histogram
}

// NewHTTPMiddleware åˆ›å»º HTTP ä¸­é—´ä»¶
func NewHTTPMiddleware() *HTTPMiddleware {
 meter := otel.Meter("http-middleware")
 
 counter, _ := meter.Int64Counter("http.requests.total")
 histogram, _ := meter.Float64Histogram("http.request.duration")

 return &HTTPMiddleware{
  meter:     meter,
  counter:   counter,
  histogram: histogram,
 }
}

// Wrap åŒ…è£… HTTP Handler
func (m *HTTPMiddleware) Wrap(handler http.Handler, operation string) http.Handler {
 // ä½¿ç”¨ otelhttp è‡ªåŠ¨æ’æ¡©
 return otelhttp.NewHandler(handler, operation,
  otelhttp.WithSpanOptions(
   trace.WithSpanKind(trace.SpanKindServer),
  ),
  otelhttp.WithMessageEvents(otelhttp.ReadEvents, otelhttp.WriteEvents),
 )
}

// CustomMiddleware è‡ªå®šä¹‰ä¸­é—´ä»¶
func (m *HTTPMiddleware) CustomMiddleware(next http.Handler) http.Handler {
 return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  start := time.Now()
  
  // åˆ›å»ºå“åº”åŒ…è£…å™¨ä»¥æ•è·çŠ¶æ€ç 
  rw := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
  
  // è°ƒç”¨ä¸‹ä¸€ä¸ªå¤„ç†å™¨
  next.ServeHTTP(rw, r)
  
  // è®°å½•æŒ‡æ ‡
  duration := time.Since(start)
  attrs := metric.WithAttributes(
   attribute.String("http.method", r.Method),
   attribute.String("http.route", r.URL.Path),
   attribute.Int("http.status_code", rw.statusCode),
  )
  
  m.counter.Add(r.Context(), 1, attrs)
  m.histogram.Record(r.Context(), float64(duration.Milliseconds()), attrs)
 })
}

type responseWriter struct {
 http.ResponseWriter
 statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
 rw.statusCode = code
 rw.ResponseWriter.WriteHeader(code)
}
```

è¿™æ˜¯ä¸€ä¸ªå…¨é¢çš„ Go 1.25.1 ä¸ OpenTelemetry OTLP é›†æˆæŒ‡å—çš„ç¬¬ä¸€éƒ¨åˆ†ã€‚æ–‡æ¡£åŒ…å«ï¼š

1. **å®Œæ•´çš„ä¾èµ–é…ç½®** - æœ€æ–°ç¨³å®šç‰ˆæœ¬
2. **ç”Ÿäº§çº§åˆå§‹åŒ–ä»£ç ** - åŒ…å«é”™è¯¯å¤„ç†ã€é‡è¯•ã€ä¼˜é›…å…³é—­
3. **Traces å®Œæ•´ç¤ºä¾‹** - åŸºæœ¬åˆ°é«˜çº§æ¨¡å¼
4. **Metrics å®Œæ•´ç¤ºä¾‹** - æ‰€æœ‰æŒ‡æ ‡ç±»å‹
5. **Context ä¼ æ’­** - HTTP å’Œ gRPC
6. **ä¸­é—´ä»¶é›†æˆ** - è‡ªåŠ¨å’Œæ‰‹åŠ¨æ’æ¡©

è®©æˆ‘ç»§ç»­åˆ›å»ºå‰©ä½™éƒ¨åˆ†...
