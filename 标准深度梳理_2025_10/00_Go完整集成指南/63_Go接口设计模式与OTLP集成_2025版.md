# Go 接口设计模式与 OTLP 集成（2025版）

> **文档版本**: v1.0.0  
> **Go 版本**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0  
> **最后更新**: 2025-10-11  
> **作者**: OTLP Go Integration Team

---

## 📋 目录

- [Go 接口设计模式与 OTLP 集成（2025版）](#go-接口设计模式与-otlp-集成2025版)
  - [📋 目录](#-目录)
  - [📖 简介](#-简介)
    - [Go 接口的特点](#go-接口的特点)
    - [为什么需要好的接口设计？](#为什么需要好的接口设计)
  - [🎯 接口基础](#-接口基础)
    - [接口声明](#接口声明)
    - [接口实现](#接口实现)
  - [📐 接口设计原则](#-接口设计原则)
    - [原则 1: 接口隔离原则（ISP）](#原则-1-接口隔离原则isp)
    - [原则 2: 依赖倒置原则（DIP）](#原则-2-依赖倒置原则dip)
    - [原则 3: 接受接口，返回结构体](#原则-3-接受接口返回结构体)
  - [🔧 核心设计模式](#-核心设计模式)
    - [模式 1: 装饰器模式（Decorator）](#模式-1-装饰器模式decorator)
    - [模式 2: 适配器模式（Adapter）](#模式-2-适配器模式adapter)
    - [模式 3: 策略模式（Strategy）](#模式-3-策略模式strategy)
    - [模式 4: 工厂模式（Factory）](#模式-4-工厂模式factory)
  - [🔌 OTLP 集成模式](#-otlp-集成模式)
    - [模式 5: 可追踪接口（Traceable Interface）](#模式-5-可追踪接口traceable-interface)
    - [模式 6: 可监控接口（Observable Interface）](#模式-6-可监控接口observable-interface)
  - [🚀 高级模式](#-高级模式)
    - [模式 7: 泛型接口与 OTLP 集成](#模式-7-泛型接口与-otlp-集成)
    - [模式 8: 接口组合与中间件链](#模式-8-接口组合与中间件链)
  - [⚡ 性能优化](#-性能优化)
    - [优化 1: 接口内联优化](#优化-1-接口内联优化)
    - [优化 2: 避免不必要的接口转换](#优化-2-避免不必要的接口转换)
  - [✅ 最佳实践](#-最佳实践)
    - [1. 接口应该小而专注](#1-接口应该小而专注)
    - [2. 在使用处定义接口，而不是在实现处](#2-在使用处定义接口而不是在实现处)
    - [3. 接口方法应该接受 Context](#3-接口方法应该接受-context)
    - [4. 返回错误而不是 panic](#4-返回错误而不是-panic)
  - [🧪 测试策略](#-测试策略)
    - [Mock 接口](#mock-接口)
  - [🎓 总结](#-总结)

---

## 📖 简介

Go 的接口是其类型系统的核心，提供了强大而灵活的抽象机制。
本文档深入探讨如何设计优雅的接口，并将其与 OpenTelemetry 无缝集成。

### Go 接口的特点

```go
// ✅ Go 接口的隐式实现
type Reader interface {
    Read(p []byte) (n int, err error)
}

// 无需显式声明 implements Reader
type File struct {
    // ...
}

func (f *File) Read(p []byte) (n int, err error) {
    // File 自动实现了 Reader 接口
    return len(p), nil
}
```

### 为什么需要好的接口设计？

1. **解耦** - 降低组件间的依赖
2. **可测试性** - 便于 mock 和单元测试
3. **可扩展性** - 易于添加新实现
4. **可维护性** - 清晰的抽象边界
5. **可观测性** - 统一的追踪点注入

---

## 🎯 接口基础

### 接口声明

```go
package main

import (
    "context"
    "io"
)

// 1. 小接口原则 - 接口应该尽可能小
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type Closer interface {
    Close() error
}

// 2. 接口组合
type ReadWriter interface {
    Reader
    Writer
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}

// 3. 带 Context 的接口（现代 Go 推荐）
type ContextualReader interface {
    ReadContext(ctx context.Context, p []byte) (n int, err error)
}

type ContextualWriter interface {
    WriteContext(ctx context.Context, p []byte) (n int, err error)
}

// 4. 泛型接口（Go 1.18+）
type Container[T any] interface {
    Get() T
    Set(T)
}

type Comparable[T any] interface {
    CompareTo(other T) int
}
```

### 接口实现

```go
package main

import (
    "context"
    "bytes"
    "errors"
)

// File 实现 ReadWriteCloser 接口
type File struct {
    buffer *bytes.Buffer
    closed bool
}

func NewFile() *File {
    return &File{
        buffer: new(bytes.Buffer),
        closed: false,
    }
}

func (f *File) Read(p []byte) (n int, err error) {
    if f.closed {
        return 0, errors.New("file closed")
    }
    return f.buffer.Read(p)
}

func (f *File) Write(p []byte) (n int, err error) {
    if f.closed {
        return 0, errors.New("file closed")
    }
    return f.buffer.Write(p)
}

func (f *File) Close() error {
    if f.closed {
        return errors.New("file already closed")
    }
    f.closed = true
    return nil
}

// Example: 使用接口
func ProcessFile(rw ReadWriter) error {
    data := []byte("Hello, World!")
    n, err := rw.Write(data)
    if err != nil {
        return err
    }
    
    result := make([]byte, n)
    _, err = rw.Read(result)
    return err
}
```

---

## 📐 接口设计原则

### 原则 1: 接口隔离原则（ISP）

```go
// ❌ 违反 ISP - 接口过大
type DatabaseClient interface {
    Connect() error
    Disconnect() error
    Query(sql string) ([]Row, error)
    Execute(sql string) error
    BeginTransaction() (Transaction, error)
    Backup() error
    Restore(path string) error
    Optimize() error
}

// ✅ 遵循 ISP - 接口细分
type Connector interface {
    Connect() error
    Disconnect() error
}

type Querier interface {
    Query(sql string) ([]Row, error)
}

type Executor interface {
    Execute(sql string) error
}

type Transactional interface {
    BeginTransaction() (Transaction, error)
}

type BackupRestore interface {
    Backup() error
    Restore(path string) error
}

// 组合需要的接口
type BasicDatabase interface {
    Connector
    Querier
    Executor
}

type FullDatabase interface {
    BasicDatabase
    Transactional
    BackupRestore
}
```

### 原则 2: 依赖倒置原则（DIP）

```go
// ✅ 依赖抽象而不是具体实现
type UserService struct {
    repo   UserRepository    // 依赖接口
    cache  Cache            // 依赖接口
    tracer trace.Tracer     // 依赖接口
}

type UserRepository interface {
    FindByID(ctx context.Context, id string) (*User, error)
    Save(ctx context.Context, user *User) error
}

type Cache interface {
    Get(ctx context.Context, key string) (interface{}, error)
    Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error
}

// 具体实现
type PostgresUserRepository struct {
    db *sql.DB
}

func (r *PostgresUserRepository) FindByID(ctx context.Context, id string) (*User, error) {
    // 实现
    return nil, nil
}

func (r *PostgresUserRepository) Save(ctx context.Context, user *User) error {
    // 实现
    return nil
}

// 依赖注入
func NewUserService(repo UserRepository, cache Cache, tracer trace.Tracer) *UserService {
    return &UserService{
        repo:   repo,
        cache:  cache,
        tracer: tracer,
    }
}
```

### 原则 3: 接受接口，返回结构体

```go
// ✅ 接受接口（更灵活）
func ProcessData(reader io.Reader) error {
    // 可以接受任何实现了 Reader 的类型
    data, err := io.ReadAll(reader)
    if err != nil {
        return err
    }
    // 处理数据
    return nil
}

// ✅ 返回具体类型（更明确）
func NewUserService(repo UserRepository) *UserService {
    return &UserService{repo: repo}
}

// ❌ 返回接口（限制了实现的灵活性）
func NewUserService(repo UserRepository) UserService {
    return &userServiceImpl{repo: repo}
}
```

---

## 🔧 核心设计模式

### 模式 1: 装饰器模式（Decorator）

```go
package main

import (
    "context"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// UserService 接口
type UserService interface {
    GetUser(ctx context.Context, id string) (*User, error)
    CreateUser(ctx context.Context, user *User) error
}

// 基础实现
type basicUserService struct {
    repo UserRepository
}

func (s *basicUserService) GetUser(ctx context.Context, id string) (*User, error) {
    return s.repo.FindByID(ctx, id)
}

func (s *basicUserService) CreateUser(ctx context.Context, user *User) error {
    return s.repo.Save(ctx, user)
}

// 追踪装饰器
type tracingUserService struct {
    next   UserService
    tracer trace.Tracer
}

func NewTracingUserService(next UserService) UserService {
    return &tracingUserService{
        next:   next,
        tracer: otel.Tracer("user-service"),
    }
}

func (s *tracingUserService) GetUser(ctx context.Context, id string) (*User, error) {
    ctx, span := s.tracer.Start(ctx, "UserService.GetUser")
    defer span.End()
    
    span.SetAttributes(attribute.String("user.id", id))
    
    user, err := s.next.GetUser(ctx, id)
    if err != nil {
        span.RecordError(err)
        return nil, err
    }
    
    return user, nil
}

func (s *tracingUserService) CreateUser(ctx context.Context, user *User) error {
    ctx, span := s.tracer.Start(ctx, "UserService.CreateUser")
    defer span.End()
    
    span.SetAttributes(attribute.String("user.name", user.Name))
    
    err := s.next.CreateUser(ctx, user)
    if err != nil {
        span.RecordError(err)
        return err
    }
    
    return nil
}

// 缓存装饰器
type cachingUserService struct {
    next  UserService
    cache Cache
}

func NewCachingUserService(next UserService, cache Cache) UserService {
    return &cachingUserService{
        next:  next,
        cache: cache,
    }
}

func (s *cachingUserService) GetUser(ctx context.Context, id string) (*User, error) {
    // 尝试从缓存读取
    cacheKey := "user:" + id
    if cached, err := s.cache.Get(ctx, cacheKey); err == nil {
        if user, ok := cached.(*User); ok {
            return user, nil
        }
    }
    
    // 缓存未命中，从下一层获取
    user, err := s.next.GetUser(ctx, id)
    if err != nil {
        return nil, err
    }
    
    // 写入缓存
    s.cache.Set(ctx, cacheKey, user, 5*time.Minute)
    
    return user, nil
}

func (s *cachingUserService) CreateUser(ctx context.Context, user *User) error {
    err := s.next.CreateUser(ctx, user)
    if err != nil {
        return err
    }
    
    // 使缓存失效
    cacheKey := "user:" + user.ID
    s.cache.Delete(ctx, cacheKey)
    
    return nil
}

// 使用装饰器链
func Example() {
    repo := NewPostgresUserRepository(db)
    cache := NewRedisCache(redisClient)
    
    // 组装装饰器链：基础服务 -> 缓存 -> 追踪
    service := NewTracingUserService(
        NewCachingUserService(
            &basicUserService{repo: repo},
            cache,
        ),
    )
    
    ctx := context.Background()
    user, err := service.GetUser(ctx, "user-123")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("User: %+v\n", user)
}
```

### 模式 2: 适配器模式（Adapter）

```go
package main

import (
    "context"
    "database/sql"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

// 目标接口
type UserRepository interface {
    FindByID(ctx context.Context, id string) (*User, error)
    Save(ctx context.Context, user *User) error
}

// 旧的数据库客户端（不支持 Context）
type LegacyDBClient struct {
    db *sql.DB
}

func (c *LegacyDBClient) GetUser(id string) (*User, error) {
    // 旧的实现
    return nil, nil
}

func (c *LegacyDBClient) SaveUser(user *User) error {
    // 旧的实现
    return nil
}

// 适配器 - 将旧接口适配到新接口
type LegacyDBAdapter struct {
    client *LegacyDBClient
    tracer trace.Tracer
}

func NewLegacyDBAdapter(client *LegacyDBClient) UserRepository {
    return &LegacyDBAdapter{
        client: client,
        tracer: otel.Tracer("legacy-db-adapter"),
    }
}

func (a *LegacyDBAdapter) FindByID(ctx context.Context, id string) (*User, error) {
    ctx, span := a.tracer.Start(ctx, "LegacyDB.FindByID")
    defer span.End()
    
    // 适配：添加 Context 支持
    // 监听 Context 取消
    done := make(chan struct{})
    var user *User
    var err error
    
    go func() {
        user, err = a.client.GetUser(id)
        close(done)
    }()
    
    select {
    case <-ctx.Done():
        return nil, ctx.Err()
    case <-done:
        if err != nil {
            span.RecordError(err)
        }
        return user, err
    }
}

func (a *LegacyDBAdapter) Save(ctx context.Context, user *User) error {
    ctx, span := a.tracer.Start(ctx, "LegacyDB.Save")
    defer span.End()
    
    done := make(chan struct{})
    var err error
    
    go func() {
        err = a.client.SaveUser(user)
        close(done)
    }()
    
    select {
    case <-ctx.Done():
        return ctx.Err()
    case <-done:
        if err != nil {
            span.RecordError(err)
        }
        return err
    }
}
```

### 模式 3: 策略模式（Strategy）

```go
package main

import (
    "context"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// 价格计算策略接口
type PricingStrategy interface {
    CalculatePrice(ctx context.Context, basePrice float64, user *User) (float64, error)
}

// 常规定价策略
type RegularPricing struct {
    tracer trace.Tracer
}

func NewRegularPricing() *RegularPricing {
    return &RegularPricing{
        tracer: otel.Tracer("regular-pricing"),
    }
}

func (p *RegularPricing) CalculatePrice(ctx context.Context, basePrice float64, user *User) (float64, error) {
    ctx, span := p.tracer.Start(ctx, "RegularPricing.CalculatePrice")
    defer span.End()
    
    span.SetAttributes(
        attribute.Float64("price.base", basePrice),
        attribute.String("strategy", "regular"),
    )
    
    // 无折扣
    return basePrice, nil
}

// VIP 定价策略
type VIPPricing struct {
    discount float64
    tracer   trace.Tracer
}

func NewVIPPricing(discount float64) *VIPPricing {
    return &VIPPricing{
        discount: discount,
        tracer:   otel.Tracer("vip-pricing"),
    }
}

func (p *VIPPricing) CalculatePrice(ctx context.Context, basePrice float64, user *User) (float64, error) {
    ctx, span := p.tracer.Start(ctx, "VIPPricing.CalculatePrice")
    defer span.End()
    
    finalPrice := basePrice * (1 - p.discount)
    
    span.SetAttributes(
        attribute.Float64("price.base", basePrice),
        attribute.Float64("price.final", finalPrice),
        attribute.Float64("discount", p.discount),
        attribute.String("strategy", "vip"),
    )
    
    return finalPrice, nil
}

// 季节性定价策略
type SeasonalPricing struct {
    seasonDiscount float64
    tracer         trace.Tracer
}

func NewSeasonalPricing(seasonDiscount float64) *SeasonalPricing {
    return &SeasonalPricing{
        seasonDiscount: seasonDiscount,
        tracer:         otel.Tracer("seasonal-pricing"),
    }
}

func (p *SeasonalPricing) CalculatePrice(ctx context.Context, basePrice float64, user *User) (float64, error) {
    ctx, span := p.tracer.Start(ctx, "SeasonalPricing.CalculatePrice")
    defer span.End()
    
    finalPrice := basePrice * (1 - p.seasonDiscount)
    
    span.SetAttributes(
        attribute.Float64("price.base", basePrice),
        attribute.Float64("price.final", finalPrice),
        attribute.Float64("discount.seasonal", p.seasonDiscount),
        attribute.String("strategy", "seasonal"),
    )
    
    return finalPrice, nil
}

// 订单服务使用策略
type OrderService struct {
    pricingStrategy PricingStrategy
    tracer          trace.Tracer
}

func NewOrderService(strategy PricingStrategy) *OrderService {
    return &OrderService{
        pricingStrategy: strategy,
        tracer:          otel.Tracer("order-service"),
    }
}

func (s *OrderService) SetPricingStrategy(strategy PricingStrategy) {
    s.pricingStrategy = strategy
}

func (s *OrderService) CalculateOrderTotal(ctx context.Context, items []OrderItem, user *User) (float64, error) {
    ctx, span := s.tracer.Start(ctx, "OrderService.CalculateOrderTotal")
    defer span.End()
    
    var total float64
    for _, item := range items {
        price, err := s.pricingStrategy.CalculatePrice(ctx, item.Price, user)
        if err != nil {
            span.RecordError(err)
            return 0, err
        }
        total += price * float64(item.Quantity)
    }
    
    span.SetAttributes(attribute.Float64("order.total", total))
    
    return total, nil
}

// Example: 使用策略模式
func ExampleStrategyPattern() {
    ctx := context.Background()
    
    items := []OrderItem{
        {Price: 100.0, Quantity: 2},
        {Price: 50.0, Quantity: 1},
    }
    
    user := &User{ID: "user-123", IsVIP: true}
    
    // 使用 VIP 定价策略
    vipStrategy := NewVIPPricing(0.2) // 20% 折扣
    orderService := NewOrderService(vipStrategy)
    
    total, _ := orderService.CalculateOrderTotal(ctx, items, user)
    fmt.Printf("VIP Total: %.2f\n", total) // Output: 200.00
    
    // 切换到季节性定价策略
    seasonalStrategy := NewSeasonalPricing(0.15) // 15% 折扣
    orderService.SetPricingStrategy(seasonalStrategy)
    
    total, _ = orderService.CalculateOrderTotal(ctx, items, user)
    fmt.Printf("Seasonal Total: %.2f\n", total) // Output: 212.50
}
```

### 模式 4: 工厂模式（Factory）

```go
package main

import (
    "context"
    "fmt"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

// 数据库类型
type DatabaseType string

const (
    PostgreSQL DatabaseType = "postgresql"
    MySQL      DatabaseType = "mysql"
    MongoDB    DatabaseType = "mongodb"
)

// Repository 工厂接口
type RepositoryFactory interface {
    CreateUserRepository(ctx context.Context) (UserRepository, error)
    CreateOrderRepository(ctx context.Context) (OrderRepository, error)
}

// PostgreSQL 工厂
type PostgreSQLFactory struct {
    connString string
    tracer     trace.Tracer
}

func NewPostgreSQLFactory(connString string) *PostgreSQLFactory {
    return &PostgreSQLFactory{
        connString: connString,
        tracer:     otel.Tracer("postgresql-factory"),
    }
}

func (f *PostgreSQLFactory) CreateUserRepository(ctx context.Context) (UserRepository, error) {
    ctx, span := f.tracer.Start(ctx, "PostgreSQLFactory.CreateUserRepository")
    defer span.End()
    
    // 创建 PostgreSQL UserRepository
    return NewPostgresUserRepository(f.connString), nil
}

func (f *PostgreSQLFactory) CreateOrderRepository(ctx context.Context) (OrderRepository, error) {
    ctx, span := f.tracer.Start(ctx, "PostgreSQLFactory.CreateOrderRepository")
    defer span.End()
    
    // 创建 PostgreSQL OrderRepository
    return NewPostgresOrderRepository(f.connString), nil
}

// MySQL 工厂
type MySQLFactory struct {
    connString string
    tracer     trace.Tracer
}

func NewMySQLFactory(connString string) *MySQLFactory {
    return &MySQLFactory{
        connString: connString,
        tracer:     otel.Tracer("mysql-factory"),
    }
}

func (f *MySQLFactory) CreateUserRepository(ctx context.Context) (UserRepository, error) {
    ctx, span := f.tracer.Start(ctx, "MySQLFactory.CreateUserRepository")
    defer span.End()
    
    // 创建 MySQL UserRepository
    return NewMySQLUserRepository(f.connString), nil
}

func (f *MySQLFactory) CreateOrderRepository(ctx context.Context) (OrderRepository, error) {
    ctx, span := f.tracer.Start(ctx, "MySQLFactory.CreateOrderRepository")
    defer span.End()
    
    // 创建 MySQL OrderRepository
    return NewMySQLOrderRepository(f.connString), nil
}

// 工厂注册器
type FactoryRegistry struct {
    factories map[DatabaseType]RepositoryFactory
}

func NewFactoryRegistry() *FactoryRegistry {
    return &FactoryRegistry{
        factories: make(map[DatabaseType]RepositoryFactory),
    }
}

func (r *FactoryRegistry) Register(dbType DatabaseType, factory RepositoryFactory) {
    r.factories[dbType] = factory
}

func (r *FactoryRegistry) GetFactory(dbType DatabaseType) (RepositoryFactory, error) {
    factory, exists := r.factories[dbType]
    if !exists {
        return nil, fmt.Errorf("factory not found for database type: %s", dbType)
    }
    return factory, nil
}

// Example: 使用工厂模式
func ExampleFactoryPattern() {
    ctx := context.Background()
    
    // 创建工厂注册器
    registry := NewFactoryRegistry()
    
    // 注册工厂
    registry.Register(PostgreSQL, NewPostgreSQLFactory("postgres://localhost"))
    registry.Register(MySQL, NewMySQLFactory("mysql://localhost"))
    
    // 根据配置获取工厂
    dbType := PostgreSQL // 从配置读取
    factory, _ := registry.GetFactory(dbType)
    
    // 使用工厂创建 Repository
    userRepo, _ := factory.CreateUserRepository(ctx)
    orderRepo, _ := factory.CreateOrderRepository(ctx)
    
    // 使用 Repository
    user, _ := userRepo.FindByID(ctx, "user-123")
    fmt.Printf("User: %+v\n", user)
    
    order, _ := orderRepo.FindByID(ctx, "order-456")
    fmt.Printf("Order: %+v\n", order)
}
```

---

## 🔌 OTLP 集成模式

### 模式 5: 可追踪接口（Traceable Interface）

```go
package main

import (
    "context"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// Traceable 接口 - 所有需要追踪的组件实现此接口
type Traceable interface {
    GetTracer() trace.Tracer
    GetSpanName(operation string) string
}

// BaseTraceable 基础可追踪组件
type BaseTraceable struct {
    serviceName string
    tracer      trace.Tracer
}

func NewBaseTraceable(serviceName string) *BaseTraceable {
    return &BaseTraceable{
        serviceName: serviceName,
        tracer:      otel.Tracer(serviceName),
    }
}

func (b *BaseTraceable) GetTracer() trace.Tracer {
    return b.tracer
}

func (b *BaseTraceable) GetSpanName(operation string) string {
    return b.serviceName + "." + operation
}

// TracedUserRepository 实现可追踪的 UserRepository
type TracedUserRepository struct {
    *BaseTraceable
    db Database
}

func NewTracedUserRepository(db Database) *TracedUserRepository {
    return &TracedUserRepository{
        BaseTraceable: NewBaseTraceable("UserRepository"),
        db:            db,
    }
}

func (r *TracedUserRepository) FindByID(ctx context.Context, id string) (*User, error) {
    ctx, span := r.GetTracer().Start(ctx, r.GetSpanName("FindByID"))
    defer span.End()
    
    span.SetAttributes(
        attribute.String("user.id", id),
        attribute.String("operation", "find"),
    )
    
    user, err := r.db.QueryUser(ctx, id)
    if err != nil {
        span.RecordError(err)
        return nil, err
    }
    
    span.SetAttributes(attribute.String("user.name", user.Name))
    
    return user, nil
}

func (r *TracedUserRepository) Save(ctx context.Context, user *User) error {
    ctx, span := r.GetTracer().Start(ctx, r.GetSpanName("Save"))
    defer span.End()
    
    span.SetAttributes(
        attribute.String("user.id", user.ID),
        attribute.String("user.name", user.Name),
        attribute.String("operation", "save"),
    )
    
    err := r.db.SaveUser(ctx, user)
    if err != nil {
        span.RecordError(err)
        return err
    }
    
    return nil
}

// TracedOrderService 实现可追踪的 OrderService
type TracedOrderService struct {
    *BaseTraceable
    userRepo  UserRepository
    orderRepo OrderRepository
}

func NewTracedOrderService(userRepo UserRepository, orderRepo OrderRepository) *TracedOrderService {
    return &TracedOrderService{
        BaseTraceable: NewBaseTraceable("OrderService"),
        userRepo:      userRepo,
        orderRepo:     orderRepo,
    }
}

func (s *TracedOrderService) CreateOrder(ctx context.Context, order *Order) error {
    ctx, span := s.GetTracer().Start(ctx, s.GetSpanName("CreateOrder"))
    defer span.End()
    
    span.SetAttributes(
        attribute.String("order.id", order.ID),
        attribute.String("user.id", order.UserID),
        attribute.Float64("order.amount", order.Amount),
    )
    
    // 验证用户
    user, err := s.userRepo.FindByID(ctx, order.UserID)
    if err != nil {
        span.RecordError(err)
        return err
    }
    
    span.SetAttributes(attribute.String("user.name", user.Name))
    
    // 创建订单
    err = s.orderRepo.Save(ctx, order)
    if err != nil {
        span.RecordError(err)
        return err
    }
    
    return nil
}
```

### 模式 6: 可监控接口（Observable Interface）

```go
package main

import (
    "context"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/metric"
)

// Observable 接口 - 所有需要监控的组件实现此接口
type Observable interface {
    GetMeter() metric.Meter
    RecordMetric(ctx context.Context, name string, value float64, attrs ...attribute.KeyValue)
}

// BaseObservable 基础可监控组件
type BaseObservable struct {
    serviceName    string
    meter          metric.Meter
    requestCounter metric.Int64Counter
    durationHisto  metric.Float64Histogram
    errorCounter   metric.Int64Counter
}

func NewBaseObservable(serviceName string) (*BaseObservable, error) {
    meter := otel.Meter(serviceName)
    
    requestCounter, err := meter.Int64Counter(
        serviceName+".requests",
        metric.WithDescription("Total requests"),
    )
    if err != nil {
        return nil, err
    }
    
    durationHisto, err := meter.Float64Histogram(
        serviceName+".duration",
        metric.WithDescription("Request duration in milliseconds"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    errorCounter, err := meter.Int64Counter(
        serviceName+".errors",
        metric.WithDescription("Total errors"),
    )
    if err != nil {
        return nil, err
    }
    
    return &BaseObservable{
        serviceName:    serviceName,
        meter:          meter,
        requestCounter: requestCounter,
        durationHisto:  durationHisto,
        errorCounter:   errorCounter,
    }, nil
}

func (b *BaseObservable) GetMeter() metric.Meter {
    return b.meter
}

func (b *BaseObservable) RecordRequest(ctx context.Context, operation string, attrs ...attribute.KeyValue) {
    allAttrs := append([]attribute.KeyValue{
        attribute.String("operation", operation),
    }, attrs...)
    
    b.requestCounter.Add(ctx, 1, metric.WithAttributes(allAttrs...))
}

func (b *BaseObservable) RecordDuration(ctx context.Context, operation string, duration time.Duration, attrs ...attribute.KeyValue) {
    allAttrs := append([]attribute.KeyValue{
        attribute.String("operation", operation),
    }, attrs...)
    
    b.durationHisto.Record(ctx, float64(duration.Milliseconds()), metric.WithAttributes(allAttrs...))
}

func (b *BaseObservable) RecordError(ctx context.Context, operation string, err error, attrs ...attribute.KeyValue) {
    allAttrs := append([]attribute.KeyValue{
        attribute.String("operation", operation),
        attribute.String("error", err.Error()),
    }, attrs...)
    
    b.errorCounter.Add(ctx, 1, metric.WithAttributes(allAttrs...))
}

// ObservableUserRepository 实现可监控的 UserRepository
type ObservableUserRepository struct {
    *BaseObservable
    db Database
}

func NewObservableUserRepository(db Database) (*ObservableUserRepository, error) {
    observable, err := NewBaseObservable("UserRepository")
    if err != nil {
        return nil, err
    }
    
    return &ObservableUserRepository{
        BaseObservable: observable,
        db:             db,
    }, nil
}

func (r *ObservableUserRepository) FindByID(ctx context.Context, id string) (*User, error) {
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        r.RecordDuration(ctx, "FindByID", duration,
            attribute.String("user.id", id),
        )
    }()
    
    r.RecordRequest(ctx, "FindByID",
        attribute.String("user.id", id),
    )
    
    user, err := r.db.QueryUser(ctx, id)
    if err != nil {
        r.RecordError(ctx, "FindByID", err,
            attribute.String("user.id", id),
        )
        return nil, err
    }
    
    return user, nil
}
```

---

## 🚀 高级模式

### 模式 7: 泛型接口与 OTLP 集成

```go
package main

import (
    "context"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// Repository 泛型接口
type Repository[T any, ID comparable] interface {
    FindByID(ctx context.Context, id ID) (T, error)
    Save(ctx context.Context, entity T) error
    Delete(ctx context.Context, id ID) error
    FindAll(ctx context.Context) ([]T, error)
}

// TracedRepository 带追踪的泛型 Repository
type TracedRepository[T any, ID comparable] struct {
    entityName string
    repo       Repository[T, ID]
    tracer     trace.Tracer
}

func NewTracedRepository[T any, ID comparable](
    entityName string,
    repo Repository[T, ID],
) *TracedRepository[T, ID] {
    return &TracedRepository[T, ID]{
        entityName: entityName,
        repo:       repo,
        tracer:     otel.Tracer("traced-repository"),
    }
}

func (tr *TracedRepository[T, ID]) FindByID(ctx context.Context, id ID) (T, error) {
    ctx, span := tr.tracer.Start(ctx, tr.entityName+".FindByID")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("entity.name", tr.entityName),
        attribute.String("entity.id", fmt.Sprintf("%v", id)),
    )
    
    entity, err := tr.repo.FindByID(ctx, id)
    if err != nil {
        span.RecordError(err)
        var zero T
        return zero, err
    }
    
    return entity, nil
}

func (tr *TracedRepository[T, ID]) Save(ctx context.Context, entity T) error {
    ctx, span := tr.tracer.Start(ctx, tr.entityName+".Save")
    defer span.End()
    
    span.SetAttributes(attribute.String("entity.name", tr.entityName))
    
    err := tr.repo.Save(ctx, entity)
    if err != nil {
        span.RecordError(err)
        return err
    }
    
    return nil
}

func (tr *TracedRepository[T, ID]) Delete(ctx context.Context, id ID) error {
    ctx, span := tr.tracer.Start(ctx, tr.entityName+".Delete")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("entity.name", tr.entityName),
        attribute.String("entity.id", fmt.Sprintf("%v", id)),
    )
    
    err := tr.repo.Delete(ctx, id)
    if err != nil {
        span.RecordError(err)
        return err
    }
    
    return nil
}

func (tr *TracedRepository[T, ID]) FindAll(ctx context.Context) ([]T, error) {
    ctx, span := tr.tracer.Start(ctx, tr.entityName+".FindAll")
    defer span.End()
    
    span.SetAttributes(attribute.String("entity.name", tr.entityName))
    
    entities, err := tr.repo.FindAll(ctx)
    if err != nil {
        span.RecordError(err)
        return nil, err
    }
    
    span.SetAttributes(attribute.Int("entity.count", len(entities)))
    
    return entities, nil
}

// Example: 使用泛型 Repository
func ExampleGenericRepository() {
    ctx := context.Background()
    
    // 创建基础 UserRepository
    baseUserRepo := NewPostgresUserRepository(db)
    
    // 包装为带追踪的泛型 Repository
    tracedUserRepo := NewTracedRepository[*User, string]("User", baseUserRepo)
    
    // 使用
    user, _ := tracedUserRepo.FindByID(ctx, "user-123")
    fmt.Printf("User: %+v\n", user)
    
    // 创建基础 OrderRepository
    baseOrderRepo := NewPostgresOrderRepository(db)
    
    // 包装为带追踪的泛型 Repository
    tracedOrderRepo := NewTracedRepository[*Order, string]("Order", baseOrderRepo)
    
    // 使用
    order, _ := tracedOrderRepo.FindByID(ctx, "order-456")
    fmt.Printf("Order: %+v\n", order)
}
```

### 模式 8: 接口组合与中间件链

```go
package main

import (
    "context"
    "time"
)

// Middleware 中间件接口
type Middleware[T any] interface {
    Execute(ctx context.Context, next func(ctx context.Context) (T, error)) (T, error)
}

// MiddlewareChain 中间件链
type MiddlewareChain[T any] struct {
    middlewares []Middleware[T]
}

func NewMiddlewareChain[T any]() *MiddlewareChain[T] {
    return &MiddlewareChain[T]{
        middlewares: make([]Middleware[T], 0),
    }
}

func (mc *MiddlewareChain[T]) Use(middleware Middleware[T]) *MiddlewareChain[T] {
    mc.middlewares = append(mc.middlewares, middleware)
    return mc
}

func (mc *MiddlewareChain[T]) Execute(ctx context.Context, handler func(ctx context.Context) (T, error)) (T, error) {
    if len(mc.middlewares) == 0 {
        return handler(ctx)
    }
    
    // 构建中间件链
    var next func(ctx context.Context) (T, error)
    next = handler
    
    for i := len(mc.middlewares) - 1; i >= 0; i-- {
        middleware := mc.middlewares[i]
        currentNext := next
        next = func(ctx context.Context) (T, error) {
            return middleware.Execute(ctx, currentNext)
        }
    }
    
    return next(ctx)
}

// TracingMiddleware 追踪中间件
type TracingMiddleware[T any] struct {
    operationName string
    tracer        trace.Tracer
}

func NewTracingMiddleware[T any](operationName string) *TracingMiddleware[T] {
    return &TracingMiddleware[T]{
        operationName: operationName,
        tracer:        otel.Tracer("tracing-middleware"),
    }
}

func (tm *TracingMiddleware[T]) Execute(ctx context.Context, next func(ctx context.Context) (T, error)) (T, error) {
    ctx, span := tm.tracer.Start(ctx, tm.operationName)
    defer span.End()
    
    result, err := next(ctx)
    if err != nil {
        span.RecordError(err)
    }
    
    return result, err
}

// RetryMiddleware 重试中间件
type RetryMiddleware[T any] struct {
    maxRetries int
    backoff    time.Duration
}

func NewRetryMiddleware[T any](maxRetries int, backoff time.Duration) *RetryMiddleware[T] {
    return &RetryMiddleware[T]{
        maxRetries: maxRetries,
        backoff:    backoff,
    }
}

func (rm *RetryMiddleware[T]) Execute(ctx context.Context, next func(ctx context.Context) (T, error)) (T, error) {
    var result T
    var err error
    
    for i := 0; i <= rm.maxRetries; i++ {
        result, err = next(ctx)
        if err == nil {
            return result, nil
        }
        
        if i < rm.maxRetries {
            time.Sleep(rm.backoff * time.Duration(i+1))
        }
    }
    
    return result, err
}

// TimeoutMiddleware 超时中间件
type TimeoutMiddleware[T any] struct {
    timeout time.Duration
}

func NewTimeoutMiddleware[T any](timeout time.Duration) *TimeoutMiddleware[T] {
    return &TimeoutMiddleware[T]{
        timeout: timeout,
    }
}

func (tm *TimeoutMiddleware[T]) Execute(ctx context.Context, next func(ctx context.Context) (T, error)) (T, error) {
    ctx, cancel := context.WithTimeout(ctx, tm.timeout)
    defer cancel()
    
    return next(ctx)
}

// Example: 使用中间件链
func ExampleMiddlewareChain() {
    ctx := context.Background()
    
    // 创建中间件链
    chain := NewMiddlewareChain[*User]()
    chain.Use(NewTracingMiddleware[*User]("GetUser"))
    chain.Use(NewTimeoutMiddleware[*User](5 * time.Second))
    chain.Use(NewRetryMiddleware[*User](3, 100*time.Millisecond))
    
    // 执行
    user, err := chain.Execute(ctx, func(ctx context.Context) (*User, error) {
        return getUserFromDB(ctx, "user-123")
    })
    
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("User: %+v\n", user)
}

func getUserFromDB(ctx context.Context, userID string) (*User, error) {
    // 实际的数据库查询
    return &User{ID: userID, Name: "John Doe"}, nil
}
```

---

## ⚡ 性能优化

### 优化 1: 接口内联优化

```go
// 编译器可以内联小接口方法调用

// ✅ 小接口 - 容易内联
type Validator interface {
    Validate() error
}

// ✅ 具体类型方法调用 - 更快
type User struct {
    ID   string
    Name string
}

func (u *User) Validate() error {
    if u.ID == "" {
        return errors.New("ID is required")
    }
    return nil
}

// Benchmark 对比
func BenchmarkInterfaceCall(b *testing.B) {
    var validator Validator = &User{ID: "123", Name: "John"}
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        validator.Validate()
    }
}

func BenchmarkDirectCall(b *testing.B) {
    user := &User{ID: "123", Name: "John"}
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        user.Validate()
    }
}
```

### 优化 2: 避免不必要的接口转换

```go
// ❌ 频繁的类型断言
func ProcessItems(items []interface{}) {
    for _, item := range items {
        if user, ok := item.(*User); ok {
            processUser(user)
        }
    }
}

// ✅ 使用泛型避免类型断言
func ProcessItems[T any](items []T, processor func(T)) {
    for _, item := range items {
        processor(item)
    }
}
```

---

## ✅ 最佳实践

### 1. 接口应该小而专注

```go
// ✅ 好的接口设计
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type Closer interface {
    Close() error
}
```

### 2. 在使用处定义接口，而不是在实现处

```go
// ✅ 在包 A 中定义接口
package a

type UserGetter interface {
    GetUser(ctx context.Context, id string) (*User, error)
}

// 包 B 实现接口（不需要知道接口的存在）
package b

type UserService struct {}

func (s *UserService) GetUser(ctx context.Context, id string) (*User, error) {
    // 实现
}
```

### 3. 接口方法应该接受 Context

```go
// ✅ 接受 Context
type UserRepository interface {
    FindByID(ctx context.Context, id string) (*User, error)
}
```

### 4. 返回错误而不是 panic

```go
// ✅ 返回错误
type UserRepository interface {
    FindByID(ctx context.Context, id string) (*User, error)
}

// ❌ panic
type UserRepository interface {
    FindByID(ctx context.Context, id string) *User // 不返回错误
}
```

---

## 🧪 测试策略

### Mock 接口

```go
package main

import (
    "context"
    "testing"
)

// MockUserRepository 实现 UserRepository 接口用于测试
type MockUserRepository struct {
    FindByIDFunc func(ctx context.Context, id string) (*User, error)
    SaveFunc     func(ctx context.Context, user *User) error
}

func (m *MockUserRepository) FindByID(ctx context.Context, id string) (*User, error) {
    if m.FindByIDFunc != nil {
        return m.FindByIDFunc(ctx, id)
    }
    return nil, nil
}

func (m *MockUserRepository) Save(ctx context.Context, user *User) error {
    if m.SaveFunc != nil {
        return m.SaveFunc(ctx, user)
    }
    return nil
}

// Test
func TestUserService_GetUser(t *testing.T) {
    ctx := context.Background()
    
    // 创建 Mock
    mockRepo := &MockUserRepository{
        FindByIDFunc: func(ctx context.Context, id string) (*User, error) {
            return &User{ID: id, Name: "Test User"}, nil
        },
    }
    
    // 创建服务
    service := NewUserService(mockRepo)
    
    // 测试
    user, err := service.GetUser(ctx, "user-123")
    if err != nil {
        t.Fatalf("GetUser failed: %v", err)
    }
    
    if user.ID != "user-123" {
        t.Errorf("Expected user ID 'user-123', got '%s'", user.ID)
    }
}
```

---

## 🎓 总结

本文档全面介绍了 Go 接口设计模式与 OTLP 集成：

✅ **接口设计原则** - ISP、DIP、接口隔离  
✅ **8+ 核心模式** - 装饰器、适配器、策略、工厂等  
✅ **OTLP 集成** - Traceable、Observable 接口  
✅ **泛型支持** - 类型安全的泛型接口  
✅ **性能优化** - 内联、避免类型断言  
✅ **测试策略** - Mock、依赖注入

**下一步**:

- 实践小接口设计
- 应用装饰器模式
- 集成 OTLP 追踪
- 编写接口测试

---

**版本**: v1.0.0  
**最后更新**: 2025-10-11  
**维护者**: OTLP Go Integration Team
