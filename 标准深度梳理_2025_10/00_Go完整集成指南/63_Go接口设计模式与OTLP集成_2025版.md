# Go æ¥å£è®¾è®¡æ¨¡å¼ä¸ OTLP é›†æˆï¼ˆ2025ç‰ˆï¼‰

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
> **Go ç‰ˆæœ¬**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0  
> **æœ€åæ›´æ–°**: 2025-10-11  
> **ä½œè€…**: OTLP Go Integration Team

---

## ğŸ“‹ ç›®å½•

- [Go æ¥å£è®¾è®¡æ¨¡å¼ä¸ OTLP é›†æˆï¼ˆ2025ç‰ˆï¼‰](#go-æ¥å£è®¾è®¡æ¨¡å¼ä¸-otlp-é›†æˆ2025ç‰ˆ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“– ç®€ä»‹](#-ç®€ä»‹)
    - [Go æ¥å£çš„ç‰¹ç‚¹](#go-æ¥å£çš„ç‰¹ç‚¹)
    - [ä¸ºä»€ä¹ˆéœ€è¦å¥½çš„æ¥å£è®¾è®¡ï¼Ÿ](#ä¸ºä»€ä¹ˆéœ€è¦å¥½çš„æ¥å£è®¾è®¡)
  - [ğŸ¯ æ¥å£åŸºç¡€](#-æ¥å£åŸºç¡€)
    - [æ¥å£å£°æ˜](#æ¥å£å£°æ˜)
    - [æ¥å£å®ç°](#æ¥å£å®ç°)
  - [ğŸ“ æ¥å£è®¾è®¡åŸåˆ™](#-æ¥å£è®¾è®¡åŸåˆ™)
    - [åŸåˆ™ 1: æ¥å£éš”ç¦»åŸåˆ™ï¼ˆISPï¼‰](#åŸåˆ™-1-æ¥å£éš”ç¦»åŸåˆ™isp)
    - [åŸåˆ™ 2: ä¾èµ–å€’ç½®åŸåˆ™ï¼ˆDIPï¼‰](#åŸåˆ™-2-ä¾èµ–å€’ç½®åŸåˆ™dip)
    - [åŸåˆ™ 3: æ¥å—æ¥å£ï¼Œè¿”å›ç»“æ„ä½“](#åŸåˆ™-3-æ¥å—æ¥å£è¿”å›ç»“æ„ä½“)
  - [ğŸ”§ æ ¸å¿ƒè®¾è®¡æ¨¡å¼](#-æ ¸å¿ƒè®¾è®¡æ¨¡å¼)
    - [æ¨¡å¼ 1: è£…é¥°å™¨æ¨¡å¼ï¼ˆDecoratorï¼‰](#æ¨¡å¼-1-è£…é¥°å™¨æ¨¡å¼decorator)
    - [æ¨¡å¼ 2: é€‚é…å™¨æ¨¡å¼ï¼ˆAdapterï¼‰](#æ¨¡å¼-2-é€‚é…å™¨æ¨¡å¼adapter)
    - [æ¨¡å¼ 3: ç­–ç•¥æ¨¡å¼ï¼ˆStrategyï¼‰](#æ¨¡å¼-3-ç­–ç•¥æ¨¡å¼strategy)
    - [æ¨¡å¼ 4: å·¥å‚æ¨¡å¼ï¼ˆFactoryï¼‰](#æ¨¡å¼-4-å·¥å‚æ¨¡å¼factory)
  - [ğŸ”Œ OTLP é›†æˆæ¨¡å¼](#-otlp-é›†æˆæ¨¡å¼)
    - [æ¨¡å¼ 5: å¯è¿½è¸ªæ¥å£ï¼ˆTraceable Interfaceï¼‰](#æ¨¡å¼-5-å¯è¿½è¸ªæ¥å£traceable-interface)
    - [æ¨¡å¼ 6: å¯ç›‘æ§æ¥å£ï¼ˆObservable Interfaceï¼‰](#æ¨¡å¼-6-å¯ç›‘æ§æ¥å£observable-interface)
  - [ğŸš€ é«˜çº§æ¨¡å¼](#-é«˜çº§æ¨¡å¼)
    - [æ¨¡å¼ 7: æ³›å‹æ¥å£ä¸ OTLP é›†æˆ](#æ¨¡å¼-7-æ³›å‹æ¥å£ä¸-otlp-é›†æˆ)
    - [æ¨¡å¼ 8: æ¥å£ç»„åˆä¸ä¸­é—´ä»¶é“¾](#æ¨¡å¼-8-æ¥å£ç»„åˆä¸ä¸­é—´ä»¶é“¾)
  - [âš¡ æ€§èƒ½ä¼˜åŒ–](#-æ€§èƒ½ä¼˜åŒ–)
    - [ä¼˜åŒ– 1: æ¥å£å†…è”ä¼˜åŒ–](#ä¼˜åŒ–-1-æ¥å£å†…è”ä¼˜åŒ–)
    - [ä¼˜åŒ– 2: é¿å…ä¸å¿…è¦çš„æ¥å£è½¬æ¢](#ä¼˜åŒ–-2-é¿å…ä¸å¿…è¦çš„æ¥å£è½¬æ¢)
  - [âœ… æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [1. æ¥å£åº”è¯¥å°è€Œä¸“æ³¨](#1-æ¥å£åº”è¯¥å°è€Œä¸“æ³¨)
    - [2. åœ¨ä½¿ç”¨å¤„å®šä¹‰æ¥å£ï¼Œè€Œä¸æ˜¯åœ¨å®ç°å¤„](#2-åœ¨ä½¿ç”¨å¤„å®šä¹‰æ¥å£è€Œä¸æ˜¯åœ¨å®ç°å¤„)
    - [3. æ¥å£æ–¹æ³•åº”è¯¥æ¥å— Context](#3-æ¥å£æ–¹æ³•åº”è¯¥æ¥å—-context)
    - [4. è¿”å›é”™è¯¯è€Œä¸æ˜¯ panic](#4-è¿”å›é”™è¯¯è€Œä¸æ˜¯-panic)
  - [ğŸ§ª æµ‹è¯•ç­–ç•¥](#-æµ‹è¯•ç­–ç•¥)
    - [Mock æ¥å£](#mock-æ¥å£)
  - [ğŸ“ æ€»ç»“](#-æ€»ç»“)

---

## ğŸ“– ç®€ä»‹

Go çš„æ¥å£æ˜¯å…¶ç±»å‹ç³»ç»Ÿçš„æ ¸å¿ƒï¼Œæä¾›äº†å¼ºå¤§è€Œçµæ´»çš„æŠ½è±¡æœºåˆ¶ã€‚
æœ¬æ–‡æ¡£æ·±å…¥æ¢è®¨å¦‚ä½•è®¾è®¡ä¼˜é›…çš„æ¥å£ï¼Œå¹¶å°†å…¶ä¸ OpenTelemetry æ— ç¼é›†æˆã€‚

### Go æ¥å£çš„ç‰¹ç‚¹

```go
// âœ… Go æ¥å£çš„éšå¼å®ç°
type Reader interface {
    Read(p []byte) (n int, err error)
}

// æ— éœ€æ˜¾å¼å£°æ˜ implements Reader
type File struct {
    // ...
}

func (f *File) Read(p []byte) (n int, err error) {
    // File è‡ªåŠ¨å®ç°äº† Reader æ¥å£
    return len(p), nil
}
```

### ä¸ºä»€ä¹ˆéœ€è¦å¥½çš„æ¥å£è®¾è®¡ï¼Ÿ

1. **è§£è€¦** - é™ä½ç»„ä»¶é—´çš„ä¾èµ–
2. **å¯æµ‹è¯•æ€§** - ä¾¿äº mock å’Œå•å…ƒæµ‹è¯•
3. **å¯æ‰©å±•æ€§** - æ˜“äºæ·»åŠ æ–°å®ç°
4. **å¯ç»´æŠ¤æ€§** - æ¸…æ™°çš„æŠ½è±¡è¾¹ç•Œ
5. **å¯è§‚æµ‹æ€§** - ç»Ÿä¸€çš„è¿½è¸ªç‚¹æ³¨å…¥

---

## ğŸ¯ æ¥å£åŸºç¡€

### æ¥å£å£°æ˜

```go
package main

import (
    "context"
    "io"
)

// 1. å°æ¥å£åŸåˆ™ - æ¥å£åº”è¯¥å°½å¯èƒ½å°
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type Closer interface {
    Close() error
}

// 2. æ¥å£ç»„åˆ
type ReadWriter interface {
    Reader
    Writer
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}

// 3. å¸¦ Context çš„æ¥å£ï¼ˆç°ä»£ Go æ¨èï¼‰
type ContextualReader interface {
    ReadContext(ctx context.Context, p []byte) (n int, err error)
}

type ContextualWriter interface {
    WriteContext(ctx context.Context, p []byte) (n int, err error)
}

// 4. æ³›å‹æ¥å£ï¼ˆGo 1.18+ï¼‰
type Container[T any] interface {
    Get() T
    Set(T)
}

type Comparable[T any] interface {
    CompareTo(other T) int
}
```

### æ¥å£å®ç°

```go
package main

import (
    "context"
    "bytes"
    "errors"
)

// File å®ç° ReadWriteCloser æ¥å£
type File struct {
    buffer *bytes.Buffer
    closed bool
}

func NewFile() *File {
    return &File{
        buffer: new(bytes.Buffer),
        closed: false,
    }
}

func (f *File) Read(p []byte) (n int, err error) {
    if f.closed {
        return 0, errors.New("file closed")
    }
    return f.buffer.Read(p)
}

func (f *File) Write(p []byte) (n int, err error) {
    if f.closed {
        return 0, errors.New("file closed")
    }
    return f.buffer.Write(p)
}

func (f *File) Close() error {
    if f.closed {
        return errors.New("file already closed")
    }
    f.closed = true
    return nil
}

// Example: ä½¿ç”¨æ¥å£
func ProcessFile(rw ReadWriter) error {
    data := []byte("Hello, World!")
    n, err := rw.Write(data)
    if err != nil {
        return err
    }
    
    result := make([]byte, n)
    _, err = rw.Read(result)
    return err
}
```

---

## ğŸ“ æ¥å£è®¾è®¡åŸåˆ™

### åŸåˆ™ 1: æ¥å£éš”ç¦»åŸåˆ™ï¼ˆISPï¼‰

```go
// âŒ è¿å ISP - æ¥å£è¿‡å¤§
type DatabaseClient interface {
    Connect() error
    Disconnect() error
    Query(sql string) ([]Row, error)
    Execute(sql string) error
    BeginTransaction() (Transaction, error)
    Backup() error
    Restore(path string) error
    Optimize() error
}

// âœ… éµå¾ª ISP - æ¥å£ç»†åˆ†
type Connector interface {
    Connect() error
    Disconnect() error
}

type Querier interface {
    Query(sql string) ([]Row, error)
}

type Executor interface {
    Execute(sql string) error
}

type Transactional interface {
    BeginTransaction() (Transaction, error)
}

type BackupRestore interface {
    Backup() error
    Restore(path string) error
}

// ç»„åˆéœ€è¦çš„æ¥å£
type BasicDatabase interface {
    Connector
    Querier
    Executor
}

type FullDatabase interface {
    BasicDatabase
    Transactional
    BackupRestore
}
```

### åŸåˆ™ 2: ä¾èµ–å€’ç½®åŸåˆ™ï¼ˆDIPï¼‰

```go
// âœ… ä¾èµ–æŠ½è±¡è€Œä¸æ˜¯å…·ä½“å®ç°
type UserService struct {
    repo   UserRepository    // ä¾èµ–æ¥å£
    cache  Cache            // ä¾èµ–æ¥å£
    tracer trace.Tracer     // ä¾èµ–æ¥å£
}

type UserRepository interface {
    FindByID(ctx context.Context, id string) (*User, error)
    Save(ctx context.Context, user *User) error
}

type Cache interface {
    Get(ctx context.Context, key string) (interface{}, error)
    Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error
}

// å…·ä½“å®ç°
type PostgresUserRepository struct {
    db *sql.DB
}

func (r *PostgresUserRepository) FindByID(ctx context.Context, id string) (*User, error) {
    // å®ç°
    return nil, nil
}

func (r *PostgresUserRepository) Save(ctx context.Context, user *User) error {
    // å®ç°
    return nil
}

// ä¾èµ–æ³¨å…¥
func NewUserService(repo UserRepository, cache Cache, tracer trace.Tracer) *UserService {
    return &UserService{
        repo:   repo,
        cache:  cache,
        tracer: tracer,
    }
}
```

### åŸåˆ™ 3: æ¥å—æ¥å£ï¼Œè¿”å›ç»“æ„ä½“

```go
// âœ… æ¥å—æ¥å£ï¼ˆæ›´çµæ´»ï¼‰
func ProcessData(reader io.Reader) error {
    // å¯ä»¥æ¥å—ä»»ä½•å®ç°äº† Reader çš„ç±»å‹
    data, err := io.ReadAll(reader)
    if err != nil {
        return err
    }
    // å¤„ç†æ•°æ®
    return nil
}

// âœ… è¿”å›å…·ä½“ç±»å‹ï¼ˆæ›´æ˜ç¡®ï¼‰
func NewUserService(repo UserRepository) *UserService {
    return &UserService{repo: repo}
}

// âŒ è¿”å›æ¥å£ï¼ˆé™åˆ¶äº†å®ç°çš„çµæ´»æ€§ï¼‰
func NewUserService(repo UserRepository) UserService {
    return &userServiceImpl{repo: repo}
}
```

---

## ğŸ”§ æ ¸å¿ƒè®¾è®¡æ¨¡å¼

### æ¨¡å¼ 1: è£…é¥°å™¨æ¨¡å¼ï¼ˆDecoratorï¼‰

```go
package main

import (
    "context"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// UserService æ¥å£
type UserService interface {
    GetUser(ctx context.Context, id string) (*User, error)
    CreateUser(ctx context.Context, user *User) error
}

// åŸºç¡€å®ç°
type basicUserService struct {
    repo UserRepository
}

func (s *basicUserService) GetUser(ctx context.Context, id string) (*User, error) {
    return s.repo.FindByID(ctx, id)
}

func (s *basicUserService) CreateUser(ctx context.Context, user *User) error {
    return s.repo.Save(ctx, user)
}

// è¿½è¸ªè£…é¥°å™¨
type tracingUserService struct {
    next   UserService
    tracer trace.Tracer
}

func NewTracingUserService(next UserService) UserService {
    return &tracingUserService{
        next:   next,
        tracer: otel.Tracer("user-service"),
    }
}

func (s *tracingUserService) GetUser(ctx context.Context, id string) (*User, error) {
    ctx, span := s.tracer.Start(ctx, "UserService.GetUser")
    defer span.End()
    
    span.SetAttributes(attribute.String("user.id", id))
    
    user, err := s.next.GetUser(ctx, id)
    if err != nil {
        span.RecordError(err)
        return nil, err
    }
    
    return user, nil
}

func (s *tracingUserService) CreateUser(ctx context.Context, user *User) error {
    ctx, span := s.tracer.Start(ctx, "UserService.CreateUser")
    defer span.End()
    
    span.SetAttributes(attribute.String("user.name", user.Name))
    
    err := s.next.CreateUser(ctx, user)
    if err != nil {
        span.RecordError(err)
        return err
    }
    
    return nil
}

// ç¼“å­˜è£…é¥°å™¨
type cachingUserService struct {
    next  UserService
    cache Cache
}

func NewCachingUserService(next UserService, cache Cache) UserService {
    return &cachingUserService{
        next:  next,
        cache: cache,
    }
}

func (s *cachingUserService) GetUser(ctx context.Context, id string) (*User, error) {
    // å°è¯•ä»ç¼“å­˜è¯»å–
    cacheKey := "user:" + id
    if cached, err := s.cache.Get(ctx, cacheKey); err == nil {
        if user, ok := cached.(*User); ok {
            return user, nil
        }
    }
    
    // ç¼“å­˜æœªå‘½ä¸­ï¼Œä»ä¸‹ä¸€å±‚è·å–
    user, err := s.next.GetUser(ctx, id)
    if err != nil {
        return nil, err
    }
    
    // å†™å…¥ç¼“å­˜
    s.cache.Set(ctx, cacheKey, user, 5*time.Minute)
    
    return user, nil
}

func (s *cachingUserService) CreateUser(ctx context.Context, user *User) error {
    err := s.next.CreateUser(ctx, user)
    if err != nil {
        return err
    }
    
    // ä½¿ç¼“å­˜å¤±æ•ˆ
    cacheKey := "user:" + user.ID
    s.cache.Delete(ctx, cacheKey)
    
    return nil
}

// ä½¿ç”¨è£…é¥°å™¨é“¾
func Example() {
    repo := NewPostgresUserRepository(db)
    cache := NewRedisCache(redisClient)
    
    // ç»„è£…è£…é¥°å™¨é“¾ï¼šåŸºç¡€æœåŠ¡ -> ç¼“å­˜ -> è¿½è¸ª
    service := NewTracingUserService(
        NewCachingUserService(
            &basicUserService{repo: repo},
            cache,
        ),
    )
    
    ctx := context.Background()
    user, err := service.GetUser(ctx, "user-123")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("User: %+v\n", user)
}
```

### æ¨¡å¼ 2: é€‚é…å™¨æ¨¡å¼ï¼ˆAdapterï¼‰

```go
package main

import (
    "context"
    "database/sql"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

// ç›®æ ‡æ¥å£
type UserRepository interface {
    FindByID(ctx context.Context, id string) (*User, error)
    Save(ctx context.Context, user *User) error
}

// æ—§çš„æ•°æ®åº“å®¢æˆ·ç«¯ï¼ˆä¸æ”¯æŒ Contextï¼‰
type LegacyDBClient struct {
    db *sql.DB
}

func (c *LegacyDBClient) GetUser(id string) (*User, error) {
    // æ—§çš„å®ç°
    return nil, nil
}

func (c *LegacyDBClient) SaveUser(user *User) error {
    // æ—§çš„å®ç°
    return nil
}

// é€‚é…å™¨ - å°†æ—§æ¥å£é€‚é…åˆ°æ–°æ¥å£
type LegacyDBAdapter struct {
    client *LegacyDBClient
    tracer trace.Tracer
}

func NewLegacyDBAdapter(client *LegacyDBClient) UserRepository {
    return &LegacyDBAdapter{
        client: client,
        tracer: otel.Tracer("legacy-db-adapter"),
    }
}

func (a *LegacyDBAdapter) FindByID(ctx context.Context, id string) (*User, error) {
    ctx, span := a.tracer.Start(ctx, "LegacyDB.FindByID")
    defer span.End()
    
    // é€‚é…ï¼šæ·»åŠ  Context æ”¯æŒ
    // ç›‘å¬ Context å–æ¶ˆ
    done := make(chan struct{})
    var user *User
    var err error
    
    go func() {
        user, err = a.client.GetUser(id)
        close(done)
    }()
    
    select {
    case <-ctx.Done():
        return nil, ctx.Err()
    case <-done:
        if err != nil {
            span.RecordError(err)
        }
        return user, err
    }
}

func (a *LegacyDBAdapter) Save(ctx context.Context, user *User) error {
    ctx, span := a.tracer.Start(ctx, "LegacyDB.Save")
    defer span.End()
    
    done := make(chan struct{})
    var err error
    
    go func() {
        err = a.client.SaveUser(user)
        close(done)
    }()
    
    select {
    case <-ctx.Done():
        return ctx.Err()
    case <-done:
        if err != nil {
            span.RecordError(err)
        }
        return err
    }
}
```

### æ¨¡å¼ 3: ç­–ç•¥æ¨¡å¼ï¼ˆStrategyï¼‰

```go
package main

import (
    "context"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// ä»·æ ¼è®¡ç®—ç­–ç•¥æ¥å£
type PricingStrategy interface {
    CalculatePrice(ctx context.Context, basePrice float64, user *User) (float64, error)
}

// å¸¸è§„å®šä»·ç­–ç•¥
type RegularPricing struct {
    tracer trace.Tracer
}

func NewRegularPricing() *RegularPricing {
    return &RegularPricing{
        tracer: otel.Tracer("regular-pricing"),
    }
}

func (p *RegularPricing) CalculatePrice(ctx context.Context, basePrice float64, user *User) (float64, error) {
    ctx, span := p.tracer.Start(ctx, "RegularPricing.CalculatePrice")
    defer span.End()
    
    span.SetAttributes(
        attribute.Float64("price.base", basePrice),
        attribute.String("strategy", "regular"),
    )
    
    // æ— æŠ˜æ‰£
    return basePrice, nil
}

// VIP å®šä»·ç­–ç•¥
type VIPPricing struct {
    discount float64
    tracer   trace.Tracer
}

func NewVIPPricing(discount float64) *VIPPricing {
    return &VIPPricing{
        discount: discount,
        tracer:   otel.Tracer("vip-pricing"),
    }
}

func (p *VIPPricing) CalculatePrice(ctx context.Context, basePrice float64, user *User) (float64, error) {
    ctx, span := p.tracer.Start(ctx, "VIPPricing.CalculatePrice")
    defer span.End()
    
    finalPrice := basePrice * (1 - p.discount)
    
    span.SetAttributes(
        attribute.Float64("price.base", basePrice),
        attribute.Float64("price.final", finalPrice),
        attribute.Float64("discount", p.discount),
        attribute.String("strategy", "vip"),
    )
    
    return finalPrice, nil
}

// å­£èŠ‚æ€§å®šä»·ç­–ç•¥
type SeasonalPricing struct {
    seasonDiscount float64
    tracer         trace.Tracer
}

func NewSeasonalPricing(seasonDiscount float64) *SeasonalPricing {
    return &SeasonalPricing{
        seasonDiscount: seasonDiscount,
        tracer:         otel.Tracer("seasonal-pricing"),
    }
}

func (p *SeasonalPricing) CalculatePrice(ctx context.Context, basePrice float64, user *User) (float64, error) {
    ctx, span := p.tracer.Start(ctx, "SeasonalPricing.CalculatePrice")
    defer span.End()
    
    finalPrice := basePrice * (1 - p.seasonDiscount)
    
    span.SetAttributes(
        attribute.Float64("price.base", basePrice),
        attribute.Float64("price.final", finalPrice),
        attribute.Float64("discount.seasonal", p.seasonDiscount),
        attribute.String("strategy", "seasonal"),
    )
    
    return finalPrice, nil
}

// è®¢å•æœåŠ¡ä½¿ç”¨ç­–ç•¥
type OrderService struct {
    pricingStrategy PricingStrategy
    tracer          trace.Tracer
}

func NewOrderService(strategy PricingStrategy) *OrderService {
    return &OrderService{
        pricingStrategy: strategy,
        tracer:          otel.Tracer("order-service"),
    }
}

func (s *OrderService) SetPricingStrategy(strategy PricingStrategy) {
    s.pricingStrategy = strategy
}

func (s *OrderService) CalculateOrderTotal(ctx context.Context, items []OrderItem, user *User) (float64, error) {
    ctx, span := s.tracer.Start(ctx, "OrderService.CalculateOrderTotal")
    defer span.End()
    
    var total float64
    for _, item := range items {
        price, err := s.pricingStrategy.CalculatePrice(ctx, item.Price, user)
        if err != nil {
            span.RecordError(err)
            return 0, err
        }
        total += price * float64(item.Quantity)
    }
    
    span.SetAttributes(attribute.Float64("order.total", total))
    
    return total, nil
}

// Example: ä½¿ç”¨ç­–ç•¥æ¨¡å¼
func ExampleStrategyPattern() {
    ctx := context.Background()
    
    items := []OrderItem{
        {Price: 100.0, Quantity: 2},
        {Price: 50.0, Quantity: 1},
    }
    
    user := &User{ID: "user-123", IsVIP: true}
    
    // ä½¿ç”¨ VIP å®šä»·ç­–ç•¥
    vipStrategy := NewVIPPricing(0.2) // 20% æŠ˜æ‰£
    orderService := NewOrderService(vipStrategy)
    
    total, _ := orderService.CalculateOrderTotal(ctx, items, user)
    fmt.Printf("VIP Total: %.2f\n", total) // Output: 200.00
    
    // åˆ‡æ¢åˆ°å­£èŠ‚æ€§å®šä»·ç­–ç•¥
    seasonalStrategy := NewSeasonalPricing(0.15) // 15% æŠ˜æ‰£
    orderService.SetPricingStrategy(seasonalStrategy)
    
    total, _ = orderService.CalculateOrderTotal(ctx, items, user)
    fmt.Printf("Seasonal Total: %.2f\n", total) // Output: 212.50
}
```

### æ¨¡å¼ 4: å·¥å‚æ¨¡å¼ï¼ˆFactoryï¼‰

```go
package main

import (
    "context"
    "fmt"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

// æ•°æ®åº“ç±»å‹
type DatabaseType string

const (
    PostgreSQL DatabaseType = "postgresql"
    MySQL      DatabaseType = "mysql"
    MongoDB    DatabaseType = "mongodb"
)

// Repository å·¥å‚æ¥å£
type RepositoryFactory interface {
    CreateUserRepository(ctx context.Context) (UserRepository, error)
    CreateOrderRepository(ctx context.Context) (OrderRepository, error)
}

// PostgreSQL å·¥å‚
type PostgreSQLFactory struct {
    connString string
    tracer     trace.Tracer
}

func NewPostgreSQLFactory(connString string) *PostgreSQLFactory {
    return &PostgreSQLFactory{
        connString: connString,
        tracer:     otel.Tracer("postgresql-factory"),
    }
}

func (f *PostgreSQLFactory) CreateUserRepository(ctx context.Context) (UserRepository, error) {
    ctx, span := f.tracer.Start(ctx, "PostgreSQLFactory.CreateUserRepository")
    defer span.End()
    
    // åˆ›å»º PostgreSQL UserRepository
    return NewPostgresUserRepository(f.connString), nil
}

func (f *PostgreSQLFactory) CreateOrderRepository(ctx context.Context) (OrderRepository, error) {
    ctx, span := f.tracer.Start(ctx, "PostgreSQLFactory.CreateOrderRepository")
    defer span.End()
    
    // åˆ›å»º PostgreSQL OrderRepository
    return NewPostgresOrderRepository(f.connString), nil
}

// MySQL å·¥å‚
type MySQLFactory struct {
    connString string
    tracer     trace.Tracer
}

func NewMySQLFactory(connString string) *MySQLFactory {
    return &MySQLFactory{
        connString: connString,
        tracer:     otel.Tracer("mysql-factory"),
    }
}

func (f *MySQLFactory) CreateUserRepository(ctx context.Context) (UserRepository, error) {
    ctx, span := f.tracer.Start(ctx, "MySQLFactory.CreateUserRepository")
    defer span.End()
    
    // åˆ›å»º MySQL UserRepository
    return NewMySQLUserRepository(f.connString), nil
}

func (f *MySQLFactory) CreateOrderRepository(ctx context.Context) (OrderRepository, error) {
    ctx, span := f.tracer.Start(ctx, "MySQLFactory.CreateOrderRepository")
    defer span.End()
    
    // åˆ›å»º MySQL OrderRepository
    return NewMySQLOrderRepository(f.connString), nil
}

// å·¥å‚æ³¨å†Œå™¨
type FactoryRegistry struct {
    factories map[DatabaseType]RepositoryFactory
}

func NewFactoryRegistry() *FactoryRegistry {
    return &FactoryRegistry{
        factories: make(map[DatabaseType]RepositoryFactory),
    }
}

func (r *FactoryRegistry) Register(dbType DatabaseType, factory RepositoryFactory) {
    r.factories[dbType] = factory
}

func (r *FactoryRegistry) GetFactory(dbType DatabaseType) (RepositoryFactory, error) {
    factory, exists := r.factories[dbType]
    if !exists {
        return nil, fmt.Errorf("factory not found for database type: %s", dbType)
    }
    return factory, nil
}

// Example: ä½¿ç”¨å·¥å‚æ¨¡å¼
func ExampleFactoryPattern() {
    ctx := context.Background()
    
    // åˆ›å»ºå·¥å‚æ³¨å†Œå™¨
    registry := NewFactoryRegistry()
    
    // æ³¨å†Œå·¥å‚
    registry.Register(PostgreSQL, NewPostgreSQLFactory("postgres://localhost"))
    registry.Register(MySQL, NewMySQLFactory("mysql://localhost"))
    
    // æ ¹æ®é…ç½®è·å–å·¥å‚
    dbType := PostgreSQL // ä»é…ç½®è¯»å–
    factory, _ := registry.GetFactory(dbType)
    
    // ä½¿ç”¨å·¥å‚åˆ›å»º Repository
    userRepo, _ := factory.CreateUserRepository(ctx)
    orderRepo, _ := factory.CreateOrderRepository(ctx)
    
    // ä½¿ç”¨ Repository
    user, _ := userRepo.FindByID(ctx, "user-123")
    fmt.Printf("User: %+v\n", user)
    
    order, _ := orderRepo.FindByID(ctx, "order-456")
    fmt.Printf("Order: %+v\n", order)
}
```

---

## ğŸ”Œ OTLP é›†æˆæ¨¡å¼

### æ¨¡å¼ 5: å¯è¿½è¸ªæ¥å£ï¼ˆTraceable Interfaceï¼‰

```go
package main

import (
    "context"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// Traceable æ¥å£ - æ‰€æœ‰éœ€è¦è¿½è¸ªçš„ç»„ä»¶å®ç°æ­¤æ¥å£
type Traceable interface {
    GetTracer() trace.Tracer
    GetSpanName(operation string) string
}

// BaseTraceable åŸºç¡€å¯è¿½è¸ªç»„ä»¶
type BaseTraceable struct {
    serviceName string
    tracer      trace.Tracer
}

func NewBaseTraceable(serviceName string) *BaseTraceable {
    return &BaseTraceable{
        serviceName: serviceName,
        tracer:      otel.Tracer(serviceName),
    }
}

func (b *BaseTraceable) GetTracer() trace.Tracer {
    return b.tracer
}

func (b *BaseTraceable) GetSpanName(operation string) string {
    return b.serviceName + "." + operation
}

// TracedUserRepository å®ç°å¯è¿½è¸ªçš„ UserRepository
type TracedUserRepository struct {
    *BaseTraceable
    db Database
}

func NewTracedUserRepository(db Database) *TracedUserRepository {
    return &TracedUserRepository{
        BaseTraceable: NewBaseTraceable("UserRepository"),
        db:            db,
    }
}

func (r *TracedUserRepository) FindByID(ctx context.Context, id string) (*User, error) {
    ctx, span := r.GetTracer().Start(ctx, r.GetSpanName("FindByID"))
    defer span.End()
    
    span.SetAttributes(
        attribute.String("user.id", id),
        attribute.String("operation", "find"),
    )
    
    user, err := r.db.QueryUser(ctx, id)
    if err != nil {
        span.RecordError(err)
        return nil, err
    }
    
    span.SetAttributes(attribute.String("user.name", user.Name))
    
    return user, nil
}

func (r *TracedUserRepository) Save(ctx context.Context, user *User) error {
    ctx, span := r.GetTracer().Start(ctx, r.GetSpanName("Save"))
    defer span.End()
    
    span.SetAttributes(
        attribute.String("user.id", user.ID),
        attribute.String("user.name", user.Name),
        attribute.String("operation", "save"),
    )
    
    err := r.db.SaveUser(ctx, user)
    if err != nil {
        span.RecordError(err)
        return err
    }
    
    return nil
}

// TracedOrderService å®ç°å¯è¿½è¸ªçš„ OrderService
type TracedOrderService struct {
    *BaseTraceable
    userRepo  UserRepository
    orderRepo OrderRepository
}

func NewTracedOrderService(userRepo UserRepository, orderRepo OrderRepository) *TracedOrderService {
    return &TracedOrderService{
        BaseTraceable: NewBaseTraceable("OrderService"),
        userRepo:      userRepo,
        orderRepo:     orderRepo,
    }
}

func (s *TracedOrderService) CreateOrder(ctx context.Context, order *Order) error {
    ctx, span := s.GetTracer().Start(ctx, s.GetSpanName("CreateOrder"))
    defer span.End()
    
    span.SetAttributes(
        attribute.String("order.id", order.ID),
        attribute.String("user.id", order.UserID),
        attribute.Float64("order.amount", order.Amount),
    )
    
    // éªŒè¯ç”¨æˆ·
    user, err := s.userRepo.FindByID(ctx, order.UserID)
    if err != nil {
        span.RecordError(err)
        return err
    }
    
    span.SetAttributes(attribute.String("user.name", user.Name))
    
    // åˆ›å»ºè®¢å•
    err = s.orderRepo.Save(ctx, order)
    if err != nil {
        span.RecordError(err)
        return err
    }
    
    return nil
}
```

### æ¨¡å¼ 6: å¯ç›‘æ§æ¥å£ï¼ˆObservable Interfaceï¼‰

```go
package main

import (
    "context"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/metric"
)

// Observable æ¥å£ - æ‰€æœ‰éœ€è¦ç›‘æ§çš„ç»„ä»¶å®ç°æ­¤æ¥å£
type Observable interface {
    GetMeter() metric.Meter
    RecordMetric(ctx context.Context, name string, value float64, attrs ...attribute.KeyValue)
}

// BaseObservable åŸºç¡€å¯ç›‘æ§ç»„ä»¶
type BaseObservable struct {
    serviceName    string
    meter          metric.Meter
    requestCounter metric.Int64Counter
    durationHisto  metric.Float64Histogram
    errorCounter   metric.Int64Counter
}

func NewBaseObservable(serviceName string) (*BaseObservable, error) {
    meter := otel.Meter(serviceName)
    
    requestCounter, err := meter.Int64Counter(
        serviceName+".requests",
        metric.WithDescription("Total requests"),
    )
    if err != nil {
        return nil, err
    }
    
    durationHisto, err := meter.Float64Histogram(
        serviceName+".duration",
        metric.WithDescription("Request duration in milliseconds"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    errorCounter, err := meter.Int64Counter(
        serviceName+".errors",
        metric.WithDescription("Total errors"),
    )
    if err != nil {
        return nil, err
    }
    
    return &BaseObservable{
        serviceName:    serviceName,
        meter:          meter,
        requestCounter: requestCounter,
        durationHisto:  durationHisto,
        errorCounter:   errorCounter,
    }, nil
}

func (b *BaseObservable) GetMeter() metric.Meter {
    return b.meter
}

func (b *BaseObservable) RecordRequest(ctx context.Context, operation string, attrs ...attribute.KeyValue) {
    allAttrs := append([]attribute.KeyValue{
        attribute.String("operation", operation),
    }, attrs...)
    
    b.requestCounter.Add(ctx, 1, metric.WithAttributes(allAttrs...))
}

func (b *BaseObservable) RecordDuration(ctx context.Context, operation string, duration time.Duration, attrs ...attribute.KeyValue) {
    allAttrs := append([]attribute.KeyValue{
        attribute.String("operation", operation),
    }, attrs...)
    
    b.durationHisto.Record(ctx, float64(duration.Milliseconds()), metric.WithAttributes(allAttrs...))
}

func (b *BaseObservable) RecordError(ctx context.Context, operation string, err error, attrs ...attribute.KeyValue) {
    allAttrs := append([]attribute.KeyValue{
        attribute.String("operation", operation),
        attribute.String("error", err.Error()),
    }, attrs...)
    
    b.errorCounter.Add(ctx, 1, metric.WithAttributes(allAttrs...))
}

// ObservableUserRepository å®ç°å¯ç›‘æ§çš„ UserRepository
type ObservableUserRepository struct {
    *BaseObservable
    db Database
}

func NewObservableUserRepository(db Database) (*ObservableUserRepository, error) {
    observable, err := NewBaseObservable("UserRepository")
    if err != nil {
        return nil, err
    }
    
    return &ObservableUserRepository{
        BaseObservable: observable,
        db:             db,
    }, nil
}

func (r *ObservableUserRepository) FindByID(ctx context.Context, id string) (*User, error) {
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        r.RecordDuration(ctx, "FindByID", duration,
            attribute.String("user.id", id),
        )
    }()
    
    r.RecordRequest(ctx, "FindByID",
        attribute.String("user.id", id),
    )
    
    user, err := r.db.QueryUser(ctx, id)
    if err != nil {
        r.RecordError(ctx, "FindByID", err,
            attribute.String("user.id", id),
        )
        return nil, err
    }
    
    return user, nil
}
```

---

## ğŸš€ é«˜çº§æ¨¡å¼

### æ¨¡å¼ 7: æ³›å‹æ¥å£ä¸ OTLP é›†æˆ

```go
package main

import (
    "context"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// Repository æ³›å‹æ¥å£
type Repository[T any, ID comparable] interface {
    FindByID(ctx context.Context, id ID) (T, error)
    Save(ctx context.Context, entity T) error
    Delete(ctx context.Context, id ID) error
    FindAll(ctx context.Context) ([]T, error)
}

// TracedRepository å¸¦è¿½è¸ªçš„æ³›å‹ Repository
type TracedRepository[T any, ID comparable] struct {
    entityName string
    repo       Repository[T, ID]
    tracer     trace.Tracer
}

func NewTracedRepository[T any, ID comparable](
    entityName string,
    repo Repository[T, ID],
) *TracedRepository[T, ID] {
    return &TracedRepository[T, ID]{
        entityName: entityName,
        repo:       repo,
        tracer:     otel.Tracer("traced-repository"),
    }
}

func (tr *TracedRepository[T, ID]) FindByID(ctx context.Context, id ID) (T, error) {
    ctx, span := tr.tracer.Start(ctx, tr.entityName+".FindByID")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("entity.name", tr.entityName),
        attribute.String("entity.id", fmt.Sprintf("%v", id)),
    )
    
    entity, err := tr.repo.FindByID(ctx, id)
    if err != nil {
        span.RecordError(err)
        var zero T
        return zero, err
    }
    
    return entity, nil
}

func (tr *TracedRepository[T, ID]) Save(ctx context.Context, entity T) error {
    ctx, span := tr.tracer.Start(ctx, tr.entityName+".Save")
    defer span.End()
    
    span.SetAttributes(attribute.String("entity.name", tr.entityName))
    
    err := tr.repo.Save(ctx, entity)
    if err != nil {
        span.RecordError(err)
        return err
    }
    
    return nil
}

func (tr *TracedRepository[T, ID]) Delete(ctx context.Context, id ID) error {
    ctx, span := tr.tracer.Start(ctx, tr.entityName+".Delete")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("entity.name", tr.entityName),
        attribute.String("entity.id", fmt.Sprintf("%v", id)),
    )
    
    err := tr.repo.Delete(ctx, id)
    if err != nil {
        span.RecordError(err)
        return err
    }
    
    return nil
}

func (tr *TracedRepository[T, ID]) FindAll(ctx context.Context) ([]T, error) {
    ctx, span := tr.tracer.Start(ctx, tr.entityName+".FindAll")
    defer span.End()
    
    span.SetAttributes(attribute.String("entity.name", tr.entityName))
    
    entities, err := tr.repo.FindAll(ctx)
    if err != nil {
        span.RecordError(err)
        return nil, err
    }
    
    span.SetAttributes(attribute.Int("entity.count", len(entities)))
    
    return entities, nil
}

// Example: ä½¿ç”¨æ³›å‹ Repository
func ExampleGenericRepository() {
    ctx := context.Background()
    
    // åˆ›å»ºåŸºç¡€ UserRepository
    baseUserRepo := NewPostgresUserRepository(db)
    
    // åŒ…è£…ä¸ºå¸¦è¿½è¸ªçš„æ³›å‹ Repository
    tracedUserRepo := NewTracedRepository[*User, string]("User", baseUserRepo)
    
    // ä½¿ç”¨
    user, _ := tracedUserRepo.FindByID(ctx, "user-123")
    fmt.Printf("User: %+v\n", user)
    
    // åˆ›å»ºåŸºç¡€ OrderRepository
    baseOrderRepo := NewPostgresOrderRepository(db)
    
    // åŒ…è£…ä¸ºå¸¦è¿½è¸ªçš„æ³›å‹ Repository
    tracedOrderRepo := NewTracedRepository[*Order, string]("Order", baseOrderRepo)
    
    // ä½¿ç”¨
    order, _ := tracedOrderRepo.FindByID(ctx, "order-456")
    fmt.Printf("Order: %+v\n", order)
}
```

### æ¨¡å¼ 8: æ¥å£ç»„åˆä¸ä¸­é—´ä»¶é“¾

```go
package main

import (
    "context"
    "time"
)

// Middleware ä¸­é—´ä»¶æ¥å£
type Middleware[T any] interface {
    Execute(ctx context.Context, next func(ctx context.Context) (T, error)) (T, error)
}

// MiddlewareChain ä¸­é—´ä»¶é“¾
type MiddlewareChain[T any] struct {
    middlewares []Middleware[T]
}

func NewMiddlewareChain[T any]() *MiddlewareChain[T] {
    return &MiddlewareChain[T]{
        middlewares: make([]Middleware[T], 0),
    }
}

func (mc *MiddlewareChain[T]) Use(middleware Middleware[T]) *MiddlewareChain[T] {
    mc.middlewares = append(mc.middlewares, middleware)
    return mc
}

func (mc *MiddlewareChain[T]) Execute(ctx context.Context, handler func(ctx context.Context) (T, error)) (T, error) {
    if len(mc.middlewares) == 0 {
        return handler(ctx)
    }
    
    // æ„å»ºä¸­é—´ä»¶é“¾
    var next func(ctx context.Context) (T, error)
    next = handler
    
    for i := len(mc.middlewares) - 1; i >= 0; i-- {
        middleware := mc.middlewares[i]
        currentNext := next
        next = func(ctx context.Context) (T, error) {
            return middleware.Execute(ctx, currentNext)
        }
    }
    
    return next(ctx)
}

// TracingMiddleware è¿½è¸ªä¸­é—´ä»¶
type TracingMiddleware[T any] struct {
    operationName string
    tracer        trace.Tracer
}

func NewTracingMiddleware[T any](operationName string) *TracingMiddleware[T] {
    return &TracingMiddleware[T]{
        operationName: operationName,
        tracer:        otel.Tracer("tracing-middleware"),
    }
}

func (tm *TracingMiddleware[T]) Execute(ctx context.Context, next func(ctx context.Context) (T, error)) (T, error) {
    ctx, span := tm.tracer.Start(ctx, tm.operationName)
    defer span.End()
    
    result, err := next(ctx)
    if err != nil {
        span.RecordError(err)
    }
    
    return result, err
}

// RetryMiddleware é‡è¯•ä¸­é—´ä»¶
type RetryMiddleware[T any] struct {
    maxRetries int
    backoff    time.Duration
}

func NewRetryMiddleware[T any](maxRetries int, backoff time.Duration) *RetryMiddleware[T] {
    return &RetryMiddleware[T]{
        maxRetries: maxRetries,
        backoff:    backoff,
    }
}

func (rm *RetryMiddleware[T]) Execute(ctx context.Context, next func(ctx context.Context) (T, error)) (T, error) {
    var result T
    var err error
    
    for i := 0; i <= rm.maxRetries; i++ {
        result, err = next(ctx)
        if err == nil {
            return result, nil
        }
        
        if i < rm.maxRetries {
            time.Sleep(rm.backoff * time.Duration(i+1))
        }
    }
    
    return result, err
}

// TimeoutMiddleware è¶…æ—¶ä¸­é—´ä»¶
type TimeoutMiddleware[T any] struct {
    timeout time.Duration
}

func NewTimeoutMiddleware[T any](timeout time.Duration) *TimeoutMiddleware[T] {
    return &TimeoutMiddleware[T]{
        timeout: timeout,
    }
}

func (tm *TimeoutMiddleware[T]) Execute(ctx context.Context, next func(ctx context.Context) (T, error)) (T, error) {
    ctx, cancel := context.WithTimeout(ctx, tm.timeout)
    defer cancel()
    
    return next(ctx)
}

// Example: ä½¿ç”¨ä¸­é—´ä»¶é“¾
func ExampleMiddlewareChain() {
    ctx := context.Background()
    
    // åˆ›å»ºä¸­é—´ä»¶é“¾
    chain := NewMiddlewareChain[*User]()
    chain.Use(NewTracingMiddleware[*User]("GetUser"))
    chain.Use(NewTimeoutMiddleware[*User](5 * time.Second))
    chain.Use(NewRetryMiddleware[*User](3, 100*time.Millisecond))
    
    // æ‰§è¡Œ
    user, err := chain.Execute(ctx, func(ctx context.Context) (*User, error) {
        return getUserFromDB(ctx, "user-123")
    })
    
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("User: %+v\n", user)
}

func getUserFromDB(ctx context.Context, userID string) (*User, error) {
    // å®é™…çš„æ•°æ®åº“æŸ¥è¯¢
    return &User{ID: userID, Name: "John Doe"}, nil
}
```

---

## âš¡ æ€§èƒ½ä¼˜åŒ–

### ä¼˜åŒ– 1: æ¥å£å†…è”ä¼˜åŒ–

```go
// ç¼–è¯‘å™¨å¯ä»¥å†…è”å°æ¥å£æ–¹æ³•è°ƒç”¨

// âœ… å°æ¥å£ - å®¹æ˜“å†…è”
type Validator interface {
    Validate() error
}

// âœ… å…·ä½“ç±»å‹æ–¹æ³•è°ƒç”¨ - æ›´å¿«
type User struct {
    ID   string
    Name string
}

func (u *User) Validate() error {
    if u.ID == "" {
        return errors.New("ID is required")
    }
    return nil
}

// Benchmark å¯¹æ¯”
func BenchmarkInterfaceCall(b *testing.B) {
    var validator Validator = &User{ID: "123", Name: "John"}
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        validator.Validate()
    }
}

func BenchmarkDirectCall(b *testing.B) {
    user := &User{ID: "123", Name: "John"}
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        user.Validate()
    }
}
```

### ä¼˜åŒ– 2: é¿å…ä¸å¿…è¦çš„æ¥å£è½¬æ¢

```go
// âŒ é¢‘ç¹çš„ç±»å‹æ–­è¨€
func ProcessItems(items []interface{}) {
    for _, item := range items {
        if user, ok := item.(*User); ok {
            processUser(user)
        }
    }
}

// âœ… ä½¿ç”¨æ³›å‹é¿å…ç±»å‹æ–­è¨€
func ProcessItems[T any](items []T, processor func(T)) {
    for _, item := range items {
        processor(item)
    }
}
```

---

## âœ… æœ€ä½³å®è·µ

### 1. æ¥å£åº”è¯¥å°è€Œä¸“æ³¨

```go
// âœ… å¥½çš„æ¥å£è®¾è®¡
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type Closer interface {
    Close() error
}
```

### 2. åœ¨ä½¿ç”¨å¤„å®šä¹‰æ¥å£ï¼Œè€Œä¸æ˜¯åœ¨å®ç°å¤„

```go
// âœ… åœ¨åŒ… A ä¸­å®šä¹‰æ¥å£
package a

type UserGetter interface {
    GetUser(ctx context.Context, id string) (*User, error)
}

// åŒ… B å®ç°æ¥å£ï¼ˆä¸éœ€è¦çŸ¥é“æ¥å£çš„å­˜åœ¨ï¼‰
package b

type UserService struct {}

func (s *UserService) GetUser(ctx context.Context, id string) (*User, error) {
    // å®ç°
}
```

### 3. æ¥å£æ–¹æ³•åº”è¯¥æ¥å— Context

```go
// âœ… æ¥å— Context
type UserRepository interface {
    FindByID(ctx context.Context, id string) (*User, error)
}
```

### 4. è¿”å›é”™è¯¯è€Œä¸æ˜¯ panic

```go
// âœ… è¿”å›é”™è¯¯
type UserRepository interface {
    FindByID(ctx context.Context, id string) (*User, error)
}

// âŒ panic
type UserRepository interface {
    FindByID(ctx context.Context, id string) *User // ä¸è¿”å›é”™è¯¯
}
```

---

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### Mock æ¥å£

```go
package main

import (
    "context"
    "testing"
)

// MockUserRepository å®ç° UserRepository æ¥å£ç”¨äºæµ‹è¯•
type MockUserRepository struct {
    FindByIDFunc func(ctx context.Context, id string) (*User, error)
    SaveFunc     func(ctx context.Context, user *User) error
}

func (m *MockUserRepository) FindByID(ctx context.Context, id string) (*User, error) {
    if m.FindByIDFunc != nil {
        return m.FindByIDFunc(ctx, id)
    }
    return nil, nil
}

func (m *MockUserRepository) Save(ctx context.Context, user *User) error {
    if m.SaveFunc != nil {
        return m.SaveFunc(ctx, user)
    }
    return nil
}

// Test
func TestUserService_GetUser(t *testing.T) {
    ctx := context.Background()
    
    // åˆ›å»º Mock
    mockRepo := &MockUserRepository{
        FindByIDFunc: func(ctx context.Context, id string) (*User, error) {
            return &User{ID: id, Name: "Test User"}, nil
        },
    }
    
    // åˆ›å»ºæœåŠ¡
    service := NewUserService(mockRepo)
    
    // æµ‹è¯•
    user, err := service.GetUser(ctx, "user-123")
    if err != nil {
        t.Fatalf("GetUser failed: %v", err)
    }
    
    if user.ID != "user-123" {
        t.Errorf("Expected user ID 'user-123', got '%s'", user.ID)
    }
}
```

---

## ğŸ“ æ€»ç»“

æœ¬æ–‡æ¡£å…¨é¢ä»‹ç»äº† Go æ¥å£è®¾è®¡æ¨¡å¼ä¸ OTLP é›†æˆï¼š

âœ… **æ¥å£è®¾è®¡åŸåˆ™** - ISPã€DIPã€æ¥å£éš”ç¦»  
âœ… **8+ æ ¸å¿ƒæ¨¡å¼** - è£…é¥°å™¨ã€é€‚é…å™¨ã€ç­–ç•¥ã€å·¥å‚ç­‰  
âœ… **OTLP é›†æˆ** - Traceableã€Observable æ¥å£  
âœ… **æ³›å‹æ”¯æŒ** - ç±»å‹å®‰å…¨çš„æ³›å‹æ¥å£  
âœ… **æ€§èƒ½ä¼˜åŒ–** - å†…è”ã€é¿å…ç±»å‹æ–­è¨€  
âœ… **æµ‹è¯•ç­–ç•¥** - Mockã€ä¾èµ–æ³¨å…¥

**ä¸‹ä¸€æ­¥**:

- å®è·µå°æ¥å£è®¾è®¡
- åº”ç”¨è£…é¥°å™¨æ¨¡å¼
- é›†æˆ OTLP è¿½è¸ª
- ç¼–å†™æ¥å£æµ‹è¯•

---

**ç‰ˆæœ¬**: v1.0.0  
**æœ€åæ›´æ–°**: 2025-10-11  
**ç»´æŠ¤è€…**: OTLP Go Integration Team
