# Go å†…å­˜ç®¡ç†ä¸æ€§èƒ½è°ƒä¼˜å®æˆ˜

> **Go ç‰ˆæœ¬**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ10æ—¥

---

## ğŸ“‹ ç›®å½•

- [Go å†…å­˜ç®¡ç†ä¸æ€§èƒ½è°ƒä¼˜å®æˆ˜](#go-å†…å­˜ç®¡ç†ä¸æ€§èƒ½è°ƒä¼˜å®æˆ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
  - [å†…å­˜åˆ†é…ä¼˜åŒ–](#å†…å­˜åˆ†é…ä¼˜åŒ–)
    - [1. é¢„åˆ†é…å®¹é‡](#1-é¢„åˆ†é…å®¹é‡)
    - [2. å‡å°‘é€ƒé€¸åˆ†æ](#2-å‡å°‘é€ƒé€¸åˆ†æ)
  - [å¯¹è±¡æ± æ¨¡å¼](#å¯¹è±¡æ± æ¨¡å¼)
    - [å®Œæ•´çš„å¯¹è±¡æ± å®ç°](#å®Œæ•´çš„å¯¹è±¡æ± å®ç°)
  - [GC è°ƒä¼˜](#gc-è°ƒä¼˜)
    - [GC ç›‘æ§å’Œè°ƒä¼˜](#gc-ç›‘æ§å’Œè°ƒä¼˜)
  - [é›¶åˆ†é…æŠ€å·§](#é›¶åˆ†é…æŠ€å·§)
  - [æ€»ç»“](#æ€»ç»“)

---

## æ¦‚è¿°

Go 1.25.1 æä¾›äº†å¼ºå¤§çš„å†…å­˜ç®¡ç†å’Œæ€§èƒ½ä¼˜åŒ–èƒ½åŠ›ï¼Œæœ¬æ–‡æ¡£å±•ç¤ºå¦‚ä½•ç»“åˆ OpenTelemetry å®ç°ç”Ÿäº§çº§æ€§èƒ½ä¼˜åŒ–ã€‚

**æ ¸å¿ƒä¼˜åŒ–ç‚¹**:

```text
âœ… å‡å°‘å†…å­˜åˆ†é…
âœ… å¯¹è±¡æ± å¤ç”¨
âœ… GC è°ƒä¼˜
âœ… å†…å­˜æ³„æ¼é˜²æŠ¤
âœ… é›¶åˆ†é…ä¼˜åŒ–
âœ… CPU æ€§èƒ½ä¼˜åŒ–
âœ… Profiling åˆ†æ
```

---

## å†…å­˜åˆ†é…ä¼˜åŒ–

### 1. é¢„åˆ†é…å®¹é‡

```go
package optimization

import (
    "context"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
)

// AllocationOptimizer å†…å­˜åˆ†é…ä¼˜åŒ–å™¨
type AllocationOptimizer struct {
    tracer        trace.Tracer
    meter         metric.Meter
    allocCounter  metric.Int64Counter
    allocBytes    metric.Int64Counter
}

// NewAllocationOptimizer åˆ›å»ºåˆ†é…ä¼˜åŒ–å™¨
func NewAllocationOptimizer() (*AllocationOptimizer, error) {
    tracer := otel.Tracer("allocation-optimizer")
    meter := otel.Meter("allocation-optimizer")
    
    ao := &AllocationOptimizer{
        tracer: tracer,
        meter:  meter,
    }
    
    var err error
    
    ao.allocCounter, err = meter.Int64Counter(
        "memory.allocations.count",
        metric.WithDescription("Number of allocations"),
    )
    if err != nil {
        return nil, err
    }
    
    ao.allocBytes, err = meter.Int64Counter(
        "memory.allocations.bytes",
        metric.WithDescription("Bytes allocated"),
        metric.WithUnit("bytes"),
    )
    if err != nil {
        return nil, err
    }
    
    return ao, nil
}

// PreAllocateSlice é¢„åˆ†é…åˆ‡ç‰‡ï¼ˆé¿å…å¤šæ¬¡æ‰©å®¹ï¼‰
func (ao *AllocationOptimizer) PreAllocateSlice(
    ctx context.Context,
    expectedSize int,
) []interface{} {
    ctx, span := ao.tracer.Start(ctx, "pre_allocate_slice",
        trace.WithAttributes(
            attribute.Int("expected_size", expectedSize),
        ),
    )
    defer span.End()
    
    // âœ… å¥½: é¢„åˆ†é…å®¹é‡
    slice := make([]interface{}, 0, expectedSize)
    
    // è®°å½•åˆ†é…
    ao.allocCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("type", "slice"),
            attribute.Bool("pre_allocated", true),
        ),
    )
    
    ao.allocBytes.Add(ctx, int64(expectedSize*8), // å‡è®¾æ¯ä¸ªå…ƒç´  8 å­—èŠ‚
        metric.WithAttributes(
            attribute.String("type", "slice"),
        ),
    )
    
    return slice
    
    // âŒ å·®: ä¸é¢„åˆ†é…ï¼ˆä¼šå¤šæ¬¡æ‰©å®¹ï¼‰
    // slice := make([]interface{}, 0)
}

// PreAllocateMap é¢„åˆ†é… Map
func (ao *AllocationOptimizer) PreAllocateMap(
    ctx context.Context,
    expectedSize int,
) map[string]interface{} {
    ctx, span := ao.tracer.Start(ctx, "pre_allocate_map",
        trace.WithAttributes(
            attribute.Int("expected_size", expectedSize),
        ),
    )
    defer span.End()
    
    // âœ… å¥½: é¢„åˆ†é…å®¹é‡
    m := make(map[string]interface{}, expectedSize)
    
    ao.allocCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("type", "map"),
            attribute.Bool("pre_allocated", true),
        ),
    )
    
    return m
}

// ReuseBuffer å¤ç”¨ç¼“å†²åŒº
func (ao *AllocationOptimizer) ReuseBuffer(
    ctx context.Context,
    buffer []byte,
    requiredSize int,
) []byte {
    ctx, span := ao.tracer.Start(ctx, "reuse_buffer")
    defer span.End()
    
    // æ£€æŸ¥ç°æœ‰å®¹é‡æ˜¯å¦è¶³å¤Ÿ
    if cap(buffer) >= requiredSize {
        // âœ… å¤ç”¨ç°æœ‰ç¼“å†²åŒº
        span.SetAttributes(
            attribute.Bool("buffer_reused", true),
            attribute.Int("buffer_capacity", cap(buffer)),
        )
        return buffer[:requiredSize]
    }
    
    // éœ€è¦é‡æ–°åˆ†é…
    span.SetAttributes(
        attribute.Bool("buffer_reused", false),
        attribute.Int("new_capacity", requiredSize),
    )
    
    ao.allocCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("type", "buffer"),
            attribute.Bool("reallocation", true),
        ),
    )
    
    return make([]byte, requiredSize)
}

// StringBuilderOptimization å­—ç¬¦ä¸²æ„å»ºä¼˜åŒ–
func (ao *AllocationOptimizer) StringBuilderOptimization(
    ctx context.Context,
    parts []string,
) string {
    ctx, span := ao.tracer.Start(ctx, "string_builder")
    defer span.End()
    
    // è®¡ç®—æ€»é•¿åº¦
    totalLen := 0
    for _, part := range parts {
        totalLen += len(part)
    }
    
    // âœ… å¥½: ä½¿ç”¨ strings.Builder å¹¶é¢„åˆ†é…
    var builder strings.Builder
    builder.Grow(totalLen) // é¢„åˆ†é…å®¹é‡
    
    for _, part := range parts {
        builder.WriteString(part)
    }
    
    span.SetAttributes(
        attribute.Int("parts_count", len(parts)),
        attribute.Int("total_length", totalLen),
        attribute.Int("allocations", 1), // åªåˆ†é…ä¸€æ¬¡
    )
    
    return builder.String()
    
    // âŒ å·®: å­—ç¬¦ä¸²è¿æ¥ï¼ˆæ¯æ¬¡éƒ½åˆ†é…æ–°å†…å­˜ï¼‰
    // result := ""
    // for _, part := range parts {
    //     result += part // æ¯æ¬¡è¿æ¥éƒ½åˆ†é…æ–°å†…å­˜
    // }
    // return result
}
```

### 2. å‡å°‘é€ƒé€¸åˆ†æ

```go
package optimization

import (
    "context"

    "go.opentelemetry.io/otel/trace"
)

// EscapeAnalysisOptimizer é€ƒé€¸åˆ†æä¼˜åŒ–å™¨
type EscapeAnalysisOptimizer struct {
    tracer trace.Tracer
}

// StackAllocation æ ˆåˆ†é…ç¤ºä¾‹ï¼ˆä¸é€ƒé€¸ï¼‰
func (ea *EscapeAnalysisOptimizer) StackAllocation(ctx context.Context) int {
    // âœ… å¥½: å€¼ç±»å‹ï¼Œæ ˆåˆ†é…
    var data struct {
        A int
        B int
        C int
    }
    
    data.A = 1
    data.B = 2
    data.C = 3
    
    return data.A + data.B + data.C
}

// HeapAllocation å †åˆ†é…ç¤ºä¾‹ï¼ˆé€ƒé€¸ï¼‰
func (ea *EscapeAnalysisOptimizer) HeapAllocation(ctx context.Context) *int {
    // âŒ å·®: è¿”å›å±€éƒ¨å˜é‡æŒ‡é’ˆï¼Œé€ƒé€¸åˆ°å †
    value := 42
    return &value // é€ƒé€¸
}

// NoEscapeByValue é€šè¿‡å€¼ä¼ é€’é¿å…é€ƒé€¸
func (ea *EscapeAnalysisOptimizer) NoEscapeByValue(data SmallStruct) SmallStruct {
    // âœ… å¥½: å€¼ä¼ é€’å’Œè¿”å›ï¼Œä¸é€ƒé€¸
    data.Value++
    return data
}

// EscapeByPointer é€šè¿‡æŒ‡é’ˆé€ƒé€¸
func (ea *EscapeAnalysisOptimizer) EscapeByPointer(data *SmallStruct) *SmallStruct {
    // âŒ å‚æ•°å’Œè¿”å›å€¼éƒ½æ˜¯æŒ‡é’ˆï¼Œå¯èƒ½é€ƒé€¸
    data.Value++
    return data
}

// SmallStruct å°å‹ç»“æ„ä½“ï¼ˆé€‚åˆå€¼ä¼ é€’ï¼‰
type SmallStruct struct {
    Value int64
    Flag  bool
}

// InterfaceEscape æ¥å£å¯¼è‡´é€ƒé€¸
func (ea *EscapeAnalysisOptimizer) InterfaceEscape() interface{} {
    // âŒ å·®: è¿”å›æ¥å£ï¼Œå¯¼è‡´é€ƒé€¸
    value := 42
    return value // è£…ç®±ï¼Œé€ƒé€¸åˆ°å †
}

// ConcreteTypeNoEscape å…·ä½“ç±»å‹ä¸é€ƒé€¸
func (ea *EscapeAnalysisOptimizer) ConcreteTypeNoEscape() int {
    // âœ… å¥½: è¿”å›å…·ä½“ç±»å‹ï¼Œä¸é€ƒé€¸
    value := 42
    return value
}
```

---

## å¯¹è±¡æ± æ¨¡å¼

### å®Œæ•´çš„å¯¹è±¡æ± å®ç°

```go
package objectpool

import (
    "context"
    "sync"
    "sync/atomic"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
)

// ObjectPool æ³›å‹å¯¹è±¡æ± 
type ObjectPool[T any] struct {
    pool      *sync.Pool
    factory   func() T
    reset     func(*T)
    tracer    trace.Tracer
    meter     metric.Meter
    
    // Metrics
    getCount      atomic.Int64
    putCount      atomic.Int64
    newCount      atomic.Int64
    reuseCount    atomic.Int64
    
    getCounter    metric.Int64Counter
    putCounter    metric.Int64Counter
    reuseRate     metric.Float64ObservableGauge
}

// NewObjectPool åˆ›å»ºå¯¹è±¡æ± 
func NewObjectPool[T any](
    factory func() T,
    reset func(*T),
) (*ObjectPool[T], error) {
    tracer := otel.Tracer("object-pool")
    meter := otel.Meter("object-pool")
    
    op := &ObjectPool[T]{
        factory: factory,
        reset:   reset,
        tracer:  tracer,
        meter:   meter,
    }
    
    op.pool = &sync.Pool{
        New: func() interface{} {
            op.newCount.Add(1)
            return factory()
        },
    }
    
    var err error
    
    // Get counter
    op.getCounter, err = meter.Int64Counter(
        "pool.get.count",
        metric.WithDescription("Object pool get operations"),
    )
    if err != nil {
        return nil, err
    }
    
    // Put counter
    op.putCounter, err = meter.Int64Counter(
        "pool.put.count",
        metric.WithDescription("Object pool put operations"),
    )
    if err != nil {
        return nil, err
    }
    
    // Reuse rate
    op.reuseRate, err = meter.Float64ObservableGauge(
        "pool.reuse.rate",
        metric.WithDescription("Object reuse rate"),
        metric.WithUnit("%"),
        metric.WithFloat64Callback(func(ctx context.Context, observer metric.Float64Observer) error {
            total := float64(op.getCount.Load())
            reused := float64(op.reuseCount.Load())
            
            var rate float64
            if total > 0 {
                rate = (reused / total) * 100
            }
            
            observer.Observe(rate)
            return nil
        }),
    )
    if err != nil {
        return nil, err
    }
    
    return op, nil
}

// Get ä»æ± ä¸­è·å–å¯¹è±¡
func (op *ObjectPool[T]) Get(ctx context.Context) *T {
    ctx, span := op.tracer.Start(ctx, "pool.get")
    defer span.End()
    
    op.getCount.Add(1)
    op.getCounter.Add(ctx, 1)
    
    obj := op.pool.Get().(T)
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯å¤ç”¨çš„å¯¹è±¡
    if op.getCount.Load() > op.newCount.Load() {
        op.reuseCount.Add(1)
        span.SetAttributes(attribute.Bool("reused", true))
    } else {
        span.SetAttributes(attribute.Bool("reused", false))
    }
    
    return &obj
}

// Put å½’è¿˜å¯¹è±¡åˆ°æ± ä¸­
func (op *ObjectPool[T]) Put(ctx context.Context, obj *T) {
    ctx, span := op.tracer.Start(ctx, "pool.put")
    defer span.End()
    
    // é‡ç½®å¯¹è±¡çŠ¶æ€
    if op.reset != nil {
        op.reset(obj)
    }
    
    op.putCount.Add(1)
    op.putCounter.Add(ctx, 1)
    
    op.pool.Put(*obj)
    
    span.AddEvent("object returned to pool")
}

// Stats è·å–ç»Ÿè®¡ä¿¡æ¯
func (op *ObjectPool[T]) Stats() PoolStats {
    total := op.getCount.Load()
    reused := op.reuseCount.Load()
    
    var reuseRate float64
    if total > 0 {
        reuseRate = float64(reused) / float64(total) * 100
    }
    
    return PoolStats{
        GetCount:   total,
        PutCount:   op.putCount.Load(),
        NewCount:   op.newCount.Load(),
        ReuseCount: reused,
        ReuseRate:  reuseRate,
    }
}

// PoolStats æ± ç»Ÿè®¡
type PoolStats struct {
    GetCount   int64
    PutCount   int64
    NewCount   int64
    ReuseCount int64
    ReuseRate  float64
}

// ä½¿ç”¨ç¤ºä¾‹

// SpanDataPool Span æ•°æ®æ± 
var spanDataPool *ObjectPool[SpanData]

func init() {
    var err error
    spanDataPool, err = NewObjectPool(
        // å·¥å‚å‡½æ•°
        func() SpanData {
            return SpanData{
                Attributes: make([]attribute.KeyValue, 0, 20),
                Events:     make([]Event, 0, 5),
            }
        },
        // é‡ç½®å‡½æ•°
        func(data *SpanData) {
            data.Name = ""
            data.Attributes = data.Attributes[:0]
            data.Events = data.Events[:0]
            data.StartTime = time.Time{}
            data.EndTime = time.Time{}
        },
    )
    if err != nil {
        panic(err)
    }
}

type SpanData struct {
    Name       string
    Attributes []attribute.KeyValue
    Events     []Event
    StartTime  time.Time
    EndTime    time.Time
}

type Event struct {
    Name       string
    Timestamp  time.Time
    Attributes []attribute.KeyValue
}

// ProcessWithPool ä½¿ç”¨å¯¹è±¡æ± å¤„ç†
func ProcessWithPool(ctx context.Context) {
    // ä»æ± ä¸­è·å–
    spanData := spanDataPool.Get(ctx)
    defer spanDataPool.Put(ctx, spanData)
    
    // ä½¿ç”¨å¯¹è±¡
    spanData.Name = "operation"
    spanData.StartTime = time.Now()
    // ... å¤„ç†é€»è¾‘
    spanData.EndTime = time.Now()
}
```

---

## GC è°ƒä¼˜

### GC ç›‘æ§å’Œè°ƒä¼˜

```go
package gctuning

import (
    "context"
    "runtime"
    "runtime/debug"
    "sync/atomic"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// GCTuner GC è°ƒä¼˜å™¨
type GCTuner struct {
    meter metric.Meter
    
    // GC Metrics
    gcPauses          metric.Float64Histogram
    gcCount           metric.Int64Counter
    heapAlloc         metric.Int64ObservableGauge
    heapSys           metric.Int64ObservableGauge
    heapIdle          metric.Int64ObservableGauge
    heapInuse         metric.Int64ObservableGauge
    heapReleased      metric.Int64ObservableGauge
    heapObjects       metric.Int64ObservableGauge
    stackInuse        metric.Int64ObservableGauge
    numGC             atomic.Uint32
    numGoroutine      metric.Int64ObservableGauge
}

// NewGCTuner åˆ›å»º GC è°ƒä¼˜å™¨
func NewGCTuner() (*GCTuner, error) {
    meter := otel.Meter("gc-tuner")
    
    tuner := &GCTuner{
        meter: meter,
    }
    
    var err error
    
    // GC æš‚åœæ—¶é—´
    tuner.gcPauses, err = meter.Float64Histogram(
        "go.gc.pause_duration",
        metric.WithDescription("GC pause duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    // GC æ¬¡æ•°
    tuner.gcCount, err = meter.Int64Counter(
        "go.gc.count",
        metric.WithDescription("Number of GC cycles"),
    )
    if err != nil {
        return nil, err
    }
    
    // å †åˆ†é…
    tuner.heapAlloc, err = meter.Int64ObservableGauge(
        "go.memory.heap_alloc",
        metric.WithDescription("Bytes allocated on heap"),
        metric.WithUnit("bytes"),
        metric.WithInt64Callback(tuner.collectHeapAlloc),
    )
    if err != nil {
        return nil, err
    }
    
    // å †ç³»ç»Ÿå†…å­˜
    tuner.heapSys, err = meter.Int64ObservableGauge(
        "go.memory.heap_sys",
        metric.WithDescription("Bytes obtained from system for heap"),
        metric.WithUnit("bytes"),
        metric.WithInt64Callback(tuner.collectHeapSys),
    )
    if err != nil {
        return nil, err
    }
    
    // å †ç©ºé—²
    tuner.heapIdle, err = meter.Int64ObservableGauge(
        "go.memory.heap_idle",
        metric.WithDescription("Bytes in idle spans"),
        metric.WithUnit("bytes"),
        metric.WithInt64Callback(tuner.collectHeapIdle),
    )
    if err != nil {
        return nil, err
    }
    
    // å †ä½¿ç”¨ä¸­
    tuner.heapInuse, err = meter.Int64ObservableGauge(
        "go.memory.heap_inuse",
        metric.WithDescription("Bytes in in-use spans"),
        metric.WithUnit("bytes"),
        metric.WithInt64Callback(tuner.collectHeapInuse),
    )
    if err != nil {
        return nil, err
    }
    
    // å †é‡Šæ”¾
    tuner.heapReleased, err = meter.Int64ObservableGauge(
        "go.memory.heap_released",
        metric.WithDescription("Bytes released to OS"),
        metric.WithUnit("bytes"),
        metric.WithInt64Callback(tuner.collectHeapReleased),
    )
    if err != nil {
        return nil, err
    }
    
    // å †å¯¹è±¡æ•°
    tuner.heapObjects, err = meter.Int64ObservableGauge(
        "go.memory.heap_objects",
        metric.WithDescription("Number of allocated objects"),
        metric.WithInt64Callback(tuner.collectHeapObjects),
    )
    if err != nil {
        return nil, err
    }
    
    // æ ˆä½¿ç”¨
    tuner.stackInuse, err = meter.Int64ObservableGauge(
        "go.memory.stack_inuse",
        metric.WithDescription("Bytes in stack spans"),
        metric.WithUnit("bytes"),
        metric.WithInt64Callback(tuner.collectStackInuse),
    )
    if err != nil {
        return nil, err
    }
    
    // Goroutine æ•°é‡
    tuner.numGoroutine, err = meter.Int64ObservableGauge(
        "go.goroutines.count",
        metric.WithDescription("Number of goroutines"),
        metric.WithInt64Callback(func(ctx context.Context, observer metric.Int64Observer) error {
            observer.Observe(int64(runtime.NumGoroutine()))
            return nil
        }),
    )
    if err != nil {
        return nil, err
    }
    
    return tuner, nil
}

// Monitor å¯åŠ¨ GC ç›‘æ§
func (gt *GCTuner) Monitor(ctx context.Context) {
    go gt.monitorGCPauses(ctx)
}

// monitorGCPauses ç›‘æ§ GC æš‚åœ
func (gt *GCTuner) monitorGCPauses(ctx context.Context) {
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()
    
    var lastNumGC uint32
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            var m runtime.MemStats
            runtime.ReadMemStats(&m)
            
            // æ£€æŸ¥ GC æ¬¡æ•°å˜åŒ–
            if m.NumGC > lastNumGC {
                gcDiff := m.NumGC - lastNumGC
                gt.gcCount.Add(ctx, int64(gcDiff))
                
                // è®°å½•æœ€è¿‘çš„ GC æš‚åœæ—¶é—´
                for i := uint32(0); i < gcDiff && i < 256; i++ {
                    idx := (m.NumGC - 1 - i) % 256
                    pauseNs := m.PauseNs[idx]
                    pauseMs := float64(pauseNs) / 1e6
                    
                    gt.gcPauses.Record(ctx, pauseMs)
                }
                
                lastNumGC = m.NumGC
            }
        }
    }
}

// Callback functions for metrics
func (gt *GCTuner) collectHeapAlloc(ctx context.Context, observer metric.Int64Observer) error {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    observer.Observe(int64(m.HeapAlloc))
    return nil
}

func (gt *GCTuner) collectHeapSys(ctx context.Context, observer metric.Int64Observer) error {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    observer.Observe(int64(m.HeapSys))
    return nil
}

func (gt *GCTuner) collectHeapIdle(ctx context.Context, observer metric.Int64Observer) error {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    observer.Observe(int64(m.HeapIdle))
    return nil
}

func (gt *GCTuner) collectHeapInuse(ctx context.Context, observer metric.Int64Observer) error {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    observer.Observe(int64(m.HeapInuse))
    return nil
}

func (gt *GCTuner) collectHeapReleased(ctx context.Context, observer metric.Int64Observer) error {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    observer.Observe(int64(m.HeapReleased))
    return nil
}

func (gt *GCTuner) collectHeapObjects(ctx context.Context, observer metric.Int64Observer) error {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    observer.Observe(int64(m.HeapObjects))
    return nil
}

func (gt *GCTuner) collectStackInuse(ctx context.Context, observer metric.Int64Observer) error {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    observer.Observe(int64(m.StackInuse))
    return nil
}

// TuneGC è°ƒæ•´ GC å‚æ•°
func (gt *GCTuner) TuneGC(gcPercent int, memoryLimit int64) {
    // è®¾ç½® GC ç™¾åˆ†æ¯”
    // é»˜è®¤ 100: å½“å †å¤§å°å¢é•¿ 100% æ—¶è§¦å‘ GC
    // è®¾ç½®æ›´å¤§å€¼: GC é¢‘ç‡é™ä½ï¼Œå†…å­˜å ç”¨å¢åŠ 
    // è®¾ç½®æ›´å°å€¼: GC é¢‘ç‡å¢åŠ ï¼Œå†…å­˜å ç”¨å‡å°‘
    if gcPercent > 0 {
        debug.SetGCPercent(gcPercent)
    }
    
    // è®¾ç½®å†…å­˜é™åˆ¶ (Go 1.19+)
    if memoryLimit > 0 {
        debug.SetMemoryLimit(memoryLimit)
    }
}

// ForceGC å¼ºåˆ¶è§¦å‘ GC
func (gt *GCTuner) ForceGC(ctx context.Context) {
    runtime.GC()
    
    span := trace.SpanFromContext(ctx)
    span.AddEvent("forced GC",
        trace.WithAttributes(
            attribute.String("reason", "manual_trigger"),
        ),
    )
}

// GetMemStats è·å–å†…å­˜ç»Ÿè®¡
func (gt *GCTuner) GetMemStats() runtime.MemStats {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    return m
}
```

---

## é›¶åˆ†é…æŠ€å·§

```go
package zeroalloc

import (
    "strconv"
    "unsafe"
)

// BytesToString é›¶åˆ†é…å­—èŠ‚è½¬å­—ç¬¦ä¸²ï¼ˆä¸å®‰å…¨ï¼Œä»…ç”¨äºä¸´æ—¶è¯»å–ï¼‰
func BytesToString(b []byte) string {
    // âš ï¸ ä¸å®‰å…¨: å­—èŠ‚åˆ‡ç‰‡å¿…é¡»åœ¨å­—ç¬¦ä¸²ä½¿ç”¨æœŸé—´ä¿æŒä¸å˜
    return *(*string)(unsafe.Pointer(&b))
}

// StringToBytes é›¶åˆ†é…å­—ç¬¦ä¸²è½¬å­—èŠ‚ï¼ˆä¸å®‰å…¨ï¼Œä»…ç”¨äºä¸´æ—¶è¯»å–ï¼‰
func StringToBytes(s string) []byte {
    // âš ï¸ ä¸å®‰å…¨: è¿”å›çš„åˆ‡ç‰‡ä¸èƒ½ä¿®æ”¹
    return *(*[]byte)(unsafe.Pointer(
        &struct {
            string
            Cap int
        }{s, len(s)},
    ))
}

// FastInt64ToString å¿«é€Ÿæ•´æ•°è½¬å­—ç¬¦ä¸²ï¼ˆä½¿ç”¨é¢„åˆ†é…ç¼“å†²åŒºï¼‰
func FastInt64ToString(n int64, buf []byte) string {
    return string(strconv.AppendInt(buf[:0], n, 10))
}

// ReuseSlice å¤ç”¨åˆ‡ç‰‡ï¼ˆé›¶åˆ†é…appendï¼‰
func ReuseSlice(slice []int, value int) []int {
    if cap(slice) > len(slice) {
        // å®¹é‡è¶³å¤Ÿï¼Œç›´æ¥è¿½åŠ 
        return append(slice, value)
    }
    
    // å®¹é‡ä¸è¶³ï¼Œéœ€è¦é‡æ–°åˆ†é…
    newSlice := make([]int, len(slice), (cap(slice)+1)*2)
    copy(newSlice, slice)
    return append(newSlice, value)
}
```

---

## æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†å®Œæ•´çš„ Go å†…å­˜ç®¡ç†ä¸æ€§èƒ½è°ƒä¼˜æ–¹æ¡ˆ:

**æ ¸å¿ƒä¼˜åŒ–**:

- âœ… é¢„åˆ†é…å®¹é‡
- âœ… å¯¹è±¡æ± å¤ç”¨
- âœ… GC è°ƒä¼˜
- âœ… å‡å°‘é€ƒé€¸åˆ†æ
- âœ… é›¶åˆ†é…æŠ€å·§

**Go 1.25.1 ç‰¹æ€§**:

- âœ… æ”¹è¿›çš„ GC ç®—æ³•
- âœ… æ›´å¥½çš„å†…å­˜ç®¡ç†
- âœ… Profile-Guided Optimization (PGO)

**ç›‘æ§æŒ‡æ ‡**:

- âœ… å†…å­˜åˆ†é…
- âœ… GC æš‚åœæ—¶é—´
- âœ… å¯¹è±¡å¤ç”¨ç‡
- âœ… Goroutine æ•°é‡

**ç›¸å…³æ–‡æ¡£**:

- [Goæ€§èƒ½ä¼˜åŒ–ä¸æœ€ä½³å®è·µ](./03_Goæ€§èƒ½ä¼˜åŒ–ä¸æœ€ä½³å®è·µ.md)
- [Goå†…å­˜ç®¡ç†ä¸OTLPæ€§èƒ½ä¼˜åŒ–](./15_Goå†…å­˜ç®¡ç†ä¸OTLPæ€§èƒ½ä¼˜åŒ–.md)

---

**æœ€åæ›´æ–°**: 2025å¹´10æœˆ10æ—¥  
**ç»´æŠ¤è€…**: OTLP Go é›†æˆé¡¹ç›®ç»„
