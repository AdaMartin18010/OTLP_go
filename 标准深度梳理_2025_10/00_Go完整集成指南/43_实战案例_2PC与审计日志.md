# 43. å®æˆ˜æ¡ˆä¾‹ï¼š2PC åˆ†å¸ƒå¼äº‹åŠ¡ä¸å®¡è®¡æ—¥å¿—

## ğŸ“š ç›®å½•

- [1. 2PC ä¸¤é˜¶æ®µæäº¤](#1-2pc-ä¸¤é˜¶æ®µæäº¤)
- [2. å®¡è®¡æ—¥å¿—æœåŠ¡](#2-å®¡è®¡æ—¥å¿—æœåŠ¡)
- [3. å¯¹è´¦æœåŠ¡](#3-å¯¹è´¦æœåŠ¡)
- [4. å®Œæ•´äº¤æ˜“æµç¨‹](#4-å®Œæ•´äº¤æ˜“æµç¨‹)
- [5. ç›‘æ§ä¸å‘Šè­¦](#5-ç›‘æ§ä¸å‘Šè­¦)
- [6. æ€»ç»“](#6-æ€»ç»“)

---

## 1. 2PC ä¸¤é˜¶æ®µæäº¤

### 1.1 2PC åè°ƒå™¨

```go
package twopc

import (
    "context"
    "errors"
    "fmt"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// TwoPhaseCommit ä¸¤é˜¶æ®µæäº¤åè°ƒå™¨
type TwoPhaseCommit struct {
    service     *transaction.Service
    transaction *transaction.Transaction
    tracer      trace.Tracer
    
    // çŠ¶æ€è·Ÿè¸ª
    riskEvaluated     bool
    frozenFrom        bool
    creditedTo        bool
}

// NewTwoPhaseCommit åˆ›å»º 2PC åè°ƒå™¨
func NewTwoPhaseCommit(svc *transaction.Service, tx *transaction.Transaction) *TwoPhaseCommit {
    return &TwoPhaseCommit{
        service:     svc,
        transaction: tx,
        tracer:      otel.Tracer("two-phase-commit"),
    }
}

// Execute æ‰§è¡Œä¸¤é˜¶æ®µæäº¤
func (tpc *TwoPhaseCommit) Execute(ctx context.Context) error {
    ctx, span := tpc.tracer.Start(ctx, "twopc.execute",
        trace.WithAttributes(
            attribute.String("transaction.id", tpc.transaction.ID.String()),
        ),
    )
    defer span.End()
    
    // Phase 1: Prepareï¼ˆå‡†å¤‡é˜¶æ®µï¼‰
    span.AddEvent("phase 1: prepare")
    
    if err := tpc.prepare(ctx); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "prepare failed")
        
        // å›æ»š
        tpc.rollback(ctx)
        
        // æ›´æ–°äº¤æ˜“çŠ¶æ€
        tpc.updateStatus(ctx, "failed")
        
        return err
    }
    
    span.AddEvent("phase 1 completed")
    
    // Phase 2: Commitï¼ˆæäº¤é˜¶æ®µï¼‰
    span.AddEvent("phase 2: commit")
    
    if err := tpc.commit(ctx); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "commit failed")
        
        // å›æ»š
        tpc.rollback(ctx)
        
        // æ›´æ–°äº¤æ˜“çŠ¶æ€
        tpc.updateStatus(ctx, "failed")
        
        return err
    }
    
    span.AddEvent("phase 2 completed")
    
    // æ›´æ–°äº¤æ˜“çŠ¶æ€
    tpc.updateStatus(ctx, "completed")
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// prepare å‡†å¤‡é˜¶æ®µ
func (tpc *TwoPhaseCommit) prepare(ctx context.Context) error {
    ctx, span := tpc.tracer.Start(ctx, "twopc.prepare")
    defer span.End()
    
    // æ›´æ–°äº¤æ˜“çŠ¶æ€ä¸ºå¤„ç†ä¸­
    tpc.updateStatus(ctx, "processing")
    
    // æ­¥éª¤ 1: é£æ§è¯„ä¼°
    span.AddEvent("step 1: risk evaluation")
    
    riskResp, err := tpc.service.riskService.Evaluate(ctx, &risk.EvaluateRequest{
        AccountID:       *tpc.transaction.FromAccountID,
        Amount:          tpc.transaction.Amount,
        TransactionType: tpc.transaction.Type,
        Currency:        tpc.transaction.Currency,
    })
    
    if err != nil {
        return fmt.Errorf("risk evaluation failed: %w", err)
    }
    
    // æ›´æ–°é£æ§ä¿¡æ¯
    tpc.transaction.RiskScore = riskResp.Score
    if riskResp.Approved {
        tpc.transaction.RiskStatus = "approved"
    } else {
        tpc.transaction.RiskStatus = "rejected"
        return errors.New("transaction rejected by risk control")
    }
    
    tpc.service.db.WithContext(ctx).Save(tpc.transaction)
    tpc.riskEvaluated = true
    
    span.AddEvent("risk evaluation passed",
        trace.WithAttributes(
            attribute.Float64("risk.score", riskResp.Score),
            attribute.String("risk.level", riskResp.Level),
        ),
    )
    
    // æ­¥éª¤ 2: å†»ç»“ä»˜æ¬¾è´¦æˆ·èµ„é‡‘
    span.AddEvent("step 2: freeze source account")
    
    if err := tpc.service.accountService.Freeze(ctx, &account.FreezeRequest{
        AccountID:     *tpc.transaction.FromAccountID,
        Amount:        tpc.transaction.Amount,
        TransactionID: tpc.transaction.ID,
    }); err != nil {
        return fmt.Errorf("failed to freeze source account: %w", err)
    }
    
    tpc.frozenFrom = true
    span.AddEvent("source account frozen")
    
    // æ­¥éª¤ 3: éªŒè¯æ”¶æ¬¾è´¦æˆ·æœ‰æ•ˆæ€§
    span.AddEvent("step 3: validate destination account")
    
    toAccount, err := tpc.service.accountService.GetAccount(ctx, &account.GetAccountRequest{
        AccountID: *tpc.transaction.ToAccountID,
    })
    
    if err != nil {
        return fmt.Errorf("destination account not found: %w", err)
    }
    
    if toAccount.Status != "active" {
        return errors.New("destination account is not active")
    }
    
    span.AddEvent("destination account validated")
    
    // æ‰€æœ‰å‡†å¤‡æ­¥éª¤å®Œæˆ
    return nil
}

// commit æäº¤é˜¶æ®µ
func (tpc *TwoPhaseCommit) commit(ctx context.Context) error {
    ctx, span := tpc.tracer.Start(ctx, "twopc.commit")
    defer span.End()
    
    // æ­¥éª¤ 1: æ‰£æ¬¾
    span.AddEvent("step 1: debit source account")
    
    if err := tpc.service.accountService.Debit(ctx, &account.DebitRequest{
        AccountID:     *tpc.transaction.FromAccountID,
        Amount:        tpc.transaction.Amount,
        TransactionID: tpc.transaction.ID,
    }); err != nil {
        return fmt.Errorf("failed to debit source account: %w", err)
    }
    
    span.AddEvent("source account debited")
    
    // æ­¥éª¤ 2: è§£å†»èµ„é‡‘ï¼ˆå› ä¸ºå·²æ‰£æ¬¾ï¼‰
    span.AddEvent("step 2: unfreeze source account")
    
    if err := tpc.service.accountService.Unfreeze(ctx, &account.UnfreezeRequest{
        AccountID:     *tpc.transaction.FromAccountID,
        Amount:        tpc.transaction.Amount,
        TransactionID: tpc.transaction.ID,
    }); err != nil {
        // è¿™é‡Œä¸è¿”å›é”™è¯¯ï¼Œå› ä¸ºæ‰£æ¬¾å·²å®Œæˆ
        span.AddEvent("warning: unfreeze failed",
            trace.WithAttributes(attribute.String("error", err.Error())),
        )
    }
    
    // æ­¥éª¤ 3: å­˜æ¬¾åˆ°æ”¶æ¬¾è´¦æˆ·
    span.AddEvent("step 3: credit destination account")
    
    if err := tpc.service.accountService.Credit(ctx, &account.CreditRequest{
        AccountID:     *tpc.transaction.ToAccountID,
        Amount:        tpc.transaction.Amount,
        TransactionID: tpc.transaction.ID,
    }); err != nil {
        // ä¸¥é‡é”™è¯¯ï¼šæ‰£æ¬¾å·²å®Œæˆä½†å­˜æ¬¾å¤±è´¥ï¼Œéœ€è¦äººå·¥ä»‹å…¥
        span.RecordError(err)
        span.AddEvent("CRITICAL: credit failed after debit succeeded")
        
        // è®°å½•åˆ°å®¡è®¡æ—¥å¿—
        tpc.service.auditService.LogCriticalError(ctx, &audit.CriticalErrorEvent{
            TransactionID: tpc.transaction.ID,
            Type:          "debit_credit_mismatch",
            Message:       "Debit succeeded but credit failed",
            Error:         err.Error(),
        })
        
        return fmt.Errorf("critical error: credit failed: %w", err)
    }
    
    tpc.creditedTo = true
    span.AddEvent("destination account credited")
    
    // æ­¥éª¤ 4: è®°å½•å®¡è®¡æ—¥å¿—
    span.AddEvent("step 4: audit logging")
    
    tpc.service.auditService.LogTransactionCompleted(ctx, &audit.TransactionCompletedEvent{
        TransactionID:     tpc.transaction.ID,
        TransactionNumber: tpc.transaction.TransactionNumber,
        FromAccountID:     *tpc.transaction.FromAccountID,
        ToAccountID:       *tpc.transaction.ToAccountID,
        Amount:            tpc.transaction.Amount,
        Currency:          tpc.transaction.Currency,
        RiskScore:         tpc.transaction.RiskScore,
        CompletedAt:       time.Now(),
    })
    
    span.AddEvent("audit log recorded")
    
    return nil
}

// rollback å›æ»šæ“ä½œ
func (tpc *TwoPhaseCommit) rollback(ctx context.Context) {
    ctx, span := tpc.tracer.Start(ctx, "twopc.rollback")
    defer span.End()
    
    span.AddEvent("starting rollback")
    
    // å›æ»šé¡ºåºï¼šä¸æäº¤ç›¸å
    
    // å¦‚æœå·²å­˜æ¬¾ï¼Œå›æ»šå­˜æ¬¾ï¼ˆä¸å¤ªå¯èƒ½å‘ç”Ÿï¼Œå› ä¸ºå­˜æ¬¾å¤±è´¥ä¼šè¢«æ ‡è®°ä¸ºä¸¥é‡é”™è¯¯ï¼‰
    if tpc.creditedTo {
        span.AddEvent("rollback: debiting destination account")
        
        tpc.service.accountService.Debit(ctx, &account.DebitRequest{
            AccountID:     *tpc.transaction.ToAccountID,
            Amount:        tpc.transaction.Amount,
            TransactionID: tpc.transaction.ID,
        })
    }
    
    // å¦‚æœå·²å†»ç»“ï¼Œè§£å†»èµ„é‡‘
    if tpc.frozenFrom {
        span.AddEvent("rollback: unfreezing source account")
        
        tpc.service.accountService.Unfreeze(ctx, &account.UnfreezeRequest{
            AccountID:     *tpc.transaction.FromAccountID,
            Amount:        tpc.transaction.Amount,
            TransactionID: tpc.transaction.ID,
        })
    }
    
    // è®°å½•å›æ»šåˆ°å®¡è®¡æ—¥å¿—
    tpc.service.auditService.LogTransactionRolledBack(ctx, &audit.TransactionRolledBackEvent{
        TransactionID:     tpc.transaction.ID,
        TransactionNumber: tpc.transaction.TransactionNumber,
        RolledBackAt:      time.Now(),
    })
    
    span.AddEvent("rollback completed")
}

// updateStatus æ›´æ–°äº¤æ˜“çŠ¶æ€
func (tpc *TwoPhaseCommit) updateStatus(ctx context.Context, status string) {
    tpc.transaction.Status = status
    
    if status == "completed" {
        now := time.Now()
        tpc.transaction.CompletedAt = &now
    }
    
    tpc.service.db.WithContext(ctx).Save(tpc.transaction)
}
```

### 1.2 2PC æµç¨‹å›¾

```
Phase 1: Prepare
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                         â”‚
â”‚  1. é£æ§è¯„ä¼°     â”€â”€â”€â”€â”€â”€â”€â”€â–º é€šè¿‡/æ‹’ç»                      â”‚
â”‚                                                         â”‚
â”‚  2. å†»ç»“èµ„é‡‘     â”€â”€â”€â”€â”€â”€â”€â”€â–º æˆåŠŸ/å¤±è´¥                      â”‚
â”‚                                                         â”‚
â”‚  3. éªŒè¯æ”¶æ¬¾è´¦æˆ·  â”€â”€â”€â”€â”€â”€â”€â”€â–º æœ‰æ•ˆ/æ— æ•ˆ                      â”‚
â”‚                                                         â”‚
â”‚  ä»»ä¸€æ­¥éª¤å¤±è´¥ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Rollback                       â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â”‚ æ‰€æœ‰æ­¥éª¤æˆåŠŸ
                           â–¼
Phase 2: Commit
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                         â”‚
â”‚  1. æ‰£æ¬¾         â”€â”€â”€â”€â”€â”€â”€â”€â–º æˆåŠŸ/å¤±è´¥ â”€â”€â–º å¤±è´¥åˆ™ Rollback   â”‚
â”‚                                                         â”‚
â”‚  2. è§£å†»         â”€â”€â”€â”€â”€â”€â”€â”€â–º (Best Effort)                â”‚
â”‚                                                         â”‚
â”‚  3. å­˜æ¬¾         â”€â”€â”€â”€â”€â”€â”€â”€â–º æˆåŠŸ/å¤±è´¥ â”€â”€â–º å¤±è´¥è®°å½•ä¸¥é‡é”™è¯¯   â”‚
â”‚                                                         â”‚
â”‚  4. å®¡è®¡æ—¥å¿—      â”€â”€â”€â”€â”€â”€â”€â”€â–º è®°å½•å®Œæˆ                      â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. å®¡è®¡æ—¥å¿—æœåŠ¡

### 2.1 å®¡è®¡æ—¥å¿—æ¨¡å‹

```go
package audit

import (
    "context"
    "encoding/json"
    "time"
    
    "github.com/google/uuid"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
    "gorm.io/gorm"
)

// AuditLog å®¡è®¡æ—¥å¿—
type AuditLog struct {
    ID            uuid.UUID  `gorm:"type:uuid;primary_key" json:"id"`
    EventType     string     `gorm:"not null;index" json:"event_type"`
    EntityType    string     `gorm:"not null;index" json:"entity_type"` // transaction, account, user
    EntityID      uuid.UUID  `gorm:"type:uuid;not null;index" json:"entity_id"`
    Action        string     `gorm:"not null" json:"action"` // created, updated, deleted, completed, failed
    ActorID       *uuid.UUID `gorm:"type:uuid;index" json:"actor_id,omitempty"`
    ActorType     string     `json:"actor_type,omitempty"` // user, system, service
    TraceID       string     `gorm:"not null;index" json:"trace_id"`
    SpanID        string     `gorm:"not null" json:"span_id"`
    Payload       string     `gorm:"type:jsonb" json:"payload"`
    Severity      string     `gorm:"not null;index" json:"severity"` // info, warning, error, critical
    IPAddress     string     `json:"ip_address,omitempty"`
    UserAgent     string     `json:"user_agent,omitempty"`
    CreatedAt     time.Time  `gorm:"index" json:"created_at"`
}

// BeforeCreate Hook
func (al *AuditLog) BeforeCreate(tx *gorm.DB) error {
    if al.ID == uuid.Nil {
        al.ID = uuid.New()
    }
    return nil
}
```

### 2.2 å®¡è®¡æ—¥å¿—æœåŠ¡å®ç°

```go
package audit

import (
    "context"
    "encoding/json"
    
    "github.com/shopspring/decimal"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
    "gorm.io/gorm"
)

// Service å®¡è®¡æ—¥å¿—æœåŠ¡
type Service struct {
    db     *gorm.DB
    tracer trace.Tracer
}

// NewService åˆ›å»ºå®¡è®¡æ—¥å¿—æœåŠ¡
func NewService(db *gorm.DB) *Service {
    return &Service{
        db:     db,
        tracer: otel.Tracer("audit-service"),
    }
}

// Log è®°å½•å®¡è®¡æ—¥å¿—
func (s *Service) Log(ctx context.Context, log *AuditLog) error {
    ctx, span := s.tracer.Start(ctx, "audit.log",
        trace.WithAttributes(
            attribute.String("event_type", log.EventType),
            attribute.String("entity_type", log.EntityType),
            attribute.String("entity_id", log.EntityID.String()),
        ),
    )
    defer span.End()
    
    // ä» Span Context æå– TraceID å’Œ SpanID
    spanContext := span.SpanContext()
    log.TraceID = spanContext.TraceID().String()
    log.SpanID = spanContext.SpanID().String()
    
    // ä¿å­˜åˆ°æ•°æ®åº“
    if err := s.db.WithContext(ctx).Create(log).Error; err != nil {
        span.RecordError(err)
        return err
    }
    
    return nil
}

// LogTransactionCompleted è®°å½•äº¤æ˜“å®Œæˆ
func (s *Service) LogTransactionCompleted(ctx context.Context, event *TransactionCompletedEvent) error {
    payload, _ := json.Marshal(event)
    
    return s.Log(ctx, &AuditLog{
        EventType:  "transaction.completed",
        EntityType: "transaction",
        EntityID:   event.TransactionID,
        Action:     "completed",
        ActorType:  "system",
        Payload:    string(payload),
        Severity:   "info",
    })
}

// LogTransactionRolledBack è®°å½•äº¤æ˜“å›æ»š
func (s *Service) LogTransactionRolledBack(ctx context.Context, event *TransactionRolledBackEvent) error {
    payload, _ := json.Marshal(event)
    
    return s.Log(ctx, &AuditLog{
        EventType:  "transaction.rolled_back",
        EntityType: "transaction",
        EntityID:   event.TransactionID,
        Action:     "rolled_back",
        ActorType:  "system",
        Payload:    string(payload),
        Severity:   "warning",
    })
}

// LogCriticalError è®°å½•ä¸¥é‡é”™è¯¯
func (s *Service) LogCriticalError(ctx context.Context, event *CriticalErrorEvent) error {
    payload, _ := json.Marshal(event)
    
    return s.Log(ctx, &AuditLog{
        EventType:  "critical.error",
        EntityType: "transaction",
        EntityID:   event.TransactionID,
        Action:     "error",
        ActorType:  "system",
        Payload:    string(payload),
        Severity:   "critical",
    })
}

// QueryLogs æŸ¥è¯¢å®¡è®¡æ—¥å¿—
func (s *Service) QueryLogs(ctx context.Context, req *QueryLogsRequest) ([]*AuditLog, int64, error) {
    ctx, span := s.tracer.Start(ctx, "audit.query_logs")
    defer span.End()
    
    query := s.db.WithContext(ctx).Model(&AuditLog{})
    
    // æ¡ä»¶è¿‡æ»¤
    if req.EntityType != "" {
        query = query.Where("entity_type = ?", req.EntityType)
    }
    
    if req.EntityID != uuid.Nil {
        query = query.Where("entity_id = ?", req.EntityID)
    }
    
    if req.EventType != "" {
        query = query.Where("event_type = ?", req.EventType)
    }
    
    if req.Severity != "" {
        query = query.Where("severity = ?", req.Severity)
    }
    
    if !req.StartTime.IsZero() {
        query = query.Where("created_at >= ?", req.StartTime)
    }
    
    if !req.EndTime.IsZero() {
        query = query.Where("created_at <= ?", req.EndTime)
    }
    
    // è·å–æ€»æ•°
    var total int64
    if err := query.Count(&total).Error; err != nil {
        span.RecordError(err)
        return nil, 0, err
    }
    
    // åˆ†é¡µæŸ¥è¯¢
    var logs []*AuditLog
    offset := (req.Page - 1) * req.PageSize
    if err := query.Offset(offset).Limit(req.PageSize).
        Order("created_at DESC").
        Find(&logs).Error; err != nil {
        span.RecordError(err)
        return nil, 0, err
    }
    
    span.SetAttributes(
        attribute.Int64("result.total", total),
        attribute.Int("result.count", len(logs)),
    )
    
    return logs, total, nil
}

// Event ç±»å‹å®šä¹‰

// TransactionCompletedEvent äº¤æ˜“å®Œæˆäº‹ä»¶
type TransactionCompletedEvent struct {
    TransactionID     uuid.UUID       `json:"transaction_id"`
    TransactionNumber string          `json:"transaction_number"`
    FromAccountID     uuid.UUID       `json:"from_account_id"`
    ToAccountID       uuid.UUID       `json:"to_account_id"`
    Amount            decimal.Decimal `json:"amount"`
    Currency          string          `json:"currency"`
    RiskScore         float64         `json:"risk_score"`
    CompletedAt       time.Time       `json:"completed_at"`
}

// TransactionRolledBackEvent äº¤æ˜“å›æ»šäº‹ä»¶
type TransactionRolledBackEvent struct {
    TransactionID     uuid.UUID `json:"transaction_id"`
    TransactionNumber string    `json:"transaction_number"`
    RolledBackAt      time.Time `json:"rolled_back_at"`
}

// CriticalErrorEvent ä¸¥é‡é”™è¯¯äº‹ä»¶
type CriticalErrorEvent struct {
    TransactionID uuid.UUID `json:"transaction_id"`
    Type          string    `json:"type"`
    Message       string    `json:"message"`
    Error         string    `json:"error"`
}

// QueryLogsRequest æŸ¥è¯¢å®¡è®¡æ—¥å¿—è¯·æ±‚
type QueryLogsRequest struct {
    EntityType string    `form:"entity_type"`
    EntityID   uuid.UUID `form:"entity_id"`
    EventType  string    `form:"event_type"`
    Severity   string    `form:"severity"`
    StartTime  time.Time `form:"start_time"`
    EndTime    time.Time `form:"end_time"`
    Page       int       `form:"page" binding:"required,min=1"`
    PageSize   int       `form:"page_size" binding:"required,min=1,max=100"`
}
```

---

## 3. å¯¹è´¦æœåŠ¡

### 3.1 å¯¹è´¦ä»»åŠ¡

```go
package reconciliation

import (
    "context"
    "fmt"
    "time"
    
    "github.com/shopspring/decimal"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
    "gorm.io/gorm"
)

// Service å¯¹è´¦æœåŠ¡
type Service struct {
    db     *gorm.DB
    tracer trace.Tracer
}

// NewService åˆ›å»ºå¯¹è´¦æœåŠ¡
func NewService(db *gorm.DB) *Service {
    return &Service{
        db:     db,
        tracer: otel.Tracer("reconciliation-service"),
    }
}

// ReconcileDaily æ¯æ—¥å¯¹è´¦
func (s *Service) ReconcileDaily(ctx context.Context, date time.Time) (*ReconciliationReport, error) {
    ctx, span := s.tracer.Start(ctx, "reconciliation.daily",
        trace.WithAttributes(
            attribute.String("date", date.Format("2006-01-02")),
        ),
    )
    defer span.End()
    
    report := &ReconciliationReport{
        Date:       date,
        StartedAt:  time.Now(),
        Status:     "in_progress",
    }
    
    // 1. å¯¹è´¦äº¤æ˜“æµæ°´
    span.AddEvent("reconciling transactions")
    
    txResult, err := s.reconcileTransactions(ctx, date)
    if err != nil {
        span.RecordError(err)
        report.Status = "failed"
        report.Error = err.Error()
        return report, err
    }
    
    report.TransactionCount = txResult.TotalCount
    report.TransactionAmount = txResult.TotalAmount
    
    span.AddEvent("transactions reconciled",
        trace.WithAttributes(
            attribute.Int64("count", txResult.TotalCount),
            attribute.String("amount", txResult.TotalAmount.String()),
        ),
    )
    
    // 2. å¯¹è´¦è´¦æˆ·ä½™é¢
    span.AddEvent("reconciling account balances")
    
    balanceResult, err := s.reconcileBalances(ctx, date)
    if err != nil {
        span.RecordError(err)
        report.Status = "failed"
        report.Error = err.Error()
        return report, err
    }
    
    report.AccountCount = balanceResult.TotalAccounts
    report.Discrepancies = balanceResult.Discrepancies
    
    span.AddEvent("balances reconciled",
        trace.WithAttributes(
            attribute.Int64("accounts", balanceResult.TotalAccounts),
            attribute.Int("discrepancies", len(balanceResult.Discrepancies)),
        ),
    )
    
    // 3. ç”ŸæˆæŠ¥å‘Š
    report.CompletedAt = time.Now()
    
    if len(report.Discrepancies) > 0 {
        report.Status = "completed_with_errors"
        span.SetStatus(codes.Error, "discrepancies found")
    } else {
        report.Status = "completed"
        span.SetStatus(codes.Ok, "")
    }
    
    // ä¿å­˜æŠ¥å‘Š
    if err := s.db.WithContext(ctx).Create(report).Error; err != nil {
        span.RecordError(err)
        return nil, err
    }
    
    return report, nil
}

// reconcileTransactions å¯¹è´¦äº¤æ˜“æµæ°´
func (s *Service) reconcileTransactions(ctx context.Context, date time.Time) (*TransactionReconciliationResult, error) {
    ctx, span := s.tracer.Start(ctx, "reconciliation.transactions")
    defer span.End()
    
    startOfDay := time.Date(date.Year(), date.Month(), date.Day(), 0, 0, 0, 0, date.Location())
    endOfDay := startOfDay.Add(24 * time.Hour)
    
    // ç»Ÿè®¡å½“å¤©å®Œæˆçš„äº¤æ˜“
    var result struct {
        Count  int64
        Amount decimal.Decimal
    }
    
    err := s.db.WithContext(ctx).
        Model(&transaction.Transaction{}).
        Select("COUNT(*) as count, COALESCE(SUM(amount), 0) as amount").
        Where("status = ? AND completed_at >= ? AND completed_at < ?",
            "completed", startOfDay, endOfDay).
        Scan(&result).Error
    
    if err != nil {
        span.RecordError(err)
        return nil, err
    }
    
    return &TransactionReconciliationResult{
        TotalCount:  result.Count,
        TotalAmount: result.Amount,
    }, nil
}

// reconcileBalances å¯¹è´¦è´¦æˆ·ä½™é¢
func (s *Service) reconcileBalances(ctx context.Context, date time.Time) (*BalanceReconciliationResult, error) {
    ctx, span := s.tracer.Start(ctx, "reconciliation.balances")
    defer span.End()
    
    // è·å–æ‰€æœ‰æ´»è·ƒè´¦æˆ·
    var accounts []account.Account
    if err := s.db.WithContext(ctx).
        Where("status = ?", "active").
        Find(&accounts).Error; err != nil {
        span.RecordError(err)
        return nil, err
    }
    
    var discrepancies []Discrepancy
    
    // éªŒè¯æ¯ä¸ªè´¦æˆ·
    for _, acc := range accounts {
        // è®¡ç®—è´¦æˆ·çš„é¢„æœŸä½™é¢
        expectedBalance, err := s.calculateExpectedBalance(ctx, acc.ID)
        if err != nil {
            span.RecordError(err)
            continue
        }
        
        // æ¯”è¾ƒå®é™…ä½™é¢å’Œé¢„æœŸä½™é¢
        if !acc.Balance.Equal(expectedBalance) {
            discrepancy := Discrepancy{
                AccountID:       acc.ID,
                AccountNumber:   acc.AccountNumber,
                ExpectedBalance: expectedBalance,
                ActualBalance:   acc.Balance,
                Difference:      acc.Balance.Sub(expectedBalance),
                DetectedAt:      time.Now(),
            }
            
            discrepancies = append(discrepancies, discrepancy)
            
            span.AddEvent("discrepancy detected",
                trace.WithAttributes(
                    attribute.String("account.id", acc.ID.String()),
                    attribute.String("difference", discrepancy.Difference.String()),
                ),
            )
        }
    }
    
    return &BalanceReconciliationResult{
        TotalAccounts:  int64(len(accounts)),
        Discrepancies: discrepancies,
    }, nil
}

// calculateExpectedBalance è®¡ç®—é¢„æœŸä½™é¢
func (s *Service) calculateExpectedBalance(ctx context.Context, accountID uuid.UUID) (decimal.Decimal, error) {
    // è·å–æ‰€æœ‰è´¦æˆ·æ“ä½œ
    var operations []account.AccountOperation
    if err := s.db.WithContext(ctx).
        Where("account_id = ? AND status = ?", accountID, "completed").
        Order("created_at ASC").
        Find(&operations).Error; err != nil {
        return decimal.Zero, err
    }
    
    // è®¡ç®—ä½™é¢ï¼ˆå‡è®¾åˆå§‹ä½™é¢ä¸º0ï¼‰
    balance := decimal.Zero
    
    for _, op := range operations {
        switch op.OperationType {
        case "credit":
            balance = balance.Add(op.Amount)
        case "debit":
            balance = balance.Sub(op.Amount)
        }
    }
    
    return balance, nil
}

// ReconciliationReport å¯¹è´¦æŠ¥å‘Š
type ReconciliationReport struct {
    ID                 uuid.UUID     `gorm:"type:uuid;primary_key" json:"id"`
    Date               time.Time     `gorm:"not null;uniqueIndex" json:"date"`
    Status             string        `gorm:"not null" json:"status"` // in_progress, completed, completed_with_errors, failed
    TransactionCount   int64         `gorm:"not null" json:"transaction_count"`
    TransactionAmount  decimal.Decimal `gorm:"type:decimal(20,2);not null" json:"transaction_amount"`
    AccountCount       int64         `gorm:"not null" json:"account_count"`
    DiscrepancyCount   int           `gorm:"not null;default:0" json:"discrepancy_count"`
    Discrepancies      []Discrepancy `gorm:"-" json:"discrepancies,omitempty"`
    Error              string        `json:"error,omitempty"`
    StartedAt          time.Time     `gorm:"not null" json:"started_at"`
    CompletedAt        time.Time     `json:"completed_at,omitempty"`
}

// Discrepancy å·®å¼‚
type Discrepancy struct {
    AccountID       uuid.UUID       `json:"account_id"`
    AccountNumber   string          `json:"account_number"`
    ExpectedBalance decimal.Decimal `json:"expected_balance"`
    ActualBalance   decimal.Decimal `json:"actual_balance"`
    Difference      decimal.Decimal `json:"difference"`
    DetectedAt      time.Time       `json:"detected_at"`
}

// TransactionReconciliationResult äº¤æ˜“å¯¹è´¦ç»“æœ
type TransactionReconciliationResult struct {
    TotalCount  int64
    TotalAmount decimal.Decimal
}

// BalanceReconciliationResult ä½™é¢å¯¹è´¦ç»“æœ
type BalanceReconciliationResult struct {
    TotalAccounts  int64
    Discrepancies []Discrepancy
}

// BeforeCreate Hook
func (rr *ReconciliationReport) BeforeCreate(tx *gorm.DB) error {
    if rr.ID == uuid.Nil {
        rr.ID = uuid.New()
    }
    return nil
}
```

### 3.2 å®šæ—¶å¯¹è´¦ä»»åŠ¡

```go
package reconciliation

import (
    "context"
    "log"
    "time"
)

// ScheduleDailyReconciliation è°ƒåº¦æ¯æ—¥å¯¹è´¦ä»»åŠ¡
func ScheduleDailyReconciliation(svc *Service) {
    ticker := time.NewTicker(24 * time.Hour)
    defer ticker.Stop()
    
    // æ¯å¤©å‡Œæ™¨ 2 ç‚¹æ‰§è¡Œ
    for {
        now := time.Now()
        next := time.Date(now.Year(), now.Month(), now.Day()+1, 2, 0, 0, 0, now.Location())
        duration := next.Sub(now)
        
        time.Sleep(duration)
        
        // æ‰§è¡Œå¯¹è´¦ï¼ˆå¯¹å‰ä¸€å¤©çš„æ•°æ®ï¼‰
        yesterday := now.AddDate(0, 0, -1)
        
        ctx := context.Background()
        report, err := svc.ReconcileDaily(ctx, yesterday)
        
        if err != nil {
            log.Printf("Reconciliation failed for %s: %v", yesterday.Format("2006-01-02"), err)
            continue
        }
        
        log.Printf("Reconciliation completed for %s: %d transactions, %d discrepancies",
            yesterday.Format("2006-01-02"),
            report.TransactionCount,
            len(report.Discrepancies),
        )
        
        // å¦‚æœæœ‰å·®å¼‚ï¼Œå‘é€å‘Šè­¦
        if len(report.Discrepancies) > 0 {
            // TODO: å‘é€å‘Šè­¦é€šçŸ¥
            log.Printf("WARNING: Found %d discrepancies", len(report.Discrepancies))
        }
    }
}
```

---

## 4. å®Œæ•´äº¤æ˜“æµç¨‹

### 4.1 æµç¨‹å›¾

```
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚  Transfer Request   â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â–¼
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚ Create Transaction  â”‚
                        â”‚    (Status=pending) â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â–¼
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚   Start 2PC         â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                             â”‚
                    â–¼                             â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Phase 1: Prepare  â”‚       â”‚   Phase 2: Commit   â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚ 1. Risk Evaluation  â”‚       â”‚ 1. Debit Source     â”‚
        â”‚ 2. Freeze Funds     â”‚â”€â”€â”€â”€â”€â”€â”€â”‚ 2. Unfreeze         â”‚
        â”‚ 3. Validate Dest    â”‚  Pass â”‚ 3. Credit Dest      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚ 4. Audit Log        â”‚
                   â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚ Fail                        â”‚
                   â–¼                             â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚      Rollback       â”‚       â”‚ Update Status       â”‚
        â”‚                     â”‚       â”‚ (Status=completed)  â”‚
        â”‚ - Unfreeze Funds    â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚ - Audit Log         â”‚
        â”‚ - Update Status     â”‚
        â”‚   (Status=failed)   â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 å®Œæ•´è¿½è¸ªç¤ºä¾‹

ä½¿ç”¨ OpenTelemetry è¿½è¸ªæ•´ä¸ªäº¤æ˜“æµç¨‹ï¼Œå¯ä»¥çœ‹åˆ°ï¼š

```
Trace: transfer-txn-abc123
â”œâ”€ transaction.transfer (120ms)
â”‚  â”œâ”€ twopc.execute (115ms)
â”‚  â”‚  â”œâ”€ twopc.prepare (45ms)
â”‚  â”‚  â”‚  â”œâ”€ risk.evaluate (15ms)
â”‚  â”‚  â”‚  â”‚  â””â”€ risk.check_frequency (5ms)
â”‚  â”‚  â”‚  â”œâ”€ account.freeze (20ms)
â”‚  â”‚  â”‚  â”‚  â””â”€ db.transaction (18ms)
â”‚  â”‚  â”‚  â””â”€ account.get (10ms)
â”‚  â”‚  â”‚     â””â”€ db.query (8ms)
â”‚  â”‚  â””â”€ twopc.commit (70ms)
â”‚  â”‚     â”œâ”€ account.debit (25ms)
â”‚  â”‚     â”‚  â””â”€ db.transaction (23ms)
â”‚  â”‚     â”œâ”€ account.unfreeze (20ms)
â”‚  â”‚     â”‚  â””â”€ db.transaction (18ms)
â”‚  â”‚     â”œâ”€ account.credit (20ms)
â”‚  â”‚     â”‚  â””â”€ db.transaction (18ms)
â”‚  â”‚     â””â”€ audit.log (5ms)
â”‚  â”‚        â””â”€ db.insert (3ms)
â”‚  â””â”€ transaction.update_status (5ms)
â”‚     â””â”€ db.update (3ms)
```

---

## 5. ç›‘æ§ä¸å‘Šè­¦

### 5.1 å…³é”®æŒ‡æ ‡

```yaml
# Prometheus å‘Šè­¦è§„åˆ™
groups:
  - name: financial_system
    interval: 30s
    rules:
      # äº¤æ˜“å¤±è´¥ç‡
      - alert: HighTransactionFailureRate
        expr: |
          (
            rate(transaction_count{status="failed"}[5m]) /
            rate(transaction_count[5m])
          ) > 0.05
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High transaction failure rate"
          description: "Transaction failure rate is {{ $value | humanizePercentage }}"
      
      # é£æ§æ‹’ç»ç‡
      - alert: HighRiskRejectionRate
        expr: |
          (
            rate(transaction_count{risk_status="rejected"}[5m]) /
            rate(transaction_count[5m])
          ) > 0.10
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High risk rejection rate"
      
      # è´¦æˆ·ä½™é¢å¼‚å¸¸
      - alert: NegativeAccountBalance
        expr: account_balance < 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Negative account balance detected"
          description: "Account {{ $labels.account_id }} has negative balance"
      
      # å¯¹è´¦å·®å¼‚
      - alert: ReconciliationDiscrepancy
        expr: reconciliation_discrepancy_count > 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Reconciliation discrepancies found"
          description: "Found {{ $value }} discrepancies in reconciliation"
      
      # äº¤æ˜“å»¶è¿Ÿ
      - alert: HighTransactionLatency
        expr: |
          histogram_quantile(0.95,
            rate(transaction_duration_bucket[5m])
          ) > 1000
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High transaction latency"
          description: "P95 latency is {{ $value }}ms"
```

### 5.2 Grafana é¢æ¿

```json
{
  "dashboard": {
    "title": "Financial System Overview",
    "panels": [
      {
        "title": "Transaction Volume",
        "targets": [
          {
            "expr": "sum(rate(transaction_count[1m])) by (type, status)"
          }
        ]
      },
      {
        "title": "Transaction Latency",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(transaction_duration_bucket[5m]))"
          }
        ]
      },
      {
        "title": "Account Balances",
        "targets": [
          {
            "expr": "sum(account_balance) by (account_type)"
          }
        ]
      },
      {
        "title": "Risk Score Distribution",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(risk_score_bucket[5m]))"
          }
        ]
      }
    ]
  }
}
```

---

## 6. æ€»ç»“

æœ¬æ–‡æ¡£å±•ç¤ºäº†é‡‘èäº¤æ˜“ç³»ç»Ÿçš„å®Œæ•´å®ç°ï¼ŒåŒ…æ‹¬ï¼š

### æ ¸å¿ƒç‰¹æ€§

âœ… **2PC ä¸¤é˜¶æ®µæäº¤**
- Prepare é˜¶æ®µï¼šé£æ§ã€å†»ç»“ã€éªŒè¯
- Commit é˜¶æ®µï¼šæ‰£æ¬¾ã€å­˜æ¬¾ã€å®¡è®¡
- Rollback æœºåˆ¶ï¼šå®Œæ•´å›æ»š

âœ… **å®¡è®¡æ—¥å¿—**
- å®Œæ•´çš„äº‹ä»¶è®°å½•
- TraceID/SpanID å…³è”
- å¯æŸ¥è¯¢ã€å¯è¿½æº¯

âœ… **å¯¹è´¦æœºåˆ¶**
- æ¯æ—¥è‡ªåŠ¨å¯¹è´¦
- å·®å¼‚æ£€æµ‹
- å‘Šè­¦é€šçŸ¥

âœ… **é£é™©æ§åˆ¶**
- å¤šç»´åº¦è¯„ä¼°
- å®æ—¶æ‹¦æˆª
- å¯é…ç½®è§„åˆ™

âœ… **å®Œæ•´çš„å¯è§‚æµ‹æ€§**
- åˆ†å¸ƒå¼è¿½è¸ªï¼ˆå®Œæ•´çš„è°ƒç”¨é“¾ï¼‰
- ä¸šåŠ¡æŒ‡æ ‡ï¼ˆäº¤æ˜“é‡ã€æˆåŠŸç‡ã€å»¶è¿Ÿï¼‰
- å®¡è®¡æ—¥å¿—ï¼ˆåˆè§„æ€§ï¼‰

### æŠ€æœ¯äº®ç‚¹

- **ç²¾ç¡®çš„è´§å¸è®¡ç®—**: ä½¿ç”¨ `decimal.Decimal`
- **ä¹è§‚é” + æ‚²è§‚é”**: é˜²æ­¢å¹¶å‘å†²çª
- **å¼ºä¸€è‡´æ€§**: 2PC ä¿è¯æ•°æ®ä¸€è‡´
- **å®¡è®¡è¿½è¸ª**: å®Œæ•´çš„æ“ä½œå†å²
- **å®æ—¶å¯¹è´¦**: åŠæ—¶å‘ç°å¼‚å¸¸

### ç›¸å…³æ–‡æ¡£

- [42_å®æˆ˜æ¡ˆä¾‹_é‡‘èäº¤æ˜“ç³»ç»Ÿ](./42_å®æˆ˜æ¡ˆä¾‹_é‡‘èäº¤æ˜“ç³»ç»Ÿ.md)
- [40_å®æˆ˜æ¡ˆä¾‹_è®¢å•æ”¯ä»˜åº“å­˜é›†æˆ](./40_å®æˆ˜æ¡ˆä¾‹_è®¢å•æ”¯ä»˜åº“å­˜é›†æˆ.md)
- [36_Goå¾®æœåŠ¡é—´é€šä¿¡ä¸åˆ†å¸ƒå¼è¿½è¸ª](./36_Goå¾®æœåŠ¡é—´é€šä¿¡ä¸åˆ†å¸ƒå¼è¿½è¸ª.md)
- [33_Goé«˜çº§é”™è¯¯å¤„ç†æ¨¡å¼ä¸Contextä¼ æ’­](./33_Goé«˜çº§é”™è¯¯å¤„ç†æ¨¡å¼ä¸Contextä¼ æ’­.md)

