# 43. 实战案例：2PC 分布式事务与审计日志

## 📚 目录

- [1. 2PC 两阶段提交](#1-2pc-两阶段提交)
- [2. 审计日志服务](#2-审计日志服务)
- [3. 对账服务](#3-对账服务)
- [4. 完整交易流程](#4-完整交易流程)
- [5. 监控与告警](#5-监控与告警)
- [6. 总结](#6-总结)

---

## 1. 2PC 两阶段提交

### 1.1 2PC 协调器

```go
package twopc

import (
    "context"
    "errors"
    "fmt"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// TwoPhaseCommit 两阶段提交协调器
type TwoPhaseCommit struct {
    service     *transaction.Service
    transaction *transaction.Transaction
    tracer      trace.Tracer
    
    // 状态跟踪
    riskEvaluated     bool
    frozenFrom        bool
    creditedTo        bool
}

// NewTwoPhaseCommit 创建 2PC 协调器
func NewTwoPhaseCommit(svc *transaction.Service, tx *transaction.Transaction) *TwoPhaseCommit {
    return &TwoPhaseCommit{
        service:     svc,
        transaction: tx,
        tracer:      otel.Tracer("two-phase-commit"),
    }
}

// Execute 执行两阶段提交
func (tpc *TwoPhaseCommit) Execute(ctx context.Context) error {
    ctx, span := tpc.tracer.Start(ctx, "twopc.execute",
        trace.WithAttributes(
            attribute.String("transaction.id", tpc.transaction.ID.String()),
        ),
    )
    defer span.End()
    
    // Phase 1: Prepare（准备阶段）
    span.AddEvent("phase 1: prepare")
    
    if err := tpc.prepare(ctx); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "prepare failed")
        
        // 回滚
        tpc.rollback(ctx)
        
        // 更新交易状态
        tpc.updateStatus(ctx, "failed")
        
        return err
    }
    
    span.AddEvent("phase 1 completed")
    
    // Phase 2: Commit（提交阶段）
    span.AddEvent("phase 2: commit")
    
    if err := tpc.commit(ctx); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "commit failed")
        
        // 回滚
        tpc.rollback(ctx)
        
        // 更新交易状态
        tpc.updateStatus(ctx, "failed")
        
        return err
    }
    
    span.AddEvent("phase 2 completed")
    
    // 更新交易状态
    tpc.updateStatus(ctx, "completed")
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// prepare 准备阶段
func (tpc *TwoPhaseCommit) prepare(ctx context.Context) error {
    ctx, span := tpc.tracer.Start(ctx, "twopc.prepare")
    defer span.End()
    
    // 更新交易状态为处理中
    tpc.updateStatus(ctx, "processing")
    
    // 步骤 1: 风控评估
    span.AddEvent("step 1: risk evaluation")
    
    riskResp, err := tpc.service.riskService.Evaluate(ctx, &risk.EvaluateRequest{
        AccountID:       *tpc.transaction.FromAccountID,
        Amount:          tpc.transaction.Amount,
        TransactionType: tpc.transaction.Type,
        Currency:        tpc.transaction.Currency,
    })
    
    if err != nil {
        return fmt.Errorf("risk evaluation failed: %w", err)
    }
    
    // 更新风控信息
    tpc.transaction.RiskScore = riskResp.Score
    if riskResp.Approved {
        tpc.transaction.RiskStatus = "approved"
    } else {
        tpc.transaction.RiskStatus = "rejected"
        return errors.New("transaction rejected by risk control")
    }
    
    tpc.service.db.WithContext(ctx).Save(tpc.transaction)
    tpc.riskEvaluated = true
    
    span.AddEvent("risk evaluation passed",
        trace.WithAttributes(
            attribute.Float64("risk.score", riskResp.Score),
            attribute.String("risk.level", riskResp.Level),
        ),
    )
    
    // 步骤 2: 冻结付款账户资金
    span.AddEvent("step 2: freeze source account")
    
    if err := tpc.service.accountService.Freeze(ctx, &account.FreezeRequest{
        AccountID:     *tpc.transaction.FromAccountID,
        Amount:        tpc.transaction.Amount,
        TransactionID: tpc.transaction.ID,
    }); err != nil {
        return fmt.Errorf("failed to freeze source account: %w", err)
    }
    
    tpc.frozenFrom = true
    span.AddEvent("source account frozen")
    
    // 步骤 3: 验证收款账户有效性
    span.AddEvent("step 3: validate destination account")
    
    toAccount, err := tpc.service.accountService.GetAccount(ctx, &account.GetAccountRequest{
        AccountID: *tpc.transaction.ToAccountID,
    })
    
    if err != nil {
        return fmt.Errorf("destination account not found: %w", err)
    }
    
    if toAccount.Status != "active" {
        return errors.New("destination account is not active")
    }
    
    span.AddEvent("destination account validated")
    
    // 所有准备步骤完成
    return nil
}

// commit 提交阶段
func (tpc *TwoPhaseCommit) commit(ctx context.Context) error {
    ctx, span := tpc.tracer.Start(ctx, "twopc.commit")
    defer span.End()
    
    // 步骤 1: 扣款
    span.AddEvent("step 1: debit source account")
    
    if err := tpc.service.accountService.Debit(ctx, &account.DebitRequest{
        AccountID:     *tpc.transaction.FromAccountID,
        Amount:        tpc.transaction.Amount,
        TransactionID: tpc.transaction.ID,
    }); err != nil {
        return fmt.Errorf("failed to debit source account: %w", err)
    }
    
    span.AddEvent("source account debited")
    
    // 步骤 2: 解冻资金（因为已扣款）
    span.AddEvent("step 2: unfreeze source account")
    
    if err := tpc.service.accountService.Unfreeze(ctx, &account.UnfreezeRequest{
        AccountID:     *tpc.transaction.FromAccountID,
        Amount:        tpc.transaction.Amount,
        TransactionID: tpc.transaction.ID,
    }); err != nil {
        // 这里不返回错误，因为扣款已完成
        span.AddEvent("warning: unfreeze failed",
            trace.WithAttributes(attribute.String("error", err.Error())),
        )
    }
    
    // 步骤 3: 存款到收款账户
    span.AddEvent("step 3: credit destination account")
    
    if err := tpc.service.accountService.Credit(ctx, &account.CreditRequest{
        AccountID:     *tpc.transaction.ToAccountID,
        Amount:        tpc.transaction.Amount,
        TransactionID: tpc.transaction.ID,
    }); err != nil {
        // 严重错误：扣款已完成但存款失败，需要人工介入
        span.RecordError(err)
        span.AddEvent("CRITICAL: credit failed after debit succeeded")
        
        // 记录到审计日志
        tpc.service.auditService.LogCriticalError(ctx, &audit.CriticalErrorEvent{
            TransactionID: tpc.transaction.ID,
            Type:          "debit_credit_mismatch",
            Message:       "Debit succeeded but credit failed",
            Error:         err.Error(),
        })
        
        return fmt.Errorf("critical error: credit failed: %w", err)
    }
    
    tpc.creditedTo = true
    span.AddEvent("destination account credited")
    
    // 步骤 4: 记录审计日志
    span.AddEvent("step 4: audit logging")
    
    tpc.service.auditService.LogTransactionCompleted(ctx, &audit.TransactionCompletedEvent{
        TransactionID:     tpc.transaction.ID,
        TransactionNumber: tpc.transaction.TransactionNumber,
        FromAccountID:     *tpc.transaction.FromAccountID,
        ToAccountID:       *tpc.transaction.ToAccountID,
        Amount:            tpc.transaction.Amount,
        Currency:          tpc.transaction.Currency,
        RiskScore:         tpc.transaction.RiskScore,
        CompletedAt:       time.Now(),
    })
    
    span.AddEvent("audit log recorded")
    
    return nil
}

// rollback 回滚操作
func (tpc *TwoPhaseCommit) rollback(ctx context.Context) {
    ctx, span := tpc.tracer.Start(ctx, "twopc.rollback")
    defer span.End()
    
    span.AddEvent("starting rollback")
    
    // 回滚顺序：与提交相反
    
    // 如果已存款，回滚存款（不太可能发生，因为存款失败会被标记为严重错误）
    if tpc.creditedTo {
        span.AddEvent("rollback: debiting destination account")
        
        tpc.service.accountService.Debit(ctx, &account.DebitRequest{
            AccountID:     *tpc.transaction.ToAccountID,
            Amount:        tpc.transaction.Amount,
            TransactionID: tpc.transaction.ID,
        })
    }
    
    // 如果已冻结，解冻资金
    if tpc.frozenFrom {
        span.AddEvent("rollback: unfreezing source account")
        
        tpc.service.accountService.Unfreeze(ctx, &account.UnfreezeRequest{
            AccountID:     *tpc.transaction.FromAccountID,
            Amount:        tpc.transaction.Amount,
            TransactionID: tpc.transaction.ID,
        })
    }
    
    // 记录回滚到审计日志
    tpc.service.auditService.LogTransactionRolledBack(ctx, &audit.TransactionRolledBackEvent{
        TransactionID:     tpc.transaction.ID,
        TransactionNumber: tpc.transaction.TransactionNumber,
        RolledBackAt:      time.Now(),
    })
    
    span.AddEvent("rollback completed")
}

// updateStatus 更新交易状态
func (tpc *TwoPhaseCommit) updateStatus(ctx context.Context, status string) {
    tpc.transaction.Status = status
    
    if status == "completed" {
        now := time.Now()
        tpc.transaction.CompletedAt = &now
    }
    
    tpc.service.db.WithContext(ctx).Save(tpc.transaction)
}
```

### 1.2 2PC 流程图

```
Phase 1: Prepare
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  1. 风控评估     ────────► 通过/拒绝                      │
│                                                         │
│  2. 冻结资金     ────────► 成功/失败                      │
│                                                         │
│  3. 验证收款账户  ────────► 有效/无效                      │
│                                                         │
│  任一步骤失败 ───────────► Rollback                       │
│                                                         │
└─────────────────────────────────────────────────────────┘
                           │
                           │ 所有步骤成功
                           ▼
Phase 2: Commit
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  1. 扣款         ────────► 成功/失败 ──► 失败则 Rollback   │
│                                                         │
│  2. 解冻         ────────► (Best Effort)                │
│                                                         │
│  3. 存款         ────────► 成功/失败 ──► 失败记录严重错误   │
│                                                         │
│  4. 审计日志      ────────► 记录完成                      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 2. 审计日志服务

### 2.1 审计日志模型

```go
package audit

import (
    "context"
    "encoding/json"
    "time"
    
    "github.com/google/uuid"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
    "gorm.io/gorm"
)

// AuditLog 审计日志
type AuditLog struct {
    ID            uuid.UUID  `gorm:"type:uuid;primary_key" json:"id"`
    EventType     string     `gorm:"not null;index" json:"event_type"`
    EntityType    string     `gorm:"not null;index" json:"entity_type"` // transaction, account, user
    EntityID      uuid.UUID  `gorm:"type:uuid;not null;index" json:"entity_id"`
    Action        string     `gorm:"not null" json:"action"` // created, updated, deleted, completed, failed
    ActorID       *uuid.UUID `gorm:"type:uuid;index" json:"actor_id,omitempty"`
    ActorType     string     `json:"actor_type,omitempty"` // user, system, service
    TraceID       string     `gorm:"not null;index" json:"trace_id"`
    SpanID        string     `gorm:"not null" json:"span_id"`
    Payload       string     `gorm:"type:jsonb" json:"payload"`
    Severity      string     `gorm:"not null;index" json:"severity"` // info, warning, error, critical
    IPAddress     string     `json:"ip_address,omitempty"`
    UserAgent     string     `json:"user_agent,omitempty"`
    CreatedAt     time.Time  `gorm:"index" json:"created_at"`
}

// BeforeCreate Hook
func (al *AuditLog) BeforeCreate(tx *gorm.DB) error {
    if al.ID == uuid.Nil {
        al.ID = uuid.New()
    }
    return nil
}
```

### 2.2 审计日志服务实现

```go
package audit

import (
    "context"
    "encoding/json"
    
    "github.com/shopspring/decimal"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
    "gorm.io/gorm"
)

// Service 审计日志服务
type Service struct {
    db     *gorm.DB
    tracer trace.Tracer
}

// NewService 创建审计日志服务
func NewService(db *gorm.DB) *Service {
    return &Service{
        db:     db,
        tracer: otel.Tracer("audit-service"),
    }
}

// Log 记录审计日志
func (s *Service) Log(ctx context.Context, log *AuditLog) error {
    ctx, span := s.tracer.Start(ctx, "audit.log",
        trace.WithAttributes(
            attribute.String("event_type", log.EventType),
            attribute.String("entity_type", log.EntityType),
            attribute.String("entity_id", log.EntityID.String()),
        ),
    )
    defer span.End()
    
    // 从 Span Context 提取 TraceID 和 SpanID
    spanContext := span.SpanContext()
    log.TraceID = spanContext.TraceID().String()
    log.SpanID = spanContext.SpanID().String()
    
    // 保存到数据库
    if err := s.db.WithContext(ctx).Create(log).Error; err != nil {
        span.RecordError(err)
        return err
    }
    
    return nil
}

// LogTransactionCompleted 记录交易完成
func (s *Service) LogTransactionCompleted(ctx context.Context, event *TransactionCompletedEvent) error {
    payload, _ := json.Marshal(event)
    
    return s.Log(ctx, &AuditLog{
        EventType:  "transaction.completed",
        EntityType: "transaction",
        EntityID:   event.TransactionID,
        Action:     "completed",
        ActorType:  "system",
        Payload:    string(payload),
        Severity:   "info",
    })
}

// LogTransactionRolledBack 记录交易回滚
func (s *Service) LogTransactionRolledBack(ctx context.Context, event *TransactionRolledBackEvent) error {
    payload, _ := json.Marshal(event)
    
    return s.Log(ctx, &AuditLog{
        EventType:  "transaction.rolled_back",
        EntityType: "transaction",
        EntityID:   event.TransactionID,
        Action:     "rolled_back",
        ActorType:  "system",
        Payload:    string(payload),
        Severity:   "warning",
    })
}

// LogCriticalError 记录严重错误
func (s *Service) LogCriticalError(ctx context.Context, event *CriticalErrorEvent) error {
    payload, _ := json.Marshal(event)
    
    return s.Log(ctx, &AuditLog{
        EventType:  "critical.error",
        EntityType: "transaction",
        EntityID:   event.TransactionID,
        Action:     "error",
        ActorType:  "system",
        Payload:    string(payload),
        Severity:   "critical",
    })
}

// QueryLogs 查询审计日志
func (s *Service) QueryLogs(ctx context.Context, req *QueryLogsRequest) ([]*AuditLog, int64, error) {
    ctx, span := s.tracer.Start(ctx, "audit.query_logs")
    defer span.End()
    
    query := s.db.WithContext(ctx).Model(&AuditLog{})
    
    // 条件过滤
    if req.EntityType != "" {
        query = query.Where("entity_type = ?", req.EntityType)
    }
    
    if req.EntityID != uuid.Nil {
        query = query.Where("entity_id = ?", req.EntityID)
    }
    
    if req.EventType != "" {
        query = query.Where("event_type = ?", req.EventType)
    }
    
    if req.Severity != "" {
        query = query.Where("severity = ?", req.Severity)
    }
    
    if !req.StartTime.IsZero() {
        query = query.Where("created_at >= ?", req.StartTime)
    }
    
    if !req.EndTime.IsZero() {
        query = query.Where("created_at <= ?", req.EndTime)
    }
    
    // 获取总数
    var total int64
    if err := query.Count(&total).Error; err != nil {
        span.RecordError(err)
        return nil, 0, err
    }
    
    // 分页查询
    var logs []*AuditLog
    offset := (req.Page - 1) * req.PageSize
    if err := query.Offset(offset).Limit(req.PageSize).
        Order("created_at DESC").
        Find(&logs).Error; err != nil {
        span.RecordError(err)
        return nil, 0, err
    }
    
    span.SetAttributes(
        attribute.Int64("result.total", total),
        attribute.Int("result.count", len(logs)),
    )
    
    return logs, total, nil
}

// Event 类型定义

// TransactionCompletedEvent 交易完成事件
type TransactionCompletedEvent struct {
    TransactionID     uuid.UUID       `json:"transaction_id"`
    TransactionNumber string          `json:"transaction_number"`
    FromAccountID     uuid.UUID       `json:"from_account_id"`
    ToAccountID       uuid.UUID       `json:"to_account_id"`
    Amount            decimal.Decimal `json:"amount"`
    Currency          string          `json:"currency"`
    RiskScore         float64         `json:"risk_score"`
    CompletedAt       time.Time       `json:"completed_at"`
}

// TransactionRolledBackEvent 交易回滚事件
type TransactionRolledBackEvent struct {
    TransactionID     uuid.UUID `json:"transaction_id"`
    TransactionNumber string    `json:"transaction_number"`
    RolledBackAt      time.Time `json:"rolled_back_at"`
}

// CriticalErrorEvent 严重错误事件
type CriticalErrorEvent struct {
    TransactionID uuid.UUID `json:"transaction_id"`
    Type          string    `json:"type"`
    Message       string    `json:"message"`
    Error         string    `json:"error"`
}

// QueryLogsRequest 查询审计日志请求
type QueryLogsRequest struct {
    EntityType string    `form:"entity_type"`
    EntityID   uuid.UUID `form:"entity_id"`
    EventType  string    `form:"event_type"`
    Severity   string    `form:"severity"`
    StartTime  time.Time `form:"start_time"`
    EndTime    time.Time `form:"end_time"`
    Page       int       `form:"page" binding:"required,min=1"`
    PageSize   int       `form:"page_size" binding:"required,min=1,max=100"`
}
```

---

## 3. 对账服务

### 3.1 对账任务

```go
package reconciliation

import (
    "context"
    "fmt"
    "time"
    
    "github.com/shopspring/decimal"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
    "gorm.io/gorm"
)

// Service 对账服务
type Service struct {
    db     *gorm.DB
    tracer trace.Tracer
}

// NewService 创建对账服务
func NewService(db *gorm.DB) *Service {
    return &Service{
        db:     db,
        tracer: otel.Tracer("reconciliation-service"),
    }
}

// ReconcileDaily 每日对账
func (s *Service) ReconcileDaily(ctx context.Context, date time.Time) (*ReconciliationReport, error) {
    ctx, span := s.tracer.Start(ctx, "reconciliation.daily",
        trace.WithAttributes(
            attribute.String("date", date.Format("2006-01-02")),
        ),
    )
    defer span.End()
    
    report := &ReconciliationReport{
        Date:       date,
        StartedAt:  time.Now(),
        Status:     "in_progress",
    }
    
    // 1. 对账交易流水
    span.AddEvent("reconciling transactions")
    
    txResult, err := s.reconcileTransactions(ctx, date)
    if err != nil {
        span.RecordError(err)
        report.Status = "failed"
        report.Error = err.Error()
        return report, err
    }
    
    report.TransactionCount = txResult.TotalCount
    report.TransactionAmount = txResult.TotalAmount
    
    span.AddEvent("transactions reconciled",
        trace.WithAttributes(
            attribute.Int64("count", txResult.TotalCount),
            attribute.String("amount", txResult.TotalAmount.String()),
        ),
    )
    
    // 2. 对账账户余额
    span.AddEvent("reconciling account balances")
    
    balanceResult, err := s.reconcileBalances(ctx, date)
    if err != nil {
        span.RecordError(err)
        report.Status = "failed"
        report.Error = err.Error()
        return report, err
    }
    
    report.AccountCount = balanceResult.TotalAccounts
    report.Discrepancies = balanceResult.Discrepancies
    
    span.AddEvent("balances reconciled",
        trace.WithAttributes(
            attribute.Int64("accounts", balanceResult.TotalAccounts),
            attribute.Int("discrepancies", len(balanceResult.Discrepancies)),
        ),
    )
    
    // 3. 生成报告
    report.CompletedAt = time.Now()
    
    if len(report.Discrepancies) > 0 {
        report.Status = "completed_with_errors"
        span.SetStatus(codes.Error, "discrepancies found")
    } else {
        report.Status = "completed"
        span.SetStatus(codes.Ok, "")
    }
    
    // 保存报告
    if err := s.db.WithContext(ctx).Create(report).Error; err != nil {
        span.RecordError(err)
        return nil, err
    }
    
    return report, nil
}

// reconcileTransactions 对账交易流水
func (s *Service) reconcileTransactions(ctx context.Context, date time.Time) (*TransactionReconciliationResult, error) {
    ctx, span := s.tracer.Start(ctx, "reconciliation.transactions")
    defer span.End()
    
    startOfDay := time.Date(date.Year(), date.Month(), date.Day(), 0, 0, 0, 0, date.Location())
    endOfDay := startOfDay.Add(24 * time.Hour)
    
    // 统计当天完成的交易
    var result struct {
        Count  int64
        Amount decimal.Decimal
    }
    
    err := s.db.WithContext(ctx).
        Model(&transaction.Transaction{}).
        Select("COUNT(*) as count, COALESCE(SUM(amount), 0) as amount").
        Where("status = ? AND completed_at >= ? AND completed_at < ?",
            "completed", startOfDay, endOfDay).
        Scan(&result).Error
    
    if err != nil {
        span.RecordError(err)
        return nil, err
    }
    
    return &TransactionReconciliationResult{
        TotalCount:  result.Count,
        TotalAmount: result.Amount,
    }, nil
}

// reconcileBalances 对账账户余额
func (s *Service) reconcileBalances(ctx context.Context, date time.Time) (*BalanceReconciliationResult, error) {
    ctx, span := s.tracer.Start(ctx, "reconciliation.balances")
    defer span.End()
    
    // 获取所有活跃账户
    var accounts []account.Account
    if err := s.db.WithContext(ctx).
        Where("status = ?", "active").
        Find(&accounts).Error; err != nil {
        span.RecordError(err)
        return nil, err
    }
    
    var discrepancies []Discrepancy
    
    // 验证每个账户
    for _, acc := range accounts {
        // 计算账户的预期余额
        expectedBalance, err := s.calculateExpectedBalance(ctx, acc.ID)
        if err != nil {
            span.RecordError(err)
            continue
        }
        
        // 比较实际余额和预期余额
        if !acc.Balance.Equal(expectedBalance) {
            discrepancy := Discrepancy{
                AccountID:       acc.ID,
                AccountNumber:   acc.AccountNumber,
                ExpectedBalance: expectedBalance,
                ActualBalance:   acc.Balance,
                Difference:      acc.Balance.Sub(expectedBalance),
                DetectedAt:      time.Now(),
            }
            
            discrepancies = append(discrepancies, discrepancy)
            
            span.AddEvent("discrepancy detected",
                trace.WithAttributes(
                    attribute.String("account.id", acc.ID.String()),
                    attribute.String("difference", discrepancy.Difference.String()),
                ),
            )
        }
    }
    
    return &BalanceReconciliationResult{
        TotalAccounts:  int64(len(accounts)),
        Discrepancies: discrepancies,
    }, nil
}

// calculateExpectedBalance 计算预期余额
func (s *Service) calculateExpectedBalance(ctx context.Context, accountID uuid.UUID) (decimal.Decimal, error) {
    // 获取所有账户操作
    var operations []account.AccountOperation
    if err := s.db.WithContext(ctx).
        Where("account_id = ? AND status = ?", accountID, "completed").
        Order("created_at ASC").
        Find(&operations).Error; err != nil {
        return decimal.Zero, err
    }
    
    // 计算余额（假设初始余额为0）
    balance := decimal.Zero
    
    for _, op := range operations {
        switch op.OperationType {
        case "credit":
            balance = balance.Add(op.Amount)
        case "debit":
            balance = balance.Sub(op.Amount)
        }
    }
    
    return balance, nil
}

// ReconciliationReport 对账报告
type ReconciliationReport struct {
    ID                 uuid.UUID     `gorm:"type:uuid;primary_key" json:"id"`
    Date               time.Time     `gorm:"not null;uniqueIndex" json:"date"`
    Status             string        `gorm:"not null" json:"status"` // in_progress, completed, completed_with_errors, failed
    TransactionCount   int64         `gorm:"not null" json:"transaction_count"`
    TransactionAmount  decimal.Decimal `gorm:"type:decimal(20,2);not null" json:"transaction_amount"`
    AccountCount       int64         `gorm:"not null" json:"account_count"`
    DiscrepancyCount   int           `gorm:"not null;default:0" json:"discrepancy_count"`
    Discrepancies      []Discrepancy `gorm:"-" json:"discrepancies,omitempty"`
    Error              string        `json:"error,omitempty"`
    StartedAt          time.Time     `gorm:"not null" json:"started_at"`
    CompletedAt        time.Time     `json:"completed_at,omitempty"`
}

// Discrepancy 差异
type Discrepancy struct {
    AccountID       uuid.UUID       `json:"account_id"`
    AccountNumber   string          `json:"account_number"`
    ExpectedBalance decimal.Decimal `json:"expected_balance"`
    ActualBalance   decimal.Decimal `json:"actual_balance"`
    Difference      decimal.Decimal `json:"difference"`
    DetectedAt      time.Time       `json:"detected_at"`
}

// TransactionReconciliationResult 交易对账结果
type TransactionReconciliationResult struct {
    TotalCount  int64
    TotalAmount decimal.Decimal
}

// BalanceReconciliationResult 余额对账结果
type BalanceReconciliationResult struct {
    TotalAccounts  int64
    Discrepancies []Discrepancy
}

// BeforeCreate Hook
func (rr *ReconciliationReport) BeforeCreate(tx *gorm.DB) error {
    if rr.ID == uuid.Nil {
        rr.ID = uuid.New()
    }
    return nil
}
```

### 3.2 定时对账任务

```go
package reconciliation

import (
    "context"
    "log"
    "time"
)

// ScheduleDailyReconciliation 调度每日对账任务
func ScheduleDailyReconciliation(svc *Service) {
    ticker := time.NewTicker(24 * time.Hour)
    defer ticker.Stop()
    
    // 每天凌晨 2 点执行
    for {
        now := time.Now()
        next := time.Date(now.Year(), now.Month(), now.Day()+1, 2, 0, 0, 0, now.Location())
        duration := next.Sub(now)
        
        time.Sleep(duration)
        
        // 执行对账（对前一天的数据）
        yesterday := now.AddDate(0, 0, -1)
        
        ctx := context.Background()
        report, err := svc.ReconcileDaily(ctx, yesterday)
        
        if err != nil {
            log.Printf("Reconciliation failed for %s: %v", yesterday.Format("2006-01-02"), err)
            continue
        }
        
        log.Printf("Reconciliation completed for %s: %d transactions, %d discrepancies",
            yesterday.Format("2006-01-02"),
            report.TransactionCount,
            len(report.Discrepancies),
        )
        
        // 如果有差异，发送告警
        if len(report.Discrepancies) > 0 {
            // TODO: 发送告警通知
            log.Printf("WARNING: Found %d discrepancies", len(report.Discrepancies))
        }
    }
}
```

---

## 4. 完整交易流程

### 4.1 流程图

```
                        ┌─────────────────────┐
                        │  Transfer Request   │
                        └──────────┬──────────┘
                                   │
                                   ▼
                        ┌─────────────────────┐
                        │ Create Transaction  │
                        │    (Status=pending) │
                        └──────────┬──────────┘
                                   │
                                   ▼
                        ┌─────────────────────┐
                        │   Start 2PC         │
                        └──────────┬──────────┘
                                   │
                    ┌──────────────┴──────────────┐
                    │                             │
                    ▼                             ▼
        ┌─────────────────────┐       ┌─────────────────────┐
        │   Phase 1: Prepare  │       │   Phase 2: Commit   │
        ├─────────────────────┤       ├─────────────────────┤
        │ 1. Risk Evaluation  │       │ 1. Debit Source     │
        │ 2. Freeze Funds     │───────│ 2. Unfreeze         │
        │ 3. Validate Dest    │  Pass │ 3. Credit Dest      │
        └──────────┬──────────┘       │ 4. Audit Log        │
                   │                  └──────────┬──────────┘
                   │ Fail                        │
                   ▼                             ▼
        ┌─────────────────────┐       ┌─────────────────────┐
        │      Rollback       │       │ Update Status       │
        │                     │       │ (Status=completed)  │
        │ - Unfreeze Funds    │       └─────────────────────┘
        │ - Audit Log         │
        │ - Update Status     │
        │   (Status=failed)   │
        └─────────────────────┘
```

### 4.2 完整追踪示例

使用 OpenTelemetry 追踪整个交易流程，可以看到：

```
Trace: transfer-txn-abc123
├─ transaction.transfer (120ms)
│  ├─ twopc.execute (115ms)
│  │  ├─ twopc.prepare (45ms)
│  │  │  ├─ risk.evaluate (15ms)
│  │  │  │  └─ risk.check_frequency (5ms)
│  │  │  ├─ account.freeze (20ms)
│  │  │  │  └─ db.transaction (18ms)
│  │  │  └─ account.get (10ms)
│  │  │     └─ db.query (8ms)
│  │  └─ twopc.commit (70ms)
│  │     ├─ account.debit (25ms)
│  │     │  └─ db.transaction (23ms)
│  │     ├─ account.unfreeze (20ms)
│  │     │  └─ db.transaction (18ms)
│  │     ├─ account.credit (20ms)
│  │     │  └─ db.transaction (18ms)
│  │     └─ audit.log (5ms)
│  │        └─ db.insert (3ms)
│  └─ transaction.update_status (5ms)
│     └─ db.update (3ms)
```

---

## 5. 监控与告警

### 5.1 关键指标

```yaml
# Prometheus 告警规则
groups:
  - name: financial_system
    interval: 30s
    rules:
      # 交易失败率
      - alert: HighTransactionFailureRate
        expr: |
          (
            rate(transaction_count{status="failed"}[5m]) /
            rate(transaction_count[5m])
          ) > 0.05
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High transaction failure rate"
          description: "Transaction failure rate is {{ $value | humanizePercentage }}"
      
      # 风控拒绝率
      - alert: HighRiskRejectionRate
        expr: |
          (
            rate(transaction_count{risk_status="rejected"}[5m]) /
            rate(transaction_count[5m])
          ) > 0.10
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High risk rejection rate"
      
      # 账户余额异常
      - alert: NegativeAccountBalance
        expr: account_balance < 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Negative account balance detected"
          description: "Account {{ $labels.account_id }} has negative balance"
      
      # 对账差异
      - alert: ReconciliationDiscrepancy
        expr: reconciliation_discrepancy_count > 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Reconciliation discrepancies found"
          description: "Found {{ $value }} discrepancies in reconciliation"
      
      # 交易延迟
      - alert: HighTransactionLatency
        expr: |
          histogram_quantile(0.95,
            rate(transaction_duration_bucket[5m])
          ) > 1000
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High transaction latency"
          description: "P95 latency is {{ $value }}ms"
```

### 5.2 Grafana 面板

```json
{
  "dashboard": {
    "title": "Financial System Overview",
    "panels": [
      {
        "title": "Transaction Volume",
        "targets": [
          {
            "expr": "sum(rate(transaction_count[1m])) by (type, status)"
          }
        ]
      },
      {
        "title": "Transaction Latency",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(transaction_duration_bucket[5m]))"
          }
        ]
      },
      {
        "title": "Account Balances",
        "targets": [
          {
            "expr": "sum(account_balance) by (account_type)"
          }
        ]
      },
      {
        "title": "Risk Score Distribution",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(risk_score_bucket[5m]))"
          }
        ]
      }
    ]
  }
}
```

---

## 6. 总结

本文档展示了金融交易系统的完整实现，包括：

### 核心特性

✅ **2PC 两阶段提交**
- Prepare 阶段：风控、冻结、验证
- Commit 阶段：扣款、存款、审计
- Rollback 机制：完整回滚

✅ **审计日志**
- 完整的事件记录
- TraceID/SpanID 关联
- 可查询、可追溯

✅ **对账机制**
- 每日自动对账
- 差异检测
- 告警通知

✅ **风险控制**
- 多维度评估
- 实时拦截
- 可配置规则

✅ **完整的可观测性**
- 分布式追踪（完整的调用链）
- 业务指标（交易量、成功率、延迟）
- 审计日志（合规性）

### 技术亮点

- **精确的货币计算**: 使用 `decimal.Decimal`
- **乐观锁 + 悲观锁**: 防止并发冲突
- **强一致性**: 2PC 保证数据一致
- **审计追踪**: 完整的操作历史
- **实时对账**: 及时发现异常

### 相关文档

- [42_实战案例_金融交易系统](./42_实战案例_金融交易系统.md)
- [40_实战案例_订单支付库存集成](./40_实战案例_订单支付库存集成.md)
- [36_Go微服务间通信与分布式追踪](./36_Go微服务间通信与分布式追踪.md)
- [33_Go高级错误处理模式与Context传播](./33_Go高级错误处理模式与Context传播.md)

