# Go 接口与抽象层设计模式

## 目录

- [Go 接口与抽象层设计模式](#go-接口与抽象层设计模式)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [核心接口层次](#核心接口层次)
  - [2. OpenTelemetry 核心接口](#2-opentelemetry-核心接口)
    - [2.1 SpanExporter 接口](#21-spanexporter-接口)
    - [2.2 SpanProcessor 接口](#22-spanprocessor-接口)
    - [2.3 Sampler 接口](#23-sampler-接口)
  - [3. 自定义 Exporter 实现](#3-自定义-exporter-实现)
    - [3.1 文件导出器](#31-文件导出器)
    - [3.2 数据库导出器](#32-数据库导出器)
    - [3.3 多目标导出器](#33-多目标导出器)
  - [4. 自定义 Processor 实现](#4-自定义-processor-实现)
    - [4.1 过滤处理器](#41-过滤处理器)
    - [4.2 数据脱敏处理器](#42-数据脱敏处理器)
    - [4.3 属性增强处理器](#43-属性增强处理器)
  - [5. 自定义 Sampler 实现](#5-自定义-sampler-实现)
    - [5.1 动态采样器](#51-动态采样器)
    - [5.2 基于规则的采样器](#52-基于规则的采样器)
    - [5.3 自适应采样器](#53-自适应采样器)
  - [6. 接口组合与装饰器模式](#6-接口组合与装饰器模式)
    - [6.1 Exporter 链](#61-exporter-链)
    - [6.2 Processor 管道](#62-processor-管道)
    - [6.3 装饰器模式应用](#63-装饰器模式应用)
  - [7. 插件化架构设计](#7-插件化架构设计)
    - [7.1 插件注册机制](#71-插件注册机制)
    - [7.2 动态加载插件](#72-动态加载插件)
    - [7.3 插件配置管理](#73-插件配置管理)
  - [8. 泛型接口设计](#8-泛型接口设计)
    - [8.1 通用导出器接口](#81-通用导出器接口)
    - [8.2 类型安全的处理器](#82-类型安全的处理器)
    - [8.3 泛型采样器](#83-泛型采样器)
  - [9. 最佳实践与模式](#9-最佳实践与模式)
    - [综合示例](#综合示例)
  - [总结](#总结)

---

## 1. 概述

接口是 Go 语言的核心设计哲学,OpenTelemetry SDK 通过接口提供了强大的扩展能力。本指南基于 **Go 1.25.1** 和 **OpenTelemetry v1.32.0**,深入讲解如何设计和实现自定义组件。

### 核心接口层次

```text
┌─────────────────────────────────────┐
│   OpenTelemetry 接口架构             │
├─────────────────────────────────────┤
│  TracerProvider                     │
│    ├─── Tracer                      │
│    ├─── SpanProcessor               │
│    │      ├─── OnStart()            │
│    │      ├─── OnEnd()              │
│    │      └─── ForceFlush()         │
│    └─── SpanExporter                │
│           ├─── ExportSpans()        │
│           └─── Shutdown()           │
│                                     │
│  Sampler                            │
│    └─── ShouldSample()              │
└─────────────────────────────────────┘
```

---

## 2. OpenTelemetry 核心接口

### 2.1 SpanExporter 接口

`SpanExporter` 负责将 Span 导出到外部系统。

```go
package otlpinterface

import (
    "context"
    
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
)

// SpanExporter 接口定义(来自 SDK)
type SpanExporter interface {
    // ExportSpans 导出一批 Span
    ExportSpans(ctx context.Context, spans []sdktrace.ReadOnlySpan) error
    
    // Shutdown 优雅关闭导出器
    Shutdown(ctx context.Context) error
}

// 核心方法说明:
// 1. ExportSpans: 必须是幂等的,可能被重复调用
// 2. Shutdown: 必须确保所有缓冲数据被导出
// 3. 实现必须是线程安全的
```

### 2.2 SpanProcessor 接口

`SpanProcessor` 在 Span 生命周期中拦截和处理 Span。

```go
// SpanProcessor 接口定义
type SpanProcessor interface {
    // OnStart 当 Span 开始时调用
    OnStart(parent context.Context, s sdktrace.ReadWriteSpan)
    
    // OnEnd 当 Span 结束时调用
    OnEnd(s sdktrace.ReadOnlySpan)
    
    // Shutdown 关闭处理器
    Shutdown(ctx context.Context) error
    
    // ForceFlush 强制刷新缓冲数据
    ForceFlush(ctx context.Context) error
}

// 生命周期:
// Span.Start() -> OnStart() -> [业务逻辑] -> Span.End() -> OnEnd()
```

### 2.3 Sampler 接口

`Sampler` 决定是否记录 Span。

```go
import (
    "go.opentelemetry.io/otel/sdk/trace"
)

// Sampler 接口定义
type Sampler interface {
    // ShouldSample 决定是否采样
    ShouldSample(parameters trace.SamplingParameters) trace.SamplingResult
    
    // Description 返回采样器描述
    Description() string
}

// SamplingParameters 包含:
// - ParentContext: 父 Span 上下文
// - TraceID: 当前 Trace ID
// - Name: Span 名称
// - SpanKind: Span 类型
// - Attributes: 初始属性

// SamplingResult 包含:
// - Decision: Drop / RecordOnly / RecordAndSample
// - Attributes: 附加属性
// - TraceState: Trace 状态
```

---

## 3. 自定义 Exporter 实现

### 3.1 文件导出器

将 Span 导出到本地文件,适合调试和离线分析。

```go
package customexporter

import (
    "context"
    "encoding/json"
    "fmt"
    "os"
    "sync"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    "go.opentelemetry.io/otel/trace"
)

// FileExporter 文件导出器
type FileExporter struct {
    tracer   trace.Tracer
    filePath string
    file     *os.File
    encoder  *json.Encoder
    mu       sync.Mutex
    
    // 统计
    exportedCount int64
}

// NewFileExporter 创建文件导出器
func NewFileExporter(filePath string) (*FileExporter, error) {
    file, err := os.OpenFile(filePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
    if err != nil {
        return nil, fmt.Errorf("failed to open file: %w", err)
    }
    
    return &FileExporter{
        tracer:   otel.Tracer("file-exporter"),
        filePath: filePath,
        file:     file,
        encoder:  json.NewEncoder(file),
    }, nil
}

// ExportSpans 实现 SpanExporter 接口
func (fe *FileExporter) ExportSpans(ctx context.Context, spans []sdktrace.ReadOnlySpan) error {
    ctx, span := fe.tracer.Start(ctx, "export-spans-to-file")
    defer span.End()
    
    span.SetAttributes(
        attribute.Int("span.count", len(spans)),
        attribute.String("file.path", fe.filePath),
    )
    
    fe.mu.Lock()
    defer fe.mu.Unlock()
    
    for _, s := range spans {
        // 转换为可序列化结构
        spanData := map[string]interface{}{
            "trace_id":    s.SpanContext().TraceID().String(),
            "span_id":     s.SpanContext().SpanID().String(),
            "name":        s.Name(),
            "start_time":  s.StartTime(),
            "end_time":    s.EndTime(),
            "attributes":  attributesToMap(s.Attributes()),
            "events":      eventsToSlice(s.Events()),
            "status":      statusToMap(s.Status()),
        }
        
        if err := fe.encoder.Encode(spanData); err != nil {
            span.RecordError(err)
            span.SetStatus(codes.Error, "encode failed")
            return fmt.Errorf("failed to encode span: %w", err)
        }
        
        fe.exportedCount++
    }
    
    span.SetAttributes(attribute.Int64("exporter.total_exported", fe.exportedCount))
    
    return nil
}

// Shutdown 实现 SpanExporter 接口
func (fe *FileExporter) Shutdown(ctx context.Context) error {
    ctx, span := fe.tracer.Start(ctx, "shutdown-file-exporter")
    defer span.End()
    
    fe.mu.Lock()
    defer fe.mu.Unlock()
    
    if fe.file != nil {
        if err := fe.file.Sync(); err != nil {
            return err
        }
        return fe.file.Close()
    }
    
    return nil
}

// 辅助函数
func attributesToMap(attrs []attribute.KeyValue) map[string]interface{} {
    m := make(map[string]interface{}, len(attrs))
    for _, attr := range attrs {
        m[string(attr.Key)] = attr.Value.AsInterface()
    }
    return m
}

func eventsToSlice(events []sdktrace.Event) []map[string]interface{} {
    result := make([]map[string]interface{}, len(events))
    for i, event := range events {
        result[i] = map[string]interface{}{
            "name":       event.Name,
            "timestamp":  event.Time,
            "attributes": attributesToMap(event.Attributes),
        }
    }
    return result
}

func statusToMap(status sdktrace.Status) map[string]interface{} {
    return map[string]interface{}{
        "code":        status.Code.String(),
        "description": status.Description,
    }
}

// 使用示例
func ExampleFileExporter() {
    exporter, err := NewFileExporter("traces.jsonl")
    if err != nil {
        panic(err)
    }
    
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter),
    )
    defer tp.Shutdown(context.Background())
    
    otel.SetTracerProvider(tp)
    
    // 创建追踪
    tracer := otel.Tracer("example")
    ctx, span := tracer.Start(context.Background(), "file-export-test")
    span.SetAttributes(attribute.String("key", "value"))
    span.End()
}
```

### 3.2 数据库导出器

将 Span 导出到关系型数据库。

```go
import (
    "database/sql"
    "time"
    
    _ "github.com/lib/pq" // PostgreSQL driver
)

// DatabaseExporter 数据库导出器
type DatabaseExporter struct {
    tracer trace.Tracer
    db     *sql.DB
    
    // 批量插入优化
    batchSize int
    buffer    []sdktrace.ReadOnlySpan
    mu        sync.Mutex
}

// NewDatabaseExporter 创建数据库导出器
func NewDatabaseExporter(dsn string, batchSize int) (*DatabaseExporter, error) {
    db, err := sql.Open("postgres", dsn)
    if err != nil {
        return nil, err
    }
    
    // 初始化表结构
    if err := initSchema(db); err != nil {
        return nil, err
    }
    
    return &DatabaseExporter{
        tracer:    otel.Tracer("database-exporter"),
        db:        db,
        batchSize: batchSize,
        buffer:    make([]sdktrace.ReadOnlySpan, 0, batchSize),
    }, nil
}

// initSchema 初始化数据库表
func initSchema(db *sql.DB) error {
    schema := `
    CREATE TABLE IF NOT EXISTS spans (
        trace_id TEXT NOT NULL,
        span_id TEXT NOT NULL PRIMARY KEY,
        parent_span_id TEXT,
        name TEXT NOT NULL,
        start_time TIMESTAMP NOT NULL,
        end_time TIMESTAMP NOT NULL,
        duration_ns BIGINT,
        status_code TEXT,
        attributes JSONB,
        events JSONB,
        created_at TIMESTAMP DEFAULT NOW()
    );
    
    CREATE INDEX IF NOT EXISTS idx_spans_trace_id ON spans(trace_id);
    CREATE INDEX IF NOT EXISTS idx_spans_start_time ON spans(start_time);
    `
    
    _, err := db.Exec(schema)
    return err
}

// ExportSpans 实现 SpanExporter 接口
func (de *DatabaseExporter) ExportSpans(ctx context.Context, spans []sdktrace.ReadOnlySpan) error {
    ctx, span := de.tracer.Start(ctx, "export-spans-to-database")
    defer span.End()
    
    de.mu.Lock()
    defer de.mu.Unlock()
    
    // 批量插入
    tx, err := de.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    stmt, err := tx.PrepareContext(ctx, `
        INSERT INTO spans (trace_id, span_id, parent_span_id, name, start_time, end_time, duration_ns, status_code, attributes, events)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        ON CONFLICT (span_id) DO NOTHING
    `)
    if err != nil {
        return err
    }
    defer stmt.Close()
    
    for _, s := range spans {
        parentSpanID := ""
        if s.Parent().IsValid() {
            parentSpanID = s.Parent().SpanID().String()
        }
        
        duration := s.EndTime().Sub(s.StartTime()).Nanoseconds()
        
        attributesJSON, _ := json.Marshal(attributesToMap(s.Attributes()))
        eventsJSON, _ := json.Marshal(eventsToSlice(s.Events()))
        
        _, err := stmt.ExecContext(ctx,
            s.SpanContext().TraceID().String(),
            s.SpanContext().SpanID().String(),
            parentSpanID,
            s.Name(),
            s.StartTime(),
            s.EndTime(),
            duration,
            s.Status().Code.String(),
            attributesJSON,
            eventsJSON,
        )
        
        if err != nil {
            span.RecordError(err)
            return err
        }
    }
    
    if err := tx.Commit(); err != nil {
        return err
    }
    
    span.SetAttributes(attribute.Int("database.inserted_rows", len(spans)))
    
    return nil
}

// Shutdown 实现 SpanExporter 接口
func (de *DatabaseExporter) Shutdown(ctx context.Context) error {
    return de.db.Close()
}

// Query 示例:查询 Trace
func (de *DatabaseExporter) QueryTrace(ctx context.Context, traceID string) ([]map[string]interface{}, error) {
    rows, err := de.db.QueryContext(ctx, `
        SELECT span_id, name, start_time, end_time, duration_ns, attributes
        FROM spans
        WHERE trace_id = $1
        ORDER BY start_time
    `, traceID)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var spans []map[string]interface{}
    for rows.Next() {
        var spanID, name string
        var startTime, endTime time.Time
        var duration int64
        var attributesJSON []byte
        
        if err := rows.Scan(&spanID, &name, &startTime, &endTime, &duration, &attributesJSON); err != nil {
            return nil, err
        }
        
        var attributes map[string]interface{}
        json.Unmarshal(attributesJSON, &attributes)
        
        spans = append(spans, map[string]interface{}{
            "span_id":     spanID,
            "name":        name,
            "start_time":  startTime,
            "end_time":    endTime,
            "duration_ms": float64(duration) / 1e6,
            "attributes":  attributes,
        })
    }
    
    return spans, nil
}
```

### 3.3 多目标导出器

同时导出到多个目标(Composite Pattern)。

```go
// MultiExporter 多目标导出器
type MultiExporter struct {
    tracer    trace.Tracer
    exporters []sdktrace.SpanExporter
    
    // 容错配置
    continueOnError bool
}

// NewMultiExporter 创建多目标导出器
func NewMultiExporter(exporters ...sdktrace.SpanExporter) *MultiExporter {
    return &MultiExporter{
        tracer:          otel.Tracer("multi-exporter"),
        exporters:       exporters,
        continueOnError: true, // 一个失败不影响其他导出器
    }
}

// ExportSpans 实现 SpanExporter 接口
func (me *MultiExporter) ExportSpans(ctx context.Context, spans []sdktrace.ReadOnlySpan) error {
    ctx, span := me.tracer.Start(ctx, "export-spans-multi")
    defer span.End()
    
    span.SetAttributes(
        attribute.Int("exporter.count", len(me.exporters)),
        attribute.Int("span.count", len(spans)),
    )
    
    var errs []error
    successCount := 0
    
    for i, exporter := range me.exporters {
        exporterSpan := trace.SpanFromContext(ctx)
        exporterSpan.AddEvent(fmt.Sprintf("exporting-to-exporter-%d", i))
        
        if err := exporter.ExportSpans(ctx, spans); err != nil {
            errs = append(errs, fmt.Errorf("exporter %d failed: %w", i, err))
            span.AddEvent("export-failed", trace.WithAttributes(
                attribute.Int("exporter.index", i),
                attribute.String("error", err.Error()),
            ))
            
            if !me.continueOnError {
                return err
            }
        } else {
            successCount++
        }
    }
    
    span.SetAttributes(
        attribute.Int("exporter.success_count", successCount),
        attribute.Int("exporter.failure_count", len(errs)),
    )
    
    if len(errs) > 0 && !me.continueOnError {
        return fmt.Errorf("multi-export failed: %v", errs)
    }
    
    return nil
}

// Shutdown 实现 SpanExporter 接口
func (me *MultiExporter) Shutdown(ctx context.Context) error {
    var errs []error
    
    for i, exporter := range me.exporters {
        if err := exporter.Shutdown(ctx); err != nil {
            errs = append(errs, fmt.Errorf("exporter %d shutdown failed: %w", i, err))
        }
    }
    
    if len(errs) > 0 {
        return fmt.Errorf("multi-shutdown failed: %v", errs)
    }
    
    return nil
}

// 使用示例
func ExampleMultiExporter() {
    // 同时导出到文件和数据库
    fileExporter, _ := NewFileExporter("traces.jsonl")
    dbExporter, _ := NewDatabaseExporter("postgres://localhost/traces", 100)
    
    multiExporter := NewMultiExporter(fileExporter, dbExporter)
    
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(multiExporter),
    )
    defer tp.Shutdown(context.Background())
    
    otel.SetTracerProvider(tp)
}
```

---

## 4. 自定义 Processor 实现

### 4.1 过滤处理器

根据条件过滤 Span,减少导出数据量。

```go
package customprocessor

import (
    "context"
    "strings"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    "go.opentelemetry.io/otel/trace"
)

// FilterProcessor 过滤处理器
type FilterProcessor struct {
    tracer    trace.Tracer
    next      sdktrace.SpanProcessor
    
    // 过滤规则
    excludeNames  []string          // 排除的 Span 名称
    excludeAttrs  map[string]string // 排除的属性键值对
    minDuration   time.Duration     // 最小持续时间
    
    // 统计
    totalSpans    int64
    filteredSpans int64
}

// NewFilterProcessor 创建过滤处理器
func NewFilterProcessor(
    next sdktrace.SpanProcessor,
    excludeNames []string,
    excludeAttrs map[string]string,
    minDuration time.Duration,
) *FilterProcessor {
    return &FilterProcessor{
        tracer:       otel.Tracer("filter-processor"),
        next:         next,
        excludeNames: excludeNames,
        excludeAttrs: excludeAttrs,
        minDuration:  minDuration,
    }
}

// OnStart 实现 SpanProcessor 接口
func (fp *FilterProcessor) OnStart(parent context.Context, s sdktrace.ReadWriteSpan) {
    // 注入过滤标记(在 OnEnd 时检查)
    fp.next.OnStart(parent, s)
}

// OnEnd 实现 SpanProcessor 接口
func (fp *FilterProcessor) OnEnd(s sdktrace.ReadOnlySpan) {
    atomic.AddInt64(&fp.totalSpans, 1)
    
    // 过滤逻辑
    if fp.shouldFilter(s) {
        atomic.AddInt64(&fp.filteredSpans, 1)
        return // 不传递给下一个处理器
    }
    
    fp.next.OnEnd(s)
}

// shouldFilter 判断是否应该过滤
func (fp *FilterProcessor) shouldFilter(s sdktrace.ReadOnlySpan) bool {
    // 1. 检查 Span 名称
    for _, name := range fp.excludeNames {
        if strings.Contains(s.Name(), name) {
            return true
        }
    }
    
    // 2. 检查属性
    for _, attr := range s.Attributes() {
        if expectedValue, exists := fp.excludeAttrs[string(attr.Key)]; exists {
            if attr.Value.AsString() == expectedValue {
                return true
            }
        }
    }
    
    // 3. 检查持续时间
    duration := s.EndTime().Sub(s.StartTime())
    if duration < fp.minDuration {
        return true
    }
    
    return false
}

// ForceFlush 实现 SpanProcessor 接口
func (fp *FilterProcessor) ForceFlush(ctx context.Context) error {
    return fp.next.ForceFlush(ctx)
}

// Shutdown 实现 SpanProcessor 接口
func (fp *FilterProcessor) Shutdown(ctx context.Context) error {
    ctx, span := fp.tracer.Start(ctx, "shutdown-filter-processor")
    defer span.End()
    
    span.SetAttributes(
        attribute.Int64("processor.total_spans", atomic.LoadInt64(&fp.totalSpans)),
        attribute.Int64("processor.filtered_spans", atomic.LoadInt64(&fp.filteredSpans)),
    )
    
    return fp.next.Shutdown(ctx)
}

// 使用示例
func ExampleFilterProcessor() {
    exporter, _ := otlptracegrpc.New(context.Background())
    
    // 创建过滤处理器
    filterProcessor := NewFilterProcessor(
        sdktrace.NewBatchSpanProcessor(exporter),
        []string{"health-check", "metrics"},        // 排除健康检查和指标 Span
        map[string]string{"http.status_code": "200"}, // 排除成功请求(可选)
        5*time.Millisecond,                         // 排除小于 5ms 的 Span
    )
    
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithSpanProcessor(filterProcessor),
    )
    defer tp.Shutdown(context.Background())
    
    otel.SetTracerProvider(tp)
}
```

### 4.2 数据脱敏处理器

自动脱敏敏感信息。

```go
import (
    "regexp"
    "strings"
)

// SensitiveDataProcessor 数据脱敏处理器
type SensitiveDataProcessor struct {
    tracer trace.Tracer
    next   sdktrace.SpanProcessor
    
    // 脱敏规则
    sensitiveKeys []string // 需要脱敏的属性键
    patterns      []*regexp.Regexp // 正则匹配模式
}

// NewSensitiveDataProcessor 创建脱敏处理器
func NewSensitiveDataProcessor(next sdktrace.SpanProcessor) *SensitiveDataProcessor {
    return &SensitiveDataProcessor{
        tracer: otel.Tracer("sensitive-data-processor"),
        next:   next,
        sensitiveKeys: []string{
            "password", "secret", "token", "api_key",
            "credit_card", "ssn", "email",
        },
        patterns: []*regexp.Regexp{
            regexp.MustCompile(`\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b`), // Email
            regexp.MustCompile(`\b\d{3}-\d{2}-\d{4}\b`),                                // SSN
            regexp.MustCompile(`\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b`),          // Credit Card
        },
    }
}

// OnStart 实现 SpanProcessor 接口
func (sdp *SensitiveDataProcessor) OnStart(parent context.Context, s sdktrace.ReadWriteSpan) {
    sdp.sanitizeSpan(s)
    sdp.next.OnStart(parent, s)
}

// OnEnd 实现 SpanProcessor 接口
func (sdp *SensitiveDataProcessor) OnEnd(s sdktrace.ReadOnlySpan) {
    // 注意:ReadOnlySpan 无法修改,脱敏应在 OnStart 时完成
    sdp.next.OnEnd(s)
}

// sanitizeSpan 脱敏 Span 数据
func (sdp *SensitiveDataProcessor) sanitizeSpan(s sdktrace.ReadWriteSpan) {
    // 1. 脱敏 Span 名称
    s.SetName(sdp.sanitizeString(s.Name()))
    
    // 2. 脱敏属性
    for _, attr := range s.Attributes() {
        key := string(attr.Key)
        value := attr.Value.AsString()
        
        // 检查敏感键
        if sdp.isSensitiveKey(key) {
            s.SetAttributes(attribute.String(key, "***REDACTED***"))
            continue
        }
        
        // 检查值是否包含敏感信息
        sanitized := sdp.sanitizeString(value)
        if sanitized != value {
            s.SetAttributes(attribute.String(key, sanitized))
        }
    }
}

// isSensitiveKey 检查是否为敏感键
func (sdp *SensitiveDataProcessor) isSensitiveKey(key string) bool {
    lowerKey := strings.ToLower(key)
    for _, sensitive := range sdp.sensitiveKeys {
        if strings.Contains(lowerKey, sensitive) {
            return true
        }
    }
    return false
}

// sanitizeString 脱敏字符串
func (sdp *SensitiveDataProcessor) sanitizeString(s string) string {
    for _, pattern := range sdp.patterns {
        s = pattern.ReplaceAllString(s, "***REDACTED***")
    }
    return s
}

// ForceFlush 实现 SpanProcessor 接口
func (sdp *SensitiveDataProcessor) ForceFlush(ctx context.Context) error {
    return sdp.next.ForceFlush(ctx)
}

// Shutdown 实现 SpanProcessor 接口
func (sdp *SensitiveDataProcessor) Shutdown(ctx context.Context) error {
    return sdp.next.Shutdown(ctx)
}

// 使用示例
func ExampleSensitiveDataProcessor() {
    exporter, _ := otlptracegrpc.New(context.Background())
    batchProcessor := sdktrace.NewBatchSpanProcessor(exporter)
    
    // 在 BatchProcessor 之前添加脱敏处理器
    sensitiveProcessor := NewSensitiveDataProcessor(batchProcessor)
    
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithSpanProcessor(sensitiveProcessor),
    )
    defer tp.Shutdown(context.Background())
    
    otel.SetTracerProvider(tp)
    
    // 测试脱敏
    tracer := otel.Tracer("example")
    _, span := tracer.Start(context.Background(), "user-login")
    span.SetAttributes(
        attribute.String("email", "user@example.com"),     // 会被脱敏
        attribute.String("password", "secret123"),         // 会被脱敏
        attribute.String("username", "john_doe"),          // 不会被脱敏
    )
    span.End()
}
```

### 4.3 属性增强处理器

自动添加环境、主机、版本等信息。

```go
import (
    "os"
    "runtime"
)

// EnrichmentProcessor 属性增强处理器
type EnrichmentProcessor struct {
    tracer trace.Tracer
    next   sdktrace.SpanProcessor
    
    // 全局属性
    globalAttrs []attribute.KeyValue
}

// NewEnrichmentProcessor 创建增强处理器
func NewEnrichmentProcessor(next sdktrace.SpanProcessor, globalAttrs []attribute.KeyValue) *EnrichmentProcessor {
    // 自动添加环境信息
    enrichedAttrs := append(globalAttrs,
        attribute.String("host.name", getHostname()),
        attribute.String("os.type", runtime.GOOS),
        attribute.String("os.arch", runtime.GOARCH),
        attribute.String("runtime.version", runtime.Version()),
        attribute.Int("runtime.num_cpu", runtime.NumCPU()),
    )
    
    return &EnrichmentProcessor{
        tracer:      otel.Tracer("enrichment-processor"),
        next:        next,
        globalAttrs: enrichedAttrs,
    }
}

// OnStart 实现 SpanProcessor 接口
func (ep *EnrichmentProcessor) OnStart(parent context.Context, s sdktrace.ReadWriteSpan) {
    // 添加全局属性
    s.SetAttributes(ep.globalAttrs...)
    
    // 添加时间戳
    s.SetAttributes(attribute.Int64("span.start_time_unix", time.Now().Unix()))
    
    // 从 Context 提取自定义属性
    if requestID := parent.Value("request-id"); requestID != nil {
        s.SetAttributes(attribute.String("request.id", requestID.(string)))
    }
    
    ep.next.OnStart(parent, s)
}

// OnEnd 实现 SpanProcessor 接口
func (ep *EnrichmentProcessor) OnEnd(s sdktrace.ReadOnlySpan) {
    ep.next.OnEnd(s)
}

// ForceFlush 实现 SpanProcessor 接口
func (ep *EnrichmentProcessor) ForceFlush(ctx context.Context) error {
    return ep.next.ForceFlush(ctx)
}

// Shutdown 实现 SpanProcessor 接口
func (ep *EnrichmentProcessor) Shutdown(ctx context.Context) error {
    return ep.next.Shutdown(ctx)
}

// 辅助函数
func getHostname() string {
    hostname, err := os.Hostname()
    if err != nil {
        return "unknown"
    }
    return hostname
}

// 使用示例
func ExampleEnrichmentProcessor() {
    exporter, _ := otlptracegrpc.New(context.Background())
    batchProcessor := sdktrace.NewBatchSpanProcessor(exporter)
    
    // 创建增强处理器
    enrichmentProcessor := NewEnrichmentProcessor(batchProcessor, []attribute.KeyValue{
        attribute.String("service.name", "my-api"),
        attribute.String("service.version", "v1.2.3"),
        attribute.String("deployment.environment", "production"),
    })
    
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithSpanProcessor(enrichmentProcessor),
    )
    defer tp.Shutdown(context.Background())
    
    otel.SetTracerProvider(tp)
}
```

---

## 5. 自定义 Sampler 实现

### 5.1 动态采样器

根据运行时条件调整采样率。

```go
package customsampler

import (
    "sync/atomic"
    
    "go.opentelemetry.io/otel/sdk/trace"
)

// DynamicSampler 动态采样器
type DynamicSampler struct {
    samplingRate atomic.Value // float64: 0.0 - 1.0
}

// NewDynamicSampler 创建动态采样器
func NewDynamicSampler(initialRate float64) *DynamicSampler {
    ds := &DynamicSampler{}
    ds.SetSamplingRate(initialRate)
    return ds
}

// ShouldSample 实现 Sampler 接口
func (ds *DynamicSampler) ShouldSample(params trace.SamplingParameters) trace.SamplingResult {
    rate := ds.samplingRate.Load().(float64)
    
    // 使用 TraceID 的哈希值决定是否采样(确保一致性)
    traceIDBytes := params.TraceID[:]
    hash := uint64(0)
    for _, b := range traceIDBytes {
        hash = hash*31 + uint64(b)
    }
    
    threshold := uint64(rate * float64(^uint64(0)))
    
    if hash <= threshold {
        return trace.SamplingResult{
            Decision:   trace.RecordAndSample,
            Attributes: []attribute.KeyValue{attribute.Float64("sampling.rate", rate)},
        }
    }
    
    return trace.SamplingResult{
        Decision: trace.Drop,
    }
}

// Description 实现 Sampler 接口
func (ds *DynamicSampler) Description() string {
    rate := ds.samplingRate.Load().(float64)
    return fmt.Sprintf("DynamicSampler{rate=%.4f}", rate)
}

// SetSamplingRate 动态调整采样率
func (ds *DynamicSampler) SetSamplingRate(rate float64) {
    if rate < 0 {
        rate = 0
    } else if rate > 1 {
        rate = 1
    }
    ds.samplingRate.Store(rate)
}

// GetSamplingRate 获取当前采样率
func (ds *DynamicSampler) GetSamplingRate() float64 {
    return ds.samplingRate.Load().(float64)
}

// 使用示例:根据系统负载调整采样率
func ExampleDynamicSampler() {
    sampler := NewDynamicSampler(0.1) // 初始 10%
    
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithSampler(sampler),
    )
    defer tp.Shutdown(context.Background())
    
    otel.SetTracerProvider(tp)
    
    // 监控系统负载并调整采样率
    go func() {
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()
        
        for range ticker.C {
            load := getSystemLoad() // 假设函数
            
            if load > 0.8 {
                sampler.SetSamplingRate(0.01) // 高负载:降低到 1%
            } else if load < 0.3 {
                sampler.SetSamplingRate(0.5)  // 低负载:提高到 50%
            } else {
                sampler.SetSamplingRate(0.1)  // 中等负载:10%
            }
        }
    }()
}
```

### 5.2 基于规则的采样器

根据 Span 属性决定采样。

```go
// RuleBasedSampler 基于规则的采样器
type RuleBasedSampler struct {
    rules       []SamplingRule
    defaultRate float64
}

// SamplingRule 采样规则
type SamplingRule struct {
    SpanNamePattern *regexp.Regexp
    AttributeMatch  map[string]string
    SamplingRate    float64
}

// NewRuleBasedSampler 创建规则采样器
func NewRuleBasedSampler(rules []SamplingRule, defaultRate float64) *RuleBasedSampler {
    return &RuleBasedSampler{
        rules:       rules,
        defaultRate: defaultRate,
    }
}

// ShouldSample 实现 Sampler 接口
func (rbs *RuleBasedSampler) ShouldSample(params trace.SamplingParameters) trace.SamplingResult {
    // 1. 匹配规则
    for _, rule := range rbs.rules {
        if rbs.matchesRule(params, rule) {
            return rbs.sampleWithRate(params, rule.SamplingRate, fmt.Sprintf("rule: %v", rule))
        }
    }
    
    // 2. 使用默认采样率
    return rbs.sampleWithRate(params, rbs.defaultRate, "default")
}

// matchesRule 检查是否匹配规则
func (rbs *RuleBasedSampler) matchesRule(params trace.SamplingParameters, rule SamplingRule) bool {
    // 检查 Span 名称
    if rule.SpanNamePattern != nil && !rule.SpanNamePattern.MatchString(params.Name) {
        return false
    }
    
    // 检查属性
    if len(rule.AttributeMatch) > 0 {
        for key, expectedValue := range rule.AttributeMatch {
            found := false
            for _, attr := range params.Attributes {
                if string(attr.Key) == key && attr.Value.AsString() == expectedValue {
                    found = true
                    break
                }
            }
            if !found {
                return false
            }
        }
    }
    
    return true
}

// sampleWithRate 根据采样率决定
func (rbs *RuleBasedSampler) sampleWithRate(params trace.SamplingParameters, rate float64, reason string) trace.SamplingResult {
    traceIDBytes := params.TraceID[:]
    hash := uint64(0)
    for _, b := range traceIDBytes {
        hash = hash*31 + uint64(b)
    }
    
    threshold := uint64(rate * float64(^uint64(0)))
    
    if hash <= threshold {
        return trace.SamplingResult{
            Decision: trace.RecordAndSample,
            Attributes: []attribute.KeyValue{
                attribute.Float64("sampling.rate", rate),
                attribute.String("sampling.reason", reason),
            },
        }
    }
    
    return trace.SamplingResult{
        Decision: trace.Drop,
    }
}

// Description 实现 Sampler 接口
func (rbs *RuleBasedSampler) Description() string {
    return fmt.Sprintf("RuleBasedSampler{rules=%d, default=%.4f}", len(rbs.rules), rbs.defaultRate)
}

// 使用示例
func ExampleRuleBasedSampler() {
    rules := []SamplingRule{
        {
            // 所有错误 Span 100% 采样
            AttributeMatch: map[string]string{"error": "true"},
            SamplingRate:   1.0,
        },
        {
            // 慢请求(>1s)100% 采样
            AttributeMatch: map[string]string{"slow_request": "true"},
            SamplingRate:   1.0,
        },
        {
            // 健康检查 0% 采样
            SpanNamePattern: regexp.MustCompile(`^health-check`),
            SamplingRate:    0.0,
        },
        {
            // 支付相关 50% 采样
            SpanNamePattern: regexp.MustCompile(`payment`),
            SamplingRate:    0.5,
        },
    }
    
    sampler := NewRuleBasedSampler(rules, 0.1) // 默认 10%
    
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithSampler(sampler),
    )
    defer tp.Shutdown(context.Background())
    
    otel.SetTracerProvider(tp)
}
```

### 5.3 自适应采样器

根据历史数据自动调整采样率。

```go
import (
    "time"
)

// AdaptiveSampler 自适应采样器
type AdaptiveSampler struct {
    tracer trace.Tracer
    
    // 目标指标
    targetSpansPerSecond int
    
    // 当前状态
    currentRate      atomic.Value // float64
    spansInLastPeriod int64
    lastAdjustment    time.Time
    mu                sync.RWMutex
    
    // 调整参数
    adjustmentInterval time.Duration
    minRate            float64
    maxRate            float64
}

// NewAdaptiveSampler 创建自适应采样器
func NewAdaptiveSampler(targetSpansPerSecond int) *AdaptiveSampler {
    as := &AdaptiveSampler{
        tracer:               otel.Tracer("adaptive-sampler"),
        targetSpansPerSecond: targetSpansPerSecond,
        lastAdjustment:       time.Now(),
        adjustmentInterval:   10 * time.Second,
        minRate:              0.001, // 最小 0.1%
        maxRate:              1.0,   // 最大 100%
    }
    
    as.currentRate.Store(0.1) // 初始 10%
    
    go as.periodicAdjustment()
    
    return as
}

// ShouldSample 实现 Sampler 接口
func (as *AdaptiveSampler) ShouldSample(params trace.SamplingParameters) trace.SamplingResult {
    rate := as.currentRate.Load().(float64)
    
    atomic.AddInt64(&as.spansInLastPeriod, 1)
    
    traceIDBytes := params.TraceID[:]
    hash := uint64(0)
    for _, b := range traceIDBytes {
        hash = hash*31 + uint64(b)
    }
    
    threshold := uint64(rate * float64(^uint64(0)))
    
    if hash <= threshold {
        return trace.SamplingResult{
            Decision: trace.RecordAndSample,
            Attributes: []attribute.KeyValue{
                attribute.Float64("sampling.rate", rate),
                attribute.String("sampling.strategy", "adaptive"),
            },
        }
    }
    
    return trace.SamplingResult{
        Decision: trace.Drop,
    }
}

// Description 实现 Sampler 接口
func (as *AdaptiveSampler) Description() string {
    rate := as.currentRate.Load().(float64)
    return fmt.Sprintf("AdaptiveSampler{rate=%.4f, target=%d spans/sec}", rate, as.targetSpansPerSecond)
}

// periodicAdjustment 定期调整采样率
func (as *AdaptiveSampler) periodicAdjustment() {
    ticker := time.NewTicker(as.adjustmentInterval)
    defer ticker.Stop()
    
    for range ticker.C {
        as.adjustSamplingRate()
    }
}

// adjustSamplingRate 调整采样率
func (as *AdaptiveSampler) adjustSamplingRate() {
    ctx, span := as.tracer.Start(context.Background(), "adjust-sampling-rate")
    defer span.End()
    
    // 计算实际 Span 速率
    spansCount := atomic.SwapInt64(&as.spansInLastPeriod, 0)
    elapsed := time.Since(as.lastAdjustment).Seconds()
    actualRate := float64(spansCount) / elapsed
    
    currentSamplingRate := as.currentRate.Load().(float64)
    sampledRate := actualRate * currentSamplingRate
    
    // 计算新采样率
    var newRate float64
    if sampledRate < float64(as.targetSpansPerSecond) {
        // 实际采样数低于目标,提高采样率
        adjustment := 1.2
        newRate = currentSamplingRate * adjustment
    } else {
        // 实际采样数高于目标,降低采样率
        adjustment := float64(as.targetSpansPerSecond) / sampledRate
        newRate = currentSamplingRate * adjustment
    }
    
    // 限制范围
    if newRate < as.minRate {
        newRate = as.minRate
    } else if newRate > as.maxRate {
        newRate = as.maxRate
    }
    
    as.currentRate.Store(newRate)
    as.lastAdjustment = time.Now()
    
    span.SetAttributes(
        attribute.Int64("sampler.total_spans", spansCount),
        attribute.Float64("sampler.actual_rate", actualRate),
        attribute.Float64("sampler.sampled_rate", sampledRate),
        attribute.Float64("sampler.old_sampling_rate", currentSamplingRate),
        attribute.Float64("sampler.new_sampling_rate", newRate),
        attribute.Int("sampler.target_spans_per_sec", as.targetSpansPerSecond),
    )
}

// 使用示例
func ExampleAdaptiveSampler() {
    // 目标:每秒采样 1000 个 Span
    sampler := NewAdaptiveSampler(1000)
    
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithSampler(sampler),
    )
    defer tp.Shutdown(context.Background())
    
    otel.SetTracerProvider(tp)
}
```

---

## 6. 接口组合与装饰器模式

### 6.1 Exporter 链

```go
// ChainExporter 导出器链
type ChainExporter struct {
    exporters []sdktrace.SpanExporter
}

func NewChainExporter(exporters ...sdktrace.SpanExporter) *ChainExporter {
    return &ChainExporter{exporters: exporters}
}

func (ce *ChainExporter) ExportSpans(ctx context.Context, spans []sdktrace.ReadOnlySpan) error {
    for _, exporter := range ce.exporters {
        // 每个导出器依次处理
        if err := exporter.ExportSpans(ctx, spans); err != nil {
            return err // 短路:遇到错误立即返回
        }
    }
    return nil
}

func (ce *ChainExporter) Shutdown(ctx context.Context) error {
    for _, exporter := range ce.exporters {
        if err := exporter.Shutdown(ctx); err != nil {
            return err
        }
    }
    return nil
}
```

### 6.2 Processor 管道

```go
// ProcessorPipeline 处理器管道
type ProcessorPipeline struct {
    processors []sdktrace.SpanProcessor
}

func NewProcessorPipeline(processors ...sdktrace.SpanProcessor) *ProcessorPipeline {
    return &ProcessorPipeline{processors: processors}
}

func (pp *ProcessorPipeline) OnStart(parent context.Context, s sdktrace.ReadWriteSpan) {
    for _, processor := range pp.processors {
        processor.OnStart(parent, s)
    }
}

func (pp *ProcessorPipeline) OnEnd(s sdktrace.ReadOnlySpan) {
    for _, processor := range pp.processors {
        processor.OnEnd(s)
    }
}

func (pp *ProcessorPipeline) ForceFlush(ctx context.Context) error {
    for _, processor := range pp.processors {
        if err := processor.ForceFlush(ctx); err != nil {
            return err
        }
    }
    return nil
}

func (pp *ProcessorPipeline) Shutdown(ctx context.Context) error {
    for _, processor := range pp.processors {
        if err := processor.Shutdown(ctx); err != nil {
            return err
        }
    }
    return nil
}

// 使用示例:组合多个处理器
func ExampleProcessorPipeline() {
    exporter, _ := otlptracegrpc.New(context.Background())
    batchProcessor := sdktrace.NewBatchSpanProcessor(exporter)
    
    pipeline := NewProcessorPipeline(
        NewEnrichmentProcessor(batchProcessor, nil),    // 1. 增强属性
        NewSensitiveDataProcessor(batchProcessor),      // 2. 脱敏
        NewFilterProcessor(batchProcessor, nil, nil, 0), // 3. 过滤
    )
    
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithSpanProcessor(pipeline),
    )
    defer tp.Shutdown(context.Background())
}
```

### 6.3 装饰器模式应用

```go
// RetryExporter 重试装饰器
type RetryExporter struct {
    wrapped    sdktrace.SpanExporter
    maxRetries int
    backoff    time.Duration
}

func NewRetryExporter(wrapped sdktrace.SpanExporter, maxRetries int, backoff time.Duration) *RetryExporter {
    return &RetryExporter{
        wrapped:    wrapped,
        maxRetries: maxRetries,
        backoff:    backoff,
    }
}

func (re *RetryExporter) ExportSpans(ctx context.Context, spans []sdktrace.ReadOnlySpan) error {
    var err error
    
    for attempt := 0; attempt <= re.maxRetries; attempt++ {
        err = re.wrapped.ExportSpans(ctx, spans)
        
        if err == nil {
            return nil // 成功
        }
        
        if attempt < re.maxRetries {
            time.Sleep(re.backoff * time.Duration(attempt+1)) // 指数退避
        }
    }
    
    return fmt.Errorf("export failed after %d retries: %w", re.maxRetries, err)
}

func (re *RetryExporter) Shutdown(ctx context.Context) error {
    return re.wrapped.Shutdown(ctx)
}
```

---

## 7. 插件化架构设计

### 7.1 插件注册机制

```go
package plugin

import (
    "sync"
    
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
)

// PluginRegistry 插件注册表
type PluginRegistry struct {
    exporters  map[string]func() (sdktrace.SpanExporter, error)
    processors map[string]func(sdktrace.SpanProcessor) sdktrace.SpanProcessor
    samplers   map[string]func() sdktrace.Sampler
    mu         sync.RWMutex
}

var globalRegistry = &PluginRegistry{
    exporters:  make(map[string]func() (sdktrace.SpanExporter, error)),
    processors: make(map[string]func(sdktrace.SpanProcessor) sdktrace.SpanProcessor),
    samplers:   make(map[string]func() sdktrace.Sampler),
}

// RegisterExporter 注册导出器工厂
func RegisterExporter(name string, factory func() (sdktrace.SpanExporter, error)) {
    globalRegistry.mu.Lock()
    defer globalRegistry.mu.Unlock()
    
    globalRegistry.exporters[name] = factory
}

// RegisterProcessor 注册处理器工厂
func RegisterProcessor(name string, factory func(sdktrace.SpanProcessor) sdktrace.SpanProcessor) {
    globalRegistry.mu.Lock()
    defer globalRegistry.mu.Unlock()
    
    globalRegistry.processors[name] = factory
}

// RegisterSampler 注册采样器工厂
func RegisterSampler(name string, factory func() sdktrace.Sampler) {
    globalRegistry.mu.Lock()
    defer globalRegistry.mu.Unlock()
    
    globalRegistry.samplers[name] = factory
}

// GetExporter 获取导出器
func GetExporter(name string) (sdktrace.SpanExporter, error) {
    globalRegistry.mu.RLock()
    factory, exists := globalRegistry.exporters[name]
    globalRegistry.mu.RUnlock()
    
    if !exists {
        return nil, fmt.Errorf("exporter '%s' not registered", name)
    }
    
    return factory()
}

// GetProcessor 获取处理器
func GetProcessor(name string, next sdktrace.SpanProcessor) (sdktrace.SpanProcessor, error) {
    globalRegistry.mu.RLock()
    factory, exists := globalRegistry.processors[name]
    globalRegistry.mu.RUnlock()
    
    if !exists {
        return nil, fmt.Errorf("processor '%s' not registered", name)
    }
    
    return factory(next), nil
}

// GetSampler 获取采样器
func GetSampler(name string) (sdktrace.Sampler, error) {
    globalRegistry.mu.RLock()
    factory, exists := globalRegistry.samplers[name]
    globalRegistry.mu.RUnlock()
    
    if !exists {
        return nil, fmt.Errorf("sampler '%s' not registered", name)
    }
    
    return factory(), nil
}

// 使用示例:注册插件
func init() {
    // 注册文件导出器
    RegisterExporter("file", func() (sdktrace.SpanExporter, error) {
        return NewFileExporter("traces.jsonl")
    })
    
    // 注册脱敏处理器
    RegisterProcessor("sensitive", func(next sdktrace.SpanProcessor) sdktrace.SpanProcessor {
        return NewSensitiveDataProcessor(next)
    })
    
    // 注册动态采样器
    RegisterSampler("dynamic", func() sdktrace.Sampler {
        return NewDynamicSampler(0.1)
    })
}

// 使用插件
func ExamplePluginSystem() {
    // 1. 获取导出器
    exporter, _ := GetExporter("file")
    
    // 2. 获取采样器
    sampler, _ := GetSampler("dynamic")
    
    // 3. 创建 TracerProvider
    batchProcessor := sdktrace.NewBatchSpanProcessor(exporter)
    
    // 4. 动态添加处理器
    processor, _ := GetProcessor("sensitive", batchProcessor)
    
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithSpanProcessor(processor),
        sdktrace.WithSampler(sampler),
    )
    defer tp.Shutdown(context.Background())
    
    otel.SetTracerProvider(tp)
}
```

### 7.2 动态加载插件

```go
// PluginConfig 插件配置
type PluginConfig struct {
    Exporters  []ExporterConfig  `yaml:"exporters"`
    Processors []ProcessorConfig `yaml:"processors"`
    Samplers   []SamplerConfig   `yaml:"samplers"`
}

type ExporterConfig struct {
    Name   string                 `yaml:"name"`
    Type   string                 `yaml:"type"`
    Config map[string]interface{} `yaml:"config"`
}

type ProcessorConfig struct {
    Name   string                 `yaml:"name"`
    Type   string                 `yaml:"type"`
    Config map[string]interface{} `yaml:"config"`
}

type SamplerConfig struct {
    Type   string                 `yaml:"type"`
    Config map[string]interface{} `yaml:"config"`
}

// LoadFromConfig 从配置文件加载插件
func LoadFromConfig(configPath string) (*sdktrace.TracerProvider, error) {
    // 1. 读取配置
    data, err := os.ReadFile(configPath)
    if err != nil {
        return nil, err
    }
    
    var config PluginConfig
    if err := yaml.Unmarshal(data, &config); err != nil {
        return nil, err
    }
    
    // 2. 创建导出器
    var exporters []sdktrace.SpanExporter
    for _, exporterCfg := range config.Exporters {
        exporter, err := GetExporter(exporterCfg.Type)
        if err != nil {
            return nil, err
        }
        exporters = append(exporters, exporter)
    }
    
    // 3. 创建处理器链
    var processor sdktrace.SpanProcessor
    if len(exporters) > 0 {
        processor = sdktrace.NewBatchSpanProcessor(exporters[0])
    }
    
    for _, processorCfg := range config.Processors {
        processor, err = GetProcessor(processorCfg.Type, processor)
        if err != nil {
            return nil, err
        }
    }
    
    // 4. 创建采样器
    var sampler sdktrace.Sampler = sdktrace.AlwaysSample()
    if len(config.Samplers) > 0 {
        sampler, err = GetSampler(config.Samplers[0].Type)
        if err != nil {
            return nil, err
        }
    }
    
    // 5. 创建 TracerProvider
    return sdktrace.NewTracerProvider(
        sdktrace.WithSpanProcessor(processor),
        sdktrace.WithSampler(sampler),
    ), nil
}
```

### 7.3 插件配置管理

```yaml
# plugins.yaml
exporters:
  - name: otlp
    type: grpc
    config:
      endpoint: localhost:4317
      insecure: true
  
  - name: file
    type: file
    config:
      path: /var/log/traces.jsonl

processors:
  - name: enrichment
    type: enrichment
    config:
      global_attributes:
        service.name: my-api
        service.version: v1.0.0
  
  - name: sensitive
    type: sensitive
    config:
      sensitive_keys:
        - password
        - token

samplers:
  - type: dynamic
    config:
      initial_rate: 0.1
      target_spans_per_second: 1000
```

---

## 8. 泛型接口设计

### 8.1 通用导出器接口

```go
// GenericExporter 泛型导出器接口(Go 1.25.1)
type GenericExporter[T any] interface {
    Export(ctx context.Context, data []T) error
    Shutdown(ctx context.Context) error
}

// TypedSpanExporter 类型安全的 Span 导出器
type TypedSpanExporter[T sdktrace.ReadOnlySpan] struct {
    exporter GenericExporter[T]
}

func (tse *TypedSpanExporter[T]) ExportSpans(ctx context.Context, spans []sdktrace.ReadOnlySpan) error {
    typedSpans := make([]T, len(spans))
    for i, span := range spans {
        typedSpans[i] = span.(T)
    }
    return tse.exporter.Export(ctx, typedSpans)
}
```

### 8.2 类型安全的处理器

```go
// GenericProcessor 泛型处理器
type GenericProcessor[T any] interface {
    Process(ctx context.Context, item T) error
}

// TypedProcessor 类型安全的处理器包装
type TypedProcessor[T any] struct {
    processor GenericProcessor[T]
    next      sdktrace.SpanProcessor
}

func NewTypedProcessor[T any](processor GenericProcessor[T], next sdktrace.SpanProcessor) *TypedProcessor[T] {
    return &TypedProcessor[T]{
        processor: processor,
        next:      next,
    }
}
```

### 8.3 泛型采样器

```go
// GenericSampler 泛型采样器
type GenericSampler[T any] interface {
    ShouldSample(item T) bool
}

// TypedSampler 类型安全的采样器
type TypedSampler[T trace.SamplingParameters] struct {
    sampler GenericSampler[T]
}

func (ts *TypedSampler[T]) ShouldSample(params trace.SamplingParameters) trace.SamplingResult {
    if ts.sampler.ShouldSample(params.(T)) {
        return trace.SamplingResult{Decision: trace.RecordAndSample}
    }
    return trace.SamplingResult{Decision: trace.Drop}
}
```

---

## 9. 最佳实践与模式

### 综合示例

```go
package main

import (
    "context"
    
    "go.opentelemetry.io/otel"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
)

func SetupAdvancedTracing(ctx context.Context) (*sdktrace.TracerProvider, error) {
    // 1. 创建多目标导出器
    fileExporter, _ := NewFileExporter("traces.jsonl")
    dbExporter, _ := NewDatabaseExporter("postgres://localhost/traces", 100)
    multiExporter := NewMultiExporter(fileExporter, dbExporter)
    
    // 2. 构建处理器管道
    batchProcessor := sdktrace.NewBatchSpanProcessor(multiExporter)
    
    pipeline := NewProcessorPipeline(
        NewEnrichmentProcessor(batchProcessor, []attribute.KeyValue{
            attribute.String("service.name", "advanced-api"),
            attribute.String("deployment.environment", "production"),
        }),
        NewSensitiveDataProcessor(batchProcessor),
        NewFilterProcessor(batchProcessor, []string{"health-check"}, nil, 5*time.Millisecond),
    )
    
    // 3. 创建自适应采样器
    sampler := NewAdaptiveSampler(1000) // 每秒 1000 个 Span
    
    // 4. 创建 TracerProvider
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithSpanProcessor(pipeline),
        sdktrace.WithSampler(sampler),
        sdktrace.WithResource(resource.NewWithAttributes(
            semconv.SchemaURL,
            semconv.ServiceName("advanced-api"),
            semconv.ServiceVersion("v1.2.3"),
        )),
    )
    
    otel.SetTracerProvider(tp)
    
    return tp, nil
}

func main() {
    ctx := context.Background()
    
    tp, err := SetupAdvancedTracing(ctx)
    if err != nil {
        panic(err)
    }
    defer tp.Shutdown(ctx)
    
    // 使用追踪
    tracer := otel.Tracer("main")
    ctx, span := tracer.Start(ctx, "main-operation")
    defer span.End()
    
    // 业务逻辑...
}
```

---

## 总结

本指南涵盖了 Go 1.25.1 与 OTLP 的接口与抽象层设计:

1. **核心接口**:SpanExporter、SpanProcessor、Sampler
2. **自定义导出器**:文件、数据库、多目标
3. **自定义处理器**:过滤、脱敏、属性增强
4. **自定义采样器**:动态、规则、自适应
5. **设计模式**:装饰器、管道、组合
6. **插件化**:注册机制、动态加载、配置管理
7. **泛型接口**:类型安全的扩展(Go 1.18+)

通过这些技术,可构建灵活、可扩展的 OTLP 集成架构。
