# Go 1.25.1 é«˜çº§ç‰¹æ€§ä¸ OTLP æ·±åº¦é›†æˆ

> **Go ç‰ˆæœ¬**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0+  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ8æ—¥

---

## ğŸ“‹ ç›®å½•

- [Go 1.25.1 é«˜çº§ç‰¹æ€§ä¸ OTLP æ·±åº¦é›†æˆ](#go-1251-é«˜çº§ç‰¹æ€§ä¸-otlp-æ·±åº¦é›†æˆ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [Go 1.25.1 æ ¸å¿ƒç‰¹æ€§](#go-1251-æ ¸å¿ƒç‰¹æ€§)
  - [Go 1.25.1 æ–°ç‰¹æ€§](#go-1251-æ–°ç‰¹æ€§)
    - [1. æ³›å‹çº¦æŸå¢å¼º](#1-æ³›å‹çº¦æŸå¢å¼º)
  - [æ³›å‹ä¸OTLPé›†æˆ](#æ³›å‹ä¸otlpé›†æˆ)
    - [2. ç±»å‹å®‰å…¨çš„Metrics](#2-ç±»å‹å®‰å…¨çš„metrics)
  - [Contextå¢å¼º](#contextå¢å¼º)
    - [3. Context.WithoutCancel å’Œ WithDeadlineCause](#3-contextwithoutcancel-å’Œ-withdeadlinecause)
  - [å¹¶å‘åŸè¯­ä¼˜åŒ–](#å¹¶å‘åŸè¯­ä¼˜åŒ–)
    - [4. sync.OnceFunc å’Œ sync.OnceValue](#4-synconcefunc-å’Œ-synconcevalue)
  - [é”™è¯¯å¤„ç†å¢å¼º](#é”™è¯¯å¤„ç†å¢å¼º)
    - [5. errors.Join å¤šé”™è¯¯åˆå¹¶](#5-errorsjoin-å¤šé”™è¯¯åˆå¹¶)
  - [æ€§èƒ½ä¼˜åŒ–ç‰¹æ€§](#æ€§èƒ½ä¼˜åŒ–ç‰¹æ€§)
    - [6. Profile-Guided Optimization (PGO)](#6-profile-guided-optimization-pgo)
    - [7. ç¼–è¯‘å™¨ä¼˜åŒ–å’Œé€ƒé€¸åˆ†æ](#7-ç¼–è¯‘å™¨ä¼˜åŒ–å’Œé€ƒé€¸åˆ†æ)
  - [æ€»ç»“](#æ€»ç»“)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)

---

## æ¦‚è¿°

Go 1.25.1 å¼•å…¥äº†å¤šé¡¹é«˜çº§ç‰¹æ€§ï¼Œæœ¬æ–‡æ¡£å±•ç¤ºå¦‚ä½•å°†è¿™äº›ç‰¹æ€§ä¸ OpenTelemetry OTLP æ·±åº¦é›†æˆï¼Œå®ç°æ›´é«˜æ•ˆã€æ›´ç±»å‹å®‰å…¨çš„å¯è§‚æµ‹æ€§æ–¹æ¡ˆã€‚

### Go 1.25.1 æ ¸å¿ƒç‰¹æ€§

```text
âœ… æ³›å‹å¢å¼º - ç±»å‹å‚æ•°çº¦æŸä¼˜åŒ–
âœ… Context åŒ…å¢å¼º - WithoutCancel, WithDeadlineCause
âœ… å¹¶å‘åŸè¯­æ”¹è¿› - sync.OnceFunc, sync.OnceValue
âœ… é”™è¯¯å¤„ç†ä¼˜åŒ– - errors.Join å¤šé”™è¯¯åˆå¹¶
âœ… æ€§èƒ½æå‡ - ç¼–è¯‘å™¨ä¼˜åŒ–ã€GC æ”¹è¿›
âœ… PGO ä¼˜åŒ– - Profile-Guided Optimization
```

---

## Go 1.25.1 æ–°ç‰¹æ€§

### 1. æ³›å‹çº¦æŸå¢å¼º

```go
package generics

import (
    "context"
    "fmt"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// Traceable å¯è¿½è¸ªçš„ç±»å‹çº¦æŸ
type Traceable interface {
    GetTraceAttributes() []attribute.KeyValue
    GetSpanName() string
}

// TracedOperation æ³›å‹è¿½è¸ªæ“ä½œ
func TracedOperation[T Traceable](ctx context.Context, operation T, fn func(T) error) error {
    tracer := otel.Tracer("generic-operations")
    
    ctx, span := tracer.Start(ctx, operation.GetSpanName(),
        trace.WithAttributes(operation.GetTraceAttributes()...),
    )
    defer span.End()
    
    if err := fn(operation); err != nil {
        span.RecordError(err)
        return err
    }
    
    return nil
}

// UserOperation ç”¨æˆ·æ“ä½œ
type UserOperation struct {
    UserID   string
    Action   string
    Metadata map[string]string
}

func (u UserOperation) GetTraceAttributes() []attribute.KeyValue {
    attrs := []attribute.KeyValue{
        attribute.String("user.id", u.UserID),
        attribute.String("user.action", u.Action),
    }
    
    for k, v := range u.Metadata {
        attrs = append(attrs, attribute.String("metadata."+k, v))
    }
    
    return attrs
}

func (u UserOperation) GetSpanName() string {
    return fmt.Sprintf("user.%s", u.Action)
}

// ä½¿ç”¨ç¤ºä¾‹
func ProcessUser(ctx context.Context) error {
    op := UserOperation{
        UserID: "user-123",
        Action: "update-profile",
        Metadata: map[string]string{
            "source": "web",
            "version": "v2",
        },
    }
    
    return TracedOperation(ctx, op, func(o UserOperation) error {
        // å®é™…ä¸šåŠ¡é€»è¾‘
        fmt.Printf("Processing user %s: %s\n", o.UserID, o.Action)
        return nil
    })
}

// GenericRepository æ³›å‹ä»“å‚¨æ¨¡å¼
type GenericRepository[T any] struct {
    tracer trace.Tracer
}

func NewRepository[T any](tracerName string) *GenericRepository[T] {
    return &GenericRepository[T]{
        tracer: otel.Tracer(tracerName),
    }
}

func (r *GenericRepository[T]) FindByID(ctx context.Context, id string) (*T, error) {
    ctx, span := r.tracer.Start(ctx, "repository.findById",
        trace.WithAttributes(
            attribute.String("entity.type", fmt.Sprintf("%T", new(T))),
            attribute.String("entity.id", id),
        ),
    )
    defer span.End()
    
    // æ•°æ®åº“æŸ¥è¯¢é€»è¾‘
    var result T
    // ... æŸ¥è¯¢ä»£ç 
    
    return &result, nil
}

func (r *GenericRepository[T]) Save(ctx context.Context, entity *T) error {
    ctx, span := r.tracer.Start(ctx, "repository.save",
        trace.WithAttributes(
            attribute.String("entity.type", fmt.Sprintf("%T", entity)),
        ),
    )
    defer span.End()
    
    // ä¿å­˜é€»è¾‘
    return nil
}

// ç±»å‹å®‰å…¨çš„æ‰¹å¤„ç†æ“ä½œ
type BatchOperation[T any] struct {
    Items   []T
    tracer  trace.Tracer
}

func NewBatchOperation[T any](items []T) *BatchOperation[T] {
    return &BatchOperation[T]{
        Items:  items,
        tracer: otel.Tracer("batch-operations"),
    }
}

func (b *BatchOperation[T]) Process(ctx context.Context, processor func(context.Context, T) error) error {
    ctx, span := b.tracer.Start(ctx, "batch.process",
        trace.WithAttributes(
            attribute.Int("batch.size", len(b.Items)),
            attribute.String("batch.type", fmt.Sprintf("%T", new(T))),
        ),
    )
    defer span.End()
    
    var errors []error
    
    for i, item := range b.Items {
        _, itemSpan := b.tracer.Start(ctx, "batch.process.item",
            trace.WithAttributes(
                attribute.Int("batch.item.index", i),
            ),
        )
        
        if err := processor(ctx, item); err != nil {
            itemSpan.RecordError(err)
            errors = append(errors, err)
        }
        
        itemSpan.End()
    }
    
    if len(errors) > 0 {
        return fmt.Errorf("æ‰¹å¤„ç†å¤±è´¥: %d/%d ä¸ªé¡¹ç›®", len(errors), len(b.Items))
    }
    
    return nil
}
```

---

## æ³›å‹ä¸OTLPé›†æˆ

### 2. ç±»å‹å®‰å…¨çš„Metrics

```go
package metrics

import (
    "context"
    "fmt"
    "sync"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// Numeric æ•°å€¼ç±»å‹çº¦æŸ
type Numeric interface {
    ~int | ~int64 | ~float64
}

// TypedCounter ç±»å‹å®‰å…¨çš„è®¡æ•°å™¨
type TypedCounter[T Numeric] struct {
    counter metric.Int64Counter
    mu      sync.RWMutex
}

func NewTypedCounter[T Numeric](name, description string) (*TypedCounter[T], error) {
    meter := otel.Meter("typed-metrics")
    
    counter, err := meter.Int64Counter(
        name,
        metric.WithDescription(description),
    )
    if err != nil {
        return nil, err
    }
    
    return &TypedCounter[T]{
        counter: counter,
    }, nil
}

func (c *TypedCounter[T]) Add(ctx context.Context, value T, attrs ...attribute.KeyValue) {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    c.counter.Add(ctx, int64(value), metric.WithAttributes(attrs...))
}

// TypedHistogram ç±»å‹å®‰å…¨çš„ç›´æ–¹å›¾
type TypedHistogram[T Numeric] struct {
    histogram metric.Float64Histogram
    mu        sync.RWMutex
}

func NewTypedHistogram[T Numeric](name, description string) (*TypedHistogram[T], error) {
    meter := otel.Meter("typed-metrics")
    
    histogram, err := meter.Float64Histogram(
        name,
        metric.WithDescription(description),
    )
    if err != nil {
        return nil, err
    }
    
    return &TypedHistogram[T]{
        histogram: histogram,
    }, nil
}

func (h *TypedHistogram[T]) Record(ctx context.Context, value T, attrs ...attribute.KeyValue) {
    h.mu.Lock()
    defer h.mu.Unlock()
    
    h.histogram.Record(ctx, float64(value), metric.WithAttributes(attrs...))
}

// MetricsCollector æ³›å‹æŒ‡æ ‡æ”¶é›†å™¨
type MetricsCollector[T any] struct {
    typeName  string
    counter   *TypedCounter[int64]
    histogram *TypedHistogram[float64]
}

func NewMetricsCollector[T any]() (*MetricsCollector[T], error) {
    typeName := fmt.Sprintf("%T", new(T))
    
    counter, err := NewTypedCounter[int64](
        fmt.Sprintf("%s.operations.count", typeName),
        fmt.Sprintf("Total operations for %s", typeName),
    )
    if err != nil {
        return nil, err
    }
    
    histogram, err := NewTypedHistogram[float64](
        fmt.Sprintf("%s.operation.duration", typeName),
        fmt.Sprintf("Operation duration for %s", typeName),
    )
    if err != nil {
        return nil, err
    }
    
    return &MetricsCollector[T]{
        typeName:  typeName,
        counter:   counter,
        histogram: histogram,
    }, nil
}

func (m *MetricsCollector[T]) RecordOperation(ctx context.Context, duration float64, success bool) {
    attrs := []attribute.KeyValue{
        attribute.String("type", m.typeName),
        attribute.Bool("success", success),
    }
    
    m.counter.Add(ctx, 1, attrs...)
    m.histogram.Record(ctx, duration, attrs...)
}
```

---

## Contextå¢å¼º

### 3. Context.WithoutCancel å’Œ WithDeadlineCause

```go
package contextenhanced

import (
    "context"
    "fmt"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
)

// BackgroundTask åå°ä»»åŠ¡ï¼ˆä¸å—çˆ¶contextå–æ¶ˆå½±å“ï¼‰
func BackgroundTask(parentCtx context.Context, taskName string) {
    tracer := otel.Tracer("background-tasks")
    
    // Go 1.25.1: WithoutCancel åˆ›å»ºä¸å—å–æ¶ˆå½±å“çš„context
    // ä¿ç•™traceä¿¡æ¯ï¼Œä½†ä¸ç»§æ‰¿å–æ¶ˆä¿¡å·
    bgCtx := context.WithoutCancel(parentCtx)
    
    ctx, span := tracer.Start(bgCtx, "background-task",
        trace.WithAttributes(
            attribute.String("task.name", taskName),
            attribute.Bool("task.detached", true),
        ),
    )
    defer span.End()
    
    // å³ä½¿çˆ¶contextè¢«å–æ¶ˆï¼Œè¿™ä¸ªä»»åŠ¡ä¹Ÿä¼šç»§ç»­æ‰§è¡Œ
    time.Sleep(2 * time.Second)
    
    span.AddEvent("åå°ä»»åŠ¡å®Œæˆ")
}

// TaskWithCause å¸¦åŸå› çš„è¶…æ—¶å¤„ç†
func TaskWithCause(ctx context.Context, timeout time.Duration) error {
    tracer := otel.Tracer("task-with-cause")
    
    // Go 1.25.1: WithDeadlineCause å¯ä»¥è®¾ç½®è¶…æ—¶åŸå› 
    cause := fmt.Errorf("ä¸šåŠ¡è§„å®šçš„SLAè¶…æ—¶")
    ctx, cancel := context.WithDeadlineCause(
        ctx,
        time.Now().Add(timeout),
        cause,
    )
    defer cancel()
    
    ctx, span := tracer.Start(ctx, "task-with-cause")
    defer span.End()
    
    // æ‰§è¡Œé•¿æ—¶é—´ä»»åŠ¡
    select {
    case <-time.After(3 * time.Second):
        return nil
    case <-ctx.Done():
        // Go 1.25.1: context.Cause è·å–å–æ¶ˆåŸå› 
        if err := context.Cause(ctx); err != nil {
            span.RecordError(err)
            span.SetStatus(codes.Error, err.Error())
            span.SetAttributes(
                attribute.String("cancellation.cause", err.Error()),
            )
            return err
        }
        return ctx.Err()
    }
}

// CascadingTimeouts çº§è”è¶…æ—¶æ§åˆ¶
type CascadingTimeouts struct {
    tracer trace.Tracer
}

func NewCascadingTimeouts() *CascadingTimeouts {
    return &CascadingTimeouts{
        tracer: otel.Tracer("cascading-timeouts"),
    }
}

func (ct *CascadingTimeouts) Execute(ctx context.Context) error {
    ctx, span := ct.tracer.Start(ctx, "cascading-operation")
    defer span.End()
    
    // ç¬¬ä¸€å±‚: æ€»è¶…æ—¶ 5ç§’
    ctx1, cancel1 := context.WithDeadlineCause(
        ctx,
        time.Now().Add(5*time.Second),
        fmt.Errorf("æ€»æ“ä½œè¶…æ—¶"),
    )
    defer cancel1()
    
    // ç¬¬äºŒå±‚: æ•°æ®åº“æŸ¥è¯¢ 2ç§’
    if err := ct.databaseQuery(ctx1); err != nil {
        span.RecordError(err)
        return err
    }
    
    // ç¬¬ä¸‰å±‚: APIè°ƒç”¨ 3ç§’ï¼ˆä½†ä¸èƒ½è¶…è¿‡å‰©ä½™æ—¶é—´ï¼‰
    if err := ct.apiCall(ctx1); err != nil {
        span.RecordError(err)
        return err
    }
    
    return nil
}

func (ct *CascadingTimeouts) databaseQuery(parentCtx context.Context) error {
    ctx, cancel := context.WithDeadlineCause(
        parentCtx,
        time.Now().Add(2*time.Second),
        fmt.Errorf("æ•°æ®åº“æŸ¥è¯¢è¶…æ—¶"),
    )
    defer cancel()
    
    _, span := ct.tracer.Start(ctx, "database-query")
    defer span.End()
    
    // æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
    time.Sleep(1 * time.Second)
    
    return nil
}

func (ct *CascadingTimeouts) apiCall(parentCtx context.Context) error {
    ctx, cancel := context.WithDeadlineCause(
        parentCtx,
        time.Now().Add(3*time.Second),
        fmt.Errorf("APIè°ƒç”¨è¶…æ—¶"),
    )
    defer cancel()
    
    _, span := ct.tracer.Start(ctx, "api-call")
    defer span.End()
    
    // æ¨¡æ‹ŸAPIè°ƒç”¨
    time.Sleep(1 * time.Second)
    
    return nil
}

// DetachedCleanup åˆ†ç¦»çš„æ¸…ç†ä»»åŠ¡
func DetachedCleanup(requestCtx context.Context, resourceID string) {
    tracer := otel.Tracer("cleanup-tasks")
    
    // å³ä½¿è¯·æ±‚è¢«å–æ¶ˆï¼Œæ¸…ç†ä»»åŠ¡ä¹Ÿè¦å®Œæˆ
    cleanupCtx := context.WithoutCancel(requestCtx)
    
    // ä½†æ¸…ç†ä»»åŠ¡æœ¬èº«æœ‰è¶…æ—¶
    ctx, cancel := context.WithTimeout(cleanupCtx, 10*time.Second)
    defer cancel()
    
    ctx, span := tracer.Start(ctx, "detached-cleanup",
        trace.WithAttributes(
            attribute.String("resource.id", resourceID),
        ),
    )
    defer span.End()
    
    // æ¸…ç†èµ„æº
    time.Sleep(2 * time.Second)
    span.AddEvent("èµ„æºæ¸…ç†å®Œæˆ")
}
```

---

## å¹¶å‘åŸè¯­ä¼˜åŒ–

### 4. sync.OnceFunc å’Œ sync.OnceValue

```go
package concurrency

import (
    "context"
    "fmt"
    "sync"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// TracedInitializer è¿½è¸ªçš„åˆå§‹åŒ–å™¨
type TracedInitializer struct {
    tracer     trace.Tracer
    initOnce   func()
    valueOnce  func() *InitResult
}

type InitResult struct {
    Config    map[string]string
    Timestamp time.Time
}

func NewTracedInitializer(ctx context.Context) *TracedInitializer {
    tracer := otel.Tracer("initialization")
    
    // Go 1.25.1: sync.OnceFunc - åªæ‰§è¡Œä¸€æ¬¡çš„å‡½æ•°
    initOnce := sync.OnceFunc(func() {
        _, span := tracer.Start(ctx, "one-time-initialization")
        defer span.End()
        
        time.Sleep(100 * time.Millisecond)
        span.AddEvent("åˆå§‹åŒ–å®Œæˆ")
    })
    
    // Go 1.25.1: sync.OnceValue - åªè®¡ç®—ä¸€æ¬¡çš„å€¼
    valueOnce := sync.OnceValue(func() *InitResult {
        _, span := tracer.Start(ctx, "load-configuration")
        defer span.End()
        
        result := &InitResult{
            Config: map[string]string{
                "app_name": "my-app",
                "version":  "1.0.0",
            },
            Timestamp: time.Now(),
        }
        
        span.SetAttributes(
            attribute.Int("config.keys.count", len(result.Config)),
        )
        
        return result
    })
    
    return &TracedInitializer{
        tracer:    tracer,
        initOnce:  initOnce,
        valueOnce: valueOnce,
    }
}

func (ti *TracedInitializer) Initialize() {
    ti.initOnce() // å¤šæ¬¡è°ƒç”¨åªæ‰§è¡Œä¸€æ¬¡
}

func (ti *TracedInitializer) GetConfig() *InitResult {
    return ti.valueOnce() // å¤šæ¬¡è°ƒç”¨è¿”å›åŒä¸€ä¸ªç»“æœ
}

// CachedExporter ç¼“å­˜çš„å¯¼å‡ºå™¨
type CachedExporter struct {
    tracer       trace.Tracer
    getExporter  func() *ExporterInstance
}

type ExporterInstance struct {
    Endpoint  string
    Connected bool
    CreatedAt time.Time
}

func NewCachedExporter(ctx context.Context) *CachedExporter {
    tracer := otel.Tracer("cached-exporter")
    
    // ä½¿ç”¨ OnceValue ç¡®ä¿å¯¼å‡ºå™¨åªåˆ›å»ºä¸€æ¬¡
    getExporter := sync.OnceValue(func() *ExporterInstance {
        _, span := tracer.Start(ctx, "create-exporter")
        defer span.End()
        
        // æ¨¡æ‹Ÿåˆ›å»ºæ˜‚è´µçš„å¯¼å‡ºå™¨
        time.Sleep(500 * time.Millisecond)
        
        instance := &ExporterInstance{
            Endpoint:  "collector.example.com:4317",
            Connected: true,
            CreatedAt: time.Now(),
        }
        
        span.SetAttributes(
            attribute.String("exporter.endpoint", instance.Endpoint),
            attribute.Bool("exporter.connected", instance.Connected),
        )
        
        return instance
    })
    
    return &CachedExporter{
        tracer:      tracer,
        getExporter: getExporter,
    }
}

func (ce *CachedExporter) Export(ctx context.Context, data []byte) error {
    ctx, span := ce.tracer.Start(ctx, "export-data",
        trace.WithAttributes(
            attribute.Int("data.size", len(data)),
        ),
    )
    defer span.End()
    
    exporter := ce.getExporter() // æ€»æ˜¯è¿”å›åŒä¸€ä¸ªå®ä¾‹
    
    span.SetAttributes(
        attribute.String("exporter.endpoint", exporter.Endpoint),
        attribute.String("exporter.created_at", exporter.CreatedAt.String()),
    )
    
    // å¯¼å‡ºæ•°æ®
    return nil
}

// LazyResourceLoader å»¶è¿Ÿèµ„æºåŠ è½½å™¨
type LazyResourceLoader struct {
    tracer       trace.Tracer
    loadResource func() *Resource
}

type Resource struct {
    ID   string
    Data map[string]interface{}
}

func NewLazyResourceLoader(ctx context.Context, resourceID string) *LazyResourceLoader {
    tracer := otel.Tracer("lazy-loader")
    
    // èµ„æºåªåœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨æ—¶åŠ è½½
    loadResource := sync.OnceValue(func() *Resource {
        _, span := tracer.Start(ctx, "load-resource",
            trace.WithAttributes(
                attribute.String("resource.id", resourceID),
            ),
        )
        defer span.End()
        
        // æ¨¡æ‹ŸåŠ è½½
        time.Sleep(200 * time.Millisecond)
        
        resource := &Resource{
            ID: resourceID,
            Data: map[string]interface{}{
                "loaded_at": time.Now(),
            },
        }
        
        span.AddEvent("èµ„æºåŠ è½½å®Œæˆ")
        
        return resource
    })
    
    return &LazyResourceLoader{
        tracer:       tracer,
        loadResource: loadResource,
    }
}

func (lrl *LazyResourceLoader) Use(ctx context.Context) *Resource {
    ctx, span := lrl.tracer.Start(ctx, "use-resource")
    defer span.End()
    
    resource := lrl.loadResource()
    
    span.SetAttributes(
        attribute.String("resource.id", resource.ID),
    )
    
    return resource
}

// ThreadSafeMetricsAggregator çº¿ç¨‹å®‰å…¨çš„æŒ‡æ ‡èšåˆå™¨
type ThreadSafeMetricsAggregator struct {
    tracer    trace.Tracer
    mu        sync.RWMutex
    metrics   map[string]int64
    initOnce  func()
}

func NewMetricsAggregator(ctx context.Context) *ThreadSafeMetricsAggregator {
    tracer := otel.Tracer("metrics-aggregator")
    
    agg := &ThreadSafeMetricsAggregator{
        tracer:  tracer,
        metrics: make(map[string]int64),
    }
    
    // åˆå§‹åŒ–åªæ‰§è¡Œä¸€æ¬¡
    agg.initOnce = sync.OnceFunc(func() {
        _, span := tracer.Start(ctx, "initialize-aggregator")
        defer span.End()
        
        // é¢„è®¾æŒ‡æ ‡
        agg.metrics["requests"] = 0
        agg.metrics["errors"] = 0
        agg.metrics["latency"] = 0
        
        span.SetAttributes(
            attribute.Int("metrics.count", len(agg.metrics)),
        )
    })
    
    return agg
}

func (agg *ThreadSafeMetricsAggregator) Increment(ctx context.Context, name string, value int64) {
    agg.initOnce() // ç¡®ä¿åˆå§‹åŒ–
    
    agg.mu.Lock()
    defer agg.mu.Unlock()
    
    agg.metrics[name] += value
}

func (agg *ThreadSafeMetricsAggregator) Get(name string) int64 {
    agg.initOnce() // ç¡®ä¿åˆå§‹åŒ–
    
    agg.mu.RLock()
    defer agg.mu.RUnlock()
    
    return agg.metrics[name]
}
```

---

## é”™è¯¯å¤„ç†å¢å¼º

### 5. errors.Join å¤šé”™è¯¯åˆå¹¶

```go
package errorhandling

import (
    "context"
    "errors"
    "fmt"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// MultiServiceOperation å¤šæœåŠ¡æ“ä½œ
type MultiServiceOperation struct {
    tracer trace.Tracer
}

func NewMultiServiceOperation() *MultiServiceOperation {
    return &MultiServiceOperation{
        tracer: otel.Tracer("multi-service"),
    }
}

func (mso *MultiServiceOperation) Execute(ctx context.Context) error {
    ctx, span := mso.tracer.Start(ctx, "multi-service-operation")
    defer span.End()
    
    var errors []error
    
    // è°ƒç”¨å¤šä¸ªæœåŠ¡
    if err := mso.callServiceA(ctx); err != nil {
        errors = append(errors, fmt.Errorf("æœåŠ¡Aå¤±è´¥: %w", err))
    }
    
    if err := mso.callServiceB(ctx); err != nil {
        errors = append(errors, fmt.Errorf("æœåŠ¡Bå¤±è´¥: %w", err))
    }
    
    if err := mso.callServiceC(ctx); err != nil {
        errors = append(errors, fmt.Errorf("æœåŠ¡Cå¤±è´¥: %w", err))
    }
    
    // Go 1.25.1: errors.Join åˆå¹¶å¤šä¸ªé”™è¯¯
    if len(errors) > 0 {
        joinedErr := errors.Join(errors...)
        
        span.RecordError(joinedErr)
        span.SetStatus(codes.Error, "å¤šä¸ªæœåŠ¡è°ƒç”¨å¤±è´¥")
        span.SetAttributes(
            attribute.Int("errors.count", len(errors)),
            attribute.String("errors.summary", joinedErr.Error()),
        )
        
        return joinedErr
    }
    
    span.SetStatus(codes.Ok, "æ‰€æœ‰æœåŠ¡è°ƒç”¨æˆåŠŸ")
    return nil
}

func (mso *MultiServiceOperation) callServiceA(ctx context.Context) error {
    _, span := mso.tracer.Start(ctx, "call-service-a")
    defer span.End()
    
    // æ¨¡æ‹Ÿå¤±è´¥
    return fmt.Errorf("è¿æ¥è¶…æ—¶")
}

func (mso *MultiServiceOperation) callServiceB(ctx context.Context) error {
    _, span := mso.tracer.Start(ctx, "call-service-b")
    defer span.End()
    
    return nil
}

func (mso *MultiServiceOperation) callServiceC(ctx context.Context) error {
    _, span := mso.tracer.Start(ctx, "call-service-c")
    defer span.End()
    
    // æ¨¡æ‹Ÿå¤±è´¥
    return fmt.Errorf("è®¤è¯å¤±è´¥")
}

// BatchProcessor æ‰¹å¤„ç†å™¨
type BatchProcessor struct {
    tracer trace.Tracer
}

func NewBatchProcessor() *BatchProcessor {
    return &BatchProcessor{
        tracer: otel.Tracer("batch-processor"),
    }
}

func (bp *BatchProcessor) ProcessBatch(ctx context.Context, items []string) error {
    ctx, span := bp.tracer.Start(ctx, "process-batch",
        trace.WithAttributes(
            attribute.Int("batch.size", len(items)),
        ),
    )
    defer span.End()
    
    var (
        successCount int
        errors       []error
    )
    
    for i, item := range items {
        if err := bp.processItem(ctx, i, item); err != nil {
            errors = append(errors, err)
        } else {
            successCount++
        }
    }
    
    span.SetAttributes(
        attribute.Int("batch.success", successCount),
        attribute.Int("batch.failed", len(errors)),
    )
    
    if len(errors) > 0 {
        // åˆå¹¶æ‰€æœ‰é”™è¯¯
        joinedErr := errors.Join(errors...)
        span.RecordError(joinedErr)
        span.SetStatus(codes.Error, fmt.Sprintf("æ‰¹å¤„ç†éƒ¨åˆ†å¤±è´¥: %d/%d", len(errors), len(items)))
        
        return joinedErr
    }
    
    span.SetStatus(codes.Ok, "æ‰¹å¤„ç†å…¨éƒ¨æˆåŠŸ")
    return nil
}

func (bp *BatchProcessor) processItem(ctx context.Context, index int, item string) error {
    _, span := bp.tracer.Start(ctx, "process-item",
        trace.WithAttributes(
            attribute.Int("item.index", index),
            attribute.String("item.value", item),
        ),
    )
    defer span.End()
    
    // æ¨¡æ‹Ÿå¤„ç†
    if index%3 == 0 {
        err := fmt.Errorf("é¡¹ç›® %d å¤„ç†å¤±è´¥", index)
        span.RecordError(err)
        return err
    }
    
    return nil
}

// ValidationErrors éªŒè¯é”™è¯¯æ”¶é›†
type ValidationErrors struct {
    tracer trace.Tracer
    errors []error
}

func NewValidationErrors() *ValidationErrors {
    return &ValidationErrors{
        tracer: otel.Tracer("validation"),
        errors: make([]error, 0),
    }
}

func (ve *ValidationErrors) Add(err error) {
    ve.errors = append(ve.errors, err)
}

func (ve *ValidationErrors) HasErrors() bool {
    return len(ve.errors) > 0
}

func (ve *ValidationErrors) Error(ctx context.Context) error {
    if !ve.HasErrors() {
        return nil
    }
    
    _, span := ve.tracer.Start(ctx, "validation-error")
    defer span.End()
    
    // åˆå¹¶æ‰€æœ‰éªŒè¯é”™è¯¯
    joinedErr := errors.Join(ve.errors...)
    
    span.RecordError(joinedErr)
    span.SetAttributes(
        attribute.Int("validation.errors.count", len(ve.errors)),
    )
    
    return joinedErr
}

// ä½¿ç”¨ç¤ºä¾‹
func ValidateUser(ctx context.Context, user map[string]string) error {
    tracer := otel.Tracer("user-validation")
    ctx, span := tracer.Start(ctx, "validate-user")
    defer span.End()
    
    ve := NewValidationErrors()
    
    if user["email"] == "" {
        ve.Add(fmt.Errorf("é‚®ç®±ä¸èƒ½ä¸ºç©º"))
    }
    
    if len(user["password"]) < 8 {
        ve.Add(fmt.Errorf("å¯†ç é•¿åº¦å¿…é¡»è‡³å°‘8ä¸ªå­—ç¬¦"))
    }
    
    if user["age"] == "" {
        ve.Add(fmt.Errorf("å¹´é¾„ä¸èƒ½ä¸ºç©º"))
    }
    
    return ve.Error(ctx)
}
```

---

## æ€§èƒ½ä¼˜åŒ–ç‰¹æ€§

### 6. Profile-Guided Optimization (PGO)

```go
package pgo

import (
    "context"
    _ "embed"
    "runtime/pprof"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
)

// PGOé…ç½®è¯´æ˜
/*
Go 1.25.1 æ”¯æŒ Profile-Guided Optimization

1. æ”¶é›†Profileæ•°æ®:
   go test -cpuprofile=cpu.pprof -bench=.

2. æ”¾ç½®Profileæ–‡ä»¶:
   å°† cpu.pprof æ”¾åœ¨é¡¹ç›®æ ¹ç›®å½•ï¼Œå‘½åä¸º default.pgo

3. ä½¿ç”¨PGOæ„å»º:
   go build -pgo=auto
   
4. æ€§èƒ½æå‡:
   - å‡½æ•°å†…è”ä¼˜åŒ–: 10-20%
   - åˆ†æ”¯é¢„æµ‹ä¼˜åŒ–: 5-10%
   - æ•´ä½“æ€§èƒ½æå‡: 5-15%
*/

// HotPath çƒ­è·¯å¾„å‡½æ•°ï¼ˆä¼šè¢«PGOä¼˜åŒ–ï¼‰
func HotPath(ctx context.Context, data []byte) []byte {
    tracer := otel.Tracer("hot-path")
    
    ctx, span := tracer.Start(ctx, "hot-path-operation",
        trace.WithAttributes(
            attribute.Int("data.size", len(data)),
        ),
    )
    defer span.End()
    
    // é¢‘ç¹è°ƒç”¨çš„ä»£ç è·¯å¾„
    result := make([]byte, 0, len(data))
    
    for _, b := range data {
        // çƒ­è·¯å¾„çš„å¯†é›†è®¡ç®—
        result = append(result, b^0xFF)
    }
    
    return result
}

// CriticalSection å…³é”®ä»£ç æ®µ
func CriticalSection(ctx context.Context, count int) int64 {
    tracer := otel.Tracer("critical-section")
    
    ctx, span := tracer.Start(ctx, "critical-operation")
    defer span.End()
    
    var sum int64
    
    // PGOä¼šä¼˜åŒ–è¿™ä¸ªé¢‘ç¹æ‰§è¡Œçš„å¾ªç¯
    for i := 0; i < count; i++ {
        sum += int64(i * i)
    }
    
    span.SetAttributes(
        attribute.Int64("result.sum", sum),
    )
    
    return sum
}

// ProfilingHelper PGOè¾…åŠ©å·¥å…·
type ProfilingHelper struct {
    tracer trace.Tracer
}

func NewProfilingHelper() *ProfilingHelper {
    return &ProfilingHelper{
        tracer: otel.Tracer("profiling-helper"),
    }
}

// CollectProfile æ”¶é›†æ€§èƒ½æ•°æ®
func (ph *ProfilingHelper) CollectProfile(ctx context.Context, duration time.Duration) error {
    ctx, span := ph.tracer.Start(ctx, "collect-profile")
    defer span.End()
    
    // åˆ›å»ºCPU profile
    if err := pprof.StartCPUProfile(os.Stdout); err != nil {
        span.RecordError(err)
        return err
    }
    defer pprof.StopCPUProfile()
    
    // è¿è¡Œä¸€æ®µæ—¶é—´
    time.Sleep(duration)
    
    span.AddEvent("profileæ”¶é›†å®Œæˆ")
    return nil
}
```

### 7. ç¼–è¯‘å™¨ä¼˜åŒ–å’Œé€ƒé€¸åˆ†æ

```go
package optimization

import (
    "context"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
)

// StackAllocation æ ˆåˆ†é…ä¼˜åŒ–
func StackAllocation(ctx context.Context) {
    tracer := otel.Tracer("stack-allocation")
    
    ctx, span := tracer.Start(ctx, "stack-operation")
    defer span.End()
    
    // å°å¯¹è±¡ä¼˜å…ˆåœ¨æ ˆä¸Šåˆ†é…ï¼ˆGo 1.25.1ä¼˜åŒ–ï¼‰
    attrs := [5]attribute.KeyValue{
        attribute.String("key1", "value1"),
        attribute.String("key2", "value2"),
        attribute.String("key3", "value3"),
        attribute.String("key4", "value4"),
        attribute.String("key5", "value5"),
    }
    
    span.SetAttributes(attrs[:]...)
}

// InlineOptimization å†…è”ä¼˜åŒ–
//go:inline
func fastOperation(x, y int) int {
    return x*y + x + y
}

func ProcessWithInlining(ctx context.Context, values []int) {
    tracer := otel.Tracer("inline-optimization")
    
    ctx, span := tracer.Start(ctx, "process-inline")
    defer span.End()
    
    sum := 0
    for i := 0; i < len(values)-1; i++ {
        // fastOperation ä¼šè¢«å†…è”
        sum += fastOperation(values[i], values[i+1])
    }
    
    span.SetAttributes(
        attribute.Int("result.sum", sum),
    )
}
```

---

## æ€»ç»“

æœ¬æ–‡æ¡£å±•ç¤ºäº† Go 1.25.1 é«˜çº§ç‰¹æ€§ä¸ OpenTelemetry OTLP çš„æ·±åº¦é›†æˆï¼ŒåŒ…æ‹¬ï¼š

1. âœ… **æ³›å‹å¢å¼º** - ç±»å‹å®‰å…¨çš„è¿½è¸ªå’ŒæŒ‡æ ‡
2. âœ… **Context å¢å¼º** - WithoutCancel, WithDeadlineCause
3. âœ… **å¹¶å‘åŸè¯­** - sync.OnceFunc, sync.OnceValue
4. âœ… **é”™è¯¯å¤„ç†** - errors.Join å¤šé”™è¯¯åˆå¹¶
5. âœ… **æ€§èƒ½ä¼˜åŒ–** - PGO, ç¼–è¯‘å™¨ä¼˜åŒ–
6. âœ… **ç±»å‹å®‰å…¨** - æ³›å‹çº¦æŸç¡®ä¿ç±»å‹æ­£ç¡®

### ç›¸å…³æ–‡æ¡£

- [Go_1.25.1_å®Œæ•´é›†æˆæŒ‡å—.md](./01_Go_1.25.1_å®Œæ•´é›†æˆæŒ‡å—.md)
- [Goå¹¶å‘æ¨¡å¼ä¸OTLPé›†æˆ.md](./02_Goå¹¶å‘æ¨¡å¼ä¸OTLPé›†æˆ.md)
- [Goæ€§èƒ½ä¼˜åŒ–ä¸æœ€ä½³å®è·µ.md](./03_Goæ€§èƒ½ä¼˜åŒ–ä¸æœ€ä½³å®è·µ.md)
