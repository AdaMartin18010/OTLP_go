# Go 反射与动态追踪技术

## 目录

- [Go 反射与动态追踪技术](#go-反射与动态追踪技术)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [反射在 OTLP 中的应用](#反射在-otlp-中的应用)
  - [2. 反射基础与 OTLP 集成](#2-反射基础与-otlp-集成)
    - [2.1 反射原理回顾](#21-反射原理回顾)
    - [2.2 类型信息提取](#22-类型信息提取)
    - [2.3 值获取与转换](#23-值获取与转换)
  - [3. 自动追踪结构体](#3-自动追踪结构体)
    - [3.1 结构体字段自动注入](#31-结构体字段自动注入)
    - [3.2 标签驱动的属性提取](#32-标签驱动的属性提取)
    - [3.3 递归追踪嵌套结构](#33-递归追踪嵌套结构)
  - [4. 函数自动追踪](#4-函数自动追踪)
    - [4.1 函数参数捕获](#41-函数参数捕获)
    - [4.2 返回值追踪](#42-返回值追踪)
    - [4.3 函数调用链分析](#43-函数调用链分析)
  - [5. 动态属性注入](#5-动态属性注入)
    - [5.1 运行时属性生成](#51-运行时属性生成)
    - [5.2 条件属性注入](#52-条件属性注入)
    - [5.3 属性模板系统](#53-属性模板系统)
  - [6. 接口类型追踪](#6-接口类型追踪)
    - [6.1 接口实现检测](#61-接口实现检测)
    - [6.2 多态调用追踪](#62-多态调用追踪)
    - [6.3 类型断言优化](#63-类型断言优化)
  - [7. 方法拦截与代理](#7-方法拦截与代理)
    - [7.1 透明代理模式](#71-透明代理模式)
    - [7.2 方法前置/后置处理](#72-方法前置后置处理)
    - [7.3 AOP 切面编程](#73-aop-切面编程)
  - [8. 性能优化](#8-性能优化)
    - [8.1 反射缓存机制](#81-反射缓存机制)
    - [8.2 类型转换优化](#82-类型转换优化)
    - [8.3 避免反射陷阱](#83-避免反射陷阱)
  - [9. 高级应用场景](#9-高级应用场景)
    - [综合示例-自动化追踪框架](#综合示例-自动化追踪框架)
  - [总结](#总结)

---

## 1. 概述

反射(`reflect`包)是 Go 运行时检查和操作类型信息的机制。虽然反射有性能开销,但在 OTLP 集成中用于自动化追踪能显著减少样板代码。

### 反射在 OTLP 中的应用

```text
┌─────────────────────────────────────┐
│   反射驱动的自动化追踪               │
├─────────────────────────────────────┤
│  1. 自动提取结构体字段为属性         │
│  2. 函数参数/返回值自动记录          │
│  3. 动态生成 Span 名称和属性         │
│  4. 接口方法透明拦截                │
│  5. 无侵入式追踪注入                │
└─────────────────────────────────────┘
```

**基于 Go 1.25.1 和 OpenTelemetry v1.32.0**。

---

## 2. 反射基础与 OTLP 集成

### 2.1 反射原理回顾

```go
package otlpreflect

import (
    "reflect"
    "fmt"
    
    "go.opentelemetry.io/otel/attribute"
)

// 反射的三个核心概念
func ReflectBasics() {
    // 1. Type:类型信息
    var x int = 42
    t := reflect.TypeOf(x)
    fmt.Println("Type:", t.Name(), "Kind:", t.Kind()) // Type: int Kind: int
    
    // 2. Value:值信息
    v := reflect.ValueOf(x)
    fmt.Println("Value:", v.Int()) // Value: 42
    
    // 3. Interface:值的原始接口表示
    originalValue := v.Interface().(int)
    fmt.Println("Original:", originalValue) // Original: 42
}

// 类型判断示例
func TypeSwitch(val interface{}) string {
    v := reflect.ValueOf(val)
    
    switch v.Kind() {
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        return "integer"
    case reflect.String:
        return "string"
    case reflect.Struct:
        return "struct"
    case reflect.Slice, reflect.Array:
        return "sequence"
    case reflect.Map:
        return "map"
    case reflect.Ptr:
        return "pointer"
    default:
        return "unknown"
    }
}
```

### 2.2 类型信息提取

```go
import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

// TypeInspector 类型检查器
type TypeInspector struct {
    tracer trace.Tracer
}

func NewTypeInspector() *TypeInspector {
    return &TypeInspector{
        tracer: otel.Tracer("type-inspector"),
    }
}

// InspectType 检查类型并记录到 Span
func (ti *TypeInspector) InspectType(ctx context.Context, obj interface{}) {
    ctx, span := ti.tracer.Start(ctx, "inspect-type")
    defer span.End()
    
    t := reflect.TypeOf(obj)
    v := reflect.ValueOf(obj)
    
    // 记录类型信息
    span.SetAttributes(
        attribute.String("reflect.type_name", t.Name()),
        attribute.String("reflect.type_kind", t.Kind().String()),
        attribute.String("reflect.type_pkg_path", t.PkgPath()),
        attribute.Bool("reflect.is_valid", v.IsValid()),
        attribute.Bool("reflect.is_zero", v.IsZero()),
    )
    
    // 结构体类型特殊处理
    if t.Kind() == reflect.Struct {
        span.SetAttributes(
            attribute.Int("reflect.struct_num_fields", t.NumField()),
        )
        
        for i := 0; i < t.NumField(); i++ {
            field := t.Field(i)
            span.AddEvent("struct-field", trace.WithAttributes(
                attribute.String("field.name", field.Name),
                attribute.String("field.type", field.Type.String()),
                attribute.String("field.tag", string(field.Tag)),
                attribute.Bool("field.exported", field.IsExported()),
            ))
        }
    }
    
    // 函数类型特殊处理
    if t.Kind() == reflect.Func {
        span.SetAttributes(
            attribute.Int("reflect.func_num_in", t.NumIn()),
            attribute.Int("reflect.func_num_out", t.NumOut()),
            attribute.Bool("reflect.func_is_variadic", t.IsVariadic()),
        )
    }
}
```

### 2.3 值获取与转换

```go
// ValueExtractor 值提取器
type ValueExtractor struct {
    tracer trace.Tracer
}

func NewValueExtractor() *ValueExtractor {
    return &ValueExtractor{
        tracer: otel.Tracer("value-extractor"),
    }
}

// ExtractToAttribute 将任意值转换为 OTLP 属性
func (ve *ValueExtractor) ExtractToAttribute(key string, val interface{}) attribute.KeyValue {
    v := reflect.ValueOf(val)
    
    // 处理指针:自动解引用
    for v.Kind() == reflect.Ptr {
        if v.IsNil() {
            return attribute.String(key, "<nil>")
        }
        v = v.Elem()
    }
    
    // 根据类型转换
    switch v.Kind() {
    case reflect.Bool:
        return attribute.Bool(key, v.Bool())
    
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        return attribute.Int64(key, v.Int())
    
    case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
        return attribute.Int64(key, int64(v.Uint()))
    
    case reflect.Float32, reflect.Float64:
        return attribute.Float64(key, v.Float())
    
    case reflect.String:
        return attribute.String(key, v.String())
    
    case reflect.Slice, reflect.Array:
        // 转换为字符串数组
        strs := make([]string, v.Len())
        for i := 0; i < v.Len(); i++ {
            strs[i] = fmt.Sprintf("%v", v.Index(i).Interface())
        }
        return attribute.StringSlice(key, strs)
    
    case reflect.Map:
        // 转换为 JSON 字符串
        jsonBytes, _ := json.Marshal(val)
        return attribute.String(key, string(jsonBytes))
    
    case reflect.Struct:
        // 转换为 JSON 字符串
        jsonBytes, _ := json.Marshal(val)
        return attribute.String(key, string(jsonBytes))
    
    default:
        return attribute.String(key, fmt.Sprintf("%v", val))
    }
}

// ExtractAllFields 提取结构体所有字段
func (ve *ValueExtractor) ExtractAllFields(obj interface{}) []attribute.KeyValue {
    v := reflect.ValueOf(obj)
    
    // 处理指针
    for v.Kind() == reflect.Ptr {
        v = v.Elem()
    }
    
    if v.Kind() != reflect.Struct {
        return nil
    }
    
    t := v.Type()
    attrs := make([]attribute.KeyValue, 0, v.NumField())
    
    for i := 0; i < v.NumField(); i++ {
        field := t.Field(i)
        fieldValue := v.Field(i)
        
        // 跳过未导出字段
        if !field.IsExported() {
            continue
        }
        
        // 使用字段名作为 key
        key := field.Name
        
        // 检查是否有 otel tag
        if tag := field.Tag.Get("otel"); tag != "" {
            if tag == "-" {
                continue // 跳过
            }
            key = tag
        }
        
        attrs = append(attrs, ve.ExtractToAttribute(key, fieldValue.Interface()))
    }
    
    return attrs
}
```

---

## 3. 自动追踪结构体

### 3.1 结构体字段自动注入

```go
// AutoTraceStruct 自动追踪结构体
type AutoTraceStruct struct {
    tracer    trace.Tracer
    extractor *ValueExtractor
}

func NewAutoTraceStruct() *AutoTraceStruct {
    return &AutoTraceStruct{
        tracer:    otel.Tracer("auto-trace-struct"),
        extractor: NewValueExtractor(),
    }
}

// TraceStruct 自动将结构体字段注入到 Span
func (ats *AutoTraceStruct) TraceStruct(ctx context.Context, spanName string, obj interface{}) (context.Context, trace.Span) {
    ctx, span := ats.tracer.Start(ctx, spanName)
    
    // 自动提取所有字段
    attrs := ats.extractor.ExtractAllFields(obj)
    span.SetAttributes(attrs...)
    
    return ctx, span
}

// 使用示例
type User struct {
    ID       int    `otel:"user.id"`
    Username string `otel:"user.name"`
    Email    string `otel:"user.email"`
    Age      int    `otel:"user.age"`
    Password string `otel:"-"` // 不追踪
}

func ExampleAutoTraceStruct() {
    autoTrace := NewAutoTraceStruct()
    
    user := User{
        ID:       123,
        Username: "john_doe",
        Email:    "john@example.com",
        Age:      30,
        Password: "secret",
    }
    
    ctx, span := autoTrace.TraceStruct(context.Background(), "user-operation", user)
    defer span.End()
    
    // Span 自动包含:user.id=123, user.name="john_doe", user.email="john@example.com", user.age=30
    // Password 不会被追踪
}
```

### 3.2 标签驱动的属性提取

```go
// TagBasedExtractor 基于标签的提取器
type TagBasedExtractor struct {
    tracer trace.Tracer
}

func NewTagBasedExtractor() *TagBasedExtractor {
    return &TagBasedExtractor{
        tracer: otel.Tracer("tag-extractor"),
    }
}

// ExtractWithTags 根据标签配置提取属性
func (tbe *TagBasedExtractor) ExtractWithTags(obj interface{}) []attribute.KeyValue {
    v := reflect.ValueOf(obj)
    
    for v.Kind() == reflect.Ptr {
        v = v.Elem()
    }
    
    if v.Kind() != reflect.Struct {
        return nil
    }
    
    t := v.Type()
    var attrs []attribute.KeyValue
    
    for i := 0; i < v.NumField(); i++ {
        field := t.Field(i)
        fieldValue := v.Field(i)
        
        if !field.IsExported() {
            continue
        }
        
        // 解析标签
        otelTag := field.Tag.Get("otel")
        if otelTag == "-" {
            continue // 跳过
        }
        
        // 支持自定义选项:otel:"key,omitempty,sensitive"
        parts := strings.Split(otelTag, ",")
        key := parts[0]
        if key == "" {
            key = field.Name
        }
        
        options := make(map[string]bool)
        for _, opt := range parts[1:] {
            options[opt] = true
        }
        
        // omitempty:跳过零值
        if options["omitempty"] && fieldValue.IsZero() {
            continue
        }
        
        // sensitive:脱敏
        if options["sensitive"] {
            attrs = append(attrs, attribute.String(key, "***REDACTED***"))
            continue
        }
        
        // 正常提取
        attrs = append(attrs, tbe.extractFieldValue(key, fieldValue))
    }
    
    return attrs
}

func (tbe *TagBasedExtractor) extractFieldValue(key string, v reflect.Value) attribute.KeyValue {
    switch v.Kind() {
    case reflect.Bool:
        return attribute.Bool(key, v.Bool())
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        return attribute.Int64(key, v.Int())
    case reflect.String:
        return attribute.String(key, v.String())
    default:
        return attribute.String(key, fmt.Sprintf("%v", v.Interface()))
    }
}

// 使用示例
type Account struct {
    ID       int    `otel:"account.id"`
    Balance  float64 `otel:"account.balance,omitempty"` // 零值不追踪
    APIKey   string  `otel:"account.api_key,sensitive"` // 敏感信息脱敏
    Metadata string  `otel:"-"`                         // 不追踪
}

func ExampleTagBasedExtractor() {
    extractor := NewTagBasedExtractor()
    
    account := Account{
        ID:      456,
        Balance: 0,      // 会被跳过(omitempty)
        APIKey:  "sk-123456", // 会被脱敏
    }
    
    attrs := extractor.ExtractWithTags(account)
    // 结果:account.id=456, account.api_key="***REDACTED***"
}
```

### 3.3 递归追踪嵌套结构

```go
// RecursiveTracer 递归追踪器
type RecursiveTracer struct {
    tracer   trace.Tracer
    maxDepth int
}

func NewRecursiveTracer(maxDepth int) *RecursiveTracer {
    return &RecursiveTracer{
        tracer:   otel.Tracer("recursive-tracer"),
        maxDepth: maxDepth,
    }
}

// TraceNested 递归追踪嵌套结构
func (rt *RecursiveTracer) TraceNested(ctx context.Context, spanName string, obj interface{}) (context.Context, trace.Span) {
    ctx, span := rt.tracer.Start(ctx, spanName)
    
    attrs := rt.extractNested("", obj, 0)
    span.SetAttributes(attrs...)
    
    return ctx, span
}

// extractNested 递归提取嵌套字段
func (rt *RecursiveTracer) extractNested(prefix string, obj interface{}, depth int) []attribute.KeyValue {
    if depth > rt.maxDepth {
        return []attribute.KeyValue{attribute.String(prefix, "<max depth reached>")}
    }
    
    v := reflect.ValueOf(obj)
    
    // 处理指针
    for v.Kind() == reflect.Ptr {
        if v.IsNil() {
            return []attribute.KeyValue{attribute.String(prefix, "<nil>")}
        }
        v = v.Elem()
    }
    
    if v.Kind() != reflect.Struct {
        // 基本类型,直接返回
        return []attribute.KeyValue{rt.extractValue(prefix, v)}
    }
    
    // 递归处理结构体
    t := v.Type()
    var attrs []attribute.KeyValue
    
    for i := 0; i < v.NumField(); i++ {
        field := t.Field(i)
        fieldValue := v.Field(i)
        
        if !field.IsExported() {
            continue
        }
        
        // 构建嵌套键名
        key := field.Name
        if prefix != "" {
            key = prefix + "." + key
        }
        
        // 检查 otel 标签
        if tag := field.Tag.Get("otel"); tag != "" {
            if tag == "-" {
                continue
            }
            if prefix != "" {
                key = prefix + "." + tag
            } else {
                key = tag
            }
        }
        
        // 递归处理嵌套结构
        if fieldValue.Kind() == reflect.Struct {
            nestedAttrs := rt.extractNested(key, fieldValue.Interface(), depth+1)
            attrs = append(attrs, nestedAttrs...)
        } else {
            attrs = append(attrs, rt.extractValue(key, fieldValue))
        }
    }
    
    return attrs
}

func (rt *RecursiveTracer) extractValue(key string, v reflect.Value) attribute.KeyValue {
    switch v.Kind() {
    case reflect.Bool:
        return attribute.Bool(key, v.Bool())
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        return attribute.Int64(key, v.Int())
    case reflect.String:
        return attribute.String(key, v.String())
    default:
        return attribute.String(key, fmt.Sprintf("%v", v.Interface()))
    }
}

// 使用示例:嵌套结构
type Address struct {
    Street string `otel:"street"`
    City   string `otel:"city"`
}

type Company struct {
    Name    string  `otel:"name"`
    Address Address `otel:"address"`
}

type Employee struct {
    ID      int     `otel:"id"`
    Name    string  `otel:"name"`
    Company Company `otel:"company"`
}

func ExampleRecursiveTracer() {
    tracer := NewRecursiveTracer(3) // 最大深度 3
    
    emp := Employee{
        ID:   1,
        Name: "Alice",
        Company: Company{
            Name: "ACME Corp",
            Address: Address{
                Street: "123 Main St",
                City:   "NYC",
            },
        },
    }
    
    ctx, span := tracer.TraceNested(context.Background(), "employee-info", emp)
    defer span.End()
    
    // 生成属性:
    // id=1
    // name="Alice"
    // company.name="ACME Corp"
    // company.address.street="123 Main St"
    // company.address.city="NYC"
}
```

---

## 4. 函数自动追踪

### 4.1 函数参数捕获

```go
// FunctionTracer 函数追踪器
type FunctionTracer struct {
    tracer trace.Tracer
}

func NewFunctionTracer() *FunctionTracer {
    return &FunctionTracer{
        tracer: otel.Tracer("function-tracer"),
    }
}

// TraceFunction 自动追踪函数调用
func (ft *FunctionTracer) TraceFunction(ctx context.Context, fn interface{}, args ...interface{}) ([]interface{}, error) {
    fnValue := reflect.ValueOf(fn)
    fnType := fnValue.Type()
    
    if fnType.Kind() != reflect.Func {
        return nil, fmt.Errorf("not a function")
    }
    
    // 提取函数名称(使用运行时信息)
    fnName := runtime.FuncForPC(fnValue.Pointer()).Name()
    
    ctx, span := ft.tracer.Start(ctx, fnName)
    defer span.End()
    
    // 记录函数签名
    span.SetAttributes(
        attribute.String("function.name", fnName),
        attribute.Int("function.num_in", fnType.NumIn()),
        attribute.Int("function.num_out", fnType.NumOut()),
    )
    
    // 记录输入参数
    for i, arg := range args {
        paramName := fmt.Sprintf("param.%d", i)
        span.AddEvent("function-parameter", trace.WithAttributes(
            attribute.String("param.name", paramName),
            attribute.String("param.type", reflect.TypeOf(arg).String()),
            attribute.String("param.value", fmt.Sprintf("%v", arg)),
        ))
    }
    
    // 转换参数为 reflect.Value
    in := make([]reflect.Value, len(args))
    for i, arg := range args {
        in[i] = reflect.ValueOf(arg)
    }
    
    // 调用函数
    startTime := time.Now()
    out := fnValue.Call(in)
    duration := time.Since(startTime)
    
    span.SetAttributes(attribute.Int64("function.duration_ns", duration.Nanoseconds()))
    
    // 记录返回值
    results := make([]interface{}, len(out))
    for i, val := range out {
        results[i] = val.Interface()
        
        span.AddEvent("function-return", trace.WithAttributes(
            attribute.Int("return.index", i),
            attribute.String("return.type", val.Type().String()),
            attribute.String("return.value", fmt.Sprintf("%v", val.Interface())),
        ))
    }
    
    // 检查最后一个返回值是否为 error
    if len(out) > 0 {
        lastOut := out[len(out)-1]
        if lastOut.Type().Implements(reflect.TypeOf((*error)(nil)).Elem()) && !lastOut.IsNil() {
            err := lastOut.Interface().(error)
            span.RecordError(err)
            span.SetStatus(codes.Error, err.Error())
            return results, err
        }
    }
    
    return results, nil
}

// 使用示例
func AddNumbers(a, b int) int {
    return a + b
}

func ProcessUser(ctx context.Context, userID int) (*User, error) {
    // 业务逻辑
    return &User{ID: userID, Username: "test"}, nil
}

func ExampleFunctionTracer() {
    tracer := NewFunctionTracer()
    
    // 追踪简单函数
    results, _ := tracer.TraceFunction(context.Background(), AddNumbers, 10, 20)
    fmt.Println("Result:", results[0].(int)) // 30
    
    // 追踪带 Context 的函数
    results, err := tracer.TraceFunction(context.Background(), ProcessUser, context.Background(), 123)
    if err != nil {
        panic(err)
    }
    user := results[0].(*User)
    fmt.Println("User:", user.Username)
}
```

### 4.2 返回值追踪

```go
// ReturnValueTracer 返回值追踪器
type ReturnValueTracer struct {
    tracer trace.Tracer
}

func NewReturnValueTracer() *ReturnValueTracer {
    return &ReturnValueTracer{
        tracer: otel.Tracer("return-value-tracer"),
    }
}

// WrapFunction 包装函数以追踪返回值
func (rvt *ReturnValueTracer) WrapFunction(fn interface{}) interface{} {
    fnValue := reflect.ValueOf(fn)
    fnType := fnValue.Type()
    
    if fnType.Kind() != reflect.Func {
        panic("not a function")
    }
    
    // 创建包装函数
    wrapper := reflect.MakeFunc(fnType, func(args []reflect.Value) []reflect.Value {
        // 提取 Context(假设第一个参数是 context.Context)
        var ctx context.Context = context.Background()
        if len(args) > 0 && args[0].Type().Implements(reflect.TypeOf((*context.Context)(nil)).Elem()) {
            ctx = args[0].Interface().(context.Context)
        }
        
        fnName := runtime.FuncForPC(fnValue.Pointer()).Name()
        ctx, span := rvt.tracer.Start(ctx, fnName)
        defer span.End()
        
        // 调用原始函数
        results := fnValue.Call(args)
        
        // 追踪返回值
        for i, result := range results {
            resultType := result.Type()
            
            // 检查是否为 error
            if resultType.Implements(reflect.TypeOf((*error)(nil)).Elem()) {
                if !result.IsNil() {
                    err := result.Interface().(error)
                    span.RecordError(err)
                    span.SetStatus(codes.Error, err.Error())
                }
            } else {
                // 记录其他返回值
                span.SetAttributes(
                    attribute.String(fmt.Sprintf("return.%d.type", i), resultType.String()),
                    attribute.String(fmt.Sprintf("return.%d.value", i), fmt.Sprintf("%v", result.Interface())),
                )
            }
        }
        
        return results
    })
    
    return wrapper.Interface()
}

// 使用示例
func GetUserByID(ctx context.Context, id int) (*User, error) {
    if id <= 0 {
        return nil, fmt.Errorf("invalid user ID")
    }
    return &User{ID: id, Username: "john"}, nil
}

func ExampleReturnValueTracer() {
    tracer := NewReturnValueTracer()
    
    // 包装函数
    wrappedGetUser := tracer.WrapFunction(GetUserByID).(func(context.Context, int) (*User, error))
    
    // 调用包装后的函数(自动追踪)
    user, err := wrappedGetUser(context.Background(), 123)
    if err != nil {
        panic(err)
    }
    fmt.Println("User:", user.Username)
}
```

### 4.3 函数调用链分析

```go
// CallChainAnalyzer 函数调用链分析器
type CallChainAnalyzer struct {
    tracer trace.Tracer
}

func NewCallChainAnalyzer() *CallChainAnalyzer {
    return &CallChainAnalyzer{
        tracer: otel.Tracer("call-chain-analyzer"),
    }
}

// AnalyzeCallStack 分析当前调用栈
func (cca *CallChainAnalyzer) AnalyzeCallStack(ctx context.Context, depth int) {
    ctx, span := cca.tracer.Start(ctx, "analyze-call-stack")
    defer span.End()
    
    pcs := make([]uintptr, depth)
    n := runtime.Callers(2, pcs) // 跳过 Callers 和 AnalyzeCallStack 本身
    
    frames := runtime.CallersFrames(pcs[:n])
    
    stackIndex := 0
    for {
        frame, more := frames.Next()
        
        span.AddEvent("stack-frame", trace.WithAttributes(
            attribute.Int("stack.index", stackIndex),
            attribute.String("stack.function", frame.Function),
            attribute.String("stack.file", frame.File),
            attribute.Int("stack.line", frame.Line),
        ))
        
        stackIndex++
        
        if !more {
            break
        }
    }
    
    span.SetAttributes(attribute.Int("stack.depth", stackIndex))
}

// 使用示例
func Level3(ctx context.Context) {
    analyzer := NewCallChainAnalyzer()
    analyzer.AnalyzeCallStack(ctx, 10)
}

func Level2(ctx context.Context) {
    Level3(ctx)
}

func Level1(ctx context.Context) {
    Level2(ctx)
}

func ExampleCallChainAnalyzer() {
    ctx := context.Background()
    Level1(ctx)
    
    // Span 会包含完整的调用链:
    // stack-frame[0]: ExampleCallChainAnalyzer -> Level1
    // stack-frame[1]: Level1 -> Level2
    // stack-frame[2]: Level2 -> Level3
}
```

---

## 5. 动态属性注入

### 5.1 运行时属性生成

```go
// DynamicAttributeInjector 动态属性注入器
type DynamicAttributeInjector struct {
    tracer trace.Tracer
    
    // 属性生成器
    generators map[string]func(interface{}) interface{}
}

func NewDynamicAttributeInjector() *DynamicAttributeInjector {
    return &DynamicAttributeInjector{
        tracer:     otel.Tracer("dynamic-attribute-injector"),
        generators: make(map[string]func(interface{}) interface{}),
    }
}

// RegisterGenerator 注册属性生成器
func (dai *DynamicAttributeInjector) RegisterGenerator(name string, fn func(interface{}) interface{}) {
    dai.generators[name] = fn
}

// InjectDynamicAttributes 注入动态属性
func (dai *DynamicAttributeInjector) InjectDynamicAttributes(span trace.Span, obj interface{}) {
    v := reflect.ValueOf(obj)
    
    for v.Kind() == reflect.Ptr {
        v = v.Elem()
    }
    
    if v.Kind() != reflect.Struct {
        return
    }
    
    t := v.Type()
    
    for i := 0; i < v.NumField(); i++ {
        field := t.Field(i)
        
        // 检查是否有 otel_gen 标签(指定生成器)
        if generatorName := field.Tag.Get("otel_gen"); generatorName != "" {
            if generator, exists := dai.generators[generatorName]; exists {
                fieldValue := v.Field(i).Interface()
                generatedValue := generator(fieldValue)
                
                key := field.Name
                if otelTag := field.Tag.Get("otel"); otelTag != "" {
                    key = otelTag
                }
                
                span.SetAttributes(
                    attribute.String(key, fmt.Sprintf("%v", generatedValue)),
                )
            }
        }
    }
}

// 使用示例
type Product struct {
    ID    int    `otel:"product.id"`
    Price float64 `otel:"product.price" otel_gen:"tax_calculator"` // 动态计算税后价格
    SKU   string  `otel:"product.sku" otel_gen:"hash"`             // 动态生成哈希
}

func ExampleDynamicAttributeInjector() {
    injector := NewDynamicAttributeInjector()
    
    // 注册生成器
    injector.RegisterGenerator("tax_calculator", func(val interface{}) interface{} {
        price := val.(float64)
        return price * 1.1 // 10% 税
    })
    
    injector.RegisterGenerator("hash", func(val interface{}) interface{} {
        str := val.(string)
        hash := sha256.Sum256([]byte(str))
        return hex.EncodeToString(hash[:8]) // 前 8 字节
    })
    
    product := Product{
        ID:    123,
        Price: 100.0,
        SKU:   "ABC-123",
    }
    
    ctx, span := otel.Tracer("example").Start(context.Background(), "product-operation")
    defer span.End()
    
    injector.InjectDynamicAttributes(span, product)
    
    // Span 包含:
    // product.id=123
    // product.price="110" (自动计算税后价格)
    // product.sku="a3c5f..." (自动生成哈希)
}
```

### 5.2 条件属性注入

```go
// ConditionalInjector 条件属性注入器
type ConditionalInjector struct {
    tracer trace.Tracer
}

func NewConditionalInjector() *ConditionalInjector {
    return &ConditionalInjector{
        tracer: otel.Tracer("conditional-injector"),
    }
}

// InjectConditional 根据条件注入属性
func (ci *ConditionalInjector) InjectConditional(span trace.Span, obj interface{}) {
    v := reflect.ValueOf(obj)
    
    for v.Kind() == reflect.Ptr {
        v = v.Elem()
    }
    
    if v.Kind() != reflect.Struct {
        return
    }
    
    t := v.Type()
    
    for i := 0; i < v.NumField(); i++ {
        field := t.Field(i)
        fieldValue := v.Field(i)
        
        // 检查 otel_if 标签(条件表达式)
        if condition := field.Tag.Get("otel_if"); condition != "" {
            if !ci.evaluateCondition(condition, v) {
                continue // 条件不满足,跳过
            }
        }
        
        // 注入属性
        if otelTag := field.Tag.Get("otel"); otelTag != "" && otelTag != "-" {
            span.SetAttributes(ci.extractAttribute(otelTag, fieldValue))
        }
    }
}

// evaluateCondition 评估条件(简化实现)
func (ci *ConditionalInjector) evaluateCondition(condition string, structValue reflect.Value) bool {
    // 支持格式:field_name>value
    parts := strings.Split(condition, ">")
    if len(parts) != 2 {
        return false
    }
    
    fieldName := strings.TrimSpace(parts[0])
    threshold := strings.TrimSpace(parts[1])
    
    fieldValue := structValue.FieldByName(fieldName)
    if !fieldValue.IsValid() {
        return false
    }
    
    // 简化:仅支持整数比较
    if fieldValue.Kind() == reflect.Int || fieldValue.Kind() == reflect.Int64 {
        thresholdInt, _ := strconv.ParseInt(threshold, 10, 64)
        return fieldValue.Int() > thresholdInt
    }
    
    return false
}

func (ci *ConditionalInjector) extractAttribute(key string, v reflect.Value) attribute.KeyValue {
    switch v.Kind() {
    case reflect.Int, reflect.Int64:
        return attribute.Int64(key, v.Int())
    case reflect.String:
        return attribute.String(key, v.String())
    default:
        return attribute.String(key, fmt.Sprintf("%v", v.Interface()))
    }
}

// 使用示例
type Order struct {
    ID     int    `otel:"order.id"`
    Amount int    `otel:"order.amount"`
    Status string `otel:"order.status" otel_if:"Amount>1000"` // 仅当金额>1000时追踪状态
}

func ExampleConditionalInjector() {
    injector := NewConditionalInjector()
    
    // 金额小于 1000,Status 不会被追踪
    order1 := Order{ID: 1, Amount: 500, Status: "pending"}
    ctx, span1 := otel.Tracer("example").Start(context.Background(), "order-1")
    injector.InjectConditional(span1, order1)
    span1.End()
    // Span 仅包含:order.id=1, order.amount=500
    
    // 金额大于 1000,Status 会被追踪
    order2 := Order{ID: 2, Amount: 2000, Status: "completed"}
    ctx, span2 := otel.Tracer("example").Start(ctx, "order-2")
    injector.InjectConditional(span2, order2)
    span2.End()
    // Span 包含:order.id=2, order.amount=2000, order.status="completed"
}
```

### 5.3 属性模板系统

```go
// AttributeTemplate 属性模板系统
type AttributeTemplate struct {
    tracer trace.Tracer
}

func NewAttributeTemplate() *AttributeTemplate {
    return &AttributeTemplate{
        tracer: otel.Tracer("attribute-template"),
    }
}

// ApplyTemplate 应用属性模板
func (at *AttributeTemplate) ApplyTemplate(span trace.Span, obj interface{}, template string) {
    v := reflect.ValueOf(obj)
    
    for v.Kind() == reflect.Ptr {
        v = v.Elem()
    }
    
    if v.Kind() != reflect.Struct {
        return
    }
    
    // 解析模板(简化实现,使用正则提取 {{field_name}})
    re := regexp.MustCompile(`\{\{(\w+)\}\}`)
    matches := re.FindAllStringSubmatch(template, -1)
    
    result := template
    for _, match := range matches {
        placeholder := match[0] // {{field_name}}
        fieldName := match[1]   // field_name
        
        // 查找字段值
        fieldValue := v.FieldByName(fieldName)
        if fieldValue.IsValid() {
            replacement := fmt.Sprintf("%v", fieldValue.Interface())
            result = strings.ReplaceAll(result, placeholder, replacement)
        }
    }
    
    span.SetAttributes(attribute.String("template.result", result))
}

// 使用示例
type Request struct {
    UserID    int
    Endpoint  string
    Method    string
    Timestamp time.Time
}

func ExampleAttributeTemplate() {
    template := NewAttributeTemplate()
    
    request := Request{
        UserID:    123,
        Endpoint:  "/api/users",
        Method:    "GET",
        Timestamp: time.Now(),
    }
    
    ctx, span := otel.Tracer("example").Start(context.Background(), "request")
    defer span.End()
    
    // 应用模板
    tmpl := "User {{UserID}} requested {{Method}} {{Endpoint}}"
    template.ApplyTemplate(span, request, tmpl)
    
    // Span 包含:template.result="User 123 requested GET /api/users"
}
```

---

由于篇幅限制,我将继续完成后续章节...

## 6. 接口类型追踪

### 6.1 接口实现检测

```go
// InterfaceTracer 接口追踪器
type InterfaceTracer struct {
    tracer trace.Tracer
}

func NewInterfaceTracer() *InterfaceTracer {
    return &InterfaceTracer{
        tracer: otel.Tracer("interface-tracer"),
    }
}

// TraceInterface 追踪接口实现
func (it *InterfaceTracer) TraceInterface(ctx context.Context, obj interface{}) {
    ctx, span := it.tracer.Start(ctx, "trace-interface")
    defer span.End()
    
    t := reflect.TypeOf(obj)
    v := reflect.ValueOf(obj)
    
    // 记录实际类型
    span.SetAttributes(
        attribute.String("interface.actual_type", t.String()),
        attribute.String("interface.kind", t.Kind().String()),
    )
    
    // 检查实现的接口(仅针对具名接口)
    // 注意:Go 运行时无法直接列出所有接口,需要手动检查
    
    // 检查常见接口
    errorInterface := reflect.TypeOf((*error)(nil)).Elem()
    if t.Implements(errorInterface) {
        span.SetAttributes(attribute.Bool("interface.implements_error", true))
    }
    
    stringerInterface := reflect.TypeOf((*fmt.Stringer)(nil)).Elem()
    if t.Implements(stringerInterface) {
        span.SetAttributes(attribute.Bool("interface.implements_stringer", true))
        
        // 调用 String() 方法
        if v.CanInterface() {
            stringer := v.Interface().(fmt.Stringer)
            span.SetAttributes(attribute.String("interface.string_value", stringer.String()))
        }
    }
}
```

### 6.2 多态调用追踪

```go
// Traceable 可追踪接口
type Traceable interface {
    GetSpanName() string
    GetAttributes() []attribute.KeyValue
}

// PolymorphicTracer 多态追踪器
type PolymorphicTracer struct {
    tracer trace.Tracer
}

func NewPolymorphicTracer() *PolymorphicTracer {
    return &PolymorphicTracer{
        tracer: otel.Tracer("polymorphic-tracer"),
    }
}

// TraceOperation 追踪多态操作
func (pt *PolymorphicTracer) TraceOperation(ctx context.Context, obj Traceable) {
    // 使用接口方法获取 Span 信息
    spanName := obj.GetSpanName()
    attrs := obj.GetAttributes()
    
    ctx, span := pt.tracer.Start(ctx, spanName, trace.WithAttributes(attrs...))
    defer span.End()
    
    // 记录实际类型
    actualType := reflect.TypeOf(obj).String()
    span.SetAttributes(attribute.String("polymorphic.actual_type", actualType))
}

// 使用示例:不同类型实现相同接口
type PaymentProcessor interface {
    Traceable
    Process(amount float64) error
}

type CreditCardPayment struct {
    CardNumber string
}

func (ccp *CreditCardPayment) GetSpanName() string {
    return "process-credit-card-payment"
}

func (ccp *CreditCardPayment) GetAttributes() []attribute.KeyValue {
    return []attribute.KeyValue{
        attribute.String("payment.method", "credit_card"),
        attribute.String("payment.card_last4", ccp.CardNumber[len(ccp.CardNumber)-4:]),
    }
}

func (ccp *CreditCardPayment) Process(amount float64) error {
    // 处理逻辑
    return nil
}

type PayPalPayment struct {
    Email string
}

func (pp *PayPalPayment) GetSpanName() string {
    return "process-paypal-payment"
}

func (pp *PayPalPayment) GetAttributes() []attribute.KeyValue {
    return []attribute.KeyValue{
        attribute.String("payment.method", "paypal"),
        attribute.String("payment.email", pp.Email),
    }
}

func (pp *PayPalPayment) Process(amount float64) error {
    // 处理逻辑
    return nil
}

func ExamplePolymorphicTracer() {
    tracer := NewPolymorphicTracer()
    
    // 多态调用:不同类型使用相同追踪逻辑
    var processor PaymentProcessor
    
    processor = &CreditCardPayment{CardNumber: "1234567890123456"}
    tracer.TraceOperation(context.Background(), processor)
    
    processor = &PayPalPayment{Email: "user@example.com"}
    tracer.TraceOperation(context.Background(), processor)
}
```

### 6.3 类型断言优化

```go
// TypeAssertionOptimizer 类型断言优化器
type TypeAssertionOptimizer struct {
    tracer trace.Tracer
    
    // 类型缓存
    typeCache sync.Map // map[reflect.Type]bool
}

func NewTypeAssertionOptimizer() *TypeAssertionOptimizer {
    return &TypeAssertionOptimizer{
        tracer: otel.Tracer("type-assertion-optimizer"),
    }
}

// SafeAssert 安全的类型断言
func (tao *TypeAssertionOptimizer) SafeAssert(ctx context.Context, obj interface{}, targetType reflect.Type) (interface{}, bool) {
    ctx, span := tao.tracer.Start(ctx, "safe-type-assert")
    defer span.End()
    
    sourceType := reflect.TypeOf(obj)
    
    span.SetAttributes(
        attribute.String("assert.source_type", sourceType.String()),
        attribute.String("assert.target_type", targetType.String()),
    )
    
    // 检查缓存
    cacheKey := sourceType
    if cached, ok := tao.typeCache.Load(cacheKey); ok {
        if cached.(bool) {
            span.SetAttributes(attribute.Bool("assert.cache_hit", true))
            // 直接断言
            return obj, true
        }
    }
    
    // 检查是否可转换
    canConvert := sourceType.ConvertibleTo(targetType)
    
    span.SetAttributes(
        attribute.Bool("assert.can_convert", canConvert),
    )
    
    if canConvert {
        tao.typeCache.Store(cacheKey, true)
        v := reflect.ValueOf(obj)
        converted := v.Convert(targetType)
        return converted.Interface(), true
    }
    
    tao.typeCache.Store(cacheKey, false)
    return nil, false
}
```

---

## 7. 方法拦截与代理

### 7.1 透明代理模式

```go
// ProxyFactory 代理工厂
type ProxyFactory struct {
    tracer trace.Tracer
}

func NewProxyFactory() *ProxyFactory {
    return &ProxyFactory{
        tracer: otel.Tracer("proxy-factory"),
    }
}

// CreateProxy 创建透明代理
func (pf *ProxyFactory) CreateProxy(obj interface{}) interface{} {
    objValue := reflect.ValueOf(obj)
    objType := objValue.Type()
    
    if objType.Kind() != reflect.Ptr || objType.Elem().Kind() != reflect.Struct {
        panic("obj must be a pointer to struct")
    }
    
    // 创建代理结构体(复制所有方法)
    proxyValue := reflect.New(objType.Elem())
    
    // 复制字段值
    proxyValue.Elem().Set(objValue.Elem())
    
    return proxyValue.Interface()
}

// WrapMethods 包装所有导出方法
func (pf *ProxyFactory) WrapMethods(obj interface{}) map[string]func([]reflect.Value) []reflect.Value {
    objValue := reflect.ValueOf(obj)
    objType := objValue.Type()
    
    methods := make(map[string]func([]reflect.Value) []reflect.Value)
    
    for i := 0; i < objType.NumMethod(); i++ {
        method := objType.Method(i)
        
        if !method.IsExported() {
            continue
        }
        
        methodName := method.Name
        originalMethod := objValue.Method(i)
        
        // 创建包装函数
        wrapper := func(args []reflect.Value) []reflect.Value {
            ctx, span := pf.tracer.Start(context.Background(), methodName)
            defer span.End()
            
            span.SetAttributes(
                attribute.String("method.name", methodName),
                attribute.Int("method.num_args", len(args)),
            )
            
            // 调用原始方法
            results := originalMethod.Call(args)
            
            span.SetAttributes(
                attribute.Int("method.num_results", len(results)),
            )
            
            return results
        }
        
        methods[methodName] = wrapper
    }
    
    return methods
}
```

### 7.2 方法前置/后置处理

```go
// InterceptorChain 拦截器链
type InterceptorChain struct {
    tracer       trace.Tracer
    preHandlers  []func(context.Context, string, []interface{})
    postHandlers []func(context.Context, string, []interface{}, error)
}

func NewInterceptorChain() *InterceptorChain {
    return &InterceptorChain{
        tracer:       otel.Tracer("interceptor-chain"),
        preHandlers:  make([]func(context.Context, string, []interface{}), 0),
        postHandlers: make([]func(context.Context, string, []interface{}, error), 0),
    }
}

// AddPreHandler 添加前置处理器
func (ic *InterceptorChain) AddPreHandler(handler func(context.Context, string, []interface{})) {
    ic.preHandlers = append(ic.preHandlers, handler)
}

// AddPostHandler 添加后置处理器
func (ic *InterceptorChain) AddPostHandler(handler func(context.Context, string, []interface{}, error)) {
    ic.postHandlers = append(ic.postHandlers, handler)
}

// InterceptMethod 拦截方法调用
func (ic *InterceptorChain) InterceptMethod(ctx context.Context, methodName string, fn interface{}, args ...interface{}) ([]interface{}, error) {
    // 执行前置处理器
    for _, handler := range ic.preHandlers {
        handler(ctx, methodName, args)
    }
    
    // 调用原始方法
    fnValue := reflect.ValueOf(fn)
    in := make([]reflect.Value, len(args))
    for i, arg := range args {
        in[i] = reflect.ValueOf(arg)
    }
    
    out := fnValue.Call(in)
    
    // 提取结果
    results := make([]interface{}, len(out))
    var err error
    
    for i, val := range out {
        results[i] = val.Interface()
        
        // 检查最后一个返回值是否为 error
        if i == len(out)-1 && val.Type().Implements(reflect.TypeOf((*error)(nil)).Elem()) {
            if !val.IsNil() {
                err = val.Interface().(error)
            }
        }
    }
    
    // 执行后置处理器
    for _, handler := range ic.postHandlers {
        handler(ctx, methodName, results, err)
    }
    
    return results, err
}

// 使用示例
func ExampleInterceptorChain() {
    chain := NewInterceptorChain()
    
    // 注册前置处理器:记录参数
    chain.AddPreHandler(func(ctx context.Context, methodName string, args []interface{}) {
        fmt.Printf("[PRE] %s called with args: %v\n", methodName, args)
    })
    
    // 注册后置处理器:记录结果
    chain.AddPostHandler(func(ctx context.Context, methodName string, results []interface{}, err error) {
        if err != nil {
            fmt.Printf("[POST] %s failed with error: %v\n", methodName, err)
        } else {
            fmt.Printf("[POST] %s returned: %v\n", methodName, results)
        }
    })
    
    // 拦截方法调用
    add := func(a, b int) int { return a + b }
    results, _ := chain.InterceptMethod(context.Background(), "Add", add, 10, 20)
    fmt.Println("Result:", results[0].(int)) // 30
}
```

### 7.3 AOP 切面编程

```go
// Aspect 切面
type Aspect struct {
    Name    string
    Before  func(context.Context, *JoinPoint)
    After   func(context.Context, *JoinPoint, []interface{}, error)
    Around  func(context.Context, *JoinPoint, func() ([]interface{}, error)) ([]interface{}, error)
}

// JoinPoint 连接点
type JoinPoint struct {
    MethodName string
    Args       []interface{}
    Target     interface{}
}

// AOPWeaver AOP 织入器
type AOPWeaver struct {
    tracer  trace.Tracer
    aspects []Aspect
}

func NewAOPWeaver() *AOPWeaver {
    return &AOPWeaver{
        tracer:  otel.Tracer("aop-weaver"),
        aspects: make([]Aspect, 0),
    }
}

// AddAspect 添加切面
func (aw *AOPWeaver) AddAspect(aspect Aspect) {
    aw.aspects = append(aw.aspects, aspect)
}

// Weave 织入切面
func (aw *AOPWeaver) Weave(ctx context.Context, target interface{}, methodName string, fn interface{}, args ...interface{}) ([]interface{}, error) {
    ctx, span := aw.tracer.Start(ctx, "aop-weave")
    defer span.End()
    
    joinPoint := &JoinPoint{
        MethodName: methodName,
        Args:       args,
        Target:     target,
    }
    
    span.SetAttributes(
        attribute.String("aop.method", methodName),
        attribute.Int("aop.num_aspects", len(aw.aspects)),
    )
    
    // 执行所有 Before 切面
    for _, aspect := range aw.aspects {
        if aspect.Before != nil {
            aspect.Before(ctx, joinPoint)
        }
    }
    
    // 原始方法调用
    originalCall := func() ([]interface{}, error) {
        fnValue := reflect.ValueOf(fn)
        in := make([]reflect.Value, len(args))
        for i, arg := range args {
            in[i] = reflect.ValueOf(arg)
        }
        
        out := fnValue.Call(in)
        
        results := make([]interface{}, len(out))
        var err error
        
        for i, val := range out {
            results[i] = val.Interface()
            
            if i == len(out)-1 && val.Type().Implements(reflect.TypeOf((*error)(nil)).Elem()) {
                if !val.IsNil() {
                    err = val.Interface().(error)
                }
            }
        }
        
        return results, err
    }
    
    // 执行 Around 切面(嵌套调用)
    var finalCall func() ([]interface{}, error) = originalCall
    
    for i := len(aw.aspects) - 1; i >= 0; i-- {
        aspect := aw.aspects[i]
        if aspect.Around != nil {
            currentCall := finalCall
            aspect := aspect // 避免闭包问题
            finalCall = func() ([]interface{}, error) {
                return aspect.Around(ctx, joinPoint, currentCall)
            }
        }
    }
    
    // 执行最终调用
    results, err := finalCall()
    
    // 执行所有 After 切面
    for _, aspect := range aw.aspects {
        if aspect.After != nil {
            aspect.After(ctx, joinPoint, results, err)
        }
    }
    
    return results, err
}

// 使用示例
func ExampleAOPWeaver() {
    weaver := NewAOPWeaver()
    
    // 添加日志切面
    weaver.AddAspect(Aspect{
        Name: "LoggingAspect",
        Before: func(ctx context.Context, jp *JoinPoint) {
            fmt.Printf("[LOG] Calling %s with args: %v\n", jp.MethodName, jp.Args)
        },
        After: func(ctx context.Context, jp *JoinPoint, results []interface{}, err error) {
            fmt.Printf("[LOG] %s completed with results: %v, error: %v\n", jp.MethodName, results, err)
        },
    })
    
    // 添加性能监控切面
    weaver.AddAspect(Aspect{
        Name: "PerformanceAspect",
        Around: func(ctx context.Context, jp *JoinPoint, proceed func() ([]interface{}, error)) ([]interface{}, error) {
            start := time.Now()
            results, err := proceed()
            duration := time.Since(start)
            
            fmt.Printf("[PERF] %s took %v\n", jp.MethodName, duration)
            
            return results, err
        },
    })
    
    // 织入切面并调用方法
    multiply := func(a, b int) int { return a * b }
    results, _ := weaver.Weave(context.Background(), nil, "Multiply", multiply, 5, 6)
    fmt.Println("Result:", results[0].(int)) // 30
}
```

---

## 8. 性能优化

### 8.1 反射缓存机制

```go
// ReflectionCache 反射缓存
type ReflectionCache struct {
    typeCache   sync.Map // map[reflect.Type]*TypeInfo
    methodCache sync.Map // map[reflect.Type][]MethodInfo
    fieldCache  sync.Map // map[reflect.Type][]FieldInfo
}

type TypeInfo struct {
    Type     reflect.Type
    Kind     reflect.Kind
    NumField int
    NumMethod int
}

type MethodInfo struct {
    Name      string
    Type      reflect.Type
    NumIn     int
    NumOut    int
    Func      reflect.Value
}

type FieldInfo struct {
    Name      string
    Type      reflect.Type
    Tag       reflect.StructTag
    Offset    uintptr
    Index     int
}

var globalReflectionCache = &ReflectionCache{}

// GetTypeInfo 获取类型信息(带缓存)
func (rc *ReflectionCache) GetTypeInfo(t reflect.Type) *TypeInfo {
    if cached, ok := rc.typeCache.Load(t); ok {
        return cached.(*TypeInfo)
    }
    
    info := &TypeInfo{
        Type: t,
        Kind: t.Kind(),
    }
    
    if t.Kind() == reflect.Struct {
        info.NumField = t.NumField()
    }
    
    info.NumMethod = t.NumMethod()
    
    rc.typeCache.Store(t, info)
    return info
}

// GetMethodInfo 获取方法信息(带缓存)
func (rc *ReflectionCache) GetMethodInfo(t reflect.Type) []MethodInfo {
    if cached, ok := rc.methodCache.Load(t); ok {
        return cached.([]MethodInfo)
    }
    
    methods := make([]MethodInfo, t.NumMethod())
    
    for i := 0; i < t.NumMethod(); i++ {
        method := t.Method(i)
        methods[i] = MethodInfo{
            Name:   method.Name,
            Type:   method.Type,
            NumIn:  method.Type.NumIn(),
            NumOut: method.Type.NumOut(),
            Func:   method.Func,
        }
    }
    
    rc.methodCache.Store(t, methods)
    return methods
}

// GetFieldInfo 获取字段信息(带缓存)
func (rc *ReflectionCache) GetFieldInfo(t reflect.Type) []FieldInfo {
    if cached, ok := rc.fieldCache.Load(t); ok {
        return cached.([]FieldInfo)
    }
    
    if t.Kind() != reflect.Struct {
        return nil
    }
    
    fields := make([]FieldInfo, t.NumField())
    
    for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        fields[i] = FieldInfo{
            Name:   field.Name,
            Type:   field.Type,
            Tag:    field.Tag,
            Offset: field.Offset,
            Index:  i,
        }
    }
    
    rc.fieldCache.Store(t, fields)
    return fields
}
```

### 8.2 类型转换优化

```go
// FastConverter 快速类型转换器
type FastConverter struct {
    converterCache sync.Map // map[string]func(interface{}) attribute.KeyValue
}

func NewFastConverter() *FastConverter {
    fc := &FastConverter{}
    
    // 预注册常见类型转换器
    fc.RegisterConverter("int", func(val interface{}) attribute.KeyValue {
        return attribute.Int("", val.(int))
    })
    
    fc.RegisterConverter("string", func(val interface{}) attribute.KeyValue {
        return attribute.String("", val.(string))
    })
    
    fc.RegisterConverter("bool", func(val interface{}) attribute.KeyValue {
        return attribute.Bool("", val.(bool))
    })
    
    return fc
}

// RegisterConverter 注册转换器
func (fc *FastConverter) RegisterConverter(typeName string, converter func(interface{}) attribute.KeyValue) {
    fc.converterCache.Store(typeName, converter)
}

// Convert 快速转换
func (fc *FastConverter) Convert(key string, val interface{}) attribute.KeyValue {
    typeName := reflect.TypeOf(val).String()
    
    if converter, ok := fc.converterCache.Load(typeName); ok {
        attr := converter.(func(interface{}) attribute.KeyValue)(val)
        return attribute.KeyValue{Key: attribute.Key(key), Value: attr.Value}
    }
    
    // 回退到反射
    return attribute.String(key, fmt.Sprintf("%v", val))
}
```

### 8.3 避免反射陷阱

```go
// 反射性能陷阱与优化建议

// ❌ 陷阱 1:频繁调用 reflect.ValueOf
func SlowAttributeExtraction(obj interface{}, count int) {
    for i := 0; i < count; i++ {
        v := reflect.ValueOf(obj) // 每次循环都创建新的 Value
        _ = v.Kind()
    }
}

// ✅ 优化:复用 Value
func FastAttributeExtraction(obj interface{}, count int) {
    v := reflect.ValueOf(obj) // 仅创建一次
    for i := 0; i < count; i++ {
        _ = v.Kind()
    }
}

// ❌ 陷阱 2:不必要的类型断言
func SlowTypeCheck(obj interface{}) bool {
    _, ok := obj.(string)
    if !ok {
        _, ok = obj.(int)
    }
    return ok
}

// ✅ 优化:使用 reflect.Kind 一次性判断
func FastTypeCheck(obj interface{}) bool {
    v := reflect.ValueOf(obj)
    kind := v.Kind()
    return kind == reflect.String || kind == reflect.Int
}

// ❌ 陷阱 3:在热路径中使用反射
func SlowLoop(objects []interface{}) {
    for _, obj := range objects {
        v := reflect.ValueOf(obj)
        // 反射操作在循环中
        _ = v.Interface()
    }
}

// ✅ 优化:提前类型断言,避免反射
func FastLoop(objects []interface{}) {
    for _, obj := range objects {
        // 尝试直接类型断言
        switch v := obj.(type) {
        case string:
            _ = v
        case int:
            _ = v
        default:
            // 仅在必要时使用反射
            _ = reflect.ValueOf(v).Interface()
        }
    }
}
```

---

## 9. 高级应用场景

### 综合示例-自动化追踪框架

```go
package autotracing

import (
    "context"
    "reflect"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

// AutoTracingFramework 自动追踪框架
type AutoTracingFramework struct {
    tracer     trace.Tracer
    cache      *ReflectionCache
    extractor  *ValueExtractor
    aopWeaver  *AOPWeaver
}

func NewAutoTracingFramework() *AutoTracingFramework {
    framework := &AutoTracingFramework{
        tracer:    otel.Tracer("auto-tracing-framework"),
        cache:     &ReflectionCache{},
        extractor: NewValueExtractor(),
        aopWeaver: NewAOPWeaver(),
    }
    
    // 注册默认切面
    framework.registerDefaultAspects()
    
    return framework
}

// registerDefaultAspects 注册默认切面
func (atf *AutoTracingFramework) registerDefaultAspects() {
    // 追踪切面
    atf.aopWeaver.AddAspect(Aspect{
        Name: "TracingAspect",
        Before: func(ctx context.Context, jp *JoinPoint) {
            // 自动提取参数并注入到 Span
        },
        After: func(ctx context.Context, jp *JoinPoint, results []interface{}, err error) {
            // 自动记录返回值
        },
    })
}

// WrapService 包装服务对象
func (atf *AutoTracingFramework) WrapService(service interface{}) interface{} {
    serviceValue := reflect.ValueOf(service)
    serviceType := serviceValue.Type()
    
    // 缓存类型信息
    typeInfo := atf.cache.GetTypeInfo(serviceType)
    
    // 创建代理
    // ... (实现略)
    
    return service
}

// TraceMethodCall 自动追踪方法调用
func (atf *AutoTracingFramework) TraceMethodCall(ctx context.Context, target interface{}, methodName string, args ...interface{}) ([]interface{}, error) {
    // 使用 AOP 织入追踪逻辑
    targetValue := reflect.ValueOf(target)
    method := targetValue.MethodByName(methodName)
    
    return atf.aopWeaver.Weave(ctx, target, methodName, method.Interface(), args...)
}
```

---

## 总结

本指南涵盖了 Go 1.25.1 反射与动态追踪的完整技术:

1. **反射基础**:类型信息提取、值转换
2. **自动追踪结构体**:标签驱动、递归追踪
3. **函数追踪**:参数捕获、返回值追踪、调用链分析
4. **动态属性注入**:运行时生成、条件注入、模板系统
5. **接口追踪**:实现检测、多态调用
6. **方法拦截**:代理模式、AOP 切面
7. **性能优化**:反射缓存、类型转换优化
8. **高级应用**:自动化追踪框架

通过反射技术,可实现 **零侵入、高度自动化** 的 OTLP 集成,显著减少样板代码。
