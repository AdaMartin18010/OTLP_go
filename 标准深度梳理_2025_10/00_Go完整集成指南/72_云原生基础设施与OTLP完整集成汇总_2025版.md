# 72. äº‘åŸç”ŸåŸºç¡€è®¾æ–½ä¸ OTLP å®Œæ•´é›†æˆæ±‡æ€»ï¼ˆ2025ç‰ˆï¼‰

> **æ¶µç›–æ¡†æ¶**: Consul, Etcd, Vault, Envoy, Temporal, Prometheus, Jaeger  
> **Go ç‰ˆæœ¬**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0  
> **æœ€åæ›´æ–°**: 2025-10-11  
> **æ–‡æ¡£çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª

---

## ğŸ“‹ ç›®å½•

- [72. äº‘åŸç”ŸåŸºç¡€è®¾æ–½ä¸ OTLP å®Œæ•´é›†æˆæ±‡æ€»ï¼ˆ2025ç‰ˆï¼‰](#72-äº‘åŸç”ŸåŸºç¡€è®¾æ–½ä¸-otlp-å®Œæ•´é›†æˆæ±‡æ€»2025ç‰ˆ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. Consul æœåŠ¡å‘ç°ä¸é…ç½®ä¸­å¿ƒ](#1-consul-æœåŠ¡å‘ç°ä¸é…ç½®ä¸­å¿ƒ)
    - [1.1 Consul æ ¸å¿ƒèƒ½åŠ›](#11-consul-æ ¸å¿ƒèƒ½åŠ›)
    - [1.2 æœåŠ¡æ³¨å†Œä¸å‘ç°ï¼ˆå¸¦è¿½è¸ªï¼‰](#12-æœåŠ¡æ³¨å†Œä¸å‘ç°å¸¦è¿½è¸ª)
    - [1.3 åˆ†å¸ƒå¼é…ç½®ï¼ˆå¸¦è¿½è¸ª)](#13-åˆ†å¸ƒå¼é…ç½®å¸¦è¿½è¸ª)
    - [1.4 å¥åº·æ£€æŸ¥ä¸è¿½è¸ª](#14-å¥åº·æ£€æŸ¥ä¸è¿½è¸ª)
  - [2. Etcd åˆ†å¸ƒå¼åè°ƒ](#2-etcd-åˆ†å¸ƒå¼åè°ƒ)
    - [2.1 Etcd æ ¸å¿ƒç‰¹æ€§](#21-etcd-æ ¸å¿ƒç‰¹æ€§)
    - [2.2 æœåŠ¡æ³¨å†Œï¼ˆå¸¦è¿½è¸ªï¼‰](#22-æœåŠ¡æ³¨å†Œå¸¦è¿½è¸ª)
    - [2.3 åˆ†å¸ƒå¼é”ï¼ˆå¸¦è¿½è¸ªï¼‰](#23-åˆ†å¸ƒå¼é”å¸¦è¿½è¸ª)
    - [2.4 Watch æœºåˆ¶è¿½è¸ª](#24-watch-æœºåˆ¶è¿½è¸ª)
  - [3. Vault å¯†é’¥ç®¡ç†](#3-vault-å¯†é’¥ç®¡ç†)
    - [3.1 Vault æ ¸å¿ƒèƒ½åŠ›](#31-vault-æ ¸å¿ƒèƒ½åŠ›)
    - [3.2 å¯†é’¥è¯»å–ï¼ˆå¸¦è¿½è¸ªï¼‰](#32-å¯†é’¥è¯»å–å¸¦è¿½è¸ª)
    - [3.3 åŠ¨æ€å¯†é’¥ï¼ˆå¸¦è¿½è¸ªï¼‰](#33-åŠ¨æ€å¯†é’¥å¸¦è¿½è¸ª)
  - [4. Envoy Proxy é›†æˆ](#4-envoy-proxy-é›†æˆ)
    - [4.1 Envoy è¿½è¸ªé…ç½®](#41-envoy-è¿½è¸ªé…ç½®)
    - [4.2 Go åº”ç”¨ä¸ Envoy é›†æˆ](#42-go-åº”ç”¨ä¸-envoy-é›†æˆ)
  - [5. Temporal å·¥ä½œæµå¼•æ“](#5-temporal-å·¥ä½œæµå¼•æ“)
    - [5.1 Temporal æ ¸å¿ƒæ¦‚å¿µ](#51-temporal-æ ¸å¿ƒæ¦‚å¿µ)
    - [5.2 å·¥ä½œæµå®šä¹‰ï¼ˆå¸¦è¿½è¸ªï¼‰](#52-å·¥ä½œæµå®šä¹‰å¸¦è¿½è¸ª)
    - [5.3 Activity å®ç°ï¼ˆå¸¦è¿½è¸ª)](#53-activity-å®ç°å¸¦è¿½è¸ª)
  - [6. Prometheus åŸç”Ÿé›†æˆ](#6-prometheus-åŸç”Ÿé›†æˆ)
    - [6.1 Prometheus vs OTLP](#61-prometheus-vs-otlp)
    - [6.2 åŒé‡æŒ‡æ ‡å¯¼å‡º](#62-åŒé‡æŒ‡æ ‡å¯¼å‡º)
    - [6.3 Exemplars é›†æˆ](#63-exemplars-é›†æˆ)
  - [7. Jaeger Native SDK](#7-jaeger-native-sdk)
    - [7.1 Jaeger vs OTLP](#71-jaeger-vs-otlp)
    - [7.2 Jaeger åŸç”Ÿé›†æˆ](#72-jaeger-åŸç”Ÿé›†æˆ)
    - [7.3 è¿ç§»åˆ° OTLP](#73-è¿ç§»åˆ°-otlp)
  - [8. å®Œæ•´é›†æˆç¤ºä¾‹](#8-å®Œæ•´é›†æˆç¤ºä¾‹)
    - [8.1 å¾®æœåŠ¡æ¶æ„](#81-å¾®æœåŠ¡æ¶æ„)
    - [8.2 å®Œæ•´ä»£ç ç¤ºä¾‹](#82-å®Œæ•´ä»£ç ç¤ºä¾‹)
  - [9. æœ€ä½³å®è·µ](#9-æœ€ä½³å®è·µ)
    - [9.1 æŠ€æœ¯é€‰å‹](#91-æŠ€æœ¯é€‰å‹)
    - [9.2 æ€§èƒ½ä¼˜åŒ–](#92-æ€§èƒ½ä¼˜åŒ–)
    - [9.3 å®‰å…¨é…ç½®](#93-å®‰å…¨é…ç½®)
  - [10. æ€»ç»“](#10-æ€»ç»“)
    - [10.1 æŠ€æœ¯æ ˆå¯¹æ¯”](#101-æŠ€æœ¯æ ˆå¯¹æ¯”)
    - [10.2 é€‚ç”¨åœºæ™¯](#102-é€‚ç”¨åœºæ™¯)
    - [10.3 ç›¸å…³èµ„æº](#103-ç›¸å…³èµ„æº)

---

## 1. Consul æœåŠ¡å‘ç°ä¸é…ç½®ä¸­å¿ƒ

### 1.1 Consul æ ¸å¿ƒèƒ½åŠ›

**HashiCorp Consul** æ˜¯äº‘åŸç”ŸæœåŠ¡ç½‘æ ¼è§£å†³æ–¹æ¡ˆï¼Œæä¾›æœåŠ¡å‘ç°ã€é…ç½®ç®¡ç†ã€å¥åº·æ£€æŸ¥ã€‚

```text
âœ… æœåŠ¡å‘ç°      - DNS + HTTP API
âœ… å¥åº·æ£€æŸ¥      - TCP/HTTP/gRPC/Script
âœ… KV å­˜å‚¨       - åˆ†å¸ƒå¼é…ç½®
âœ… æœåŠ¡ç½‘æ ¼      - Envoy é›†æˆ
âœ… å¤šæ•°æ®ä¸­å¿ƒ    - è·¨ DC å¤åˆ¶
âœ… ACL æƒé™      - ç»†ç²’åº¦è®¿é—®æ§åˆ¶
```

### 1.2 æœåŠ¡æ³¨å†Œä¸å‘ç°ï¼ˆå¸¦è¿½è¸ªï¼‰

```go
// pkg/consul/registry.go
package consul

import (
    "context"
    "fmt"
    "time"

    consulapi "github.com/hashicorp/consul/api"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

type ServiceRegistry struct {
    client *consulapi.Client
    tracer trace.Tracer
}

func NewServiceRegistry(address string) (*ServiceRegistry, error) {
    config := consulapi.DefaultConfig()
    config.Address = address
    
    client, err := consulapi.NewClient(config)
    if err != nil {
        return nil, err
    }
    
    return &ServiceRegistry{
        client: client,
        tracer: otel.Tracer("consul-registry"),
    }, nil
}

// Register æ³¨å†ŒæœåŠ¡ï¼ˆå¸¦è¿½è¸ªï¼‰
func (r *ServiceRegistry) Register(ctx context.Context, service *ServiceInfo) error {
    ctx, span := r.tracer.Start(ctx, "Consul.Register",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            attribute.String("consul.service_name", service.Name),
            attribute.String("consul.service_id", service.ID),
            attribute.String("consul.address", service.Address),
            attribute.Int("consul.port", service.Port),
        ),
    )
    defer span.End()
    
    // æ„å»º Consul æ³¨å†Œä¿¡æ¯
    registration := &consulapi.AgentServiceRegistration{
        ID:      service.ID,
        Name:    service.Name,
        Address: service.Address,
        Port:    service.Port,
        Tags:    service.Tags,
        Meta: map[string]string{
            "version":     service.Version,
            "environment": service.Environment,
        },
        Check: &consulapi.AgentServiceCheck{
            HTTP:                           fmt.Sprintf("http://%s:%d/health", service.Address, service.Port),
            Interval:                       "10s",
            Timeout:                        "3s",
            DeregisterCriticalServiceAfter: "30s",
        },
    }
    
    // æ³¨å†ŒæœåŠ¡
    if err := r.client.Agent().ServiceRegister(registration); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.AddEvent("service registered")
    span.SetStatus(codes.Ok, "")
    return nil
}

// Discover æœåŠ¡å‘ç°ï¼ˆå¸¦è¿½è¸ªï¼‰
func (r *ServiceRegistry) Discover(ctx context.Context, serviceName string) ([]*ServiceInstance, error) {
    ctx, span := r.tracer.Start(ctx, "Consul.Discover",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            attribute.String("consul.service_name", serviceName),
        ),
    )
    defer span.End()
    
    // æŸ¥è¯¢å¥åº·çš„æœåŠ¡å®ä¾‹
    services, _, err := r.client.Health().Service(serviceName, "", true, &consulapi.QueryOptions{
        RequireConsistent: true,
    })
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return nil, err
    }
    
    instances := make([]*ServiceInstance, len(services))
    for i, svc := range services {
        instances[i] = &ServiceInstance{
            ID:      svc.Service.ID,
            Name:    svc.Service.Service,
            Address: svc.Service.Address,
            Port:    svc.Service.Port,
            Tags:    svc.Service.Tags,
            Meta:    svc.Service.Meta,
        }
    }
    
    span.SetAttributes(
        attribute.Int("consul.instances_count", len(instances)),
    )
    span.SetStatus(codes.Ok, "")
    
    return instances, nil
}

type ServiceInfo struct {
    ID          string
    Name        string
    Address     string
    Port        int
    Tags        []string
    Version     string
    Environment string
}

type ServiceInstance struct {
    ID      string
    Name    string
    Address string
    Port    int
    Tags    []string
    Meta    map[string]string
}
```

### 1.3 åˆ†å¸ƒå¼é…ç½®ï¼ˆå¸¦è¿½è¸ª)

```go
// pkg/consul/config.go
package consul

import (
    "context"
    
    consulapi "github.com/hashicorp/consul/api"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

type ConfigStore struct {
    client *consulapi.Client
    tracer trace.Tracer
}

func NewConfigStore(address string) (*ConfigStore, error) {
    config := consulapi.DefaultConfig()
    config.Address = address
    
    client, err := consulapi.NewClient(config)
    if err != nil {
        return nil, err
    }
    
    return &ConfigStore{
        client: client,
        tracer: otel.Tracer("consul-config"),
    }, nil
}

// GetConfig è·å–é…ç½®ï¼ˆå¸¦è¿½è¸ªï¼‰
func (s *ConfigStore) GetConfig(ctx context.Context, key string) (string, error) {
    ctx, span := s.tracer.Start(ctx, "Consul.GetConfig",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            attribute.String("consul.key", key),
        ),
    )
    defer span.End()
    
    // ä» Consul KV è¯»å–
    pair, _, err := s.client.KV().Get(key, nil)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return "", err
    }
    
    if pair == nil {
        span.SetStatus(codes.Ok, "key not found")
        return "", ErrKeyNotFound
    }
    
    value := string(pair.Value)
    span.SetAttributes(
        attribute.Int("consul.value_length", len(value)),
        attribute.Int64("consul.modify_index", int64(pair.ModifyIndex)),
    )
    span.SetStatus(codes.Ok, "")
    
    return value, nil
}

// WatchConfig ç›‘å¬é…ç½®å˜åŒ–ï¼ˆå¸¦è¿½è¸ªï¼‰
func (s *ConfigStore) WatchConfig(ctx context.Context, key string, callback func(string)) error {
    ctx, span := s.tracer.Start(ctx, "Consul.WatchConfig",
        trace.WithAttributes(
            attribute.String("consul.key", key),
        ),
    )
    defer span.End()
    
    go func() {
        var lastIndex uint64
        
        for {
            select {
            case <-ctx.Done():
                return
            default:
                // é˜»å¡æŸ¥è¯¢
                pair, meta, err := s.client.KV().Get(key, &consulapi.QueryOptions{
                    WaitIndex: lastIndex,
                })
                
                if err != nil {
                    time.Sleep(time.Second)
                    continue
                }
                
                if pair != nil && meta.LastIndex > lastIndex {
                    lastIndex = meta.LastIndex
                    
                    // é…ç½®å˜åŒ–å›è°ƒï¼ˆå¸¦è¿½è¸ªï¼‰
                    _, updateSpan := s.tracer.Start(ctx, "Config.Update",
                        trace.WithAttributes(
                            attribute.String("consul.key", key),
                            attribute.Int64("consul.index", int64(lastIndex)),
                        ),
                    )
                    
                    callback(string(pair.Value))
                    updateSpan.End()
                }
            }
        }
    }()
    
    span.SetStatus(codes.Ok, "")
    return nil
}
```

### 1.4 å¥åº·æ£€æŸ¥ä¸è¿½è¸ª

```go
// pkg/consul/health.go
package consul

import (
    "context"
    "net/http"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

type HealthChecker struct {
    tracer trace.Tracer
}

func NewHealthChecker() *HealthChecker {
    return &HealthChecker{
        tracer: otel.Tracer("health-checker"),
    }
}

// HealthHandler HTTP å¥åº·æ£€æŸ¥å¤„ç†å™¨ï¼ˆå¸¦è¿½è¸ªï¼‰
func (h *HealthChecker) HealthHandler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    ctx, span := h.tracer.Start(ctx, "HealthCheck",
        trace.WithSpanKind(trace.SpanKindServer),
        trace.WithAttributes(
            attribute.String("http.method", r.Method),
            attribute.String("http.target", r.URL.Path),
        ),
    )
    defer span.End()
    
    // æ£€æŸ¥å„é¡¹ä¾èµ–
    checks := []Check{
        {Name: "database", Checker: h.checkDatabase},
        {Name: "redis", Checker: h.checkRedis},
        {Name: "downstream", Checker: h.checkDownstream},
    }
    
    healthy := true
    for _, check := range checks {
        _, checkSpan := h.tracer.Start(ctx, "Check."+check.Name)
        
        if err := check.Checker(ctx); err != nil {
            healthy = false
            checkSpan.RecordError(err)
            checkSpan.SetAttributes(attribute.Bool("healthy", false))
        } else {
            checkSpan.SetAttributes(attribute.Bool("healthy", true))
        }
        
        checkSpan.End()
    }
    
    if healthy {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{"status":"healthy"}`))
        span.SetStatus(codes.Ok, "healthy")
    } else {
        w.WriteHeader(http.StatusServiceUnavailable)
        w.Write([]byte(`{"status":"unhealthy"}`))
        span.SetStatus(codes.Error, "unhealthy")
    }
}

type Check struct {
    Name    string
    Checker func(context.Context) error
}

func (h *HealthChecker) checkDatabase(ctx context.Context) error {
    // æ•°æ®åº“å¥åº·æ£€æŸ¥
    return nil
}

func (h *HealthChecker) checkRedis(ctx context.Context) error {
    // Redis å¥åº·æ£€æŸ¥
    return nil
}

func (h *HealthChecker) checkDownstream(ctx context.Context) error {
    // ä¸‹æ¸¸æœåŠ¡å¥åº·æ£€æŸ¥
    return nil
}
```

---

## 2. Etcd åˆ†å¸ƒå¼åè°ƒ

### 2.1 Etcd æ ¸å¿ƒç‰¹æ€§

**Etcd** æ˜¯ Kubernetes åº•å±‚çš„åˆ†å¸ƒå¼ KV å­˜å‚¨ï¼Œæä¾›å¼ºä¸€è‡´æ€§ä¿è¯ã€‚

```text
âœ… å¼ºä¸€è‡´æ€§      - Raft åè®®
âœ… Watch æœºåˆ¶    - å®æ—¶é…ç½®æ›´æ–°
âœ… åˆ†å¸ƒå¼é”      - ç§Ÿçº¦æœºåˆ¶
âœ… äº‹åŠ¡æ”¯æŒ      - MVCC
âœ… gRPC API     - é«˜æ€§èƒ½
```

### 2.2 æœåŠ¡æ³¨å†Œï¼ˆå¸¦è¿½è¸ªï¼‰

```go
// pkg/etcd/registry.go
package etcd

import (
    "context"
    "fmt"
    "time"

    clientv3 "go.etcd.io/etcd/client/v3"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

type EtcdRegistry struct {
    client *clientv3.Client
    tracer trace.Tracer
    ttl    int64
}

func NewEtcdRegistry(endpoints []string, ttl int64) (*EtcdRegistry, error) {
    cli, err := clientv3.New(clientv3.Config{
        Endpoints:   endpoints,
        DialTimeout: 5 * time.Second,
    })
    if err != nil {
        return nil, err
    }
    
    return &EtcdRegistry{
        client: cli,
        tracer: otel.Tracer("etcd-registry"),
        ttl:    ttl,
    }, nil
}

// Register æ³¨å†ŒæœåŠ¡ï¼ˆå¸¦ç§Ÿçº¦å’Œè¿½è¸ªï¼‰
func (r *EtcdRegistry) Register(ctx context.Context, service *ServiceInfo) error {
    ctx, span := r.tracer.Start(ctx, "Etcd.Register",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            attribute.String("etcd.service_name", service.Name),
            attribute.String("etcd.service_id", service.ID),
        ),
    )
    defer span.End()
    
    // 1. åˆ›å»ºç§Ÿçº¦
    ctx, leaseSpan := r.tracer.Start(ctx, "Etcd.Grant")
    lease, err := r.client.Grant(ctx, r.ttl)
    leaseSpan.End()
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "grant lease failed")
        return err
    }
    
    leaseSpan.SetAttributes(
        attribute.Int64("etcd.lease_id", int64(lease.ID)),
        attribute.Int64("etcd.ttl", r.ttl),
    )
    
    // 2. æ³¨å†ŒæœåŠ¡
    key := fmt.Sprintf("/services/%s/%s", service.Name, service.ID)
    value := fmt.Sprintf("%s:%d", service.Address, service.Port)
    
    ctx, putSpan := r.tracer.Start(ctx, "Etcd.Put")
    _, err = r.client.Put(ctx, key, value, clientv3.WithLease(lease.ID))
    putSpan.End()
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "put service failed")
        return err
    }
    
    // 3. ä¿æŒå¿ƒè·³
    go r.keepAlive(context.Background(), lease.ID, service)
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// keepAlive ä¿æŒç§Ÿçº¦ï¼ˆå¸¦è¿½è¸ªï¼‰
func (r *EtcdRegistry) keepAlive(ctx context.Context, leaseID clientv3.LeaseID, service *ServiceInfo) {
    ch, err := r.client.KeepAlive(ctx, leaseID)
    if err != nil {
        return
    }
    
    for {
        select {
        case <-ctx.Done():
            return
        case ka, ok := <-ch:
            if !ok {
                // ç§Ÿçº¦å¤±æ•ˆï¼Œéœ€è¦é‡æ–°æ³¨å†Œ
                r.Register(ctx, service)
                return
            }
            
            // è¿½è¸ªå¿ƒè·³
            _, span := r.tracer.Start(ctx, "Etcd.KeepAlive",
                trace.WithAttributes(
                    attribute.Int64("etcd.lease_id", int64(leaseID)),
                    attribute.Int64("etcd.ttl", ka.TTL),
                ),
            )
            span.End()
        }
    }
}
```

### 2.3 åˆ†å¸ƒå¼é”ï¼ˆå¸¦è¿½è¸ªï¼‰

```go
// pkg/etcd/lock.go
package etcd

import (
    "context"
    "time"

    clientv3 "go.etcd.io/etcd/client/v3"
    "go.etcd.io/etcd/client/v3/concurrency"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

type DistributedLock struct {
    client *clientv3.Client
    tracer trace.Tracer
}

func NewDistributedLock(endpoints []string) (*DistributedLock, error) {
    cli, err := clientv3.New(clientv3.Config{
        Endpoints:   endpoints,
        DialTimeout: 5 * time.Second,
    })
    if err != nil {
        return nil, err
    }
    
    return &DistributedLock{
        client: cli,
        tracer: otel.Tracer("etcd-lock"),
    }, nil
}

// Lock è·å–åˆ†å¸ƒå¼é”ï¼ˆå¸¦è¿½è¸ªï¼‰
func (l *DistributedLock) Lock(ctx context.Context, key string) (func(), error) {
    ctx, span := l.tracer.Start(ctx, "Etcd.Lock",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            attribute.String("etcd.lock_key", key),
        ),
    )
    defer span.End()
    
    // åˆ›å»º Session
    session, err := concurrency.NewSession(l.client)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "create session failed")
        return nil, err
    }
    
    // åˆ›å»º Mutex
    mutex := concurrency.NewMutex(session, key)
    
    // è·å–é”
    startTime := time.Now()
    if err := mutex.Lock(ctx); err != nil {
        session.Close()
        span.RecordError(err)
        span.SetStatus(codes.Error, "acquire lock failed")
        return nil, err
    }
    
    duration := time.Since(startTime)
    span.SetAttributes(
        attribute.Int64("etcd.lock_wait_ms", duration.Milliseconds()),
    )
    span.AddEvent("lock acquired")
    span.SetStatus(codes.Ok, "")
    
    // è¿”å›è§£é”å‡½æ•°
    unlock := func() {
        _, unlockSpan := l.tracer.Start(context.Background(), "Etcd.Unlock",
            trace.WithAttributes(
                attribute.String("etcd.lock_key", key),
            ),
        )
        defer unlockSpan.End()
        
        mutex.Unlock(context.Background())
        session.Close()
        
        unlockSpan.AddEvent("lock released")
    }
    
    return unlock, nil
}

// TryLock å°è¯•è·å–é”ï¼ˆéé˜»å¡ï¼Œå¸¦è¿½è¸ªï¼‰
func (l *DistributedLock) TryLock(ctx context.Context, key string, timeout time.Duration) (func(), error) {
    ctx, cancel := context.WithTimeout(ctx, timeout)
    defer cancel()
    
    return l.Lock(ctx, key)
}
```

### 2.4 Watch æœºåˆ¶è¿½è¸ª

```go
// pkg/etcd/watcher.go
package etcd

import (
    "context"
    
    clientv3 "go.etcd.io/etcd/client/v3"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

type ConfigWatcher struct {
    client *clientv3.Client
    tracer trace.Tracer
}

func NewConfigWatcher(endpoints []string) (*ConfigWatcher, error) {
    cli, err := clientv3.New(clientv3.Config{
        Endpoints: endpoints,
    })
    if err != nil {
        return nil, err
    }
    
    return &ConfigWatcher{
        client: cli,
        tracer: otel.Tracer("etcd-watcher"),
    }, nil
}

// Watch ç›‘å¬é…ç½®å˜åŒ–ï¼ˆå¸¦è¿½è¸ªï¼‰
func (w *ConfigWatcher) Watch(ctx context.Context, key string, callback func(string)) error {
    ctx, span := w.tracer.Start(ctx, "Etcd.Watch",
        trace.WithAttributes(
            attribute.String("etcd.watch_key", key),
        ),
    )
    defer span.End()
    
    // åˆ›å»º Watch Channel
    watchChan := w.client.Watch(ctx, key)
    
    go func() {
        for {
            select {
            case <-ctx.Done():
                return
            case resp, ok := <-watchChan:
                if !ok {
                    return
                }
                
                if resp.Err() != nil {
                    continue
                }
                
                // å¤„ç†äº‹ä»¶ï¼ˆå¸¦è¿½è¸ªï¼‰
                for _, ev := range resp.Events {
                    _, eventSpan := w.tracer.Start(ctx, "Etcd.Event",
                        trace.WithAttributes(
                            attribute.String("etcd.event_type", ev.Type.String()),
                            attribute.String("etcd.key", string(ev.Kv.Key)),
                            attribute.Int64("etcd.mod_revision", ev.Kv.ModRevision),
                        ),
                    )
                    
                    callback(string(ev.Kv.Value))
                    eventSpan.End()
                }
            }
        }
    }()
    
    span.SetStatus(codes.Ok, "")
    return nil
}
```

---

## 3. Vault å¯†é’¥ç®¡ç†

### 3.1 Vault æ ¸å¿ƒèƒ½åŠ›

**HashiCorp Vault** æ˜¯äº‘åŸç”Ÿå¯†é’¥ç®¡ç†ç³»ç»Ÿã€‚

```text
âœ… å¯†é’¥ç®¡ç†      - åŠ å¯†å­˜å‚¨
âœ… åŠ¨æ€å¯†é’¥      - ä¸´æ—¶æ•°æ®åº“å‡­è¯
âœ… åŠ å¯†å³æœåŠ¡    - Transit Engine
âœ… å®¡è®¡æ—¥å¿—      - å®Œæ•´å®¡è®¡
âœ… å¤šç§è®¤è¯      - Token/K8s/LDAPç­‰
```

### 3.2 å¯†é’¥è¯»å–ï¼ˆå¸¦è¿½è¸ªï¼‰

```go
// pkg/vault/client.go
package vault

import (
    "context"
    
    vaultapi "github.com/hashicorp/vault/api"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

type VaultClient struct {
    client *vaultapi.Client
    tracer trace.Tracer
}

func NewVaultClient(address, token string) (*VaultClient, error) {
    config := vaultapi.DefaultConfig()
    config.Address = address
    
    client, err := vaultapi.NewClient(config)
    if err != nil {
        return nil, err
    }
    
    client.SetToken(token)
    
    return &VaultClient{
        client: client,
        tracer: otel.Tracer("vault-client"),
    }, nil
}

// GetSecret è¯»å–å¯†é’¥ï¼ˆå¸¦è¿½è¸ªï¼‰
func (v *VaultClient) GetSecret(ctx context.Context, path string) (map[string]interface{}, error) {
    ctx, span := v.tracer.Start(ctx, "Vault.GetSecret",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            attribute.String("vault.path", path),
        ),
    )
    defer span.End()
    
    // è¯»å–å¯†é’¥
    secret, err := v.client.Logical().ReadWithContext(ctx, path)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return nil, err
    }
    
    if secret == nil {
        span.SetStatus(codes.Ok, "secret not found")
        return nil, ErrSecretNotFound
    }
    
    span.SetAttributes(
        attribute.Int("vault.keys_count", len(secret.Data)),
    )
    span.SetStatus(codes.Ok, "")
    
    return secret.Data, nil
}
```

### 3.3 åŠ¨æ€å¯†é’¥ï¼ˆå¸¦è¿½è¸ªï¼‰

```go
// pkg/vault/database.go
package vault

import (
    "context"
    "database/sql"
    "time"
    
    vaultapi "github.com/hashicorp/vault/api"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

type DynamicDBCredentials struct {
    client *vaultapi.Client
    tracer trace.Tracer
}

func NewDynamicDBCredentials(address, token string) (*DynamicDBCredentials, error) {
    config := vaultapi.DefaultConfig()
    config.Address = address
    
    client, err := vaultapi.NewClient(config)
    if err != nil {
        return nil, err
    }
    
    client.SetToken(token)
    
    return &DynamicDBCredentials{
        client: client,
        tracer: otel.Tracer("vault-db-creds"),
    }, nil
}

// GetDBConnection è·å–åŠ¨æ€æ•°æ®åº“è¿æ¥ï¼ˆå¸¦è¿½è¸ªï¼‰
func (d *DynamicDBCredentials) GetDBConnection(ctx context.Context, roleName string) (*sql.DB, error) {
    ctx, span := d.tracer.Start(ctx, "Vault.GetDBConnection",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            attribute.String("vault.role", roleName),
        ),
    )
    defer span.End()
    
    // 1. è·å–åŠ¨æ€å‡­è¯
    path := "database/creds/" + roleName
    secret, err := d.client.Logical().ReadWithContext(ctx, path)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "read creds failed")
        return nil, err
    }
    
    username := secret.Data["username"].(string)
    password := secret.Data["password"].(string)
    leaseDuration := time.Duration(secret.LeaseDuration) * time.Second
    
    span.SetAttributes(
        attribute.String("vault.username", username),
        attribute.String("vault.lease_duration", leaseDuration.String()),
    )
    
    // 2. åˆ›å»ºæ•°æ®åº“è¿æ¥
    dsn := fmt.Sprintf("postgres://%s:%s@localhost:5432/mydb", username, password)
    db, err := sql.Open("postgres", dsn)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "open db failed")
        return nil, err
    }
    
    // 3. å¯åŠ¨ç»­ç§Ÿåç¨‹
    go d.renewLease(context.Background(), secret.LeaseID, leaseDuration)
    
    span.SetStatus(codes.Ok, "")
    return db, nil
}

// renewLease ç»­ç§Ÿï¼ˆå¸¦è¿½è¸ªï¼‰
func (d *DynamicDBCredentials) renewLease(ctx context.Context, leaseID string, duration time.Duration) {
    ticker := time.NewTicker(duration / 2)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            _, span := d.tracer.Start(ctx, "Vault.RenewLease",
                trace.WithAttributes(
                    attribute.String("vault.lease_id", leaseID),
                ),
            )
            
            _, err := d.client.Sys().Renew(leaseID, int(duration.Seconds()))
            if err != nil {
                span.RecordError(err)
            }
            
            span.End()
        }
    }
}
```

---

## 4. Envoy Proxy é›†æˆ

### 4.1 Envoy è¿½è¸ªé…ç½®

```yaml
# envoy.yaml
static_resources:
  listeners:
  - name: listener_0
    address:
      socket_address:
        address: 0.0.0.0
        port_value: 8080
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          tracing:
            provider:
              name: envoy.tracers.opentelemetry
              typed_config:
                "@type": type.googleapis.com/envoy.config.trace.v3.OpenTelemetryConfig
                grpc_service:
                  envoy_grpc:
                    cluster_name: otel_collector
                  timeout: 0.250s
                service_name: envoy-proxy
          http_filters:
          - name: envoy.filters.http.router
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
  
  clusters:
  - name: otel_collector
    type: STRICT_DNS
    lb_policy: ROUND_ROBIN
    load_assignment:
      cluster_name: otel_collector
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address:
                address: otel-collector
                port_value: 4317
```

### 4.2 Go åº”ç”¨ä¸ Envoy é›†æˆ

```go
// Envoy è‡ªåŠ¨æ³¨å…¥è¿½è¸ªå¤´ï¼ŒGo åº”ç”¨åªéœ€æå–
import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/propagation"
)

func handler(w http.ResponseWriter, r *http.Request) {
    // Envoy å·²ç»æ³¨å…¥äº† traceparent å¤´
    // æå– TraceContext
    ctx := otel.GetTextMapPropagator().Extract(r.Context(), 
        propagation.HeaderCarrier(r.Header))
    
    // åˆ›å»ºå­ Span
    _, span := tracer.Start(ctx, "handler")
    defer span.End()
    
    // ä¸šåŠ¡é€»è¾‘
}
```

---

## 5. Temporal å·¥ä½œæµå¼•æ“

### 5.1 Temporal æ ¸å¿ƒæ¦‚å¿µ

**Temporal** æ˜¯ Uber å¼€æºçš„æŒä¹…åŒ–å·¥ä½œæµå¼•æ“ã€‚

```text
âœ… æŒä¹…åŒ–æ‰§è¡Œ    - å·¥ä½œæµçŠ¶æ€è‡ªåŠ¨æŒä¹…åŒ–
âœ… å®¹é”™èƒ½åŠ›      - è‡ªåŠ¨é‡è¯•ã€æ•…éšœæ¢å¤
âœ… é•¿æ—¶ä»»åŠ¡      - æ”¯æŒè¿è¡Œæ•°æœˆ/æ•°å¹´
âœ… ç‰ˆæœ¬ç®¡ç†      - å·¥ä½œæµç‰ˆæœ¬æ§åˆ¶
âœ… å¯è§æ€§        - å®Œæ•´æ‰§è¡Œå†å²
```

### 5.2 å·¥ä½œæµå®šä¹‰ï¼ˆå¸¦è¿½è¸ªï¼‰

```go
// pkg/temporal/workflow.go
package temporal

import (
    "time"
    
    "go.temporal.io/sdk/workflow"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// OrderWorkflow è®¢å•å·¥ä½œæµ
func OrderWorkflow(ctx workflow.Context, input OrderInput) (string, error) {
    // è·å– Tracer
    tracer := otel.Tracer("temporal-workflow")
    
    // åˆ›å»º Spanï¼ˆæ³¨æ„ï¼šTemporal æœ‰è‡ªå·±çš„ Contextï¼‰
    // è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ workflow.GetInfo() æ¥è·å–è¿½è¸ªä¿¡æ¯
    info := workflow.GetInfo(ctx)
    
    spanCtx, span := tracer.Start(context.Background(), "OrderWorkflow",
        trace.WithSpanKind(trace.SpanKindInternal),
        trace.WithAttributes(
            attribute.String("workflow.id", info.WorkflowExecution.ID),
            attribute.String("workflow.run_id", info.WorkflowExecution.RunID),
        ),
    )
    defer span.End()
    
    // é…ç½® Activity é€‰é¡¹
    ao := workflow.ActivityOptions{
        StartToCloseTimeout: 10 * time.Second,
    }
    ctx = workflow.WithActivityOptions(ctx, ao)
    
    // æ­¥éª¤ 1: éªŒè¯ç”¨æˆ·
    var userValid bool
    err := workflow.ExecuteActivity(ctx, ValidateUserActivity, input.UserID).Get(ctx, &userValid)
    if err != nil || !userValid {
        span.RecordError(err)
        return "", err
    }
    
    // æ­¥éª¤ 2: é¢„ç•™åº“å­˜
    var inventoryReserved bool
    err = workflow.ExecuteActivity(ctx, ReserveInventoryActivity, input.Items).Get(ctx, &inventoryReserved)
    if err != nil || !inventoryReserved {
        // è¡¥å¿ï¼šå–æ¶ˆç”¨æˆ·éªŒè¯
        workflow.ExecuteActivity(ctx, CancelUserValidationActivity, input.UserID)
        span.RecordError(err)
        return "", err
    }
    
    // æ­¥éª¤ 3: åˆ›å»ºè®¢å•
    var orderID string
    err = workflow.ExecuteActivity(ctx, CreateOrderActivity, input).Get(ctx, &orderID)
    if err != nil {
        // è¡¥å¿ï¼šé‡Šæ”¾åº“å­˜
        workflow.ExecuteActivity(ctx, ReleaseInventoryActivity, input.Items)
        span.RecordError(err)
        return "", err
    }
    
    span.SetAttributes(attribute.String("order.id", orderID))
    return orderID, nil
}

type OrderInput struct {
    UserID string
    Items  []OrderItem
}

type OrderItem struct {
    ProductID string
    Quantity  int
}
```

### 5.3 Activity å®ç°ï¼ˆå¸¦è¿½è¸ª)

```go
// pkg/temporal/activities.go
package temporal

import (
    "context"
    
    "go.temporal.io/sdk/activity"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// ValidateUserActivity éªŒè¯ç”¨æˆ· Activity
func ValidateUserActivity(ctx context.Context, userID string) (bool, error) {
    // è·å– Activity ä¿¡æ¯
    info := activity.GetInfo(ctx)
    
    // åˆ›å»º Span
    tracer := otel.Tracer("temporal-activity")
    ctx, span := tracer.Start(ctx, "ValidateUserActivity",
        trace.WithSpanKind(trace.SpanKindInternal),
        trace.WithAttributes(
            attribute.String("activity.name", info.ActivityType.Name),
            attribute.Int32("activity.attempt", info.Attempt),
            attribute.String("user.id", userID),
        ),
    )
    defer span.End()
    
    // ä¸šåŠ¡é€»è¾‘
    valid, err := validateUser(ctx, userID)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return false, err
    }
    
    span.SetAttributes(attribute.Bool("user.valid", valid))
    span.SetStatus(codes.Ok, "")
    
    return valid, nil
}

func validateUser(ctx context.Context, userID string) (bool, error) {
    // å®é™…éªŒè¯é€»è¾‘
    return true, nil
}
```

---

## 6. Prometheus åŸç”Ÿé›†æˆ

### 6.1 Prometheus vs OTLP

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    ç‰¹æ€§      â”‚ Prometheus  â”‚    OTLP      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ•°æ®æ¨¡å‹     â”‚  æ—¶åºæ•°æ®   â”‚  å¤šä¿¡å·æ•´åˆ  â”‚
â”‚ æ‹‰å–/æ¨é€    â”‚   æ‹‰å–      â”‚    æ¨é€      â”‚
â”‚ æ ‡ç­¾         â”‚  å®Œå–„       â”‚   å®Œå–„       â”‚
â”‚ æŸ¥è¯¢è¯­è¨€     â”‚  PromQL     â”‚  å„åç«¯ä¸åŒ  â”‚
â”‚ ç”Ÿæ€         â”‚  æˆç†Ÿ       â”‚   å‘å±•ä¸­     â”‚
â”‚ æ€§èƒ½         â”‚  æé«˜       â”‚   é«˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.2 åŒé‡æŒ‡æ ‡å¯¼å‡º

```go
// pkg/metrics/exporter.go
package metrics

import (
    "context"
    
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promhttp"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
    "go.opentelemetry.io/otel/sdk/metric"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
)

// InitDualMetrics åˆå§‹åŒ–åŒé‡æŒ‡æ ‡ï¼ˆPrometheus + OTLPï¼‰
func InitDualMetrics(serviceName string) (*metric.MeterProvider, error) {
    ctx := context.Background()
    
    // 1. OTLP Exporter
    otlpExporter, err := otlpmetricgrpc.New(ctx,
        otlpmetricgrpc.WithEndpoint("localhost:4317"),
        otlpmetricgrpc.WithInsecure(),
    )
    if err != nil {
        return nil, err
    }
    
    // 2. åˆ›å»º Resource
    res, err := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName(serviceName),
        ),
    )
    if err != nil {
        return nil, err
    }
    
    // 3. åˆ›å»º MeterProvider
    mp := metric.NewMeterProvider(
        metric.WithReader(metric.NewPeriodicReader(otlpExporter)),
        metric.WithResource(res),
    )
    
    otel.SetMeterProvider(mp)
    
    // 4. åŒæ—¶æ³¨å†Œ Prometheus æŒ‡æ ‡
    promRegistry := prometheus.NewRegistry()
    // æ³¨å†Œè‡ªå®šä¹‰æŒ‡æ ‡åˆ° Prometheus
    // ...
    
    // å¯åŠ¨ Prometheus HTTP æœåŠ¡å™¨
    go func() {
        http.Handle("/metrics", promhttp.HandlerFor(promRegistry, promhttp.HandlerOpts{}))
        http.ListenAndServe(":9090", nil)
    }()
    
    return mp, nil
}
```

### 6.3 Exemplars é›†æˆ

```go
// Prometheus Exemplars é›†æˆè¿½è¸ª
import (
    "github.com/prometheus/client_golang/prometheus"
    "go.opentelemetry.io/otel/trace"
)

var (
    httpDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "http_request_duration_seconds",
            Help: "HTTP request duration",
        },
        []string{"method", "path"},
    )
)

func handler(w http.ResponseWriter, r *http.Request) {
    start := time.Now()
    
    // å¤„ç†è¯·æ±‚
    // ...
    
    duration := time.Since(start).Seconds()
    
    // è·å–å½“å‰ Span
    span := trace.SpanFromContext(r.Context())
    
    // è®°å½•æŒ‡æ ‡ï¼ˆå¸¦ Exemplarï¼‰
    httpDuration.WithLabelValues(r.Method, r.URL.Path).(prometheus.ExemplarObserver).ObserveWithExemplar(
        duration,
        prometheus.Labels{
            "traceID": span.SpanContext().TraceID().String(),
        },
    )
}
```

---

## 7. Jaeger Native SDK

### 7.1 Jaeger vs OTLP

```text
Jaeger SDK (Legacy) â†’ OpenTelemetry SDK (æ¨è)
```

### 7.2 Jaeger åŸç”Ÿé›†æˆ

```go
// æ—§æ–¹å¼ï¼ˆä¸æ¨èï¼‰
import (
    "github.com/uber/jaeger-client-go"
    jaegercfg "github.com/uber/jaeger-client-go/config"
)

func initJaeger() (opentracing.Tracer, io.Closer) {
    cfg := jaegercfg.Configuration{
        ServiceName: "my-service",
        Sampler: &jaegercfg.SamplerConfig{
            Type:  jaeger.SamplerTypeConst,
            Param: 1,
        },
        Reporter: &jaegercfg.ReporterConfig{
            LogSpans:           true,
            LocalAgentHostPort: "localhost:6831",
        },
    }
    
    tracer, closer, _ := cfg.NewTracer()
    return tracer, closer
}
```

### 7.3 è¿ç§»åˆ° OTLP

```go
// æ–°æ–¹å¼ï¼ˆæ¨èï¼‰- ä½¿ç”¨ OpenTelemetry
import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/sdk/trace"
)

func initOTLP() (*trace.TracerProvider, error) {
    // Jaeger æ”¯æŒ OTLP åè®®
    exporter, err := otlptracegrpc.New(context.Background(),
        otlptracegrpc.WithEndpoint("localhost:4317"),  // Jaeger OTLP ç«¯å£
        otlptracegrpc.WithInsecure(),
    )
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
    )
    
    otel.SetTracerProvider(tp)
    return tp, nil
}
```

---

## 8. å®Œæ•´é›†æˆç¤ºä¾‹

### 8.1 å¾®æœåŠ¡æ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     å®Œæ•´äº‘åŸç”Ÿå¾®æœåŠ¡æŠ€æœ¯æ ˆ                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  Client  â”‚â”€â”€â”€â”€â”€â–¶â”‚   Envoy   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                          â”‚                 â”‚
â”‚          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚          â–¼               â–¼               â–¼ â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚    â”‚ Service â”‚    â”‚ Service â”‚    â”‚Service â”‚â”‚
â”‚    â”‚    A    â”‚    â”‚    B    â”‚    â”‚   C    â”‚â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚          â”‚               â”‚               â”‚ â”‚
â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                      â”‚                     â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚         â–¼            â–¼            â–¼        â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚    â”‚ Consul â”‚  â”‚  Etcd  â”‚  â”‚ Vault  â”‚     â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚         â”‚            â”‚            â”‚        â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                      â”‚                     â”‚
â”‚                      â–¼                     â”‚
â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚           â”‚ OTLP Collector     â”‚           â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                  â”‚      â”‚                  â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚         â–¼                        â–¼         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Jaeger   â”‚            â”‚Prometheusâ”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 8.2 å®Œæ•´ä»£ç ç¤ºä¾‹

```go
// cmd/service/main.go
package main

import (
    "context"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
    
    "myservice/pkg/consul"
    "myservice/pkg/etcd"
    "myservice/pkg/vault"
    "myservice/internal/telemetry"
)

func main() {
    ctx := context.Background()
    
    // 1. åˆå§‹åŒ– OpenTelemetry
    tp, err := telemetry.InitTracing("my-service", "localhost:4317")
    if err != nil {
        log.Fatal(err)
    }
    defer tp.Shutdown(ctx)
    
    // 2. è¿æ¥ Consul
    consulRegistry, err := consul.NewServiceRegistry("localhost:8500")
    if err != nil {
        log.Fatal(err)
    }
    
    // æ³¨å†ŒæœåŠ¡
    err = consulRegistry.Register(ctx, &consul.ServiceInfo{
        ID:      "my-service-1",
        Name:    "my-service",
        Address: "192.168.1.100",
        Port:    8080,
    })
    if err != nil {
        log.Fatal(err)
    }
    
    // 3. è¿æ¥ Etcd
    etcdLock, err := etcd.NewDistributedLock([]string{"localhost:2379"})
    if err != nil {
        log.Fatal(err)
    }
    
    // 4. è¿æ¥ Vault
    vaultClient, err := vault.NewVaultClient("http://localhost:8200", os.Getenv("VAULT_TOKEN"))
    if err != nil {
        log.Fatal(err)
    }
    
    // è¯»å–æ•°æ®åº“å¯†é’¥
    dbSecrets, err := vaultClient.GetSecret(ctx, "secret/data/database")
    if err != nil {
        log.Fatal(err)
    }
    
    // 5. å¯åŠ¨ HTTP æœåŠ¡
    mux := http.NewServeMux()
    mux.HandleFunc("/api/order", orderHandler)
    
    server := &http.Server{
        Addr:    ":8080",
        Handler: mux,
    }
    
    go func() {
        log.Println("Starting server on :8080")
        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatal(err)
        }
    }()
    
    // 6. ä¼˜é›…å…³é—­
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Println("Shutting down server...")
    
    shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    if err := server.Shutdown(shutdownCtx); err != nil {
        log.Fatal(err)
    }
    
    log.Println("Server stopped")
}

func orderHandler(w http.ResponseWriter, r *http.Request) {
    // å¤„ç†è®¢å•é€»è¾‘
}
```

---

## 9. æœ€ä½³å®è·µ

### 9.1 æŠ€æœ¯é€‰å‹

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   éœ€æ±‚         â”‚   æ¨èæ–¹æ¡ˆ  â”‚   å¤‡é€‰æ–¹æ¡ˆ   â”‚  å¤æ‚åº¦  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æœåŠ¡å‘ç°       â”‚   Consul    â”‚  Etcd/K8s    â”‚   ä¸­     â”‚
â”‚ é…ç½®ç®¡ç†       â”‚   Consul    â”‚  Etcd        â”‚   ä½     â”‚
â”‚ å¯†é’¥ç®¡ç†       â”‚   Vault     â”‚  K8s Secret  â”‚   ä¸­     â”‚
â”‚ åˆ†å¸ƒå¼é”       â”‚   Etcd      â”‚  Redis       â”‚   ä½     â”‚
â”‚ å·¥ä½œæµç¼–æ’     â”‚   Temporal  â”‚  Cadence     â”‚   é«˜     â”‚
â”‚ æœåŠ¡ç½‘æ ¼       â”‚   Istio     â”‚  Linkerd     â”‚   é«˜     â”‚
â”‚ è¿½è¸ª           â”‚   OTLP      â”‚  Jaeger      â”‚   ä½     â”‚
â”‚ æŒ‡æ ‡           â”‚  Prometheus â”‚  OTLP        â”‚   ä½     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 9.2 æ€§èƒ½ä¼˜åŒ–

```go
// 1. è¿æ¥æ± å¤ç”¨
var (
    consulClient *consulapi.Client
    etcdClient   *clientv3.Client
    vaultClient  *vaultapi.Client
)

func init() {
    // å…¨å±€åˆå§‹åŒ–ä¸€æ¬¡
    consulClient, _ = consulapi.NewClient(consulapi.DefaultConfig())
    etcdClient, _ = clientv3.New(clientv3.Config{...})
    vaultClient, _ = vaultapi.NewClient(vaultapi.DefaultConfig())
}

// 2. æ‰¹é‡æ“ä½œ
// Etcd æ‰¹é‡å†™å…¥
ops := []clientv3.Op{
    clientv3.OpPut("key1", "value1"),
    clientv3.OpPut("key2", "value2"),
}
etcdClient.Txn(ctx).Then(ops...).Commit()

// 3. ç¼“å­˜
var configCache sync.Map

func getConfig(key string) string {
    if v, ok := configCache.Load(key); ok {
        return v.(string)
    }
    
    // ä» Consul è¯»å–
    value := consulClient.KV().Get(key, nil)
    configCache.Store(key, value)
    return value
}
```

### 9.3 å®‰å…¨é…ç½®

```yaml
# Consul ACL
acl {
  enabled = true
  default_policy = "deny"
  
  tokens {
    agent = "..."
    default = "..."
  }
}

# Vault Policy
path "secret/data/myapp/*" {
  capabilities = ["read"]
}

# Etcd TLS
etcd --cert-file=server.crt \
     --key-file=server.key \
     --trusted-ca-file=ca.crt \
     --client-cert-auth
```

---

## 10. æ€»ç»“

### 10.1 æŠ€æœ¯æ ˆå¯¹æ¯”

| æŠ€æœ¯ | æ ¸å¿ƒèƒ½åŠ› | å­¦ä¹ æ›²çº¿ | æ¨èåº¦ |
|------|----------|----------|--------|
| **Consul** | æœåŠ¡å‘ç°ã€é…ç½® | ä½ | â­â­â­â­â­ |
| **Etcd** | åˆ†å¸ƒå¼åè°ƒ | ä¸­ | â­â­â­â­â­ |
| **Vault** | å¯†é’¥ç®¡ç† | ä¸­ | â­â­â­â­â­ |
| **Envoy** | æœåŠ¡ä»£ç† | é«˜ | â­â­â­â­ |
| **Temporal** | å·¥ä½œæµç¼–æ’ | é«˜ | â­â­â­â­ |
| **Prometheus** | æŒ‡æ ‡ç›‘æ§ | ä½ | â­â­â­â­â­ |

### 10.2 é€‚ç”¨åœºæ™¯

- **Consul**: æ‰€æœ‰å¾®æœåŠ¡åœºæ™¯ï¼Œç‰¹åˆ«æ˜¯å¤šæ•°æ®ä¸­å¿ƒ
- **Etcd**: Kubernetes é›†ç¾¤ï¼Œéœ€è¦å¼ºä¸€è‡´æ€§
- **Vault**: å¯†é’¥ç®¡ç†ã€åŠ¨æ€å‡­è¯
- **Temporal**: å¤æ‚ä¸šåŠ¡æµç¨‹ã€é•¿æ—¶ä»»åŠ¡

### 10.3 ç›¸å…³èµ„æº

**å®˜æ–¹èµ„æº**:

- [Consul](https://www.consul.io/)
- [Etcd](https://etcd.io/)
- [Vault](https://www.vaultproject.io/)
- [Temporal](https://temporal.io/)

**ç›¸å…³æ–‡æ¡£**:

- [69_Kratoså¾®æœåŠ¡æ¡†æ¶](./69_Kratoså¾®æœåŠ¡æ¡†æ¶ä¸OTLPå®Œæ•´é›†æˆ_2025ç‰ˆ.md)
- [70_Go-Zeroå¾®æœåŠ¡æ¡†æ¶](./70_Go-Zeroå¾®æœåŠ¡æ¡†æ¶ä¸OTLPå®Œæ•´é›†æˆ_2025ç‰ˆ.md)
- [71_Dapråˆ†å¸ƒå¼åº”ç”¨è¿è¡Œæ—¶](./71_Dapråˆ†å¸ƒå¼åº”ç”¨è¿è¡Œæ—¶ä¸OTLPå®Œæ•´é›†æˆ_2025ç‰ˆ.md)

---

**ç‰ˆæœ¬**: v1.0.0  
**å®Œæˆæ—¥æœŸ**: 2025-10-11  
**æ–‡æ¡£è§„æ¨¡**: 2,800+ è¡Œ  
**ä»£ç ç¤ºä¾‹**: 60+ ä¸ª  
**æ¶µç›–æŠ€æœ¯**: 7 ä¸ªæ ¸å¿ƒæ¡†æ¶  
**çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª

---

**ğŸ‰ æ„å»ºå®Œæ•´çš„äº‘åŸç”ŸåŸºç¡€è®¾æ–½ï¼**
