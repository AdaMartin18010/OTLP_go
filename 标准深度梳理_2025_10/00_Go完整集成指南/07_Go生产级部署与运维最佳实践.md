# Go ç”Ÿäº§çº§éƒ¨ç½²ä¸è¿ç»´æœ€ä½³å®è·µ

> **Go ç‰ˆæœ¬**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0+  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ8æ—¥

---

## ğŸ“‹ ç›®å½•

- [Go ç”Ÿäº§çº§éƒ¨ç½²ä¸è¿ç»´æœ€ä½³å®è·µ](#go-ç”Ÿäº§çº§éƒ¨ç½²ä¸è¿ç»´æœ€ä½³å®è·µ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
  - [èµ„æºç®¡ç†](#èµ„æºç®¡ç†)
    - [1. è¿æ¥æ± ç®¡ç†](#1-è¿æ¥æ± ç®¡ç†)
  - [ä¼˜é›…å…³é—­](#ä¼˜é›…å…³é—­)
    - [2. ä¿¡å·å¤„ç†å’Œä¼˜é›…å…³é—­](#2-ä¿¡å·å¤„ç†å’Œä¼˜é›…å…³é—­)
  - [å¥åº·æ£€æŸ¥](#å¥åº·æ£€æŸ¥)
    - [3. å¥åº·æ£€æŸ¥ç«¯ç‚¹](#3-å¥åº·æ£€æŸ¥ç«¯ç‚¹)
  - [é…ç½®ç®¡ç†](#é…ç½®ç®¡ç†)
    - [4. ç¯å¢ƒé…ç½®å’ŒåŠ¨æ€é…ç½®](#4-ç¯å¢ƒé…ç½®å’ŒåŠ¨æ€é…ç½®)
  - [æ€»ç»“](#æ€»ç»“)
    - [ä¸‹ä¸€æ­¥](#ä¸‹ä¸€æ­¥)

---

## æ¦‚è¿°

ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²éœ€è¦è€ƒè™‘å¯é æ€§ã€å¯ç»´æŠ¤æ€§å’Œå¯è§‚æµ‹æ€§ã€‚
æœ¬æ–‡æ¡£æä¾› Go åº”ç”¨ä¸ OpenTelemetry é›†æˆçš„ç”Ÿäº§çº§æœ€ä½³å®è·µã€‚

---

## èµ„æºç®¡ç†

### 1. è¿æ¥æ± ç®¡ç†

```go
package resources

import (
    "context"
    "database/sql"
    "fmt"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// ResourceManager èµ„æºç®¡ç†å™¨
type ResourceManager struct {
    tracer   trace.Tracer
    db       *sql.DB
    closers  []func() error
}

func NewResourceManager(ctx context.Context) (*ResourceManager, error) {
    rm := &ResourceManager{
        tracer:  otel.Tracer("resource-manager"),
        closers: make([]func() error, 0),
    }
    
    // åˆå§‹åŒ–æ•°æ®åº“
    if err := rm.initDatabase(ctx); err != nil {
        return nil, err
    }
    
    return rm, nil
}

func (rm *ResourceManager) initDatabase(ctx context.Context) error {
    ctx, span := rm.tracer.Start(ctx, "init-database")
    defer span.End()
    
    db, err := sql.Open("postgres", "connection-string")
    if err != nil {
        span.RecordError(err)
        return err
    }
    
    // é…ç½®è¿æ¥æ± 
    db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(5)
    db.SetConnMaxLifetime(5 * time.Minute)
    db.SetConnMaxIdleTime(10 * time.Minute)
    
    // éªŒè¯è¿æ¥
    if err := db.PingContext(ctx); err != nil {
        span.RecordError(err)
        db.Close()
        return err
    }
    
    rm.db = db
    rm.closers = append(rm.closers, db.Close)
    
    span.SetAttributes(
        attribute.Int("db.max_open_conns", 25),
        attribute.Int("db.max_idle_conns", 5),
    )
    
    return nil
}

// RegisterCloser æ³¨å†Œèµ„æºæ¸…ç†å‡½æ•°
func (rm *ResourceManager) RegisterCloser(closer func() error) {
    rm.closers = append(rm.closers, closer)
}

// Close å…³é—­æ‰€æœ‰èµ„æº
func (rm *ResourceManager) Close(ctx context.Context) error {
    ctx, span := rm.tracer.Start(ctx, "close-resources")
    defer span.End()
    
    var errors []error
    
    for i := len(rm.closers) - 1; i >= 0; i-- {
        if err := rm.closers[i](); err != nil {
            errors = append(errors, err)
        }
    }
    
    if len(errors) > 0 {
        span.SetAttributes(
            attribute.Int("errors.count", len(errors)),
        )
        return fmt.Errorf("å…³é—­èµ„æºæ—¶å‘ç”Ÿ %d ä¸ªé”™è¯¯", len(errors))
    }
    
    return nil
}

// GetDBStats è·å–æ•°æ®åº“ç»Ÿè®¡ä¿¡æ¯
func (rm *ResourceManager) GetDBStats(ctx context.Context) sql.DBStats {
    _, span := rm.tracer.Start(ctx, "get-db-stats")
    defer span.End()
    
    stats := rm.db.Stats()
    
    span.SetAttributes(
        attribute.Int("db.open_connections", stats.OpenConnections),
        attribute.Int("db.in_use", stats.InUse),
        attribute.Int("db.idle", stats.Idle),
        attribute.Int64("db.wait_count", stats.WaitCount),
        attribute.Int64("db.wait_duration_ms", stats.WaitDuration.Milliseconds()),
    )
    
    return stats
}
```

---

## ä¼˜é›…å…³é—­

### 2. ä¿¡å·å¤„ç†å’Œä¼˜é›…å…³é—­

```go
package shutdown

import (
    "context"
    "fmt"
    "os"
    "os/signal"
    "sync"
    "syscall"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/sdk/trace"
)

// GracefulShutdown ä¼˜é›…å…³é—­ç®¡ç†å™¨
type GracefulShutdown struct {
    tracer         trace.Tracer
    shutdownFuncs  []ShutdownFunc
    timeout        time.Duration
    mu             sync.Mutex
}

type ShutdownFunc struct {
    Name     string
    Func     func(context.Context) error
    Critical bool // æ˜¯å¦æ˜¯å…³é”®æœåŠ¡
}

func NewGracefulShutdown(timeout time.Duration) *GracefulShutdown {
    return &GracefulShutdown{
        tracer:        otel.Tracer("graceful-shutdown"),
        shutdownFuncs: make([]ShutdownFunc, 0),
        timeout:       timeout,
    }
}

// Register æ³¨å†Œå…³é—­å‡½æ•°
func (gs *GracefulShutdown) Register(name string, fn func(context.Context) error, critical bool) {
    gs.mu.Lock()
    defer gs.mu.Unlock()
    
    gs.shutdownFuncs = append(gs.shutdownFuncs, ShutdownFunc{
        Name:     name,
        Func:     fn,
        Critical: critical,
    })
}

// Listen ç›‘å¬å…³é—­ä¿¡å·
func (gs *GracefulShutdown) Listen(ctx context.Context) {
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM, syscall.SIGINT)
    
    sig := <-sigChan
    
    ctx, span := gs.tracer.Start(ctx, "graceful-shutdown",
        trace.WithAttributes(
            attribute.String("signal", sig.String()),
        ),
    )
    defer span.End()
    
    fmt.Printf("\næ”¶åˆ°å…³é—­ä¿¡å·: %s\n", sig)
    
    // åˆ›å»ºå¸¦è¶…æ—¶çš„context
    shutdownCtx, cancel := context.WithTimeout(context.Background(), gs.timeout)
    defer cancel()
    
    if err := gs.Shutdown(shutdownCtx); err != nil {
        span.RecordError(err)
        fmt.Printf("å…³é—­è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: %v\n", err)
        os.Exit(1)
    }
    
    fmt.Println("åº”ç”¨å·²æˆåŠŸå…³é—­")
    os.Exit(0)
}

// Shutdown æ‰§è¡Œå…³é—­æµç¨‹
func (gs *GracefulShutdown) Shutdown(ctx context.Context) error {
    ctx, span := gs.tracer.Start(ctx, "execute-shutdown")
    defer span.End()
    
    gs.mu.Lock()
    funcs := make([]ShutdownFunc, len(gs.shutdownFuncs))
    copy(funcs, gs.shutdownFuncs)
    gs.mu.Unlock()
    
    // åˆ†é˜¶æ®µå…³é—­
    // é˜¶æ®µ1: åœæ­¢æ¥æ”¶æ–°è¯·æ±‚
    fmt.Println("é˜¶æ®µ1: åœæ­¢æ¥æ”¶æ–°è¯·æ±‚...")
    if err := gs.shutdownPhase(ctx, funcs, false); err != nil {
        return err
    }
    
    // é˜¶æ®µ2: ç­‰å¾…ç°æœ‰è¯·æ±‚å®Œæˆ
    fmt.Println("é˜¶æ®µ2: ç­‰å¾…ç°æœ‰è¯·æ±‚å®Œæˆ...")
    time.Sleep(2 * time.Second)
    
    // é˜¶æ®µ3: å…³é—­å…³é”®æœåŠ¡
    fmt.Println("é˜¶æ®µ3: å…³é—­å…³é”®æœåŠ¡...")
    if err := gs.shutdownPhase(ctx, funcs, true); err != nil {
        return err
    }
    
    span.AddEvent("æ‰€æœ‰æœåŠ¡å·²å…³é—­")
    return nil
}

func (gs *GracefulShutdown) shutdownPhase(ctx context.Context, funcs []ShutdownFunc, critical bool) error {
    var wg sync.WaitGroup
    errors := make(chan error, len(funcs))
    
    for _, fn := range funcs {
        if fn.Critical != critical {
            continue
        }
        
        wg.Add(1)
        go func(sf ShutdownFunc) {
            defer wg.Done()
            
            _, span := gs.tracer.Start(ctx, "shutdown-"+sf.Name)
            defer span.End()
            
            fmt.Printf("  å…³é—­ %s...\n", sf.Name)
            
            if err := sf.Func(ctx); err != nil {
                span.RecordError(err)
                errors <- fmt.Errorf("%s å…³é—­å¤±è´¥: %w", sf.Name, err)
            } else {
                fmt.Printf("  âœ“ %s å·²å…³é—­\n", sf.Name)
            }
        }(fn)
    }
    
    wg.Wait()
    close(errors)
    
    var errs []error
    for err := range errors {
        errs = append(errs, err)
    }
    
    if len(errs) > 0 {
        return fmt.Errorf("å…³é—­é˜¶æ®µå¤±è´¥: %v", errs)
    }
    
    return nil
}

// å®Œæ•´ä½¿ç”¨ç¤ºä¾‹
func RunApplicationWithGracefulShutdown() {
    ctx := context.Background()
    
    // åˆå§‹åŒ–è¿½è¸ª
    tp, err := initTracer(ctx)
    if err != nil {
        fmt.Printf("åˆå§‹åŒ–è¿½è¸ªå¤±è´¥: %v\n", err)
        os.Exit(1)
    }
    
    // åˆ›å»ºå…³é—­ç®¡ç†å™¨
    gs := NewGracefulShutdown(30 * time.Second)
    
    // æ³¨å†Œå…³é—­å‡½æ•°ï¼ˆæŒ‰ä¼˜å…ˆçº§ï¼‰
    // 1. éå…³é”®æœåŠ¡
    gs.Register("http-server", func(ctx context.Context) error {
        // åœæ­¢HTTPæœåŠ¡å™¨
        return nil
    }, false)
    
    gs.Register("worker-pool", func(ctx context.Context) error {
        // åœæ­¢worker pool
        return nil
    }, false)
    
    // 2. å…³é”®æœåŠ¡
    gs.Register("database", func(ctx context.Context) error {
        // å…³é—­æ•°æ®åº“è¿æ¥
        return nil
    }, true)
    
    gs.Register("tracer-provider", func(ctx context.Context) error {
        return tp.Shutdown(ctx)
    }, true)
    
    // å¯åŠ¨åº”ç”¨
    fmt.Println("åº”ç”¨å¯åŠ¨ä¸­...")
    
    // ç›‘å¬å…³é—­ä¿¡å·
    gs.Listen(ctx)
}
```

---

## å¥åº·æ£€æŸ¥

### 3. å¥åº·æ£€æŸ¥ç«¯ç‚¹

```go
package health

import (
    "context"
    "database/sql"
    "encoding/json"
    "net/http"
    "sync"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// HealthChecker å¥åº·æ£€æŸ¥å™¨
type HealthChecker struct {
    tracer    trace.Tracer
    checks    map[string]CheckFunc
    mu        sync.RWMutex
}

type CheckFunc func(context.Context) HealthStatus

type HealthStatus struct {
    Status  string                 `json:"status"`  // healthy, degraded, unhealthy
    Message string                 `json:"message,omitempty"`
    Details map[string]interface{} `json:"details,omitempty"`
}

type HealthResponse struct {
    Status    string                    `json:"status"`
    Timestamp time.Time                 `json:"timestamp"`
    Checks    map[string]HealthStatus   `json:"checks"`
}

func NewHealthChecker() *HealthChecker {
    return &HealthChecker{
        tracer: otel.Tracer("health-checker"),
        checks: make(map[string]CheckFunc),
    }
}

// RegisterCheck æ³¨å†Œå¥åº·æ£€æŸ¥
func (hc *HealthChecker) RegisterCheck(name string, check CheckFunc) {
    hc.mu.Lock()
    defer hc.mu.Unlock()
    
    hc.checks[name] = check
}

// Check æ‰§è¡Œæ‰€æœ‰å¥åº·æ£€æŸ¥
func (hc *HealthChecker) Check(ctx context.Context) HealthResponse {
    ctx, span := hc.tracer.Start(ctx, "health-check")
    defer span.End()
    
    hc.mu.RLock()
    checks := make(map[string]CheckFunc, len(hc.checks))
    for k, v := range hc.checks {
        checks[k] = v
    }
    hc.mu.RUnlock()
    
    response := HealthResponse{
        Timestamp: time.Now(),
        Checks:    make(map[string]HealthStatus),
    }
    
    var (
        wg           sync.WaitGroup
        mu           sync.Mutex
        healthyCount int
        totalCount   = len(checks)
    )
    
    // å¹¶å‘æ‰§è¡Œæ‰€æœ‰æ£€æŸ¥
    for name, checkFn := range checks {
        wg.Add(1)
        
        go func(n string, fn CheckFunc) {
            defer wg.Done()
            
            checkCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
            defer cancel()
            
            _, checkSpan := hc.tracer.Start(checkCtx, "check-"+n)
            defer checkSpan.End()
            
            status := fn(checkCtx)
            
            checkSpan.SetAttributes(
                attribute.String("check.name", n),
                attribute.String("check.status", status.Status),
            )
            
            mu.Lock()
            response.Checks[n] = status
            if status.Status == "healthy" {
                healthyCount++
            }
            mu.Unlock()
        }(name, checkFn)
    }
    
    wg.Wait()
    
    // ç¡®å®šæ•´ä½“çŠ¶æ€
    if healthyCount == totalCount {
        response.Status = "healthy"
    } else if healthyCount > 0 {
        response.Status = "degraded"
    } else {
        response.Status = "unhealthy"
    }
    
    span.SetAttributes(
        attribute.String("health.status", response.Status),
        attribute.Int("health.total_checks", totalCount),
        attribute.Int("health.healthy_checks", healthyCount),
    )
    
    return response
}

// HTTPHandler HTTPå¥åº·æ£€æŸ¥å¤„ç†å™¨
func (hc *HealthChecker) HTTPHandler() http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        ctx := r.Context()
        
        response := hc.Check(ctx)
        
        // è®¾ç½®HTTPçŠ¶æ€ç 
        statusCode := http.StatusOK
        if response.Status == "degraded" {
            statusCode = http.StatusOK // é™çº§ä½†ä»å¯ç”¨
        } else if response.Status == "unhealthy" {
            statusCode = http.StatusServiceUnavailable
        }
        
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        json.NewEncoder(w).Encode(response)
    }
}

// é¢„å®šä¹‰çš„å¥åº·æ£€æŸ¥

// DatabaseCheck æ•°æ®åº“å¥åº·æ£€æŸ¥
func DatabaseCheck(db *sql.DB) CheckFunc {
    return func(ctx context.Context) HealthStatus {
        if err := db.PingContext(ctx); err != nil {
            return HealthStatus{
                Status:  "unhealthy",
                Message: fmt.Sprintf("æ•°æ®åº“è¿æ¥å¤±è´¥: %v", err),
            }
        }
        
        stats := db.Stats()
        return HealthStatus{
            Status: "healthy",
            Details: map[string]interface{}{
                "open_connections": stats.OpenConnections,
                "in_use":          stats.InUse,
                "idle":            stats.Idle,
            },
        }
    }
}

// MemoryCheck å†…å­˜å¥åº·æ£€æŸ¥
func MemoryCheck(thresholdPercent float64) CheckFunc {
    return func(ctx context.Context) HealthStatus {
        var m runtime.MemStats
        runtime.ReadMemStats(&m)
        
        usedPercent := float64(m.Alloc) / float64(m.Sys) * 100
        
        status := "healthy"
        if usedPercent > thresholdPercent {
            status = "degraded"
        }
        if usedPercent > thresholdPercent*1.2 {
            status = "unhealthy"
        }
        
        return HealthStatus{
            Status: status,
            Details: map[string]interface{}{
                "alloc_mb":        m.Alloc / 1024 / 1024,
                "sys_mb":          m.Sys / 1024 / 1024,
                "used_percent":    usedPercent,
                "num_gc":          m.NumGC,
                "goroutines":      runtime.NumGoroutine(),
            },
        }
    }
}

// DiskCheck ç£ç›˜å¥åº·æ£€æŸ¥
func DiskCheck(path string, thresholdPercent float64) CheckFunc {
    return func(ctx context.Context) HealthStatus {
        var stat syscall.Statfs_t
        if err := syscall.Statfs(path, &stat); err != nil {
            return HealthStatus{
                Status:  "unhealthy",
                Message: fmt.Sprintf("æ— æ³•è·å–ç£ç›˜ä¿¡æ¯: %v", err),
            }
        }
        
        available := stat.Bavail * uint64(stat.Bsize)
        total := stat.Blocks * uint64(stat.Bsize)
        usedPercent := float64(total-available) / float64(total) * 100
        
        status := "healthy"
        if usedPercent > thresholdPercent {
            status = "degraded"
        }
        if usedPercent > thresholdPercent*1.2 {
            status = "unhealthy"
        }
        
        return HealthStatus{
            Status: status,
            Details: map[string]interface{}{
                "path":         path,
                "total_gb":     total / 1024 / 1024 / 1024,
                "available_gb": available / 1024 / 1024 / 1024,
                "used_percent": usedPercent,
            },
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func SetupHealthChecks(db *sql.DB) *HealthChecker {
    hc := NewHealthChecker()
    
    // æ³¨å†Œå„ç§æ£€æŸ¥
    hc.RegisterCheck("database", DatabaseCheck(db))
    hc.RegisterCheck("memory", MemoryCheck(80.0))
    hc.RegisterCheck("disk", DiskCheck("/", 85.0))
    
    // è‡ªå®šä¹‰æ£€æŸ¥
    hc.RegisterCheck("custom-service", func(ctx context.Context) HealthStatus {
        // è‡ªå®šä¹‰å¥åº·æ£€æŸ¥é€»è¾‘
        return HealthStatus{
            Status: "healthy",
        }
    })
    
    return hc
}
```

---

## é…ç½®ç®¡ç†

### 4. ç¯å¢ƒé…ç½®å’ŒåŠ¨æ€é…ç½®

```go
package config

import (
    "context"
    "fmt"
    "os"
    "strconv"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// Config åº”ç”¨é…ç½®
type Config struct {
    // åº”ç”¨é…ç½®
    AppName    string
    AppVersion string
    Environment string
    
    // OTLPé…ç½®
    OTLPEndpoint    string
    OTLPInsecure    bool
    OTLPCompression bool
    SampleRate      float64
    
    // æ€§èƒ½é…ç½®
    MaxBatchSize  int
    BatchTimeout  time.Duration
    MaxQueueSize  int
    
    // èµ„æºé…ç½®
    MaxConcurrency int
    RequestTimeout time.Duration
    
    // æ•°æ®åº“é…ç½®
    DatabaseURL      string
    DatabaseMaxConns int
    DatabaseTimeout  time.Duration
}

// ConfigLoader é…ç½®åŠ è½½å™¨
type ConfigLoader struct {
    tracer trace.Tracer
}

func NewConfigLoader() *ConfigLoader {
    return &ConfigLoader{
        tracer: otel.Tracer("config-loader"),
    }
}

// Load åŠ è½½é…ç½®
func (cl *ConfigLoader) Load(ctx context.Context) (*Config, error) {
    ctx, span := cl.tracer.Start(ctx, "load-config")
    defer span.End()
    
    cfg := &Config{
        // é»˜è®¤å€¼
        AppName:         getEnv("APP_NAME", "my-app"),
        AppVersion:      getEnv("APP_VERSION", "1.0.0"),
        Environment:     getEnv("APP_ENV", "development"),
        
        // OTLPé»˜è®¤é…ç½®
        OTLPEndpoint:    getEnv("OTLP_ENDPOINT", "localhost:4317"),
        OTLPInsecure:    getEnvBool("OTLP_INSECURE", true),
        OTLPCompression: getEnvBool("OTLP_COMPRESSION", true),
        SampleRate:      getEnvFloat("OTLP_SAMPLE_RATE", 1.0),
        
        // æ€§èƒ½é»˜è®¤é…ç½®
        MaxBatchSize: getEnvInt("OTLP_MAX_BATCH_SIZE", 512),
        BatchTimeout: getEnvDuration("OTLP_BATCH_TIMEOUT", 5*time.Second),
        MaxQueueSize: getEnvInt("OTLP_MAX_QUEUE_SIZE", 2048),
        
        // èµ„æºé»˜è®¤é…ç½®
        MaxConcurrency: getEnvInt("MAX_CONCURRENCY", 100),
        RequestTimeout: getEnvDuration("REQUEST_TIMEOUT", 30*time.Second),
        
        // æ•°æ®åº“é»˜è®¤é…ç½®
        DatabaseURL:      getEnv("DATABASE_URL", ""),
        DatabaseMaxConns: getEnvInt("DATABASE_MAX_CONNS", 25),
        DatabaseTimeout:  getEnvDuration("DATABASE_TIMEOUT", 10*time.Second),
    }
    
    // éªŒè¯é…ç½®
    if err := cfg.Validate(); err != nil {
        span.RecordError(err)
        return nil, err
    }
    
    span.SetAttributes(
        attribute.String("config.app_name", cfg.AppName),
        attribute.String("config.environment", cfg.Environment),
        attribute.String("config.otlp_endpoint", cfg.OTLPEndpoint),
        attribute.Float64("config.sample_rate", cfg.SampleRate),
    )
    
    return cfg, nil
}

// Validate éªŒè¯é…ç½®
func (c *Config) Validate() error {
    if c.AppName == "" {
        return fmt.Errorf("APP_NAME ä¸èƒ½ä¸ºç©º")
    }
    
    if c.SampleRate < 0 || c.SampleRate > 1 {
        return fmt.Errorf("SAMPLE_RATE å¿…é¡»åœ¨ 0 å’Œ 1 ä¹‹é—´")
    }
    
    if c.MaxBatchSize <= 0 {
        return fmt.Errorf("MAX_BATCH_SIZE å¿…é¡»å¤§äº 0")
    }
    
    return nil
}

// è¾…åŠ©å‡½æ•°

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func getEnvInt(key string, defaultValue int) int {
    if value := os.Getenv(key); value != "" {
        if intValue, err := strconv.Atoi(value); err == nil {
            return intValue
        }
    }
    return defaultValue
}

func getEnvFloat(key string, defaultValue float64) float64 {
    if value := os.Getenv(key); value != "" {
        if floatValue, err := strconv.ParseFloat(value, 64); err == nil {
            return floatValue
        }
    }
    return defaultValue
}

func getEnvBool(key string, defaultValue bool) bool {
    if value := os.Getenv(key); value != "" {
        if boolValue, err := strconv.ParseBool(value); err == nil {
            return boolValue
        }
    }
    return defaultValue
}

func getEnvDuration(key string, defaultValue time.Duration) time.Duration {
    if value := os.Getenv(key); value != "" {
        if duration, err := time.ParseDuration(value); err == nil {
            return duration
        }
    }
    return defaultValue
}
```

---

## æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº† Go ç”Ÿäº§çº§éƒ¨ç½²çš„å®Œæ•´æœ€ä½³å®è·µï¼ŒåŒ…æ‹¬ï¼š

1. âœ… **èµ„æºç®¡ç†** - è¿æ¥æ± ã€èµ„æºæ¸…ç†
2. âœ… **ä¼˜é›…å…³é—­** - ä¿¡å·å¤„ç†ã€åˆ†é˜¶æ®µå…³é—­
3. âœ… **å¥åº·æ£€æŸ¥** - æ•°æ®åº“ã€å†…å­˜ã€ç£ç›˜æ£€æŸ¥
4. âœ… **é…ç½®ç®¡ç†** - ç¯å¢ƒå˜é‡ã€éªŒè¯
5. âœ… **å¯è§‚æµ‹æ€§** - å…¨æµç¨‹è¿½è¸ª

### ä¸‹ä¸€æ­¥

- [å®¹å™¨åŒ–éƒ¨ç½²](./08_Goå®¹å™¨åŒ–ä¸Kubernetesé›†æˆ.md)
- [ç›‘æ§å‘Šè­¦](./09_Goç›‘æ§å‘Šè­¦æœ€ä½³å®è·µ.md)
- [æ•…éšœæ’æŸ¥](../../16_æ•…éšœæ’æŸ¥æ‰‹å†Œ/01_OpenTelemetryæ•…éšœæ’æŸ¥å®Œæ•´æ‰‹å†Œ.md)
