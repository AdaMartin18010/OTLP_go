# Go 生产级部署与运维最佳实践

> **Go 版本**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0+  
> **最后更新**: 2025年10月8日

---

## 📋 目录

- [Go 生产级部署与运维最佳实践](#go-生产级部署与运维最佳实践)
  - [📋 目录](#-目录)
  - [概述](#概述)
  - [资源管理](#资源管理)
    - [1. 连接池管理](#1-连接池管理)
  - [优雅关闭](#优雅关闭)
    - [2. 信号处理和优雅关闭](#2-信号处理和优雅关闭)
  - [健康检查](#健康检查)
    - [3. 健康检查端点](#3-健康检查端点)
  - [配置管理](#配置管理)
    - [4. 环境配置和动态配置](#4-环境配置和动态配置)
  - [总结](#总结)
    - [下一步](#下一步)

---

## 概述

生产环境部署需要考虑可靠性、可维护性和可观测性。
本文档提供 Go 应用与 OpenTelemetry 集成的生产级最佳实践。

---

## 资源管理

### 1. 连接池管理

```go
package resources

import (
    "context"
    "database/sql"
    "fmt"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// ResourceManager 资源管理器
type ResourceManager struct {
    tracer   trace.Tracer
    db       *sql.DB
    closers  []func() error
}

func NewResourceManager(ctx context.Context) (*ResourceManager, error) {
    rm := &ResourceManager{
        tracer:  otel.Tracer("resource-manager"),
        closers: make([]func() error, 0),
    }
    
    // 初始化数据库
    if err := rm.initDatabase(ctx); err != nil {
        return nil, err
    }
    
    return rm, nil
}

func (rm *ResourceManager) initDatabase(ctx context.Context) error {
    ctx, span := rm.tracer.Start(ctx, "init-database")
    defer span.End()
    
    db, err := sql.Open("postgres", "connection-string")
    if err != nil {
        span.RecordError(err)
        return err
    }
    
    // 配置连接池
    db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(5)
    db.SetConnMaxLifetime(5 * time.Minute)
    db.SetConnMaxIdleTime(10 * time.Minute)
    
    // 验证连接
    if err := db.PingContext(ctx); err != nil {
        span.RecordError(err)
        db.Close()
        return err
    }
    
    rm.db = db
    rm.closers = append(rm.closers, db.Close)
    
    span.SetAttributes(
        attribute.Int("db.max_open_conns", 25),
        attribute.Int("db.max_idle_conns", 5),
    )
    
    return nil
}

// RegisterCloser 注册资源清理函数
func (rm *ResourceManager) RegisterCloser(closer func() error) {
    rm.closers = append(rm.closers, closer)
}

// Close 关闭所有资源
func (rm *ResourceManager) Close(ctx context.Context) error {
    ctx, span := rm.tracer.Start(ctx, "close-resources")
    defer span.End()
    
    var errors []error
    
    for i := len(rm.closers) - 1; i >= 0; i-- {
        if err := rm.closers[i](); err != nil {
            errors = append(errors, err)
        }
    }
    
    if len(errors) > 0 {
        span.SetAttributes(
            attribute.Int("errors.count", len(errors)),
        )
        return fmt.Errorf("关闭资源时发生 %d 个错误", len(errors))
    }
    
    return nil
}

// GetDBStats 获取数据库统计信息
func (rm *ResourceManager) GetDBStats(ctx context.Context) sql.DBStats {
    _, span := rm.tracer.Start(ctx, "get-db-stats")
    defer span.End()
    
    stats := rm.db.Stats()
    
    span.SetAttributes(
        attribute.Int("db.open_connections", stats.OpenConnections),
        attribute.Int("db.in_use", stats.InUse),
        attribute.Int("db.idle", stats.Idle),
        attribute.Int64("db.wait_count", stats.WaitCount),
        attribute.Int64("db.wait_duration_ms", stats.WaitDuration.Milliseconds()),
    )
    
    return stats
}
```

---

## 优雅关闭

### 2. 信号处理和优雅关闭

```go
package shutdown

import (
    "context"
    "fmt"
    "os"
    "os/signal"
    "sync"
    "syscall"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/sdk/trace"
)

// GracefulShutdown 优雅关闭管理器
type GracefulShutdown struct {
    tracer         trace.Tracer
    shutdownFuncs  []ShutdownFunc
    timeout        time.Duration
    mu             sync.Mutex
}

type ShutdownFunc struct {
    Name     string
    Func     func(context.Context) error
    Critical bool // 是否是关键服务
}

func NewGracefulShutdown(timeout time.Duration) *GracefulShutdown {
    return &GracefulShutdown{
        tracer:        otel.Tracer("graceful-shutdown"),
        shutdownFuncs: make([]ShutdownFunc, 0),
        timeout:       timeout,
    }
}

// Register 注册关闭函数
func (gs *GracefulShutdown) Register(name string, fn func(context.Context) error, critical bool) {
    gs.mu.Lock()
    defer gs.mu.Unlock()
    
    gs.shutdownFuncs = append(gs.shutdownFuncs, ShutdownFunc{
        Name:     name,
        Func:     fn,
        Critical: critical,
    })
}

// Listen 监听关闭信号
func (gs *GracefulShutdown) Listen(ctx context.Context) {
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM, syscall.SIGINT)
    
    sig := <-sigChan
    
    ctx, span := gs.tracer.Start(ctx, "graceful-shutdown",
        trace.WithAttributes(
            attribute.String("signal", sig.String()),
        ),
    )
    defer span.End()
    
    fmt.Printf("\n收到关闭信号: %s\n", sig)
    
    // 创建带超时的context
    shutdownCtx, cancel := context.WithTimeout(context.Background(), gs.timeout)
    defer cancel()
    
    if err := gs.Shutdown(shutdownCtx); err != nil {
        span.RecordError(err)
        fmt.Printf("关闭过程中发生错误: %v\n", err)
        os.Exit(1)
    }
    
    fmt.Println("应用已成功关闭")
    os.Exit(0)
}

// Shutdown 执行关闭流程
func (gs *GracefulShutdown) Shutdown(ctx context.Context) error {
    ctx, span := gs.tracer.Start(ctx, "execute-shutdown")
    defer span.End()
    
    gs.mu.Lock()
    funcs := make([]ShutdownFunc, len(gs.shutdownFuncs))
    copy(funcs, gs.shutdownFuncs)
    gs.mu.Unlock()
    
    // 分阶段关闭
    // 阶段1: 停止接收新请求
    fmt.Println("阶段1: 停止接收新请求...")
    if err := gs.shutdownPhase(ctx, funcs, false); err != nil {
        return err
    }
    
    // 阶段2: 等待现有请求完成
    fmt.Println("阶段2: 等待现有请求完成...")
    time.Sleep(2 * time.Second)
    
    // 阶段3: 关闭关键服务
    fmt.Println("阶段3: 关闭关键服务...")
    if err := gs.shutdownPhase(ctx, funcs, true); err != nil {
        return err
    }
    
    span.AddEvent("所有服务已关闭")
    return nil
}

func (gs *GracefulShutdown) shutdownPhase(ctx context.Context, funcs []ShutdownFunc, critical bool) error {
    var wg sync.WaitGroup
    errors := make(chan error, len(funcs))
    
    for _, fn := range funcs {
        if fn.Critical != critical {
            continue
        }
        
        wg.Add(1)
        go func(sf ShutdownFunc) {
            defer wg.Done()
            
            _, span := gs.tracer.Start(ctx, "shutdown-"+sf.Name)
            defer span.End()
            
            fmt.Printf("  关闭 %s...\n", sf.Name)
            
            if err := sf.Func(ctx); err != nil {
                span.RecordError(err)
                errors <- fmt.Errorf("%s 关闭失败: %w", sf.Name, err)
            } else {
                fmt.Printf("  ✓ %s 已关闭\n", sf.Name)
            }
        }(fn)
    }
    
    wg.Wait()
    close(errors)
    
    var errs []error
    for err := range errors {
        errs = append(errs, err)
    }
    
    if len(errs) > 0 {
        return fmt.Errorf("关闭阶段失败: %v", errs)
    }
    
    return nil
}

// 完整使用示例
func RunApplicationWithGracefulShutdown() {
    ctx := context.Background()
    
    // 初始化追踪
    tp, err := initTracer(ctx)
    if err != nil {
        fmt.Printf("初始化追踪失败: %v\n", err)
        os.Exit(1)
    }
    
    // 创建关闭管理器
    gs := NewGracefulShutdown(30 * time.Second)
    
    // 注册关闭函数（按优先级）
    // 1. 非关键服务
    gs.Register("http-server", func(ctx context.Context) error {
        // 停止HTTP服务器
        return nil
    }, false)
    
    gs.Register("worker-pool", func(ctx context.Context) error {
        // 停止worker pool
        return nil
    }, false)
    
    // 2. 关键服务
    gs.Register("database", func(ctx context.Context) error {
        // 关闭数据库连接
        return nil
    }, true)
    
    gs.Register("tracer-provider", func(ctx context.Context) error {
        return tp.Shutdown(ctx)
    }, true)
    
    // 启动应用
    fmt.Println("应用启动中...")
    
    // 监听关闭信号
    gs.Listen(ctx)
}
```

---

## 健康检查

### 3. 健康检查端点

```go
package health

import (
    "context"
    "database/sql"
    "encoding/json"
    "net/http"
    "sync"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// HealthChecker 健康检查器
type HealthChecker struct {
    tracer    trace.Tracer
    checks    map[string]CheckFunc
    mu        sync.RWMutex
}

type CheckFunc func(context.Context) HealthStatus

type HealthStatus struct {
    Status  string                 `json:"status"`  // healthy, degraded, unhealthy
    Message string                 `json:"message,omitempty"`
    Details map[string]interface{} `json:"details,omitempty"`
}

type HealthResponse struct {
    Status    string                    `json:"status"`
    Timestamp time.Time                 `json:"timestamp"`
    Checks    map[string]HealthStatus   `json:"checks"`
}

func NewHealthChecker() *HealthChecker {
    return &HealthChecker{
        tracer: otel.Tracer("health-checker"),
        checks: make(map[string]CheckFunc),
    }
}

// RegisterCheck 注册健康检查
func (hc *HealthChecker) RegisterCheck(name string, check CheckFunc) {
    hc.mu.Lock()
    defer hc.mu.Unlock()
    
    hc.checks[name] = check
}

// Check 执行所有健康检查
func (hc *HealthChecker) Check(ctx context.Context) HealthResponse {
    ctx, span := hc.tracer.Start(ctx, "health-check")
    defer span.End()
    
    hc.mu.RLock()
    checks := make(map[string]CheckFunc, len(hc.checks))
    for k, v := range hc.checks {
        checks[k] = v
    }
    hc.mu.RUnlock()
    
    response := HealthResponse{
        Timestamp: time.Now(),
        Checks:    make(map[string]HealthStatus),
    }
    
    var (
        wg           sync.WaitGroup
        mu           sync.Mutex
        healthyCount int
        totalCount   = len(checks)
    )
    
    // 并发执行所有检查
    for name, checkFn := range checks {
        wg.Add(1)
        
        go func(n string, fn CheckFunc) {
            defer wg.Done()
            
            checkCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
            defer cancel()
            
            _, checkSpan := hc.tracer.Start(checkCtx, "check-"+n)
            defer checkSpan.End()
            
            status := fn(checkCtx)
            
            checkSpan.SetAttributes(
                attribute.String("check.name", n),
                attribute.String("check.status", status.Status),
            )
            
            mu.Lock()
            response.Checks[n] = status
            if status.Status == "healthy" {
                healthyCount++
            }
            mu.Unlock()
        }(name, checkFn)
    }
    
    wg.Wait()
    
    // 确定整体状态
    if healthyCount == totalCount {
        response.Status = "healthy"
    } else if healthyCount > 0 {
        response.Status = "degraded"
    } else {
        response.Status = "unhealthy"
    }
    
    span.SetAttributes(
        attribute.String("health.status", response.Status),
        attribute.Int("health.total_checks", totalCount),
        attribute.Int("health.healthy_checks", healthyCount),
    )
    
    return response
}

// HTTPHandler HTTP健康检查处理器
func (hc *HealthChecker) HTTPHandler() http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        ctx := r.Context()
        
        response := hc.Check(ctx)
        
        // 设置HTTP状态码
        statusCode := http.StatusOK
        if response.Status == "degraded" {
            statusCode = http.StatusOK // 降级但仍可用
        } else if response.Status == "unhealthy" {
            statusCode = http.StatusServiceUnavailable
        }
        
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        json.NewEncoder(w).Encode(response)
    }
}

// 预定义的健康检查

// DatabaseCheck 数据库健康检查
func DatabaseCheck(db *sql.DB) CheckFunc {
    return func(ctx context.Context) HealthStatus {
        if err := db.PingContext(ctx); err != nil {
            return HealthStatus{
                Status:  "unhealthy",
                Message: fmt.Sprintf("数据库连接失败: %v", err),
            }
        }
        
        stats := db.Stats()
        return HealthStatus{
            Status: "healthy",
            Details: map[string]interface{}{
                "open_connections": stats.OpenConnections,
                "in_use":          stats.InUse,
                "idle":            stats.Idle,
            },
        }
    }
}

// MemoryCheck 内存健康检查
func MemoryCheck(thresholdPercent float64) CheckFunc {
    return func(ctx context.Context) HealthStatus {
        var m runtime.MemStats
        runtime.ReadMemStats(&m)
        
        usedPercent := float64(m.Alloc) / float64(m.Sys) * 100
        
        status := "healthy"
        if usedPercent > thresholdPercent {
            status = "degraded"
        }
        if usedPercent > thresholdPercent*1.2 {
            status = "unhealthy"
        }
        
        return HealthStatus{
            Status: status,
            Details: map[string]interface{}{
                "alloc_mb":        m.Alloc / 1024 / 1024,
                "sys_mb":          m.Sys / 1024 / 1024,
                "used_percent":    usedPercent,
                "num_gc":          m.NumGC,
                "goroutines":      runtime.NumGoroutine(),
            },
        }
    }
}

// DiskCheck 磁盘健康检查
func DiskCheck(path string, thresholdPercent float64) CheckFunc {
    return func(ctx context.Context) HealthStatus {
        var stat syscall.Statfs_t
        if err := syscall.Statfs(path, &stat); err != nil {
            return HealthStatus{
                Status:  "unhealthy",
                Message: fmt.Sprintf("无法获取磁盘信息: %v", err),
            }
        }
        
        available := stat.Bavail * uint64(stat.Bsize)
        total := stat.Blocks * uint64(stat.Bsize)
        usedPercent := float64(total-available) / float64(total) * 100
        
        status := "healthy"
        if usedPercent > thresholdPercent {
            status = "degraded"
        }
        if usedPercent > thresholdPercent*1.2 {
            status = "unhealthy"
        }
        
        return HealthStatus{
            Status: status,
            Details: map[string]interface{}{
                "path":         path,
                "total_gb":     total / 1024 / 1024 / 1024,
                "available_gb": available / 1024 / 1024 / 1024,
                "used_percent": usedPercent,
            },
        }
    }
}

// 使用示例
func SetupHealthChecks(db *sql.DB) *HealthChecker {
    hc := NewHealthChecker()
    
    // 注册各种检查
    hc.RegisterCheck("database", DatabaseCheck(db))
    hc.RegisterCheck("memory", MemoryCheck(80.0))
    hc.RegisterCheck("disk", DiskCheck("/", 85.0))
    
    // 自定义检查
    hc.RegisterCheck("custom-service", func(ctx context.Context) HealthStatus {
        // 自定义健康检查逻辑
        return HealthStatus{
            Status: "healthy",
        }
    })
    
    return hc
}
```

---

## 配置管理

### 4. 环境配置和动态配置

```go
package config

import (
    "context"
    "fmt"
    "os"
    "strconv"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// Config 应用配置
type Config struct {
    // 应用配置
    AppName    string
    AppVersion string
    Environment string
    
    // OTLP配置
    OTLPEndpoint    string
    OTLPInsecure    bool
    OTLPCompression bool
    SampleRate      float64
    
    // 性能配置
    MaxBatchSize  int
    BatchTimeout  time.Duration
    MaxQueueSize  int
    
    // 资源配置
    MaxConcurrency int
    RequestTimeout time.Duration
    
    // 数据库配置
    DatabaseURL      string
    DatabaseMaxConns int
    DatabaseTimeout  time.Duration
}

// ConfigLoader 配置加载器
type ConfigLoader struct {
    tracer trace.Tracer
}

func NewConfigLoader() *ConfigLoader {
    return &ConfigLoader{
        tracer: otel.Tracer("config-loader"),
    }
}

// Load 加载配置
func (cl *ConfigLoader) Load(ctx context.Context) (*Config, error) {
    ctx, span := cl.tracer.Start(ctx, "load-config")
    defer span.End()
    
    cfg := &Config{
        // 默认值
        AppName:         getEnv("APP_NAME", "my-app"),
        AppVersion:      getEnv("APP_VERSION", "1.0.0"),
        Environment:     getEnv("APP_ENV", "development"),
        
        // OTLP默认配置
        OTLPEndpoint:    getEnv("OTLP_ENDPOINT", "localhost:4317"),
        OTLPInsecure:    getEnvBool("OTLP_INSECURE", true),
        OTLPCompression: getEnvBool("OTLP_COMPRESSION", true),
        SampleRate:      getEnvFloat("OTLP_SAMPLE_RATE", 1.0),
        
        // 性能默认配置
        MaxBatchSize: getEnvInt("OTLP_MAX_BATCH_SIZE", 512),
        BatchTimeout: getEnvDuration("OTLP_BATCH_TIMEOUT", 5*time.Second),
        MaxQueueSize: getEnvInt("OTLP_MAX_QUEUE_SIZE", 2048),
        
        // 资源默认配置
        MaxConcurrency: getEnvInt("MAX_CONCURRENCY", 100),
        RequestTimeout: getEnvDuration("REQUEST_TIMEOUT", 30*time.Second),
        
        // 数据库默认配置
        DatabaseURL:      getEnv("DATABASE_URL", ""),
        DatabaseMaxConns: getEnvInt("DATABASE_MAX_CONNS", 25),
        DatabaseTimeout:  getEnvDuration("DATABASE_TIMEOUT", 10*time.Second),
    }
    
    // 验证配置
    if err := cfg.Validate(); err != nil {
        span.RecordError(err)
        return nil, err
    }
    
    span.SetAttributes(
        attribute.String("config.app_name", cfg.AppName),
        attribute.String("config.environment", cfg.Environment),
        attribute.String("config.otlp_endpoint", cfg.OTLPEndpoint),
        attribute.Float64("config.sample_rate", cfg.SampleRate),
    )
    
    return cfg, nil
}

// Validate 验证配置
func (c *Config) Validate() error {
    if c.AppName == "" {
        return fmt.Errorf("APP_NAME 不能为空")
    }
    
    if c.SampleRate < 0 || c.SampleRate > 1 {
        return fmt.Errorf("SAMPLE_RATE 必须在 0 和 1 之间")
    }
    
    if c.MaxBatchSize <= 0 {
        return fmt.Errorf("MAX_BATCH_SIZE 必须大于 0")
    }
    
    return nil
}

// 辅助函数

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func getEnvInt(key string, defaultValue int) int {
    if value := os.Getenv(key); value != "" {
        if intValue, err := strconv.Atoi(value); err == nil {
            return intValue
        }
    }
    return defaultValue
}

func getEnvFloat(key string, defaultValue float64) float64 {
    if value := os.Getenv(key); value != "" {
        if floatValue, err := strconv.ParseFloat(value, 64); err == nil {
            return floatValue
        }
    }
    return defaultValue
}

func getEnvBool(key string, defaultValue bool) bool {
    if value := os.Getenv(key); value != "" {
        if boolValue, err := strconv.ParseBool(value); err == nil {
            return boolValue
        }
    }
    return defaultValue
}

func getEnvDuration(key string, defaultValue time.Duration) time.Duration {
    if value := os.Getenv(key); value != "" {
        if duration, err := time.ParseDuration(value); err == nil {
            return duration
        }
    }
    return defaultValue
}
```

---

## 总结

本文档提供了 Go 生产级部署的完整最佳实践，包括：

1. ✅ **资源管理** - 连接池、资源清理
2. ✅ **优雅关闭** - 信号处理、分阶段关闭
3. ✅ **健康检查** - 数据库、内存、磁盘检查
4. ✅ **配置管理** - 环境变量、验证
5. ✅ **可观测性** - 全流程追踪

### 下一步

- [容器化部署](./08_Go容器化与Kubernetes集成.md)
- [监控告警](./09_Go监控告警最佳实践.md)
- [故障排查](../../16_故障排查手册/01_OpenTelemetry故障排查完整手册.md)
