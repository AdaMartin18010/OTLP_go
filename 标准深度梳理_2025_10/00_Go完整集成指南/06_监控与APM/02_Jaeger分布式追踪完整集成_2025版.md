# Jaeger åˆ†å¸ƒå¼è¿½è¸ªå®Œæ•´é›†æˆï¼ˆ2025ç‰ˆï¼‰

> **Jaeger ç‰ˆæœ¬**: v1.52+  
> **Go ç‰ˆæœ¬**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0  
> **æœ€åæ›´æ–°**: 2025-10-11  
> **æ–‡æ¡£çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª

---

## ğŸ“‹ ç›®å½•

- [Jaeger åˆ†å¸ƒå¼è¿½è¸ªå®Œæ•´é›†æˆï¼ˆ2025ç‰ˆï¼‰](#jaeger-åˆ†å¸ƒå¼è¿½è¸ªå®Œæ•´é›†æˆ2025ç‰ˆ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. Jaeger æ¦‚è¿°](#1-jaeger-æ¦‚è¿°)
    - [1.1 ä¸ºä»€ä¹ˆé€‰æ‹© Jaeger](#11-ä¸ºä»€ä¹ˆé€‰æ‹©-jaeger)
    - [1.2 ä¸å…¶ä»–è¿½è¸ªç³»ç»Ÿå¯¹æ¯”](#12-ä¸å…¶ä»–è¿½è¸ªç³»ç»Ÿå¯¹æ¯”)
    - [1.3 æ ¸å¿ƒæ¦‚å¿µ](#13-æ ¸å¿ƒæ¦‚å¿µ)
  - [2. å¿«é€Ÿå¼€å§‹](#2-å¿«é€Ÿå¼€å§‹)
    - [2.1 Docker éƒ¨ç½² Jaeger](#21-docker-éƒ¨ç½²-jaeger)
    - [2.2 ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²](#22-ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²)
    - [2.3 Go ä¾èµ–å®‰è£…](#23-go-ä¾èµ–å®‰è£…)
  - [3. OTLP å®Œæ•´é›†æˆ](#3-otlp-å®Œæ•´é›†æˆ)
    - [3.1 ä½¿ç”¨ OTLP Exporterï¼ˆæ¨èï¼‰](#31-ä½¿ç”¨-otlp-exporteræ¨è)
    - [3.2 ä½¿ç”¨ Jaeger Exporter](#32-ä½¿ç”¨-jaeger-exporter)
  - [4. é«˜çº§ç‰¹æ€§](#4-é«˜çº§ç‰¹æ€§)
    - [4.1 é‡‡æ ·ç­–ç•¥](#41-é‡‡æ ·ç­–ç•¥)
    - [4.2 Span ç”Ÿå‘½å‘¨æœŸ](#42-span-ç”Ÿå‘½å‘¨æœŸ)
    - [4.3 Context ä¼ æ’­](#43-context-ä¼ æ’­)
  - [5. å®Œæ•´ç¤ºä¾‹](#5-å®Œæ•´ç¤ºä¾‹)
    - [5.1 å¾®æœåŠ¡è¿½è¸ªç¤ºä¾‹](#51-å¾®æœåŠ¡è¿½è¸ªç¤ºä¾‹)
  - [6. æ€§èƒ½ä¼˜åŒ–](#6-æ€§èƒ½ä¼˜åŒ–)
    - [6.1 æ‰¹é‡å¯¼å‡ºé…ç½®](#61-æ‰¹é‡å¯¼å‡ºé…ç½®)
    - [6.2 é‡‡æ ·ä¼˜åŒ–](#62-é‡‡æ ·ä¼˜åŒ–)
  - [7. æœ€ä½³å®è·µ](#7-æœ€ä½³å®è·µ)
    - [7.1 Span å‘½åè§„èŒƒ](#71-span-å‘½åè§„èŒƒ)
    - [7.2 æ ‡ç­¾ä½¿ç”¨è§„èŒƒ](#72-æ ‡ç­¾ä½¿ç”¨è§„èŒƒ)
  - [8. æ€»ç»“](#8-æ€»ç»“)
    - [8.1 ä¼˜åŠ¿ä¸åŠ£åŠ¿](#81-ä¼˜åŠ¿ä¸åŠ£åŠ¿)

---

## 1. Jaeger æ¦‚è¿°

### 1.1 ä¸ºä»€ä¹ˆé€‰æ‹© Jaeger

**Jaeger** æ˜¯ Uber å¼€æºçš„åˆ†å¸ƒå¼è¿½è¸ªç³»ç»Ÿï¼ŒCNCF æ¯•ä¸šé¡¹ç›®ã€‚

```text
âœ… æ ¸å¿ƒä¼˜åŠ¿:
  - åˆ†å¸ƒå¼è¿½è¸ª - å®Œæ•´çš„è°ƒç”¨é“¾è·¯
  - æ€§èƒ½åˆ†æ - æ‰¾å‡ºæ€§èƒ½ç“¶é¢ˆ
  - æ ¹å› åˆ†æ - å¿«é€Ÿå®šä½é—®é¢˜
  - æœåŠ¡ä¾èµ– - å¯è§†åŒ–æœåŠ¡å…³ç³»
  - é‡‡æ ·ç­–ç•¥ - çµæ´»çš„é‡‡æ ·é…ç½®
  - å¤šç§å­˜å‚¨ - æ”¯æŒå¤šç§åç«¯
  - OpenTracing - å…¼å®¹æ ‡å‡†

ğŸ“Š ä½¿ç”¨ç»Ÿè®¡:
  - GitHub Stars: 20,000+
  - ç”Ÿäº§ä½¿ç”¨: æ•°åƒå®¶å…¬å¸
  - CNCF: æ¯•ä¸šé¡¹ç›®
  - Uber å†…éƒ¨: æ—¥å‡ 10 äº¿+ span
```

### 1.2 ä¸å…¶ä»–è¿½è¸ªç³»ç»Ÿå¯¹æ¯”

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç³»ç»Ÿ       â”‚  æ€§èƒ½   â”‚ åŠŸèƒ½     â”‚ æ˜“ç”¨æ€§   â”‚ æ¨èæŒ‡æ•°   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Jaeger       â”‚  â­â­â­â­â­ â”‚ â­â­â­â­â­  â”‚ â­â­â­â­â­  â”‚  â­â­â­â­â­  â”‚
â”‚ Zipkin       â”‚  â­â­â­â­  â”‚ â­â­â­â­   â”‚ â­â­â­â­   â”‚  â­â­â­â­   â”‚
â”‚ SkyWalking   â”‚  â­â­â­â­  â”‚ â­â­â­â­â­  â”‚ â­â­â­â­   â”‚  â­â­â­â­â­  â”‚
â”‚ Datadog APM  â”‚  â­â­â­â­â­ â”‚ â­â­â­â­â­  â”‚ â­â­â­â­â­  â”‚  â­â­â­â­â­  â”‚
â”‚ AWS X-Ray    â”‚  â­â­â­â­  â”‚ â­â­â­â­   â”‚ â­â­â­â­â­  â”‚  â­â­â­â­   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç‰¹ç‚¹:
  - Jaeger: CNCF æ ‡å‡†ï¼ŒåŠŸèƒ½å®Œæ•´
  - Zipkin: è€ç‰Œï¼ŒTwitter å¼€æº
  - SkyWalking: APM å…¨å®¶æ¡¶ï¼Œä¸­æ–‡å‹å¥½
  - Datadog APM: å•†ä¸šæ–¹æ¡ˆï¼ŒåŠŸèƒ½æœ€å¼º
```

### 1.3 æ ¸å¿ƒæ¦‚å¿µ

```text
Trace (è¿½è¸ª)
  â””â”€ Span (è·¨åº¦)
      â”œâ”€ Operation Name (æ“ä½œå)
      â”œâ”€ Start Time (å¼€å§‹æ—¶é—´)
      â”œâ”€ Duration (æŒç»­æ—¶é—´)
      â”œâ”€ Tags (æ ‡ç­¾)
      â”‚   â”œâ”€ http.method: GET
      â”‚   â”œâ”€ http.url: /api/users
      â”‚   â””â”€ http.status_code: 200
      â”œâ”€ Logs (æ—¥å¿—)
      â”‚   â””â”€ event: error, message: "connection timeout"
      â””â”€ SpanContext (ä¸Šä¸‹æ–‡)
          â”œâ”€ TraceID (è¿½è¸ªID)
          â”œâ”€ SpanID (è·¨åº¦ID)
          â””â”€ ParentSpanID (çˆ¶è·¨åº¦ID)

ç¤ºä¾‹è°ƒç”¨é“¾:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Trace (æ€»è€—æ—¶ 250ms)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â”Œâ”€ API Gateway (200ms) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚  â”Œâ”€ Auth Service (20ms) â”€â”€â”€â”                  â”‚ â”‚
â”‚ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚ â”‚
â”‚ â”‚  â”Œâ”€ Order Service (150ms) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚
â”‚ â”‚  â”‚  â”Œâ”€ DB Query (50ms) â”€â”€â”                 â”‚  â”‚ â”‚
â”‚ â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚  â”‚ â”‚
â”‚ â”‚  â”‚  â”Œâ”€ Cache Get (5ms) â”€â”                  â”‚  â”‚ â”‚
â”‚ â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚  â”‚ â”‚
â”‚ â”‚  â”‚  â”Œâ”€ Payment API (80ms) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚ â”‚
â”‚ â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚ â”‚
â”‚ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. å¿«é€Ÿå¼€å§‹

### 2.1 Docker éƒ¨ç½² Jaeger

```bash
# All-in-One æ¨¡å¼ï¼ˆå¼€å‘ç¯å¢ƒï¼‰
docker run -d --name jaeger \
  -e COLLECTOR_OTLP_ENABLED=true \
  -p 6831:6831/udp \
  -p 6832:6832/udp \
  -p 5778:5778 \
  -p 16686:16686 \
  -p 4317:4317 \
  -p 4318:4318 \
  -p 14250:14250 \
  -p 14268:14268 \
  -p 14269:14269 \
  -p 9411:9411 \
  jaegertracing/all-in-one:1.52

# è®¿é—® UI: http://localhost:16686
# OTLP gRPC: localhost:4317
# OTLP HTTP: localhost:4318
```

### 2.2 ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²

```yaml
# docker-compose.yml
version: '3'
services:
  jaeger-collector:
    image: jaegertracing/jaeger-collector:1.52
    ports:
      - "14268:14268"
      - "14250:14250"
      - "4317:4317"
      - "4318:4318"
    environment:
      - SPAN_STORAGE_TYPE=elasticsearch
      - ES_SERVER_URLS=http://elasticsearch:9200
    depends_on:
      - elasticsearch

  jaeger-query:
    image: jaegertracing/jaeger-query:1.52
    ports:
      - "16686:16686"
    environment:
      - SPAN_STORAGE_TYPE=elasticsearch
      - ES_SERVER_URLS=http://elasticsearch:9200
    depends_on:
      - elasticsearch

  elasticsearch:
    image: elasticsearch:8.11.0
    environment:
      - discovery.type=single-node
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    ports:
      - "9200:9200"
```

### 2.3 Go ä¾èµ–å®‰è£…

```bash
# OpenTelemetry Go SDK
go get go.opentelemetry.io/otel@v1.32.0
go get go.opentelemetry.io/otel/sdk@v1.32.0
go get go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc@v1.32.0
go get go.opentelemetry.io/otel/exporters/jaeger@v1.32.0
```

---

## 3. OTLP å®Œæ•´é›†æˆ

### 3.1 ä½¿ç”¨ OTLP Exporterï¼ˆæ¨èï¼‰

```go
package main

import (
    "context"
    "log"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/sdk/resource"
    "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
)

func initJaeger() (*trace.TracerProvider, error) {
    ctx := context.Background()
    
    // åˆ›å»º OTLP Trace Exporter
    exporter, err := otlptracegrpc.New(ctx,
        otlptracegrpc.WithEndpoint("localhost:4317"),
        otlptracegrpc.WithInsecure(),
        otlptracegrpc.WithDialOption(grpc.WithBlock()),
        otlptracegrpc.WithTimeout(5*time.Second),
    )
    if err != nil {
        return nil, err
    }
    
    // åˆ›å»º Resource
    res, err := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName("my-service"),
            semconv.ServiceVersion("1.0.0"),
            semconv.DeploymentEnvironment("production"),
            semconv.ServiceInstanceID("instance-1"),
        ),
        resource.WithProcessRuntimeDescription(),
        resource.WithHost(),
    )
    if err != nil {
        return nil, err
    }
    
    // åˆ›å»º TracerProvider
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter,
            trace.WithBatchTimeout(5*time.Second),
            trace.WithMaxExportBatchSize(512),
            trace.WithMaxQueueSize(2048),
        ),
        trace.WithResource(res),
        trace.WithSampler(trace.ParentBased(trace.TraceIDRatioBased(1.0))), // 100% é‡‡æ ·
    )
    
    // è®¾ç½®å…¨å±€ TracerProvider
    otel.SetTracerProvider(tp)
    
    // è®¾ç½®å…¨å±€ Propagator
    otel.SetTextMapPropagator(
        propagation.NewCompositeTextMapPropagator(
            propagation.TraceContext{},
            propagation.Baggage{},
        ),
    )
    
    return tp, nil
}

func main() {
    ctx := context.Background()
    
    // åˆå§‹åŒ– Jaeger
    tp, err := initJaeger()
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err := tp.Shutdown(ctx); err != nil {
            log.Printf("Error shutting down tracer provider: %v", err)
        }
    }()
    
    // åˆ›å»º Tracer
    tracer := otel.Tracer("my-service")
    
    // åˆ›å»º Span
    ctx, span := tracer.Start(ctx, "main-operation")
    defer span.End()
    
    // ä¸šåŠ¡é€»è¾‘
    doSomething(ctx)
    
    log.Println("Trace sent to Jaeger")
}

func doSomething(ctx context.Context) {
    tracer := otel.Tracer("my-service")
    ctx, span := tracer.Start(ctx, "do-something")
    defer span.End()
    
    // æ·»åŠ æ ‡ç­¾
    span.SetAttributes(
        attribute.String("component", "business-logic"),
        attribute.Int("iteration", 1),
    )
    
    // æ·»åŠ äº‹ä»¶
    span.AddEvent("processing started")
    
    time.Sleep(100 * time.Millisecond)
    
    span.AddEvent("processing completed")
}
```

### 3.2 ä½¿ç”¨ Jaeger Exporter

```go
package main

import (
    "context"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/jaeger"
    "go.opentelemetry.io/otel/sdk/resource"
    "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

func initJaegerLegacy() (*trace.TracerProvider, error) {
    // åˆ›å»º Jaeger Exporter
    exporter, err := jaeger.New(
        jaeger.WithCollectorEndpoint(
            jaeger.WithEndpoint("http://localhost:14268/api/traces"),
        ),
    )
    if err != nil {
        return nil, err
    }
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
        trace.WithResource(resource.NewWithAttributes(
            semconv.SchemaURL,
            semconv.ServiceName("my-service"),
        )),
    )
    
    otel.SetTracerProvider(tp)
    
    return tp, nil
}
```

---

## 4. é«˜çº§ç‰¹æ€§

### 4.1 é‡‡æ ·ç­–ç•¥

```go
// 1. Always Sample - 100% é‡‡æ ·
alwaysSampler := trace.AlwaysSample()

// 2. Never Sample - 0% é‡‡æ ·
neverSampler := trace.NeverSample()

// 3. TraceID Ratio - åŸºäº TraceID çš„æ¯”ä¾‹é‡‡æ ·
ratioSampler := trace.TraceIDRatioBased(0.1) // 10% é‡‡æ ·

// 4. Parent Based - åŸºäºçˆ¶ Span çš„é‡‡æ ·
parentBasedSampler := trace.ParentBased(
    trace.TraceIDRatioBased(0.1),
)

// 5. è‡ªå®šä¹‰é‡‡æ ·å™¨
type CustomSampler struct{}

func (cs CustomSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    // æ ¹æ®ä¸šåŠ¡é€»è¾‘å†³å®šæ˜¯å¦é‡‡æ ·
    if strings.Contains(p.Name, "health") {
        return trace.SamplingResult{
            Decision: trace.Drop,
        }
    }
    
    // é”™è¯¯è¯·æ±‚æ€»æ˜¯é‡‡æ ·
    for _, attr := range p.Attributes {
        if attr.Key == "error" && attr.Value.AsBool() {
            return trace.SamplingResult{
                Decision: trace.RecordAndSample,
            }
        }
    }
    
    // å…¶ä»–æƒ…å†µ 10% é‡‡æ ·
    return trace.TraceIDRatioBased(0.1).ShouldSample(p)
}

func (cs CustomSampler) Description() string {
    return "CustomSampler"
}

// ä½¿ç”¨è‡ªå®šä¹‰é‡‡æ ·å™¨
tp := trace.NewTracerProvider(
    trace.WithSampler(CustomSampler{}),
)
```

### 4.2 Span ç”Ÿå‘½å‘¨æœŸ

```go
func CompleteSpanExample(ctx context.Context) {
    tracer := otel.Tracer("my-service")
    
    // 1. åˆ›å»º Span
    ctx, span := tracer.Start(ctx, "operation",
        trace.WithSpanKind(trace.SpanKindServer),
        trace.WithAttributes(
            attribute.String("component", "api"),
            attribute.String("http.method", "GET"),
        ),
    )
    defer span.End()
    
    // 2. æ·»åŠ æ›´å¤šå±æ€§
    span.SetAttributes(
        attribute.String("user.id", "123"),
        attribute.Int("retry.count", 0),
    )
    
    // 3. è®°å½•äº‹ä»¶
    span.AddEvent("validation started")
    
    // 4. å­ Span
    childCtx, childSpan := tracer.Start(ctx, "database-query",
        trace.WithSpanKind(trace.SpanKindClient),
    )
    
    // æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
    time.Sleep(50 * time.Millisecond)
    
    childSpan.SetAttributes(
        attribute.String("db.system", "postgresql"),
        attribute.String("db.statement", "SELECT * FROM users"),
    )
    childSpan.End()
    
    // 5. è®°å½•é”™è¯¯
    if err := someOperation(); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return
    }
    
    // 6. æˆåŠŸå®Œæˆ
    span.SetStatus(codes.Ok, "operation completed successfully")
    span.AddEvent("operation completed")
}
```

### 4.3 Context ä¼ æ’­

```go
// HTTP Client
func HTTPClientWithTracing(ctx context.Context, url string) error {
    tracer := otel.Tracer("http-client")
    ctx, span := tracer.Start(ctx, "http-request",
        trace.WithSpanKind(trace.SpanKindClient),
    )
    defer span.End()
    
    req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
    
    // æ³¨å…¥ trace context åˆ° HTTP è¯·æ±‚å¤´
    otel.GetTextMapPropagator().Inject(ctx, propagation.HeaderCarrier(req.Header))
    
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        span.RecordError(err)
        return err
    }
    defer resp.Body.Close()
    
    span.SetAttributes(
        attribute.Int("http.status_code", resp.StatusCode),
    )
    
    return nil
}

// HTTP Server
func HTTPServerWithTracing(w http.ResponseWriter, r *http.Request) {
    tracer := otel.Tracer("http-server")
    
    // æå– trace context ä» HTTP è¯·æ±‚å¤´
    ctx := otel.GetTextMapPropagator().Extract(r.Context(), propagation.HeaderCarrier(r.Header))
    
    ctx, span := tracer.Start(ctx, "handle-request",
        trace.WithSpanKind(trace.SpanKindServer),
    )
    defer span.End()
    
    // å¤„ç†è¯·æ±‚
    result := processRequest(ctx)
    
    w.Write([]byte(result))
}

// gRPC Client
func GRPCClientWithTracing(ctx context.Context) {
    // gRPC è‡ªåŠ¨æ”¯æŒ OTLPï¼Œåªéœ€ç¡®ä¿ context ä¼ é€’
    conn, _ := grpc.Dial("localhost:50051",
        grpc.WithInsecure(),
        grpc.WithUnaryInterceptor(otelgrpc.UnaryClientInterceptor()),
    )
    
    client := pb.NewGreeterClient(conn)
    resp, err := client.SayHello(ctx, &pb.HelloRequest{Name: "World"})
    // trace context ä¼šè‡ªåŠ¨ä¼ æ’­
}
```

---

## 5. å®Œæ•´ç¤ºä¾‹

### 5.1 å¾®æœåŠ¡è¿½è¸ªç¤ºä¾‹

```go
package main

import (
    "context"
    "encoding/json"
    "log"
    "net/http"
    "time"
    
    "github.com/gorilla/mux"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
)

type OrderService struct {
    tracer trace.Tracer
}

func NewOrderService() *OrderService {
    return &OrderService{
        tracer: otel.Tracer("order-service"),
    }
}

// CreateOrder åˆ›å»ºè®¢å•ï¼ˆå¸¦å®Œæ•´è¿½è¸ªï¼‰
func (s *OrderService) CreateOrder(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    ctx, span := s.tracer.Start(ctx, "create-order",
        trace.WithSpanKind(trace.SpanKindServer),
    )
    defer span.End()
    
    // 1. è§£æè¯·æ±‚
    var req struct {
        UserID    string  `json:"user_id"`
        ProductID string  `json:"product_id"`
        Amount    float64 `json:"amount"`
    }
    
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "invalid request")
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    span.SetAttributes(
        attribute.String("user.id", req.UserID),
        attribute.String("product.id", req.ProductID),
        attribute.Float64("order.amount", req.Amount),
    )
    
    // 2. éªŒè¯åº“å­˜
    if err := s.checkInventory(ctx, req.ProductID); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "inventory check failed")
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    // 3. å¤„ç†æ”¯ä»˜
    paymentID, err := s.processPayment(ctx, req.UserID, req.Amount)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "payment failed")
        http.Error(w, err.Error(), http.StatusPaymentRequired)
        return
    }
    
    span.SetAttributes(attribute.String("payment.id", paymentID))
    
    // 4. åˆ›å»ºè®¢å•è®°å½•
    orderID, err := s.createOrderRecord(ctx, req)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "order creation failed")
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    span.SetAttributes(attribute.String("order.id", orderID))
    span.SetStatus(codes.Ok, "order created successfully")
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(map[string]string{
        "order_id":   orderID,
        "payment_id": paymentID,
        "status":     "success",
    })
}

// checkInventory æ£€æŸ¥åº“å­˜
func (s *OrderService) checkInventory(ctx context.Context, productID string) error {
    ctx, span := s.tracer.Start(ctx, "check-inventory")
    defer span.End()
    
    span.SetAttributes(attribute.String("product.id", productID))
    
    // æ¨¡æ‹Ÿ HTTP è°ƒç”¨åº“å­˜æœåŠ¡
    req, _ := http.NewRequestWithContext(ctx, "GET",
        "http://inventory-service/api/check/"+productID, nil)
    
    client := &http.Client{
        Transport: otelhttp.NewTransport(http.DefaultTransport),
    }
    
    resp, err := client.Do(req)
    if err != nil {
        span.RecordError(err)
        return err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        err := fmt.Errorf("inventory check failed: %d", resp.StatusCode)
        span.RecordError(err)
        return err
    }
    
    span.SetStatus(codes.Ok, "inventory available")
    return nil
}

// processPayment å¤„ç†æ”¯ä»˜
func (s *OrderService) processPayment(ctx context.Context, userID string, amount float64) (string, error) {
    ctx, span := s.tracer.Start(ctx, "process-payment")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("user.id", userID),
        attribute.Float64("payment.amount", amount),
    )
    
    // æ¨¡æ‹Ÿæ”¯ä»˜å¤„ç†
    time.Sleep(150 * time.Millisecond)
    
    paymentID := fmt.Sprintf("pay_%d", time.Now().Unix())
    
    span.SetAttributes(attribute.String("payment.id", paymentID))
    span.SetStatus(codes.Ok, "payment processed")
    
    return paymentID, nil
}

// createOrderRecord åˆ›å»ºè®¢å•è®°å½•
func (s *OrderService) createOrderRecord(ctx context.Context, req struct {
    UserID    string
    ProductID string
    Amount    float64
}) (string, error) {
    ctx, span := s.tracer.Start(ctx, "create-order-record",
        trace.WithSpanKind(trace.SpanKindClient),
    )
    defer span.End()
    
    span.SetAttributes(
        attribute.String("db.system", "postgresql"),
        attribute.String("db.operation", "INSERT"),
    )
    
    // æ¨¡æ‹Ÿæ•°æ®åº“å†™å…¥
    time.Sleep(50 * time.Millisecond)
    
    orderID := fmt.Sprintf("order_%d", time.Now().Unix())
    
    span.SetAttributes(attribute.String("order.id", orderID))
    span.SetStatus(codes.Ok, "order record created")
    
    return orderID, nil
}

func main() {
    ctx := context.Background()
    
    // åˆå§‹åŒ– Jaeger
    tp, err := initJaeger()
    if err != nil {
        log.Fatal(err)
    }
    defer tp.Shutdown(ctx)
    
    // åˆ›å»ºæœåŠ¡
    orderService := NewOrderService()
    
    // åˆ›å»ºè·¯ç”±
    r := mux.NewRouter()
    
    // åº”ç”¨ OTLP ä¸­é—´ä»¶
    r.Use(func(next http.Handler) http.Handler {
        return otelhttp.NewHandler(next, "http-server")
    })
    
    // æ³¨å†Œè·¯ç”±
    r.HandleFunc("/api/orders", orderService.CreateOrder).Methods("POST")
    
    log.Println("Starting order service on :8080")
    http.ListenAndServe(":8080", r)
}
```

---

## 6. æ€§èƒ½ä¼˜åŒ–

### 6.1 æ‰¹é‡å¯¼å‡ºé…ç½®

```go
tp := trace.NewTracerProvider(
    trace.WithBatcher(exporter,
        trace.WithBatchTimeout(5*time.Second),      // æ‰¹é‡è¶…æ—¶
        trace.WithMaxExportBatchSize(512),          // æœ€å¤§æ‰¹é‡å¤§å°
        trace.WithMaxQueueSize(2048),               // æœ€å¤§é˜Ÿåˆ—å¤§å°
        trace.WithExportTimeout(30*time.Second),    // å¯¼å‡ºè¶…æ—¶
    ),
)
```

### 6.2 é‡‡æ ·ä¼˜åŒ–

```go
// æ ¹æ®ç¯å¢ƒä½¿ç”¨ä¸åŒé‡‡æ ·ç‡
func getSampler(env string) trace.Sampler {
    switch env {
    case "production":
        return trace.ParentBased(trace.TraceIDRatioBased(0.1)) // 10%
    case "staging":
        return trace.ParentBased(trace.TraceIDRatioBased(0.5)) // 50%
    default:
        return trace.AlwaysSample() // 100%
    }
}
```

---

## 7. æœ€ä½³å®è·µ

### 7.1 Span å‘½åè§„èŒƒ

```go
// âœ… å¥½çš„å‘½å
goodNames := []string{
    "GET /api/users",
    "database.query",
    "cache.get",
    "payment.process",
    "email.send",
}

// âŒ ä¸å¥½çš„å‘½å
badNames := []string{
    "function1",           // ä¸æè¿°æ€§
    "GET /api/users/123",  // åŒ…å«å˜é‡
    "very long operation name that is too descriptive", // å¤ªé•¿
}
```

### 7.2 æ ‡ç­¾ä½¿ç”¨è§„èŒƒ

```go
// âœ… æ¨èçš„æ ‡ç­¾
span.SetAttributes(
    semconv.HTTPMethodKey.String("GET"),
    semconv.HTTPStatusCodeKey.Int(200),
    semconv.DBSystemKey.String("postgresql"),
    attribute.String("user.id", userID),
)

// âŒ é¿å…é«˜åŸºæ•°æ ‡ç­¾
span.SetAttributes(
    attribute.String("request.id", requestID),  // æ¯ä¸ªè¯·æ±‚éƒ½ä¸åŒ
    attribute.String("timestamp", time.Now().String()), // é«˜åŸºæ•°
)
```

---

## 8. æ€»ç»“

### 8.1 ä¼˜åŠ¿ä¸åŠ£åŠ¿

```text
âœ… ä¼˜åŠ¿:
  - CNCF æ ‡å‡†
  - æ€§èƒ½ä¼˜ç§€
  - UI å‹å¥½
  - å¤šç§å­˜å‚¨åç«¯
  - ç¤¾åŒºæ´»è·ƒ

âŒ åŠ£åŠ¿:
  - éƒ¨ç½²ç›¸å¯¹å¤æ‚
  - éœ€è¦é¢å¤–å­˜å‚¨
```

**ç›¸å…³æ–‡æ¡£**:

- [01_Prometheusé«˜çº§é›†æˆä¸OTLPå®Œæ•´é›†æˆ_2025ç‰ˆ.md](./01_Prometheusé«˜çº§é›†æˆä¸OTLPå®Œæ•´é›†æˆ_2025ç‰ˆ.md)
- [03_Zipkinåˆ†å¸ƒå¼è¿½è¸ªé›†æˆ_2025ç‰ˆ.md](./03_Zipkinåˆ†å¸ƒå¼è¿½è¸ªé›†æˆ_2025ç‰ˆ.md)

---

**æ›´æ–°æ—¥æœŸ**: 2025-10-11  
**Jaeger ç‰ˆæœ¬**: v1.52+  
**æ€§èƒ½çº§åˆ«**: â­â­â­â­â­  
**æ¨èæŒ‡æ•°**: â­â­â­â­â­
