# Jaeger 分布式追踪完整集成（2025版）

> **Jaeger 版本**: v1.52+  
> **Go 版本**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0  
> **最后更新**: 2025-10-11  
> **文档状态**: ✅ 生产就绪

---

## 📋 目录

- [Jaeger 分布式追踪完整集成（2025版）](#jaeger-分布式追踪完整集成2025版)
  - [📋 目录](#-目录)
  - [1. Jaeger 概述](#1-jaeger-概述)
    - [1.1 为什么选择 Jaeger](#11-为什么选择-jaeger)
    - [1.2 与其他追踪系统对比](#12-与其他追踪系统对比)
    - [1.3 核心概念](#13-核心概念)
  - [2. 快速开始](#2-快速开始)
    - [2.1 Docker 部署 Jaeger](#21-docker-部署-jaeger)
    - [2.2 生产环境部署](#22-生产环境部署)
    - [2.3 Go 依赖安装](#23-go-依赖安装)
  - [3. OTLP 完整集成](#3-otlp-完整集成)
    - [3.1 使用 OTLP Exporter（推荐）](#31-使用-otlp-exporter推荐)
    - [3.2 使用 Jaeger Exporter](#32-使用-jaeger-exporter)
  - [4. 高级特性](#4-高级特性)
    - [4.1 采样策略](#41-采样策略)
    - [4.2 Span 生命周期](#42-span-生命周期)
    - [4.3 Context 传播](#43-context-传播)
  - [5. 完整示例](#5-完整示例)
    - [5.1 微服务追踪示例](#51-微服务追踪示例)
  - [6. 性能优化](#6-性能优化)
    - [6.1 批量导出配置](#61-批量导出配置)
    - [6.2 采样优化](#62-采样优化)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 Span 命名规范](#71-span-命名规范)
    - [7.2 标签使用规范](#72-标签使用规范)
  - [8. 总结](#8-总结)
    - [8.1 优势与劣势](#81-优势与劣势)

---

## 1. Jaeger 概述

### 1.1 为什么选择 Jaeger

**Jaeger** 是 Uber 开源的分布式追踪系统，CNCF 毕业项目。

```text
✅ 核心优势:
  - 分布式追踪 - 完整的调用链路
  - 性能分析 - 找出性能瓶颈
  - 根因分析 - 快速定位问题
  - 服务依赖 - 可视化服务关系
  - 采样策略 - 灵活的采样配置
  - 多种存储 - 支持多种后端
  - OpenTracing - 兼容标准

📊 使用统计:
  - GitHub Stars: 20,000+
  - 生产使用: 数千家公司
  - CNCF: 毕业项目
  - Uber 内部: 日均 10 亿+ span
```

### 1.2 与其他追踪系统对比

```text
┌──────────────┬─────────┬──────────┬──────────┬────────────┐
│   系统       │  性能   │ 功能     │ 易用性   │ 推荐指数   │
├──────────────┼─────────┼──────────┼──────────┼────────────┤
│ Jaeger       │  ⭐⭐⭐⭐⭐ │ ⭐⭐⭐⭐⭐  │ ⭐⭐⭐⭐⭐  │  ⭐⭐⭐⭐⭐  │
│ Zipkin       │  ⭐⭐⭐⭐  │ ⭐⭐⭐⭐   │ ⭐⭐⭐⭐   │  ⭐⭐⭐⭐   │
│ SkyWalking   │  ⭐⭐⭐⭐  │ ⭐⭐⭐⭐⭐  │ ⭐⭐⭐⭐   │  ⭐⭐⭐⭐⭐  │
│ Datadog APM  │  ⭐⭐⭐⭐⭐ │ ⭐⭐⭐⭐⭐  │ ⭐⭐⭐⭐⭐  │  ⭐⭐⭐⭐⭐  │
│ AWS X-Ray    │  ⭐⭐⭐⭐  │ ⭐⭐⭐⭐   │ ⭐⭐⭐⭐⭐  │  ⭐⭐⭐⭐   │
└──────────────┴─────────┴──────────┴──────────┴────────────┘

特点:
  - Jaeger: CNCF 标准，功能完整
  - Zipkin: 老牌，Twitter 开源
  - SkyWalking: APM 全家桶，中文友好
  - Datadog APM: 商业方案，功能最强
```

### 1.3 核心概念

```text
Trace (追踪)
  └─ Span (跨度)
      ├─ Operation Name (操作名)
      ├─ Start Time (开始时间)
      ├─ Duration (持续时间)
      ├─ Tags (标签)
      │   ├─ http.method: GET
      │   ├─ http.url: /api/users
      │   └─ http.status_code: 200
      ├─ Logs (日志)
      │   └─ event: error, message: "connection timeout"
      └─ SpanContext (上下文)
          ├─ TraceID (追踪ID)
          ├─ SpanID (跨度ID)
          └─ ParentSpanID (父跨度ID)

示例调用链:
┌────────────────────────────────────────────────────┐
│                   Trace (总耗时 250ms)              │
├────────────────────────────────────────────────────┤
│ ┌─ API Gateway (200ms) ─────────────────────────┐ │
│ │  ┌─ Auth Service (20ms) ───┐                  │ │
│ │  └──────────────────────────┘                  │ │
│ │  ┌─ Order Service (150ms) ─────────────────┐  │ │
│ │  │  ┌─ DB Query (50ms) ──┐                 │  │ │
│ │  │  └────────────────────┘                 │  │ │
│ │  │  ┌─ Cache Get (5ms) ─┐                  │  │ │
│ │  │  └───────────────────┘                  │  │ │
│ │  │  ┌─ Payment API (80ms) ───────────────┐ │  │ │
│ │  │  └─────────────────────────────────────┘ │  │ │
│ │  └──────────────────────────────────────────┘  │ │
│ └────────────────────────────────────────────────┘ │
└────────────────────────────────────────────────────┘
```

---

## 2. 快速开始

### 2.1 Docker 部署 Jaeger

```bash
# All-in-One 模式（开发环境）
docker run -d --name jaeger \
  -e COLLECTOR_OTLP_ENABLED=true \
  -p 6831:6831/udp \
  -p 6832:6832/udp \
  -p 5778:5778 \
  -p 16686:16686 \
  -p 4317:4317 \
  -p 4318:4318 \
  -p 14250:14250 \
  -p 14268:14268 \
  -p 14269:14269 \
  -p 9411:9411 \
  jaegertracing/all-in-one:1.52

# 访问 UI: http://localhost:16686
# OTLP gRPC: localhost:4317
# OTLP HTTP: localhost:4318
```

### 2.2 生产环境部署

```yaml
# docker-compose.yml
version: '3'
services:
  jaeger-collector:
    image: jaegertracing/jaeger-collector:1.52
    ports:
      - "14268:14268"
      - "14250:14250"
      - "4317:4317"
      - "4318:4318"
    environment:
      - SPAN_STORAGE_TYPE=elasticsearch
      - ES_SERVER_URLS=http://elasticsearch:9200
    depends_on:
      - elasticsearch

  jaeger-query:
    image: jaegertracing/jaeger-query:1.52
    ports:
      - "16686:16686"
    environment:
      - SPAN_STORAGE_TYPE=elasticsearch
      - ES_SERVER_URLS=http://elasticsearch:9200
    depends_on:
      - elasticsearch

  elasticsearch:
    image: elasticsearch:8.11.0
    environment:
      - discovery.type=single-node
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    ports:
      - "9200:9200"
```

### 2.3 Go 依赖安装

```bash
# OpenTelemetry Go SDK
go get go.opentelemetry.io/otel@v1.32.0
go get go.opentelemetry.io/otel/sdk@v1.32.0
go get go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc@v1.32.0
go get go.opentelemetry.io/otel/exporters/jaeger@v1.32.0
```

---

## 3. OTLP 完整集成

### 3.1 使用 OTLP Exporter（推荐）

```go
package main

import (
    "context"
    "log"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/sdk/resource"
    "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
)

func initJaeger() (*trace.TracerProvider, error) {
    ctx := context.Background()
    
    // 创建 OTLP Trace Exporter
    exporter, err := otlptracegrpc.New(ctx,
        otlptracegrpc.WithEndpoint("localhost:4317"),
        otlptracegrpc.WithInsecure(),
        otlptracegrpc.WithDialOption(grpc.WithBlock()),
        otlptracegrpc.WithTimeout(5*time.Second),
    )
    if err != nil {
        return nil, err
    }
    
    // 创建 Resource
    res, err := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName("my-service"),
            semconv.ServiceVersion("1.0.0"),
            semconv.DeploymentEnvironment("production"),
            semconv.ServiceInstanceID("instance-1"),
        ),
        resource.WithProcessRuntimeDescription(),
        resource.WithHost(),
    )
    if err != nil {
        return nil, err
    }
    
    // 创建 TracerProvider
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter,
            trace.WithBatchTimeout(5*time.Second),
            trace.WithMaxExportBatchSize(512),
            trace.WithMaxQueueSize(2048),
        ),
        trace.WithResource(res),
        trace.WithSampler(trace.ParentBased(trace.TraceIDRatioBased(1.0))), // 100% 采样
    )
    
    // 设置全局 TracerProvider
    otel.SetTracerProvider(tp)
    
    // 设置全局 Propagator
    otel.SetTextMapPropagator(
        propagation.NewCompositeTextMapPropagator(
            propagation.TraceContext{},
            propagation.Baggage{},
        ),
    )
    
    return tp, nil
}

func main() {
    ctx := context.Background()
    
    // 初始化 Jaeger
    tp, err := initJaeger()
    if err != nil {
        log.Fatal(err)
    }
    defer func() {
        if err := tp.Shutdown(ctx); err != nil {
            log.Printf("Error shutting down tracer provider: %v", err)
        }
    }()
    
    // 创建 Tracer
    tracer := otel.Tracer("my-service")
    
    // 创建 Span
    ctx, span := tracer.Start(ctx, "main-operation")
    defer span.End()
    
    // 业务逻辑
    doSomething(ctx)
    
    log.Println("Trace sent to Jaeger")
}

func doSomething(ctx context.Context) {
    tracer := otel.Tracer("my-service")
    ctx, span := tracer.Start(ctx, "do-something")
    defer span.End()
    
    // 添加标签
    span.SetAttributes(
        attribute.String("component", "business-logic"),
        attribute.Int("iteration", 1),
    )
    
    // 添加事件
    span.AddEvent("processing started")
    
    time.Sleep(100 * time.Millisecond)
    
    span.AddEvent("processing completed")
}
```

### 3.2 使用 Jaeger Exporter

```go
package main

import (
    "context"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/jaeger"
    "go.opentelemetry.io/otel/sdk/resource"
    "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

func initJaegerLegacy() (*trace.TracerProvider, error) {
    // 创建 Jaeger Exporter
    exporter, err := jaeger.New(
        jaeger.WithCollectorEndpoint(
            jaeger.WithEndpoint("http://localhost:14268/api/traces"),
        ),
    )
    if err != nil {
        return nil, err
    }
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
        trace.WithResource(resource.NewWithAttributes(
            semconv.SchemaURL,
            semconv.ServiceName("my-service"),
        )),
    )
    
    otel.SetTracerProvider(tp)
    
    return tp, nil
}
```

---

## 4. 高级特性

### 4.1 采样策略

```go
// 1. Always Sample - 100% 采样
alwaysSampler := trace.AlwaysSample()

// 2. Never Sample - 0% 采样
neverSampler := trace.NeverSample()

// 3. TraceID Ratio - 基于 TraceID 的比例采样
ratioSampler := trace.TraceIDRatioBased(0.1) // 10% 采样

// 4. Parent Based - 基于父 Span 的采样
parentBasedSampler := trace.ParentBased(
    trace.TraceIDRatioBased(0.1),
)

// 5. 自定义采样器
type CustomSampler struct{}

func (cs CustomSampler) ShouldSample(p trace.SamplingParameters) trace.SamplingResult {
    // 根据业务逻辑决定是否采样
    if strings.Contains(p.Name, "health") {
        return trace.SamplingResult{
            Decision: trace.Drop,
        }
    }
    
    // 错误请求总是采样
    for _, attr := range p.Attributes {
        if attr.Key == "error" && attr.Value.AsBool() {
            return trace.SamplingResult{
                Decision: trace.RecordAndSample,
            }
        }
    }
    
    // 其他情况 10% 采样
    return trace.TraceIDRatioBased(0.1).ShouldSample(p)
}

func (cs CustomSampler) Description() string {
    return "CustomSampler"
}

// 使用自定义采样器
tp := trace.NewTracerProvider(
    trace.WithSampler(CustomSampler{}),
)
```

### 4.2 Span 生命周期

```go
func CompleteSpanExample(ctx context.Context) {
    tracer := otel.Tracer("my-service")
    
    // 1. 创建 Span
    ctx, span := tracer.Start(ctx, "operation",
        trace.WithSpanKind(trace.SpanKindServer),
        trace.WithAttributes(
            attribute.String("component", "api"),
            attribute.String("http.method", "GET"),
        ),
    )
    defer span.End()
    
    // 2. 添加更多属性
    span.SetAttributes(
        attribute.String("user.id", "123"),
        attribute.Int("retry.count", 0),
    )
    
    // 3. 记录事件
    span.AddEvent("validation started")
    
    // 4. 子 Span
    childCtx, childSpan := tracer.Start(ctx, "database-query",
        trace.WithSpanKind(trace.SpanKindClient),
    )
    
    // 模拟数据库查询
    time.Sleep(50 * time.Millisecond)
    
    childSpan.SetAttributes(
        attribute.String("db.system", "postgresql"),
        attribute.String("db.statement", "SELECT * FROM users"),
    )
    childSpan.End()
    
    // 5. 记录错误
    if err := someOperation(); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return
    }
    
    // 6. 成功完成
    span.SetStatus(codes.Ok, "operation completed successfully")
    span.AddEvent("operation completed")
}
```

### 4.3 Context 传播

```go
// HTTP Client
func HTTPClientWithTracing(ctx context.Context, url string) error {
    tracer := otel.Tracer("http-client")
    ctx, span := tracer.Start(ctx, "http-request",
        trace.WithSpanKind(trace.SpanKindClient),
    )
    defer span.End()
    
    req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
    
    // 注入 trace context 到 HTTP 请求头
    otel.GetTextMapPropagator().Inject(ctx, propagation.HeaderCarrier(req.Header))
    
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        span.RecordError(err)
        return err
    }
    defer resp.Body.Close()
    
    span.SetAttributes(
        attribute.Int("http.status_code", resp.StatusCode),
    )
    
    return nil
}

// HTTP Server
func HTTPServerWithTracing(w http.ResponseWriter, r *http.Request) {
    tracer := otel.Tracer("http-server")
    
    // 提取 trace context 从 HTTP 请求头
    ctx := otel.GetTextMapPropagator().Extract(r.Context(), propagation.HeaderCarrier(r.Header))
    
    ctx, span := tracer.Start(ctx, "handle-request",
        trace.WithSpanKind(trace.SpanKindServer),
    )
    defer span.End()
    
    // 处理请求
    result := processRequest(ctx)
    
    w.Write([]byte(result))
}

// gRPC Client
func GRPCClientWithTracing(ctx context.Context) {
    // gRPC 自动支持 OTLP，只需确保 context 传递
    conn, _ := grpc.Dial("localhost:50051",
        grpc.WithInsecure(),
        grpc.WithUnaryInterceptor(otelgrpc.UnaryClientInterceptor()),
    )
    
    client := pb.NewGreeterClient(conn)
    resp, err := client.SayHello(ctx, &pb.HelloRequest{Name: "World"})
    // trace context 会自动传播
}
```

---

## 5. 完整示例

### 5.1 微服务追踪示例

```go
package main

import (
    "context"
    "encoding/json"
    "log"
    "net/http"
    "time"
    
    "github.com/gorilla/mux"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
)

type OrderService struct {
    tracer trace.Tracer
}

func NewOrderService() *OrderService {
    return &OrderService{
        tracer: otel.Tracer("order-service"),
    }
}

// CreateOrder 创建订单（带完整追踪）
func (s *OrderService) CreateOrder(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    ctx, span := s.tracer.Start(ctx, "create-order",
        trace.WithSpanKind(trace.SpanKindServer),
    )
    defer span.End()
    
    // 1. 解析请求
    var req struct {
        UserID    string  `json:"user_id"`
        ProductID string  `json:"product_id"`
        Amount    float64 `json:"amount"`
    }
    
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "invalid request")
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    span.SetAttributes(
        attribute.String("user.id", req.UserID),
        attribute.String("product.id", req.ProductID),
        attribute.Float64("order.amount", req.Amount),
    )
    
    // 2. 验证库存
    if err := s.checkInventory(ctx, req.ProductID); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "inventory check failed")
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    // 3. 处理支付
    paymentID, err := s.processPayment(ctx, req.UserID, req.Amount)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "payment failed")
        http.Error(w, err.Error(), http.StatusPaymentRequired)
        return
    }
    
    span.SetAttributes(attribute.String("payment.id", paymentID))
    
    // 4. 创建订单记录
    orderID, err := s.createOrderRecord(ctx, req)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "order creation failed")
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    span.SetAttributes(attribute.String("order.id", orderID))
    span.SetStatus(codes.Ok, "order created successfully")
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(map[string]string{
        "order_id":   orderID,
        "payment_id": paymentID,
        "status":     "success",
    })
}

// checkInventory 检查库存
func (s *OrderService) checkInventory(ctx context.Context, productID string) error {
    ctx, span := s.tracer.Start(ctx, "check-inventory")
    defer span.End()
    
    span.SetAttributes(attribute.String("product.id", productID))
    
    // 模拟 HTTP 调用库存服务
    req, _ := http.NewRequestWithContext(ctx, "GET",
        "http://inventory-service/api/check/"+productID, nil)
    
    client := &http.Client{
        Transport: otelhttp.NewTransport(http.DefaultTransport),
    }
    
    resp, err := client.Do(req)
    if err != nil {
        span.RecordError(err)
        return err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        err := fmt.Errorf("inventory check failed: %d", resp.StatusCode)
        span.RecordError(err)
        return err
    }
    
    span.SetStatus(codes.Ok, "inventory available")
    return nil
}

// processPayment 处理支付
func (s *OrderService) processPayment(ctx context.Context, userID string, amount float64) (string, error) {
    ctx, span := s.tracer.Start(ctx, "process-payment")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("user.id", userID),
        attribute.Float64("payment.amount", amount),
    )
    
    // 模拟支付处理
    time.Sleep(150 * time.Millisecond)
    
    paymentID := fmt.Sprintf("pay_%d", time.Now().Unix())
    
    span.SetAttributes(attribute.String("payment.id", paymentID))
    span.SetStatus(codes.Ok, "payment processed")
    
    return paymentID, nil
}

// createOrderRecord 创建订单记录
func (s *OrderService) createOrderRecord(ctx context.Context, req struct {
    UserID    string
    ProductID string
    Amount    float64
}) (string, error) {
    ctx, span := s.tracer.Start(ctx, "create-order-record",
        trace.WithSpanKind(trace.SpanKindClient),
    )
    defer span.End()
    
    span.SetAttributes(
        attribute.String("db.system", "postgresql"),
        attribute.String("db.operation", "INSERT"),
    )
    
    // 模拟数据库写入
    time.Sleep(50 * time.Millisecond)
    
    orderID := fmt.Sprintf("order_%d", time.Now().Unix())
    
    span.SetAttributes(attribute.String("order.id", orderID))
    span.SetStatus(codes.Ok, "order record created")
    
    return orderID, nil
}

func main() {
    ctx := context.Background()
    
    // 初始化 Jaeger
    tp, err := initJaeger()
    if err != nil {
        log.Fatal(err)
    }
    defer tp.Shutdown(ctx)
    
    // 创建服务
    orderService := NewOrderService()
    
    // 创建路由
    r := mux.NewRouter()
    
    // 应用 OTLP 中间件
    r.Use(func(next http.Handler) http.Handler {
        return otelhttp.NewHandler(next, "http-server")
    })
    
    // 注册路由
    r.HandleFunc("/api/orders", orderService.CreateOrder).Methods("POST")
    
    log.Println("Starting order service on :8080")
    http.ListenAndServe(":8080", r)
}
```

---

## 6. 性能优化

### 6.1 批量导出配置

```go
tp := trace.NewTracerProvider(
    trace.WithBatcher(exporter,
        trace.WithBatchTimeout(5*time.Second),      // 批量超时
        trace.WithMaxExportBatchSize(512),          // 最大批量大小
        trace.WithMaxQueueSize(2048),               // 最大队列大小
        trace.WithExportTimeout(30*time.Second),    // 导出超时
    ),
)
```

### 6.2 采样优化

```go
// 根据环境使用不同采样率
func getSampler(env string) trace.Sampler {
    switch env {
    case "production":
        return trace.ParentBased(trace.TraceIDRatioBased(0.1)) // 10%
    case "staging":
        return trace.ParentBased(trace.TraceIDRatioBased(0.5)) // 50%
    default:
        return trace.AlwaysSample() // 100%
    }
}
```

---

## 7. 最佳实践

### 7.1 Span 命名规范

```go
// ✅ 好的命名
goodNames := []string{
    "GET /api/users",
    "database.query",
    "cache.get",
    "payment.process",
    "email.send",
}

// ❌ 不好的命名
badNames := []string{
    "function1",           // 不描述性
    "GET /api/users/123",  // 包含变量
    "very long operation name that is too descriptive", // 太长
}
```

### 7.2 标签使用规范

```go
// ✅ 推荐的标签
span.SetAttributes(
    semconv.HTTPMethodKey.String("GET"),
    semconv.HTTPStatusCodeKey.Int(200),
    semconv.DBSystemKey.String("postgresql"),
    attribute.String("user.id", userID),
)

// ❌ 避免高基数标签
span.SetAttributes(
    attribute.String("request.id", requestID),  // 每个请求都不同
    attribute.String("timestamp", time.Now().String()), // 高基数
)
```

---

## 8. 总结

### 8.1 优势与劣势

```text
✅ 优势:
  - CNCF 标准
  - 性能优秀
  - UI 友好
  - 多种存储后端
  - 社区活跃

❌ 劣势:
  - 部署相对复杂
  - 需要额外存储
```

**相关文档**:

- [01_Prometheus高级集成与OTLP完整集成_2025版.md](./01_Prometheus高级集成与OTLP完整集成_2025版.md)
- [03_Zipkin分布式追踪集成_2025版.md](./03_Zipkin分布式追踪集成_2025版.md)

---

**更新日期**: 2025-10-11  
**Jaeger 版本**: v1.52+  
**性能级别**: ⭐⭐⭐⭐⭐  
**推荐指数**: ⭐⭐⭐⭐⭐
