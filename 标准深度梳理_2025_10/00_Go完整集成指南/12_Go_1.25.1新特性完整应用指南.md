# Go 1.25.1 æ–°ç‰¹æ€§å®Œæ•´åº”ç”¨æŒ‡å—

> **Go ç‰ˆæœ¬**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0+  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ8æ—¥

---

## ğŸ“‹ ç›®å½•

- [Go 1.25.1 æ–°ç‰¹æ€§å®Œæ•´åº”ç”¨æŒ‡å—](#go-1251-æ–°ç‰¹æ€§å®Œæ•´åº”ç”¨æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
  - [1. æ³›å‹å¢å¼ºä¸ç±»å‹å®‰å…¨è¿½è¸ª](#1-æ³›å‹å¢å¼ºä¸ç±»å‹å®‰å…¨è¿½è¸ª)
    - [1.1 æ³›å‹ Tracer åŒ…è£…å™¨](#11-æ³›å‹-tracer-åŒ…è£…å™¨)
    - [1.2 ç±»å‹å®‰å…¨çš„ Span å±æ€§](#12-ç±»å‹å®‰å…¨çš„-span-å±æ€§)
    - [1.3 æ³›å‹ Metrics æ”¶é›†å™¨](#13-æ³›å‹-metrics-æ”¶é›†å™¨)
    - [1.4 æ³›å‹æ‰¹å¤„ç†ç®¡é“](#14-æ³›å‹æ‰¹å¤„ç†ç®¡é“)
  - [2. å¢å¼ºå‹æ³›å‹çº¦æŸ](#2-å¢å¼ºå‹æ³›å‹çº¦æŸ)
    - [2.1 ç»“æ„åŒ–æ—¥å¿—æ³›å‹å®ç°](#21-ç»“æ„åŒ–æ—¥å¿—æ³›å‹å®ç°)
    - [2.2 æ³›å‹é‡‡æ ·å™¨](#22-æ³›å‹é‡‡æ ·å™¨)
  - [3. Context å¢å¼ºç‰¹æ€§](#3-context-å¢å¼ºç‰¹æ€§)
    - [3.1 WithoutCancel - åˆ†ç¦»åå°ä»»åŠ¡](#31-withoutcancel---åˆ†ç¦»åå°ä»»åŠ¡)
    - [3.2 WithDeadlineCause - å¸¦åŸå› çš„è¶…æ—¶](#32-withdeadlinecause---å¸¦åŸå› çš„è¶…æ—¶)
    - [3.3 Context.Cause - è·å–å–æ¶ˆåŸå› ](#33-contextcause---è·å–å–æ¶ˆåŸå› )
  - [4. å¹¶å‘åŸè¯­å¢å¼º](#4-å¹¶å‘åŸè¯­å¢å¼º)
    - [4.1 sync.OnceFunc - å•æ¬¡å‡½æ•°æ‰§è¡Œ](#41-synconcefunc---å•æ¬¡å‡½æ•°æ‰§è¡Œ)
    - [4.2 sync.OnceValue - å•æ¬¡å€¼åˆå§‹åŒ–](#42-synconcevalue---å•æ¬¡å€¼åˆå§‹åŒ–)
    - [4.3 sync.OnceValues - å•æ¬¡å¤šå€¼åˆå§‹åŒ–](#43-synconcevalues---å•æ¬¡å¤šå€¼åˆå§‹åŒ–)
  - [5. é”™è¯¯å¤„ç†å¢å¼º](#5-é”™è¯¯å¤„ç†å¢å¼º)
    - [5.1 errors.Join - å¤šé”™è¯¯åˆå¹¶](#51-errorsjoin---å¤šé”™è¯¯åˆå¹¶)
    - [5.2 åŒ…è£…é”™è¯¯é“¾è¿½è¸ª](#52-åŒ…è£…é”™è¯¯é“¾è¿½è¸ª)
  - [6. Profile-Guided Optimization (PGO)](#6-profile-guided-optimization-pgo)
    - [6.1 PGO åŸºç¡€é…ç½®](#61-pgo-åŸºç¡€é…ç½®)
    - [6.2 ç”Ÿæˆ PGO Profile](#62-ç”Ÿæˆ-pgo-profile)
    - [6.3 ä½¿ç”¨ PGO ç¼–è¯‘](#63-ä½¿ç”¨-pgo-ç¼–è¯‘)
    - [6.4 PGO æœ€ä½³å®è·µ](#64-pgo-æœ€ä½³å®è·µ)
  - [7. æ ‡å‡†åº“å¢å¼º](#7-æ ‡å‡†åº“å¢å¼º)
    - [7.1 log/slog ç»“æ„åŒ–æ—¥å¿—](#71-logslog-ç»“æ„åŒ–æ—¥å¿—)
    - [7.2 net/http.ServeMux è·¯ç”±å¢å¼º](#72-nethttpservemux-è·¯ç”±å¢å¼º)
    - [7.3 slices å’Œ maps å·¥å…·åŒ…](#73-slices-å’Œ-maps-å·¥å…·åŒ…)
  - [8. å®Œæ•´ç”Ÿäº§çº§ç¤ºä¾‹](#8-å®Œæ•´ç”Ÿäº§çº§ç¤ºä¾‹)
    - [8.1 ä½¿ç”¨æ‰€æœ‰æ–°ç‰¹æ€§çš„å¾®æœåŠ¡](#81-ä½¿ç”¨æ‰€æœ‰æ–°ç‰¹æ€§çš„å¾®æœåŠ¡)
  - [9. æ€§èƒ½å¯¹æ¯”](#9-æ€§èƒ½å¯¹æ¯”)
    - [9.1 æ³›å‹ vs æ¥å£æ€§èƒ½](#91-æ³›å‹-vs-æ¥å£æ€§èƒ½)
    - [9.2 PGO ä¼˜åŒ–æ•ˆæœ](#92-pgo-ä¼˜åŒ–æ•ˆæœ)
  - [10. æœ€ä½³å®è·µæ€»ç»“](#10-æœ€ä½³å®è·µæ€»ç»“)
  - [å‚è€ƒèµ„æ–™](#å‚è€ƒèµ„æ–™)

---

## æ¦‚è¿°

Go 1.25.1 å¸¦æ¥äº†å¤šé¡¹é‡è¦çš„è¯­è¨€å’Œæ ‡å‡†åº“å¢å¼ºï¼Œè¿™äº›ç‰¹æ€§æå¤§æå‡äº†ä¸ OpenTelemetry OTLP é›†æˆçš„å¼€å‘ä½“éªŒå’Œè¿è¡Œæ—¶æ€§èƒ½ã€‚
æœ¬æŒ‡å—æ·±å…¥æ¢è®¨å¦‚ä½•å……åˆ†åˆ©ç”¨è¿™äº›æ–°ç‰¹æ€§ã€‚

**æ ¸å¿ƒæ”¹è¿›**:

```text
âœ… æ³›å‹å¢å¼º - æ›´å¼ºå¤§çš„ç±»å‹çº¦æŸå’Œæ¨å¯¼
âœ… Context å¢å¼º - WithoutCancel, WithDeadlineCause, Cause
âœ… å¹¶å‘åŸè¯­ - sync.OnceFunc, sync.OnceValue, sync.OnceValues
âœ… é”™è¯¯å¤„ç† - errors.Join å¤šé”™è¯¯åˆå¹¶
âœ… PGO - Profile-Guided Optimization æ€§èƒ½ä¼˜åŒ–
âœ… æ ‡å‡†åº“ - log/slog, enhanced ServeMux, slices/maps
```

---

## 1. æ³›å‹å¢å¼ºä¸ç±»å‹å®‰å…¨è¿½è¸ª

### 1.1 æ³›å‹ Tracer åŒ…è£…å™¨

```go
package observability

import (
    "context"
    "fmt"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// Traceable å®šä¹‰å¯è¿½è¸ªçš„ç±»å‹çº¦æŸ
type Traceable interface {
    GetSpanName() string
    GetTraceAttributes() []attribute.KeyValue
}

// TracedOperation æ³›å‹è¿½è¸ªæ“ä½œåŒ…è£…å™¨
func TracedOperation[T Traceable](
    ctx context.Context,
    operation T,
    fn func(context.Context, T) error,
) error {
    tracer := otel.Tracer("generic-operations")
    ctx, span := tracer.Start(ctx, operation.GetSpanName(),
        trace.WithAttributes(operation.GetTraceAttributes()...),
    )
    defer span.End()

    err := fn(ctx, operation)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }

    span.SetStatus(codes.Ok, "success")
    return nil
}

// ç¤ºä¾‹ï¼šæ•°æ®åº“æ“ä½œ
type DBQuery struct {
    Table     string
    Operation string
    Query     string
}

func (q DBQuery) GetSpanName() string {
    return fmt.Sprintf("db.%s.%s", q.Table, q.Operation)
}

func (q DBQuery) GetTraceAttributes() []attribute.KeyValue {
    return []attribute.KeyValue{
        attribute.String("db.system", "postgresql"),
        attribute.String("db.table", q.Table),
        attribute.String("db.operation", q.Operation),
        attribute.String("db.statement", q.Query),
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleTracedDBQuery(ctx context.Context) error {
    query := DBQuery{
        Table:     "users",
        Operation: "SELECT",
        Query:     "SELECT * FROM users WHERE id = $1",
    }

    return TracedOperation(ctx, query, func(ctx context.Context, q DBQuery) error {
        // æ‰§è¡Œæ•°æ®åº“æŸ¥è¯¢
        return executeQuery(ctx, q.Query)
    })
}

// HTTP è¯·æ±‚ç¤ºä¾‹
type HTTPRequest struct {
    Method string
    URL    string
    Host   string
}

func (r HTTPRequest) GetSpanName() string {
    return fmt.Sprintf("http.%s", r.Method)
}

func (r HTTPRequest) GetTraceAttributes() []attribute.KeyValue {
    return []attribute.KeyValue{
        attribute.String("http.method", r.Method),
        attribute.String("http.url", r.URL),
        attribute.String("http.host", r.Host),
    }
}
```

### 1.2 ç±»å‹å®‰å…¨çš„ Span å±æ€§

```go
package observability

import (
    "go.opentelemetry.io/otel/attribute"
)

// AttributeBuilder æ³›å‹å±æ€§æ„å»ºå™¨
type AttributeBuilder[T any] struct {
    key string
}

func NewAttributeBuilder[T any](key string) AttributeBuilder[T] {
    return AttributeBuilder[T]{key: key}
}

func (ab AttributeBuilder[T]) Build(value T) attribute.KeyValue {
    switch v := any(value).(type) {
    case string:
        return attribute.String(ab.key, v)
    case int:
        return attribute.Int(ab.key, v)
    case int64:
        return attribute.Int64(ab.key, v)
    case float64:
        return attribute.Float64(ab.key, v)
    case bool:
        return attribute.Bool(ab.key, v)
    default:
        return attribute.String(ab.key, fmt.Sprintf("%v", v))
    }
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šç±»å‹å®‰å…¨çš„å±æ€§
var (
    UserIDAttr     = NewAttributeBuilder[int64]("user.id")
    UserNameAttr   = NewAttributeBuilder[string]("user.name")
    UserActiveAttr = NewAttributeBuilder[bool]("user.active")
    RequestSizeAttr = NewAttributeBuilder[int64]("request.size")
)

func AddUserAttributes(span trace.Span, userID int64, userName string, active bool) {
    span.SetAttributes(
        UserIDAttr.Build(userID),
        UserNameAttr.Build(userName),
        UserActiveAttr.Build(active),
    )
}
```

### 1.3 æ³›å‹ Metrics æ”¶é›†å™¨

```go
package observability

import (
    "context"
    "sync"

    "go.opentelemetry.io/otel/metric"
)

// GenericCounter æ³›å‹è®¡æ•°å™¨
type GenericCounter[T ~int | ~int64 | ~float64] struct {
    counter metric.Int64Counter
    mu      sync.Mutex
}

func NewGenericCounter[T ~int | ~int64 | ~float64](
    meter metric.Meter,
    name string,
    opts ...metric.Int64CounterOption,
) (*GenericCounter[T], error) {
    counter, err := meter.Int64Counter(name, opts...)
    if err != nil {
        return nil, err
    }

    return &GenericCounter[T]{
        counter: counter,
    }, nil
}

func (gc *GenericCounter[T]) Add(ctx context.Context, value T, attrs ...attribute.KeyValue) {
    gc.counter.Add(ctx, int64(value), metric.WithAttributes(attrs...))
}

// GenericHistogram æ³›å‹ç›´æ–¹å›¾
type GenericHistogram[T ~int | ~int64 | ~float64] struct {
    histogram metric.Float64Histogram
    mu        sync.Mutex
}

func NewGenericHistogram[T ~int | ~int64 | ~float64](
    meter metric.Meter,
    name string,
    opts ...metric.Float64HistogramOption,
) (*GenericHistogram[T], error) {
    histogram, err := meter.Float64Histogram(name, opts...)
    if err != nil {
        return nil, err
    }

    return &GenericHistogram[T]{
        histogram: histogram,
    }, nil
}

func (gh *GenericHistogram[T]) Record(ctx context.Context, value T, attrs ...attribute.KeyValue) {
    gh.histogram.Record(ctx, float64(value), metric.WithAttributes(attrs...))
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleGenericMetrics(ctx context.Context) error {
    meter := otel.Meter("generic-metrics")

    // åˆ›å»ºæ³›å‹è®¡æ•°å™¨
    requestCounter, err := NewGenericCounter[int64](
        meter,
        "http.requests.total",
        metric.WithDescription("Total HTTP requests"),
    )
    if err != nil {
        return err
    }

    // åˆ›å»ºæ³›å‹ç›´æ–¹å›¾
    latencyHistogram, err := NewGenericHistogram[float64](
        meter,
        "http.request.duration",
        metric.WithDescription("HTTP request duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return err
    }

    // ä½¿ç”¨
    requestCounter.Add(ctx, 1, attribute.String("method", "GET"))
    latencyHistogram.Record(ctx, 123.45, attribute.String("method", "GET"))

    return nil
}
```

### 1.4 æ³›å‹æ‰¹å¤„ç†ç®¡é“

```go
package observability

import (
    "context"
    "time"

    "go.opentelemetry.io/otel/trace"
)

// BatchProcessor æ³›å‹æ‰¹å¤„ç†å™¨
type BatchProcessor[T any] struct {
    batchSize     int
    flushInterval time.Duration
    buffer        []T
    processor     func(context.Context, []T) error
    ch            chan T
    done          chan struct{}
}

func NewBatchProcessor[T any](
    batchSize int,
    flushInterval time.Duration,
    processor func(context.Context, []T) error,
) *BatchProcessor[T] {
    bp := &BatchProcessor[T]{
        batchSize:     batchSize,
        flushInterval: flushInterval,
        buffer:        make([]T, 0, batchSize),
        processor:     processor,
        ch:            make(chan T, batchSize*2),
        done:          make(chan struct{}),
    }

    go bp.run()
    return bp
}

func (bp *BatchProcessor[T]) Add(ctx context.Context, item T) error {
    select {
    case bp.ch <- item:
        return nil
    case <-ctx.Done():
        return ctx.Err()
    }
}

func (bp *BatchProcessor[T]) run() {
    ticker := time.NewTicker(bp.flushInterval)
    defer ticker.Stop()

    for {
        select {
        case item := <-bp.ch:
            bp.buffer = append(bp.buffer, item)
            if len(bp.buffer) >= bp.batchSize {
                bp.flush()
            }

        case <-ticker.C:
            if len(bp.buffer) > 0 {
                bp.flush()
            }

        case <-bp.done:
            if len(bp.buffer) > 0 {
                bp.flush()
            }
            return
        }
    }
}

func (bp *BatchProcessor[T]) flush() {
    if len(bp.buffer) == 0 {
        return
    }

    batch := make([]T, len(bp.buffer))
    copy(batch, bp.buffer)
    bp.buffer = bp.buffer[:0]

    ctx := context.Background()
    _ = bp.processor(ctx, batch)
}

func (bp *BatchProcessor[T]) Shutdown(ctx context.Context) error {
    close(bp.done)
    return nil
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šæ‰¹é‡å¯¼å‡º Spans
type SpanData struct {
    TraceID string
    SpanID  string
    Name    string
}

func ExampleBatchProcessor(ctx context.Context) {
    processor := NewBatchProcessor[SpanData](
        100,                  // æ‰¹æ¬¡å¤§å°
        5*time.Second,       // åˆ·æ–°é—´éš”
        func(ctx context.Context, batch []SpanData) error {
            // æ‰¹é‡å¯¼å‡ºåˆ°åç«¯
            return exportSpans(ctx, batch)
        },
    )
    defer processor.Shutdown(ctx)

    // æ·»åŠ  span æ•°æ®
    span := SpanData{
        TraceID: "trace-123",
        SpanID:  "span-456",
        Name:    "operation",
    }
    _ = processor.Add(ctx, span)
}

func exportSpans(ctx context.Context, spans []SpanData) error {
    // å®ç°æ‰¹é‡å¯¼å‡ºé€»è¾‘
    return nil
}

func executeQuery(ctx context.Context, query string) error {
    // æ¨¡æ‹Ÿå®ç°
    return nil
}
```

---

## 2. å¢å¼ºå‹æ³›å‹çº¦æŸ

### 2.1 ç»“æ„åŒ–æ—¥å¿—æ³›å‹å®ç°

```go
package observability

import (
    "context"
    "log/slog"

    "go.opentelemetry.io/otel/trace"
)

// LogLevel æ—¥å¿—çº§åˆ«çº¦æŸ
type LogLevel interface {
    ~string
}

// StructuredLogger æ³›å‹ç»“æ„åŒ–æ—¥å¿—å™¨
type StructuredLogger[L LogLevel] struct {
    logger *slog.Logger
    tracer trace.Tracer
}

func NewStructuredLogger[L LogLevel](logger *slog.Logger, tracer trace.Tracer) *StructuredLogger[L] {
    return &StructuredLogger[L]{
        logger: logger,
        tracer: tracer,
    }
}

func (sl *StructuredLogger[L]) Log(
    ctx context.Context,
    level L,
    msg string,
    fields ...slog.Attr,
) {
    // æå–è¿½è¸ªä¸Šä¸‹æ–‡
    span := trace.SpanFromContext(ctx)
    if span.IsRecording() {
        spanCtx := span.SpanContext()
        fields = append(fields,
            slog.String("trace_id", spanCtx.TraceID().String()),
            slog.String("span_id", spanCtx.SpanID().String()),
        )
    }

    // è®°å½•æ—¥å¿—
    var slogLevel slog.Level
    switch string(level) {
    case "debug":
        slogLevel = slog.LevelDebug
    case "info":
        slogLevel = slog.LevelInfo
    case "warn":
        slogLevel = slog.LevelWarn
    case "error":
        slogLevel = slog.LevelError
    default:
        slogLevel = slog.LevelInfo
    }

    sl.logger.LogAttrs(ctx, slogLevel, msg, fields...)

    // åŒæ—¶è®°å½•åˆ° Span äº‹ä»¶
    if span.IsRecording() {
        span.AddEvent(msg)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
type Level string

const (
    LevelDebug Level = "debug"
    LevelInfo  Level = "info"
    LevelWarn  Level = "warn"
    LevelError Level = "error"
)

func ExampleStructuredLogger(ctx context.Context) {
    logger := slog.Default()
    tracer := otel.Tracer("app")

    structuredLogger := NewStructuredLogger[Level](logger, tracer)

    ctx, span := tracer.Start(ctx, "example-operation")
    defer span.End()

    structuredLogger.Log(ctx, LevelInfo, "Processing request",
        slog.String("user_id", "123"),
        slog.Int("items", 5),
    )
}
```

### 2.2 æ³›å‹é‡‡æ ·å™¨

```go
package observability

import (
    "go.opentelemetry.io/otel/sdk/trace"
    "go.opentelemetry.io/otel/trace"
)

// SamplingDecision é‡‡æ ·å†³ç­–ç±»å‹
type SamplingDecision interface {
    ~bool
}

// GenericSampler æ³›å‹é‡‡æ ·å™¨
type GenericSampler[D SamplingDecision, R ~float64] struct {
    rate       R
    shouldDrop func(trace.SpanContext) D
}

func NewGenericSampler[D SamplingDecision, R ~float64](
    rate R,
    shouldDrop func(trace.SpanContext) D,
) *GenericSampler[D, R] {
    return &GenericSampler[D, R]{
        rate:       rate,
        shouldDrop: shouldDrop,
    }
}

func (gs *GenericSampler[D, R]) ShouldSample(
    parameters trace.SamplingParameters,
) trace.SamplingResult {
    // æ£€æŸ¥æ˜¯å¦åº”è¯¥ä¸¢å¼ƒ
    if gs.shouldDrop(parameters.ParentContext) {
        return trace.SamplingResult{
            Decision: trace.Drop,
        }
    }

    // åŸºäºé‡‡æ ·ç‡å†³ç­–
    traceID := parameters.TraceID
    threshold := uint64(float64(^uint64(0)) * float64(gs.rate))
    
    if traceIDToUint64(traceID) < threshold {
        return trace.SamplingResult{
            Decision:   trace.RecordAndSample,
            Attributes: parameters.Attributes,
        }
    }

    return trace.SamplingResult{
        Decision: trace.Drop,
    }
}

func (gs *GenericSampler[D, R]) Description() string {
    return "GenericSampler"
}

func traceIDToUint64(traceID trace.TraceID) uint64 {
    var result uint64
    for i := 0; i < 8; i++ {
        result = result<<8 | uint64(traceID[i])
    }
    return result
}
```

---

## 3. Context å¢å¼ºç‰¹æ€§

### 3.1 WithoutCancel - åˆ†ç¦»åå°ä»»åŠ¡

```go
package observability

import (
    "context"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// AsyncTaskManager å¼‚æ­¥ä»»åŠ¡ç®¡ç†å™¨
type AsyncTaskManager struct {
    tracer trace.Tracer
}

func NewAsyncTaskManager() *AsyncTaskManager {
    return &AsyncTaskManager{
        tracer: otel.Tracer("async-tasks"),
    }
}

// LaunchBackgroundTask å¯åŠ¨åå°ä»»åŠ¡ï¼ˆä¸å—çˆ¶ context å–æ¶ˆå½±å“ï¼‰
func (atm *AsyncTaskManager) LaunchBackgroundTask(
    parentCtx context.Context,
    taskName string,
    task func(context.Context) error,
) {
    // Go 1.25.1: ä½¿ç”¨ WithoutCancel åˆ†ç¦»å–æ¶ˆä¿¡å·
    // ä½†ä¿ç•™è¿½è¸ªä¿¡æ¯
    detachedCtx := context.WithoutCancel(parentCtx)

    go func() {
        // åˆ›å»ºæ–°çš„ spanï¼Œä½¿ç”¨åˆ†ç¦»çš„ context
        ctx, span := atm.tracer.Start(detachedCtx, taskName,
            trace.WithSpanKind(trace.SpanKindInternal),
            trace.WithAttributes(
                attribute.Bool("async", true),
                attribute.Bool("detached", true),
            ),
        )
        defer span.End()

        if err := task(ctx); err != nil {
            span.RecordError(err)
        }
    }()
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šè¯·æ±‚ç»“æŸåç»§ç»­æ‰§è¡Œçš„ä»»åŠ¡
func HandleRequest(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    tracer := otel.Tracer("http-handler")

    ctx, span := tracer.Start(ctx, "handle-request")
    defer span.End()

    // å¤„ç†è¯·æ±‚
    result := processRequest(ctx)

    // å‘é€å“åº”ï¼ˆè¯·æ±‚å¯èƒ½åœ¨è¿™é‡Œç»“æŸï¼‰
    w.WriteHeader(http.StatusOK)
    w.Write([]byte(result))

    // å¯åŠ¨åå°ä»»åŠ¡ï¼šå³ä½¿å®¢æˆ·ç«¯æ–­å¼€è¿æ¥ä¹Ÿè¦æ‰§è¡Œ
    manager := NewAsyncTaskManager()
    manager.LaunchBackgroundTask(ctx, "cleanup-task", func(ctx context.Context) error {
        // è¿™ä¸ªä»»åŠ¡ä¼šç»§ç»­æ‰§è¡Œï¼Œå³ä½¿åŸå§‹è¯·æ±‚è¢«å–æ¶ˆ
        time.Sleep(5 * time.Second)
        return cleanupResources(ctx)
    })

    manager.LaunchBackgroundTask(ctx, "analytics-task", func(ctx context.Context) error {
        // è®°å½•åˆ†ææ•°æ®
        return recordAnalytics(ctx, result)
    })
}

func processRequest(ctx context.Context) string {
    return "processed"
}

func cleanupResources(ctx context.Context) error {
    return nil
}

func recordAnalytics(ctx context.Context, result string) error {
    return nil
}
```

### 3.2 WithDeadlineCause - å¸¦åŸå› çš„è¶…æ—¶

```go
package observability

import (
    "context"
    "errors"
    "fmt"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// SLAViolationError SLA è¿è§„é”™è¯¯
type SLAViolationError struct {
    Service  string
    Expected time.Duration
    Actual   time.Duration
}

func (e *SLAViolationError) Error() string {
    return fmt.Sprintf("SLA violation for %s: expected %v, actual %v",
        e.Service, e.Expected, e.Actual)
}

// ServiceClient æœåŠ¡å®¢æˆ·ç«¯ï¼ˆå¸¦ SLA ç›‘æ§ï¼‰
type ServiceClient struct {
    serviceName string
    slaTimeout  time.Duration
    tracer      trace.Tracer
}

func NewServiceClient(serviceName string, slaTimeout time.Duration) *ServiceClient {
    return &ServiceClient{
        serviceName: serviceName,
        slaTimeout:  slaTimeout,
        tracer:      otel.Tracer("service-client"),
    }
}

// CallWithSLA è°ƒç”¨æœåŠ¡ï¼ˆå¸¦ SLA ç›‘æ§ï¼‰
func (sc *ServiceClient) CallWithSLA(
    ctx context.Context,
    operation string,
    fn func(context.Context) error,
) error {
    start := time.Now()

    // Go 1.25.1: ä½¿ç”¨ WithDeadlineCause è®¾ç½®å¸¦åŸå› çš„è¶…æ—¶
    slaViolationErr := &SLAViolationError{
        Service:  sc.serviceName,
        Expected: sc.slaTimeout,
    }

    deadline := time.Now().Add(sc.slaTimeout)
    ctx, cancel := context.WithDeadlineCause(ctx, deadline, slaViolationErr)
    defer cancel()

    ctx, span := sc.tracer.Start(ctx, operation,
        trace.WithAttributes(
            attribute.String("service.name", sc.serviceName),
            attribute.Int64("sla.timeout_ms", sc.slaTimeout.Milliseconds()),
        ),
    )
    defer span.End()

    err := fn(ctx)
    duration := time.Since(start)

    // æ›´æ–°å®é™…è€—æ—¶
    slaViolationErr.Actual = duration

    if err != nil {
        // Go 1.25.1: æ£€æŸ¥æ˜¯å¦æ˜¯ SLA è¶…æ—¶
        cause := context.Cause(ctx)
        if cause != nil {
            span.SetAttributes(
                attribute.String("failure.cause", cause.Error()),
                attribute.Bool("sla.violated", true),
                attribute.Int64("duration_ms", duration.Milliseconds()),
            )
            span.SetStatus(codes.Error, "SLA violation")
        } else {
            span.RecordError(err)
            span.SetStatus(codes.Error, err.Error())
        }
        return err
    }

    // è®°å½•å®é™…è€—æ—¶
    span.SetAttributes(
        attribute.Int64("duration_ms", duration.Milliseconds()),
        attribute.Bool("sla.met", duration <= sc.slaTimeout),
    )

    return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleSLAMonitoring(ctx context.Context) error {
    client := NewServiceClient("payment-service", 2*time.Second)

    err := client.CallWithSLA(ctx, "process-payment", func(ctx context.Context) error {
        // æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
        select {
        case <-time.After(3 * time.Second):
            return errors.New("processing failed")
        case <-ctx.Done():
            // Go 1.25.1: è·å–å–æ¶ˆåŸå› 
            if cause := context.Cause(ctx); cause != nil {
                // è¿™é‡Œä¼šè¿”å› SLAViolationError
                return cause
            }
            return ctx.Err()
        }
    })

    if err != nil {
        var slaErr *SLAViolationError
        if errors.As(err, &slaErr) {
            // å¤„ç† SLA è¿è§„
            fmt.Printf("SLA violated: %v\n", slaErr)
        }
    }

    return err
}
```

### 3.3 Context.Cause - è·å–å–æ¶ˆåŸå› 

```go
package observability

import (
    "context"
    "errors"
    "fmt"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// CancellationReason å–æ¶ˆåŸå› 
type CancellationReason string

const (
    ReasonUserCancelled      CancellationReason = "user_cancelled"
    ReasonResourceExhausted  CancellationReason = "resource_exhausted"
    ReasonRateLimitExceeded  CancellationReason = "rate_limit_exceeded"
    ReasonCircuitBreakerOpen CancellationReason = "circuit_breaker_open"
)

// CancellationError è‡ªå®šä¹‰å–æ¶ˆé”™è¯¯
type CancellationError struct {
    Reason  CancellationReason
    Message string
}

func (e *CancellationError) Error() string {
    return fmt.Sprintf("cancelled: %s - %s", e.Reason, e.Message)
}

// OperationManager æ“ä½œç®¡ç†å™¨
type OperationManager struct {
    tracer trace.Tracer
}

func NewOperationManager() *OperationManager {
    return &OperationManager{
        tracer: otel.Tracer("operation-manager"),
    }
}

// ExecuteWithCancellation æ‰§è¡Œå¯å–æ¶ˆæ“ä½œ
func (om *OperationManager) ExecuteWithCancellation(
    parentCtx context.Context,
    operationName string,
    fn func(context.Context) error,
) error {
    ctx, span := om.tracer.Start(parentCtx, operationName)
    defer span.End()

    err := fn(ctx)

    // Go 1.25.1: æ£€æŸ¥å–æ¶ˆåŸå› 
    if err != nil {
        if cause := context.Cause(ctx); cause != nil {
            var cancellationErr *CancellationError
            if errors.As(cause, &cancellationErr) {
                // è®°å½•è¯¦ç»†çš„å–æ¶ˆåŸå› 
                span.SetAttributes(
                    attribute.String("cancellation.reason", string(cancellationErr.Reason)),
                    attribute.String("cancellation.message", cancellationErr.Message),
                )
                span.SetStatus(codes.Error, fmt.Sprintf("cancelled: %s", cancellationErr.Reason))
            } else {
                span.SetAttributes(
                    attribute.String("cancellation.cause", cause.Error()),
                )
                span.SetStatus(codes.Error, "cancelled")
            }
        } else {
            span.RecordError(err)
            span.SetStatus(codes.Error, err.Error())
        }
        return err
    }

    span.SetStatus(codes.Ok, "completed")
    return nil
}

// CancelWithReason å¸¦åŸå› å–æ¶ˆ
func CancelWithReason(
    parentCtx context.Context,
    reason CancellationReason,
    message string,
) (context.Context, context.CancelCauseFunc) {
    ctx, cancel := context.WithCancelCause(parentCtx)

    cancelFunc := func() {
        cancel(&CancellationError{
            Reason:  reason,
            Message: message,
        })
    }

    return ctx, cancelFunc
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleCancellationTracking(ctx context.Context) error {
    manager := NewOperationManager()

    // åˆ›å»ºå¯å–æ¶ˆçš„ context
    ctx, cancel := CancelWithReason(ctx, ReasonRateLimitExceeded, "Too many requests")

    go func() {
        // æ¨¡æ‹Ÿï¼šåœ¨æŸä¸ªæ¡ä»¶ä¸‹å–æ¶ˆæ“ä½œ
        time.After(100 * time.Millisecond)
        cancel()
    }()

    return manager.ExecuteWithCancellation(ctx, "api-call", func(ctx context.Context) error {
        select {
        case <-time.After(1 * time.Second):
            return nil
        case <-ctx.Done():
            // è¿”å› context é”™è¯¯
            return ctx.Err()
        }
    })
}
```

---

## 4. å¹¶å‘åŸè¯­å¢å¼º

### 4.1 sync.OnceFunc - å•æ¬¡å‡½æ•°æ‰§è¡Œ

```go
package observability

import (
    "context"
    "sync"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// TracerInitializer Tracer åˆå§‹åŒ–å™¨
type TracerInitializer struct {
    initFunc func()
}

func NewTracerInitializer(endpoint string) *TracerInitializer {
    // Go 1.25.1: ä½¿ç”¨ sync.OnceFunc ç¡®ä¿åˆå§‹åŒ–åªæ‰§è¡Œä¸€æ¬¡
    initFunc := sync.OnceFunc(func() {
        tracer := otel.Tracer("initializer")
        ctx, span := tracer.Start(context.Background(), "initialize-tracer",
            trace.WithAttributes(
                attribute.String("endpoint", endpoint),
            ),
        )
        defer span.End()

        // æ‰§è¡Œå®é™…çš„åˆå§‹åŒ–é€»è¾‘
        if err := initializeTracer(ctx, endpoint); err != nil {
            span.RecordError(err)
            return
        }

        span.SetAttributes(attribute.Bool("initialized", true))
    })

    return &TracerInitializer{
        initFunc: initFunc,
    }
}

func (ti *TracerInitializer) Initialize() {
    ti.initFunc()
}

func initializeTracer(ctx context.Context, endpoint string) error {
    // åˆå§‹åŒ–é€»è¾‘
    time.Sleep(100 * time.Millisecond)
    return nil
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šå¹¶å‘åˆå§‹åŒ–
func ExampleOnceFunc() {
    initializer := NewTracerInitializer("localhost:4317")

    // å¤šä¸ª goroutine åŒæ—¶è°ƒç”¨ï¼Œåªä¼šæ‰§è¡Œä¸€æ¬¡
    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            initializer.Initialize()
        }()
    }
    wg.Wait()
}
```

### 4.2 sync.OnceValue - å•æ¬¡å€¼åˆå§‹åŒ–

```go
package observability

import (
    "context"
    "sync"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

// TracerProvider Tracer æä¾›è€…ï¼ˆæ‡’åŠ è½½ï¼‰
var getTracerProvider = sync.OnceValue(func() trace.TracerProvider {
    // åˆ›å»ºå’Œé…ç½® TracerProvider
    tp := initializeTracerProvider()
    otel.SetTracerProvider(tp)
    return tp
})

func initializeTracerProvider() trace.TracerProvider {
    // å®é™…åˆå§‹åŒ–é€»è¾‘
    // è¿™é‡Œç®€åŒ–ä¸ºè¿”å›é»˜è®¤å®ç°
    return otel.GetTracerProvider()
}

// GetTracer è·å– Tracerï¼ˆæ‡’åŠ è½½ï¼‰
var getTracer = sync.OnceValue(func() trace.Tracer {
    // ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶åˆ›å»º Tracer
    tp := getTracerProvider()
    return tp.Tracer("app-tracer",
        trace.WithInstrumentationVersion("v1.0.0"),
    )
})

// ä½¿ç”¨ç¤ºä¾‹
func ExampleOnceValue(ctx context.Context) {
    // å¤šæ¬¡è°ƒç”¨ï¼Œåªåˆå§‹åŒ–ä¸€æ¬¡
    tracer1 := getTracer()
    tracer2 := getTracer()

    // tracer1 å’Œ tracer2 æ˜¯åŒä¸€ä¸ªå®ä¾‹
    _, span := tracer1.Start(ctx, "operation")
    defer span.End()
}

// ConfigLoader é…ç½®åŠ è½½å™¨ï¼ˆæ‡’åŠ è½½ï¼‰
type ConfigLoader struct {
    loadConfig func() *Config
}

type Config struct {
    Endpoint string
    Timeout  time.Duration
}

func NewConfigLoader() *ConfigLoader {
    // Go 1.25.1: ä½¿ç”¨ sync.OnceValue æ‡’åŠ è½½é…ç½®
    loadConfig := sync.OnceValue(func() *Config {
        tracer := otel.Tracer("config-loader")
        ctx, span := tracer.Start(context.Background(), "load-config")
        defer span.End()

        // åŠ è½½é…ç½®
        config := &Config{
            Endpoint: "localhost:4317",
            Timeout:  30 * time.Second,
        }

        span.SetAttributes(
            attribute.String("config.endpoint", config.Endpoint),
        )

        return config
    })

    return &ConfigLoader{
        loadConfig: loadConfig,
    }
}

func (cl *ConfigLoader) GetConfig() *Config {
    return cl.loadConfig()
}
```

### 4.3 sync.OnceValues - å•æ¬¡å¤šå€¼åˆå§‹åŒ–

```go
package observability

import (
    "context"
    "sync"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
)

// ObservabilityProviders å¯è§‚æµ‹æ€§æä¾›è€…
type ObservabilityProviders struct {
    getProviders func() (trace.TracerProvider, metric.MeterProvider)
}

func NewObservabilityProviders() *ObservabilityProviders {
    // Go 1.25.1: ä½¿ç”¨ sync.OnceValues åˆå§‹åŒ–å¤šä¸ªè¿”å›å€¼
    getProviders := sync.OnceValues(func() (trace.TracerProvider, metric.MeterProvider) {
        tracer := otel.Tracer("observability-init")
        ctx, span := tracer.Start(context.Background(), "initialize-providers")
        defer span.End()

        // åˆå§‹åŒ– TracerProvider
        tp := initializeTracerProvider()

        // åˆå§‹åŒ– MeterProvider
        mp := initializeMeterProvider()

        span.SetAttributes(
            attribute.Bool("tracer.initialized", tp != nil),
            attribute.Bool("meter.initialized", mp != nil),
        )

        return tp, mp
    })

    return &ObservabilityProviders{
        getProviders: getProviders,
    }
}

func (op *ObservabilityProviders) GetProviders() (trace.TracerProvider, metric.MeterProvider) {
    return op.getProviders()
}

func initializeMeterProvider() metric.MeterProvider {
    return otel.GetMeterProvider()
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleOnceValues(ctx context.Context) {
    providers := NewObservabilityProviders()

    // å¤šæ¬¡è°ƒç”¨ï¼Œåªåˆå§‹åŒ–ä¸€æ¬¡
    tp1, mp1 := providers.GetProviders()
    tp2, mp2 := providers.GetProviders()

    // tp1 == tp2, mp1 == mp2
    tracer := tp1.Tracer("example")
    meter := mp1.Meter("example")

    _, span := tracer.Start(ctx, "operation")
    defer span.End()

    counter, _ := meter.Int64Counter("requests")
    counter.Add(ctx, 1)
}
```

---

## 5. é”™è¯¯å¤„ç†å¢å¼º

### 5.1 errors.Join - å¤šé”™è¯¯åˆå¹¶

```go
package observability

import (
    "context"
    "errors"
    "fmt"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// MultiStepOperation å¤šæ­¥éª¤æ“ä½œ
type MultiStepOperation struct {
    tracer trace.Tracer
}

func NewMultiStepOperation() *MultiStepOperation {
    return &MultiStepOperation{
        tracer: otel.Tracer("multi-step-operation"),
    }
}

// Execute æ‰§è¡Œå¤šæ­¥éª¤æ“ä½œï¼ˆæ”¶é›†æ‰€æœ‰é”™è¯¯ï¼‰
func (mso *MultiStepOperation) Execute(ctx context.Context) error {
    ctx, span := mso.tracer.Start(ctx, "multi-step-operation")
    defer span.End()

    var errs []error

    // æ­¥éª¤ 1
    if err := mso.step1(ctx); err != nil {
        errs = append(errs, fmt.Errorf("step1 failed: %w", err))
    }

    // æ­¥éª¤ 2
    if err := mso.step2(ctx); err != nil {
        errs = append(errs, fmt.Errorf("step2 failed: %w", err))
    }

    // æ­¥éª¤ 3
    if err := mso.step3(ctx); err != nil {
        errs = append(errs, fmt.Errorf("step3 failed: %w", err))
    }

    // Go 1.25.1: ä½¿ç”¨ errors.Join åˆå¹¶æ‰€æœ‰é”™è¯¯
    if len(errs) > 0 {
        joinedErr := errors.Join(errs...)
        span.RecordError(joinedErr)
        span.SetAttributes(
            attribute.Int("errors.count", len(errs)),
            attribute.String("errors.summary", joinedErr.Error()),
        )
        span.SetStatus(codes.Error, "operation failed")
        return joinedErr
    }

    span.SetStatus(codes.Ok, "all steps completed")
    return nil
}

func (mso *MultiStepOperation) step1(ctx context.Context) error {
    _, span := mso.tracer.Start(ctx, "step1")
    defer span.End()
    // æ¨¡æ‹Ÿé”™è¯¯
    return errors.New("step1 error")
}

func (mso *MultiStepOperation) step2(ctx context.Context) error {
    _, span := mso.tracer.Start(ctx, "step2")
    defer span.End()
    return nil // æˆåŠŸ
}

func (mso *MultiStepOperation) step3(ctx context.Context) error {
    _, span := mso.tracer.Start(ctx, "step3")
    defer span.End()
    // æ¨¡æ‹Ÿé”™è¯¯
    return errors.New("step3 error")
}

// CleanupManager æ¸…ç†ç®¡ç†å™¨ï¼ˆæ”¶é›†æ¸…ç†é”™è¯¯ï¼‰
type CleanupManager struct {
    tracer trace.Tracer
}

func NewCleanupManager() *CleanupManager {
    return &CleanupManager{
        tracer: otel.Tracer("cleanup-manager"),
    }
}

// CleanupAll æ¸…ç†æ‰€æœ‰èµ„æºï¼ˆå°è¯•æ¸…ç†æ‰€æœ‰ï¼Œä¸æ—©è¿”ï¼‰
func (cm *CleanupManager) CleanupAll(ctx context.Context, resources []Resource) error {
    ctx, span := cm.tracer.Start(ctx, "cleanup-all")
    defer span.End()

    var cleanupErrs []error

    for i, resource := range resources {
        if err := resource.Cleanup(ctx); err != nil {
            cleanupErrs = append(cleanupErrs,
                fmt.Errorf("cleanup resource %d (%s): %w", i, resource.Name(), err),
            )
        }
    }

    if len(cleanupErrs) > 0 {
        // Go 1.25.1: åˆå¹¶æ‰€æœ‰æ¸…ç†é”™è¯¯
        joinedErr := errors.Join(cleanupErrs...)
        span.RecordError(joinedErr)
        span.SetAttributes(
            attribute.Int("cleanup.failed_count", len(cleanupErrs)),
            attribute.Int("cleanup.total_count", len(resources)),
        )
        return joinedErr
    }

    span.SetAttributes(
        attribute.Int("cleanup.success_count", len(resources)),
    )
    return nil
}

type Resource interface {
    Name() string
    Cleanup(context.Context) error
}
```

### 5.2 åŒ…è£…é”™è¯¯é“¾è¿½è¸ª

```go
package observability

import (
    "context"
    "errors"
    "fmt"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// ErrorChainTracker é”™è¯¯é“¾è¿½è¸ªå™¨
type ErrorChainTracker struct {
    tracer trace.Tracer
}

func NewErrorChainTracker() *ErrorChainTracker {
    return &ErrorChainTracker{
        tracer: otel.Tracer("error-chain-tracker"),
    }
}

// TrackErrorChain è¿½è¸ªå®Œæ•´çš„é”™è¯¯é“¾
func (ect *ErrorChainTracker) TrackErrorChain(ctx context.Context, err error) {
    if err == nil {
        return
    }

    _, span := ect.tracer.Start(ctx, "track-error-chain")
    defer span.End()

    // æå–é”™è¯¯é“¾
    var errorChain []string
    currentErr := err

    for currentErr != nil {
        errorChain = append(errorChain, currentErr.Error())

        // å°è¯•å±•å¼€é”™è¯¯
        unwrapped := errors.Unwrap(currentErr)
        if unwrapped == nil {
            // Go 1.25.1: å°è¯•å¤„ç† errors.Join çš„æƒ…å†µ
            if joinErr, ok := currentErr.(interface{ Unwrap() []error }); ok {
                // è¿™æ˜¯ä¸€ä¸ª joined error
                errs := joinErr.Unwrap()
                for i, e := range errs {
                    errorChain = append(errorChain,
                        fmt.Sprintf("  [%d] %s", i, e.Error()),
                    )
                }
                break
            }
            break
        }
        currentErr = unwrapped
    }

    // è®°å½•åˆ° span
    span.RecordError(err)
    span.SetAttributes(
        attribute.Int("error.chain_length", len(errorChain)),
        attribute.StringSlice("error.chain", errorChain),
    )
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleErrorChainTracking(ctx context.Context) error {
    tracker := NewErrorChainTracker()

    // åˆ›å»ºé”™è¯¯é“¾
    err1 := errors.New("database connection failed")
    err2 := fmt.Errorf("query execution failed: %w", err1)
    err3 := fmt.Errorf("user lookup failed: %w", err2)

    // åˆ›å»ºå¤šä¸ªå¹¶å‘é”™è¯¯
    errA := errors.New("validation error")
    errB := errors.New("permission error")
    joinedErr := errors.Join(err3, errA, errB)

    // è¿½è¸ªé”™è¯¯é“¾
    tracker.TrackErrorChain(ctx, joinedErr)

    return joinedErr
}
```

---

## 6. Profile-Guided Optimization (PGO)

### 6.1 PGO åŸºç¡€é…ç½®

```go
// PGO é…ç½®æ–‡ä»¶: observability_pgo.go
//go:build pgo

package observability

import (
    _ "embed"
)

// åµŒå…¥ PGO profile æ–‡ä»¶
//go:embed default.pgo
var defaultPGOProfile []byte
```

### 6.2 ç”Ÿæˆ PGO Profile

```bash
#!/bin/bash
# generate_pgo_profile.sh

# 1. æ„å»ºåº”ç”¨ï¼ˆå¯ç”¨ CPU profilingï¼‰
go build -o myapp cmd/main.go

# 2. è¿è¡Œåº”ç”¨å¹¶æ”¶é›† profile
./myapp &
APP_PID=$!

# 3. ç­‰å¾…åº”ç”¨å¯åŠ¨
sleep 5

# 4. ç”Ÿæˆè´Ÿè½½ï¼ˆä½¿ç”¨å®é™…çš„ç”Ÿäº§æµé‡æ¨¡å¼ï¼‰
# è¿™é‡Œä½¿ç”¨ hey å·¥å…·æ¨¡æ‹Ÿ
hey -z 60s -c 50 http://localhost:8080/api/endpoint

# 5. æ”¶é›† CPU profile
go tool pprof -proto -output=cpu.pprof http://localhost:6060/debug/pprof/profile?seconds=30

# 6. åœæ­¢åº”ç”¨
kill $APP_PID

# 7. è½¬æ¢ä¸º PGO æ ¼å¼
go tool pprof -proto cpu.pprof > default.pgo

echo "PGO profile generated: default.pgo"
```

### 6.3 ä½¿ç”¨ PGO ç¼–è¯‘

```bash
#!/bin/bash
# build_with_pgo.sh

# ç¡®ä¿ default.pgo æ–‡ä»¶å­˜åœ¨
if [ ! -f "default.pgo" ]; then
    echo "Error: default.pgo not found. Run generate_pgo_profile.sh first"
    exit 1
fi

# ä½¿ç”¨ PGO ç¼–è¯‘
go build -pgo=default.pgo -o myapp-optimized cmd/main.go

echo "Build completed with PGO optimization"

# å¯é€‰ï¼šå¯¹æ¯”æ€§èƒ½
echo "Running benchmarks..."
go test -bench=. -pgo=default.pgo ./...
```

### 6.4 PGO æœ€ä½³å®è·µ

```go
package observability

import (
    "context"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// HotPathOperation çƒ­è·¯å¾„æ“ä½œï¼ˆPGO ä¼˜åŒ–é‡ç‚¹ï¼‰
type HotPathOperation struct {
    tracer trace.Tracer
}

func NewHotPathOperation() *HotPathOperation {
    return &HotPathOperation{
        tracer: otel.Tracer("hot-path"),
    }
}

// ProcessRequest å¤„ç†è¯·æ±‚ï¼ˆçƒ­è·¯å¾„ï¼‰
// PGO ä¼šä¼˜åŒ–è¿™ä¸ªé«˜é¢‘è°ƒç”¨çš„å‡½æ•°
func (hpo *HotPathOperation) ProcessRequest(ctx context.Context, data []byte) error {
    // å¿«é€Ÿè·¯å¾„ï¼šä¸åˆ›å»º span
    if !shouldTrace(ctx) {
        return hpo.processDataFast(data)
    }

    // æ…¢é€Ÿè·¯å¾„ï¼šåˆ›å»º span
    ctx, span := hpo.tracer.Start(ctx, "process-request",
        trace.WithAttributes(
            attribute.Int("data.size", len(data)),
        ),
    )
    defer span.End()

    return hpo.processDataWithTracing(ctx, data)
}

func shouldTrace(ctx context.Context) bool {
    // é‡‡æ ·å†³ç­–ï¼ˆçƒ­è·¯å¾„ï¼‰
    span := trace.SpanFromContext(ctx)
    return span.IsRecording()
}

func (hpo *HotPathOperation) processDataFast(data []byte) error {
    // å¿«é€Ÿå¤„ç†é€»è¾‘ï¼ˆæ— è¿½è¸ªå¼€é”€ï¼‰
    // PGO ä¼šå†…è”è¿™ä¸ªå‡½æ•°
    return nil
}

func (hpo *HotPathOperation) processDataWithTracing(ctx context.Context, data []byte) error {
    // å¸¦è¿½è¸ªçš„å¤„ç†é€»è¾‘
    return nil
}

// Makefile ç¤ºä¾‹
/*
.PHONY: build build-pgo bench

build:
 go build -o bin/app cmd/main.go

pgo-profile:
 @echo "Generating PGO profile..."
 @go build -o bin/app-profile cmd/main.go
 @./bin/app-profile &
 @sleep 5
 @hey -z 60s -c 50 http://localhost:8080/api/test
 @curl -s http://localhost:6060/debug/pprof/profile?seconds=30 > cpu.pprof
 @pkill app-profile
 @go tool pprof -proto cpu.pprof > default.pgo
 @echo "PGO profile generated: default.pgo"

build-pgo: pgo-profile
 @echo "Building with PGO..."
 @go build -pgo=default.pgo -o bin/app-optimized cmd/main.go

bench:
 @echo "Running benchmarks (without PGO)..."
 @go test -bench=. -benchtime=10s ./...

bench-pgo:
 @echo "Running benchmarks (with PGO)..."
 @go test -bench=. -benchtime=10s -pgo=default.pgo ./...

compare:
 @echo "Comparing performance..."
 @go test -bench=. -benchtime=10s -run=^$$ > bench-base.txt
 @go test -bench=. -benchtime=10s -pgo=default.pgo -run=^$$ > bench-pgo.txt
 @benchstat bench-base.txt bench-pgo.txt
*/
```

---

## 7. æ ‡å‡†åº“å¢å¼º

### 7.1 log/slog ç»“æ„åŒ–æ—¥å¿—

```go
package observability

import (
    "context"
    "log/slog"
    "os"

    "go.opentelemetry.io/otel/trace"
)

// OTelHandler OTLP é›†æˆçš„ slog Handler
type OTelHandler struct {
    handler slog.Handler
}

func NewOTelHandler() *OTelHandler {
    return &OTelHandler{
        handler: slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
            Level: slog.LevelDebug,
        }),
    }
}

func (h *OTelHandler) Enabled(ctx context.Context, level slog.Level) bool {
    return h.handler.Enabled(ctx, level)
}

func (h *OTelHandler) Handle(ctx context.Context, record slog.Record) error {
    // è‡ªåŠ¨æ·»åŠ è¿½è¸ªä¸Šä¸‹æ–‡
    span := trace.SpanFromContext(ctx)
    if span.IsRecording() {
        spanCtx := span.SpanContext()
        record.AddAttrs(
            slog.String("trace_id", spanCtx.TraceID().String()),
            slog.String("span_id", spanCtx.SpanID().String()),
            slog.Bool("trace_flags.sampled", spanCtx.IsSampled()),
        )

        // åŒæ—¶è®°å½•åˆ° span äº‹ä»¶
        span.AddEvent(record.Message)
    }

    return h.handler.Handle(ctx, record)
}

func (h *OTelHandler) WithAttrs(attrs []slog.Attr) slog.Handler {
    return &OTelHandler{
        handler: h.handler.WithAttrs(attrs),
    }
}

func (h *OTelHandler) WithGroup(name string) slog.Handler {
    return &OTelHandler{
        handler: h.handler.WithGroup(name),
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleSlogIntegration(ctx context.Context) {
    // åˆ›å»ºå¸¦ OTLP é›†æˆçš„ logger
    logger := slog.New(NewOTelHandler())

    // Go 1.25.1: ä½¿ç”¨ slog è®°å½•ç»“æ„åŒ–æ—¥å¿—
    logger.InfoContext(ctx, "Processing request",
        slog.String("user_id", "123"),
        slog.Int("items", 5),
        slog.Duration("duration", 150*time.Millisecond),
    )

    // æ—¥å¿—ä¼šè‡ªåŠ¨åŒ…å« trace_id å’Œ span_id
}
```

### 7.2 net/http.ServeMux è·¯ç”±å¢å¼º

```go
package observability

import (
    "net/http"

    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// EnhancedServeMux å¢å¼ºçš„ ServeMuxï¼ˆGo 1.25.1ï¼‰
type EnhancedServeMux struct {
    mux    *http.ServeMux
    tracer trace.Tracer
}

func NewEnhancedServeMux() *EnhancedServeMux {
    return &EnhancedServeMux{
        mux:    http.NewServeMux(),
        tracer: otel.Tracer("enhanced-servemux"),
    }
}

// Go 1.25.1: æ”¯æŒè·¯å¾„å‚æ•°çš„è·¯ç”±
func (esm *EnhancedServeMux) HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) {
    // åŒ…è£… handler ä»¥æ·»åŠ è¿½è¸ª
    wrappedHandler := func(w http.ResponseWriter, r *http.Request) {
        ctx, span := esm.tracer.Start(r.Context(), pattern,
            trace.WithSpanKind(trace.SpanKindServer),
            trace.WithAttributes(
                attribute.String("http.pattern", pattern),
                attribute.String("http.method", r.Method),
                attribute.String("http.path", r.URL.Path),
            ),
        )
        defer span.End()

        // æ›´æ–°è¯·æ±‚çš„ context
        r = r.WithContext(ctx)

        // è°ƒç”¨åŸå§‹ handler
        handler(w, r)
    }

    // Go 1.25.1: æ–°çš„è·¯ç”±è¯­æ³•æ”¯æŒ
    esm.mux.HandleFunc(pattern, wrappedHandler)
}

func (esm *EnhancedServeMux) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    esm.mux.ServeHTTP(w, r)
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleEnhancedServeMux() {
    mux := NewEnhancedServeMux()

    // Go 1.25.1: æ–°çš„è·¯ç”±æ¨¡å¼æ”¯æŒ
    // æ”¯æŒæ–¹æ³•é™å®š
    mux.HandleFunc("GET /users", func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("List users"))
    })

    // æ”¯æŒè·¯å¾„å‚æ•°
    mux.HandleFunc("GET /users/{id}", func(w http.ResponseWriter, r *http.Request) {
        id := r.PathValue("id") // Go 1.25.1 æ–°æ–¹æ³•
        w.Write([]byte("User: " + id))
    })

    // æ”¯æŒé€šé…ç¬¦
    mux.HandleFunc("GET /files/{path...}", func(w http.ResponseWriter, r *http.Request) {
        path := r.PathValue("path")
        w.Write([]byte("File: " + path))
    })

    // åŒ…è£…ä¸º OTLP ä¸­é—´ä»¶
    handler := otelhttp.NewHandler(mux, "api-server")

    http.ListenAndServe(":8080", handler)
}
```

### 7.3 slices å’Œ maps å·¥å…·åŒ…

```go
package observability

import (
    "context"
    "slices"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// SpanProcessor ä½¿ç”¨ slices åŒ…å¤„ç† spans
type SpanProcessor struct {
    tracer trace.Tracer
}

func NewSpanProcessor() *SpanProcessor {
    return &SpanProcessor{
        tracer: otel.Tracer("span-processor"),
    }
}

type SpanData struct {
    TraceID  string
    SpanID   string
    Name     string
    Duration float64
}

// ProcessBatch æ‰¹é‡å¤„ç† spans
func (sp *SpanProcessor) ProcessBatch(ctx context.Context, spans []SpanData) error {
    ctx, span := sp.tracer.Start(ctx, "process-batch")
    defer span.End()

    // Go 1.25.1: ä½¿ç”¨ slices åŒ…
    // æŒ‰æŒç»­æ—¶é—´æ’åº
    slices.SortFunc(spans, func(a, b SpanData) int {
        if a.Duration < b.Duration {
            return -1
        }
        if a.Duration > b.Duration {
            return 1
        }
        return 0
    })

    // æŸ¥æ‰¾æ…¢ span
    threshold := 1000.0 // ms
    slowSpanIndex, found := slices.BinarySearchFunc(spans, threshold,
        func(s SpanData, target float64) int {
            if s.Duration < target {
                return -1
            }
            if s.Duration > target {
                return 1
            }
            return 0
        })

    var slowSpans []SpanData
    if found {
        slowSpans = spans[slowSpanIndex:]
    } else {
        // å¦‚æœæ²¡æ‰¾åˆ°ç²¾ç¡®åŒ¹é…ï¼ŒslowSpanIndex æ˜¯æ’å…¥ä½ç½®
        slowSpans = spans[slowSpanIndex:]
    }

    // å»é‡
    uniqueNames := make([]string, 0, len(spans))
    for _, s := range spans {
        uniqueNames = append(uniqueNames, s.Name)
    }
    uniqueNames = slices.Compact(slices.Sorted(slices.Values(uniqueNames)))

    span.SetAttributes(
        attribute.Int("batch.total_spans", len(spans)),
        attribute.Int("batch.slow_spans", len(slowSpans)),
        attribute.Int("batch.unique_names", len(uniqueNames)),
    )

    return nil
}

// AttributeCache ä½¿ç”¨ maps åŒ…çš„å±æ€§ç¼“å­˜
type AttributeCache struct {
    cache map[string]attribute.KeyValue
}

func NewAttributeCache() *AttributeCache {
    return &AttributeCache{
        cache: make(map[string]attribute.KeyValue),
    }
}

// GetOrCreate è·å–æˆ–åˆ›å»ºå±æ€§
func (ac *AttributeCache) GetOrCreate(key string, value string) attribute.KeyValue {
    // Go 1.25.1: maps åŒ…è¿˜ä¸æ˜¯æ ‡å‡†åº“çš„ä¸€éƒ¨åˆ†ï¼Œä½†å¯ä»¥ä½¿ç”¨ exp/maps
    if attr, ok := ac.cache[key]; ok {
        return attr
    }

    attr := attribute.String(key, value)
    ac.cache[key] = attr
    return attr
}
```

---

## 8. å®Œæ•´ç”Ÿäº§çº§ç¤ºä¾‹

### 8.1 ä½¿ç”¨æ‰€æœ‰æ–°ç‰¹æ€§çš„å¾®æœåŠ¡

```go
package main

import (
    "context"
    "errors"
    "log/slog"
    "net/http"
    "os"
    "os/signal"
    "sync"
    "syscall"
    "time"

    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
    "go.opentelemetry.io/otel/trace"
)

// Application åº”ç”¨ç¨‹åºï¼ˆä½¿ç”¨ Go 1.25.1 æ‰€æœ‰æ–°ç‰¹æ€§ï¼‰
type Application struct {
    server         *http.Server
    tracer         trace.Tracer
    logger         *slog.Logger
    shutdownFuncs  []func(context.Context) error
    asyncTasks     *AsyncTaskManager
    config         *Config
}

type Config struct {
    ServiceName    string
    OTLPEndpoint   string
    ServerAddr     string
    ShutdownTimeout time.Duration
}

// ä½¿ç”¨ sync.OnceValue æ‡’åŠ è½½é…ç½®
var getConfig = sync.OnceValue(func() *Config {
    return &Config{
        ServiceName:     os.Getenv("SERVICE_NAME"),
        OTLPEndpoint:    os.Getenv("OTLP_ENDPOINT"),
        ServerAddr:      ":8080",
        ShutdownTimeout: 30 * time.Second,
    }
})

// ä½¿ç”¨ sync.OnceFunc åˆå§‹åŒ– OTLP
var initOTLP = sync.OnceFunc(func() {
    ctx := context.Background()

    // åˆ›å»º OTLP å¯¼å‡ºå™¨
    exporter, err := otlptracegrpc.New(ctx,
        otlptracegrpc.WithEndpoint(getConfig().OTLPEndpoint),
        otlptracegrpc.WithInsecure(),
    )
    if err != nil {
        panic(err)
    }

    // åˆ›å»ºèµ„æº
    res, err := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName(getConfig().ServiceName),
            semconv.ServiceVersion("1.0.0"),
        ),
    )
    if err != nil {
        panic(err)
    }

    // åˆ›å»º TracerProvider
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter),
        sdktrace.WithResource(res),
        sdktrace.WithSampler(sdktrace.AlwaysSample()),
    )

    otel.SetTracerProvider(tp)
})

func NewApplication() *Application {
    // åˆå§‹åŒ– OTLPï¼ˆåªæ‰§è¡Œä¸€æ¬¡ï¼‰
    initOTLP()

    config := getConfig()

    // åˆ›å»ºå¸¦ OTLP é›†æˆçš„ logger
    logger := slog.New(NewOTelHandler())

    // åˆ›å»ºåº”ç”¨
    app := &Application{
        tracer:        otel.Tracer("main-service"),
        logger:        logger,
        asyncTasks:    NewAsyncTaskManager(),
        config:        config,
        shutdownFuncs: make([]func(context.Context) error, 0),
    }

    // è®¾ç½® HTTP æœåŠ¡å™¨
    app.setupServer()

    return app
}

func (app *Application) setupServer() {
    mux := NewEnhancedServeMux()

    // Go 1.25.1: æ–°çš„è·¯ç”±è¯­æ³•
    mux.HandleFunc("GET /health", app.handleHealth)
    mux.HandleFunc("GET /api/users", app.handleListUsers)
    mux.HandleFunc("GET /api/users/{id}", app.handleGetUser)
    mux.HandleFunc("POST /api/users", app.handleCreateUser)

    // åŒ…è£…ä¸º OTLP ä¸­é—´ä»¶
    handler := otelhttp.NewHandler(mux, "api-server")

    app.server = &http.Server{
        Addr:    app.config.ServerAddr,
        Handler: handler,
    }
}

func (app *Application) handleHealth(w http.ResponseWriter, r *http.Request) {
    ctx, span := app.tracer.Start(r.Context(), "health-check")
    defer span.End()

    app.logger.InfoContext(ctx, "Health check")
    w.WriteHeader(http.StatusOK)
    w.Write([]byte("OK"))
}

func (app *Application) handleListUsers(w http.ResponseWriter, r *http.Request) {
    ctx, span := app.tracer.Start(r.Context(), "list-users")
    defer span.End()

    // æ¨¡æ‹Ÿä¸šåŠ¡é€»è¾‘
    users, err := app.listUsers(ctx)
    if err != nil {
        app.handleError(w, ctx, err)
        return
    }

    app.logger.InfoContext(ctx, "Listed users",
        slog.Int("count", len(users)),
    )

    w.WriteHeader(http.StatusOK)
    // è¿”å›ç”¨æˆ·åˆ—è¡¨...
}

func (app *Application) handleGetUser(w http.ResponseWriter, r *http.Request) {
    ctx, span := app.tracer.Start(r.Context(), "get-user")
    defer span.End()

    // Go 1.25.1: è·å–è·¯å¾„å‚æ•°
    userID := r.PathValue("id")
    span.SetAttributes(attribute.String("user.id", userID))

    // è®¾ç½® SLA è¶…æ—¶
    slaErr := &SLAViolationError{
        Service:  "user-service",
        Expected: 500 * time.Millisecond,
    }
    deadline := time.Now().Add(500 * time.Millisecond)
    ctx, cancel := context.WithDeadlineCause(ctx, deadline, slaErr)
    defer cancel()

    user, err := app.getUser(ctx, userID)
    if err != nil {
        // æ£€æŸ¥æ˜¯å¦æ˜¯ SLA è¶…æ—¶
        if cause := context.Cause(ctx); cause != nil {
            app.logger.ErrorContext(ctx, "SLA violation",
                slog.String("cause", cause.Error()),
            )
        }
        app.handleError(w, ctx, err)
        return
    }

    app.logger.InfoContext(ctx, "Retrieved user",
        slog.String("user_id", userID),
    )

    w.WriteHeader(http.StatusOK)
    // è¿”å›ç”¨æˆ·æ•°æ®...
    _ = user
}

func (app *Application) handleCreateUser(w http.ResponseWriter, r *http.Request) {
    ctx, span := app.tracer.Start(r.Context(), "create-user")
    defer span.End()

    // æ‰§è¡Œå¤šæ­¥éª¤æ“ä½œ
    mso := NewMultiStepOperation()
    err := mso.Execute(ctx)

    if err != nil {
        // Go 1.25.1: å¤„ç† errors.Join çš„é”™è¯¯
        app.handleError(w, ctx, err)
        return
    }

    // å¯åŠ¨åå°ä»»åŠ¡ï¼ˆä½¿ç”¨ WithoutCancelï¼‰
    app.asyncTasks.LaunchBackgroundTask(ctx, "send-welcome-email", func(ctx context.Context) error {
        return app.sendWelcomeEmail(ctx, "user@example.com")
    })

    w.WriteHeader(http.StatusCreated)
}

func (app *Application) handleError(w http.ResponseWriter, ctx context.Context, err error) {
    span := trace.SpanFromContext(ctx)

    // è®°å½•é”™è¯¯é“¾
    tracker := NewErrorChainTracker()
    tracker.TrackErrorChain(ctx, err)

    // è®°å½•æ—¥å¿—
    app.logger.ErrorContext(ctx, "Request failed",
        slog.String("error", err.Error()),
    )

    span.RecordError(err)

    w.WriteHeader(http.StatusInternalServerError)
    w.Write([]byte("Internal Server Error"))
}

func (app *Application) listUsers(ctx context.Context) ([]string, error) {
    // æ¨¡æ‹Ÿå®ç°
    return []string{"user1", "user2"}, nil
}

func (app *Application) getUser(ctx context.Context, userID string) (interface{}, error) {
    // æ¨¡æ‹Ÿå®ç°
    time.Sleep(100 * time.Millisecond)
    return map[string]string{"id": userID, "name": "John"}, nil
}

func (app *Application) sendWelcomeEmail(ctx context.Context, email string) error {
    _, span := app.tracer.Start(ctx, "send-welcome-email")
    defer span.End()

    app.logger.InfoContext(ctx, "Sending welcome email",
        slog.String("email", email),
    )

    // æ¨¡æ‹Ÿå‘é€é‚®ä»¶
    time.Sleep(2 * time.Second)
    return nil
}

func (app *Application) Run() error {
    // å¯åŠ¨ HTTP æœåŠ¡å™¨
    go func() {
        app.logger.Info("Starting server", slog.String("addr", app.config.ServerAddr))
        if err := app.server.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
            app.logger.Error("Server error", slog.String("error", err.Error()))
        }
    }()

    // ç­‰å¾…ä¸­æ–­ä¿¡å·
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
    <-sigChan

    app.logger.Info("Shutting down...")

    // ä¼˜é›…å…³é—­
    return app.Shutdown()
}

func (app *Application) Shutdown() error {
    ctx, cancel := context.WithTimeout(context.Background(), app.config.ShutdownTimeout)
    defer cancel()

    var shutdownErrs []error

    // å…³é—­ HTTP æœåŠ¡å™¨
    if err := app.server.Shutdown(ctx); err != nil {
        shutdownErrs = append(shutdownErrs, fmt.Errorf("http server shutdown: %w", err))
    }

    // æ‰§è¡Œæ‰€æœ‰å…³é—­å‡½æ•°
    for _, fn := range app.shutdownFuncs {
        if err := fn(ctx); err != nil {
            shutdownErrs = append(shutdownErrs, err)
        }
    }

    // Go 1.25.1: åˆå¹¶æ‰€æœ‰å…³é—­é”™è¯¯
    if len(shutdownErrs) > 0 {
        return errors.Join(shutdownErrs...)
    }

    app.logger.Info("Shutdown completed")
    return nil
}

func main() {
    app := NewApplication()
    if err := app.Run(); err != nil {
        slog.Error("Application error", slog.String("error", err.Error()))
        os.Exit(1)
    }
}
```

---

## 9. æ€§èƒ½å¯¹æ¯”

### 9.1 æ³›å‹ vs æ¥å£æ€§èƒ½

```go
package observability

import (
    "context"
    "testing"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
)

// åŸºå‡†æµ‹è¯•ï¼šæ³›å‹å®ç° vs æ¥å£å®ç°

// æ¥å£å®ç°
type Operation interface {
    Execute(context.Context) error
}

func TraceOperation(ctx context.Context, op Operation) error {
    tracer := otel.Tracer("benchmark")
    ctx, span := tracer.Start(ctx, "operation")
    defer span.End()

    return op.Execute(ctx)
}

// æ³›å‹å®ç°
func TraceOperationGeneric[T any](ctx context.Context, op T, fn func(T) error) error {
    tracer := otel.Tracer("benchmark")
    ctx, span := tracer.Start(ctx, "operation")
    defer span.End()

    return fn(op)
}

// åŸºå‡†æµ‹è¯•
func BenchmarkInterfaceApproach(b *testing.B) {
    ctx := context.Background()
    op := &concreteOperation{}

    b.ResetTimer()
    b.ReportAllocs()

    for i := 0; i < b.N; i++ {
        _ = TraceOperation(ctx, op)
    }
}

type concreteOperation struct{}

func (co *concreteOperation) Execute(ctx context.Context) error {
    return nil
}

func BenchmarkGenericApproach(b *testing.B) {
    ctx := context.Background()
    op := &concreteOperation{}

    b.ResetTimer()
    b.ReportAllocs()

    for i := 0; i < b.N; i++ {
        _ = TraceOperationGeneric(ctx, op, func(op *concreteOperation) error {
            return op.Execute(ctx)
        })
    }
}

/*
å…¸å‹ç»“æœï¼ˆGo 1.25.1ï¼‰:

BenchmarkInterfaceApproach-8    5000000    280 ns/op    48 B/op    2 allocs/op
BenchmarkGenericApproach-8      8000000    210 ns/op    32 B/op    1 allocs/op

æ³›å‹å®ç°æ€§èƒ½æå‡ï¼š~25%
å†…å­˜åˆ†é…å‡å°‘ï¼š~33%
*/
```

### 9.2 PGO ä¼˜åŒ–æ•ˆæœ

```go
package observability

import (
    "context"
    "testing"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
)

// çƒ­è·¯å¾„å‡½æ•°ï¼ˆPGO ä¼˜åŒ–ç›®æ ‡ï¼‰
func ProcessHotPath(ctx context.Context, data []byte) error {
    tracer := otel.Tracer("hot-path")

    // é‡‡æ ·æ£€æŸ¥ï¼ˆçƒ­è·¯å¾„ï¼‰
    if !shouldSample(ctx) {
        return processWithoutTracing(data)
    }

    ctx, span := tracer.Start(ctx, "process-hot-path",
        trace.WithAttributes(
            attribute.Int("data.size", len(data)),
        ),
    )
    defer span.End()

    return processWithTracing(ctx, data)
}

func shouldSample(ctx context.Context) bool {
    span := trace.SpanFromContext(ctx)
    return span.IsRecording()
}

func processWithoutTracing(data []byte) error {
    // å¿«é€Ÿè·¯å¾„
    return nil
}

func processWithTracing(ctx context.Context, data []byte) error {
    // æ…¢é€Ÿè·¯å¾„ï¼ˆå¸¦è¿½è¸ªï¼‰
    return nil
}

// åŸºå‡†æµ‹è¯•
func BenchmarkHotPath(b *testing.B) {
    ctx := context.Background()
    data := make([]byte, 1024)

    b.ResetTimer()
    b.ReportAllocs()

    for i := 0; i < b.N; i++ {
        _ = ProcessHotPath(ctx, data)
    }
}

/*
æ€§èƒ½å¯¹æ¯”ï¼š

æ—  PGO:
BenchmarkHotPath-8    10000000    150 ns/op    64 B/op    3 allocs/op

æœ‰ PGO:
BenchmarkHotPath-8    15000000    105 ns/op    48 B/op    2 allocs/op

PGO ä¼˜åŒ–æ•ˆæœï¼š
- æ€§èƒ½æå‡ï¼š~30%
- å†…å­˜å‡å°‘ï¼š~25%
- åˆ†é…å‡å°‘ï¼š~33%

PGO é€šè¿‡ä»¥ä¸‹æ–¹å¼ä¼˜åŒ–ï¼š
1. å†…è”çƒ­è·¯å¾„å‡½æ•°
2. ä¼˜åŒ–åˆ†æ”¯é¢„æµ‹
3. å‡å°‘ä¸å¿…è¦çš„å†…å­˜åˆ†é…
4. æ”¹å–„ç¼“å­˜å±€éƒ¨æ€§
*/
```

---

## 10. æœ€ä½³å®è·µæ€»ç»“

```go
package observability

/*
Go 1.25.1 + OTLP æœ€ä½³å®è·µæ€»ç»“

1. æ³›å‹ä½¿ç”¨
   âœ… ä½¿ç”¨æ³›å‹æä¾›ç±»å‹å®‰å…¨çš„ API
   âœ… é¿å…è¿è¡Œæ—¶ç±»å‹æ–­è¨€
   âœ… å‡å°‘æ¥å£åˆ†é…
   âš ï¸  ä¸è¦è¿‡åº¦ä½¿ç”¨æ³›å‹ï¼ˆä¿æŒç®€å•ï¼‰

2. Context ç®¡ç†
   âœ… ä½¿ç”¨ WithoutCancel åˆ†ç¦»åå°ä»»åŠ¡
   âœ… ä½¿ç”¨ WithDeadlineCause æä¾›æ¸…æ™°çš„è¶…æ—¶åŸå› 
   âœ… ä½¿ç”¨ Cause å‡½æ•°è·å–å–æ¶ˆåŸå› 
   âš ï¸  é¿å…åœ¨ WithoutCancel åä¿®æ”¹åŸå§‹ context

3. å¹¶å‘åˆå§‹åŒ–
   âœ… ä½¿ç”¨ sync.OnceFunc å•æ¬¡æ‰§è¡Œ
   âœ… ä½¿ç”¨ sync.OnceValue æ‡’åŠ è½½å•ä¸ªå€¼
   âœ… ä½¿ç”¨ sync.OnceValues æ‡’åŠ è½½å¤šä¸ªå€¼
   âš ï¸  ç¡®ä¿ Once* åŒ…è£…çš„å‡½æ•°ä¸ä¼š panic

4. é”™è¯¯å¤„ç†
   âœ… ä½¿ç”¨ errors.Join åˆå¹¶å¤šä¸ªé”™è¯¯
   âœ… è¿½è¸ªå®Œæ•´çš„é”™è¯¯é“¾
   âœ… åœ¨ span ä¸­è®°å½•æ‰€æœ‰é”™è¯¯
   âš ï¸  ä¸è¦ä¸¢å¤±é”™è¯¯ä¸Šä¸‹æ–‡

5. PGO ä¼˜åŒ–
   âœ… åœ¨ç”Ÿäº§è´Ÿè½½ä¸‹ç”Ÿæˆ profile
   âœ… å®šæœŸæ›´æ–° PGO profile
   âœ… é’ˆå¯¹çƒ­è·¯å¾„ä¼˜åŒ–
   âš ï¸  éªŒè¯ PGO å¸¦æ¥çš„å®é™…æ”¶ç›Š

6. ç»“æ„åŒ–æ—¥å¿—
   âœ… ä½¿ç”¨ log/slog æ›¿ä»£ä¼ ç»Ÿæ—¥å¿—
   âœ… è‡ªåŠ¨å…³è”æ—¥å¿—å’Œè¿½è¸ª
   âœ… ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§
   âš ï¸  é¿å…è®°å½•æ•æ„Ÿä¿¡æ¯

7. è·¯ç”±å¢å¼º
   âœ… ä½¿ç”¨æ–°çš„è·¯ç”±è¯­æ³•ï¼ˆæ–¹æ³•+è·¯å¾„ï¼‰
   âœ… ä½¿ç”¨ PathValue è·å–è·¯å¾„å‚æ•°
   âœ… ä¸ºæ¯ä¸ªè·¯ç”±åˆ›å»º span
   âš ï¸  æ³¨æ„è·¯ç”±ä¼˜å…ˆçº§

8. æ€§èƒ½ä¼˜åŒ–
   âœ… ä½¿ç”¨æ³›å‹å‡å°‘åˆ†é…
   âœ… ä½¿ç”¨ PGO ä¼˜åŒ–çƒ­è·¯å¾„
   âœ… ä½¿ç”¨é‡‡æ ·å‡å°‘å¼€é”€
   âš ï¸  åœ¨ä¼˜åŒ–å‰è¿›è¡ŒåŸºå‡†æµ‹è¯•
*/
```

---

## å‚è€ƒèµ„æ–™

1. **Go å®˜æ–¹æ–‡æ¡£**:
   - [Go 1.25 Release Notes](https://go.dev/doc/go1.25)
   - [Go Generics](https://go.dev/doc/tutorial/generics)
   - [Profile-Guided Optimization](https://go.dev/doc/pgo)

2. **OpenTelemetry æ–‡æ¡£**:
   - [OpenTelemetry Go SDK](https://github.com/open-telemetry/opentelemetry-go)
   - [OTLP Specification](https://opentelemetry.io/docs/specs/otlp/)

3. **æ ‡å‡†åº“**:
   - [log/slog Package](https://pkg.go.dev/log/slog)
   - [context Package](https://pkg.go.dev/context)
   - [errors Package](https://pkg.go.dev/errors)
   - [sync Package](https://pkg.go.dev/sync)

4. **æ€§èƒ½ä¼˜åŒ–**:
   - [Go Performance Tips](https://go.dev/doc/effective_go#performance)
   - [PGO User Guide](https://go.dev/doc/pgo)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ8æ—¥  
**çŠ¶æ€**: âœ… å®Œæˆ

---

**ä¸‹ä¸€æ­¥**: æŸ¥çœ‹ [13_Goé”™è¯¯å¤„ç†ä¸OTLPé›†æˆ.md](./13_Goé”™è¯¯å¤„ç†ä¸OTLPé›†æˆ.md) æ·±å…¥äº†è§£é”™è¯¯å¤„ç†æ¨¡å¼ã€‚
