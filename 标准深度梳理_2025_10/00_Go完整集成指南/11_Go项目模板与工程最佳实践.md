# Go 项目模板与工程最佳实践

> **Go 版本**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0+  
> **最后更新**: 2025年10月8日

---

## 📋 目录

- [Go 项目模板与工程最佳实践](#go-项目模板与工程最佳实践)
  - [📋 目录](#-目录)
  - [概述](#概述)
    - [项目结构设计原则](#项目结构设计原则)
  - [标准项目结构](#标准项目结构)
    - [1. 目录布局](#1-目录布局)
    - [2. 依赖管理](#2-依赖管理)
  - [核心模块实现](#核心模块实现)
    - [3. 主程序入口](#3-主程序入口)
    - [4. 配置管理](#4-配置管理)
    - [5. 可观测性初始化](#5-可观测性初始化)
  - [领域驱动设计](#领域驱动设计)
    - [6. 领域层](#6-领域层)
    - [7. 应用层](#7-应用层)
    - [8. 基础设施层](#8-基础设施层)
  - [中间件和工具](#中间件和工具)
    - [9. HTTP 中间件](#9-http-中间件)
    - [10. gRPC 拦截器](#10-grpc-拦截器)
  - [测试策略](#测试策略)
    - [11. 单元测试模板](#11-单元测试模板)
    - [12. 集成测试模板](#12-集成测试模板)
  - [部署配置](#部署配置)
    - [13. Dockerfile 模板](#13-dockerfile-模板)
    - [14. Kubernetes 配置](#14-kubernetes-配置)
    - [15. CI/CD 配置](#15-cicd-配置)
  - [开发工具链](#开发工具链)
    - [16. Makefile](#16-makefile)
    - [17. 代码质量工具](#17-代码质量工具)
  - [总结](#总结)
    - [项目结构](#项目结构)
    - [核心实现](#核心实现)
    - [基础设施](#基础设施)
    - [测试和部署](#测试和部署)
    - [开发工具](#开发工具)
    - [相关文档](#相关文档)

---

## 概述

### 项目结构设计原则

```text
✅ 关注点分离 - Separation of Concerns
✅ 依赖倒置 - Dependency Inversion
✅ 单一职责 - Single Responsibility
✅ 接口隔离 - Interface Segregation
✅ 可测试性 - Testability
✅ 可维护性 - Maintainability
```

---

## 标准项目结构

### 1. 目录布局

```text
my-go-service/
├── cmd/
│   └── server/
│       └── main.go                 # 主程序入口
├── internal/
│   ├── domain/                     # 领域层
│   │   ├── user/
│   │   │   ├── user.go            # 领域模型
│   │   │   ├── repository.go      # 仓储接口
│   │   │   └── service.go         # 领域服务
│   │   └── order/
│   ├── application/                # 应用层
│   │   ├── user/
│   │   │   ├── handler.go         # HTTP 处理器
│   │   │   ├── grpc_server.go     # gRPC 服务
│   │   │   └── dto.go             # 数据传输对象
│   │   └── order/
│   ├── infrastructure/             # 基础设施层
│   │   ├── repository/
│   │   │   ├── user_postgres.go   # 用户仓储实现
│   │   │   └── order_postgres.go
│   │   ├── cache/
│   │   │   └── redis.go           # 缓存实现
│   │   └── messaging/
│   │       └── kafka.go           # 消息队列
│   ├── middleware/                 # 中间件
│   │   ├── auth.go
│   │   ├── logging.go
│   │   └── tracing.go
│   └── config/                     # 配置
│       └── config.go
├── pkg/                            # 公共库
│   ├── observability/
│   │   ├── tracing.go
│   │   ├── metrics.go
│   │   └── logging.go
│   ├── httpclient/
│   │   └── client.go
│   └── errors/
│       └── errors.go
├── api/                            # API 定义
│   ├── proto/                      # Protocol Buffers
│   │   └── user.proto
│   └── openapi/                    # OpenAPI 规范
│       └── swagger.yaml
├── deployments/                    # 部署配置
│   ├── docker/
│   │   └── Dockerfile
│   └── k8s/
│       ├── deployment.yaml
│       ├── service.yaml
│       └── configmap.yaml
├── scripts/                        # 脚本
│   ├── build.sh
│   └── test.sh
├── test/                           # 测试
│   ├── integration/
│   └── e2e/
├── configs/                        # 配置文件
│   ├── config.dev.yaml
│   ├── config.prod.yaml
│   └── otel-collector.yaml
├── docs/                           # 文档
│   └── architecture.md
├── go.mod
├── go.sum
├── Makefile
└── README.md
```

### 2. 依赖管理

**go.mod**:

```go
module github.com/yourorg/my-go-service

go 1.25.1

require (
    // OpenTelemetry 核心
    go.opentelemetry.io/otel v1.32.0
    go.opentelemetry.io/otel/trace v1.32.0
    go.opentelemetry.io/otel/metric v1.32.0
    go.opentelemetry.io/otel/sdk v1.32.0
    go.opentelemetry.io/otel/sdk/metric v1.32.0
    
    // OpenTelemetry 导出器
    go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.32.0
    go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.32.0
    go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc v1.32.0
    go.opentelemetry.io/otel/exporters/prometheus v0.54.0
    
    // OpenTelemetry 自动化
    go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.57.0
    go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.57.0
    go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin v0.57.0
    
    // Web 框架
    github.com/gin-gonic/gin v1.10.0
    github.com/gorilla/mux v1.8.1
    
    // gRPC
    google.golang.org/grpc v1.68.0
    google.golang.org/protobuf v1.35.2
    
    // 数据库
    github.com/jackc/pgx/v5 v5.7.1
    gorm.io/gorm v1.25.12
    gorm.io/driver/postgres v1.5.9
    
    // 缓存
    github.com/redis/go-redis/v9 v9.7.0
    
    // 消息队列
    github.com/segmentio/kafka-go v0.4.47
    github.com/rabbitmq/amqp091-go v1.10.0
    
    // 配置
    github.com/spf13/viper v1.19.0
    
    // 日志
    go.uber.org/zap v1.27.0
    
    // 并发
    golang.org/x/sync v0.10.0
    
    // 测试
    github.com/stretchr/testify v1.10.0
    github.com/testcontainers/testcontainers-go v0.34.0
)
```

---

## 核心模块实现

### 3. 主程序入口

**cmd/server/main.go**:

```go
package main

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"

    "github.com/yourorg/my-go-service/internal/application/user"
    "github.com/yourorg/my-go-service/internal/config"
    "github.com/yourorg/my-go-service/internal/infrastructure/repository"
    "github.com/yourorg/my-go-service/pkg/observability"
    
    "github.com/gin-gonic/gin"
    "go.uber.org/zap"
)

func main() {
    // 1. 加载配置
    cfg, err := config.Load()
    if err != nil {
        log.Fatalf("加载配置失败: %v", err)
    }

    // 2. 初始化日志
    logger, err := zap.NewProduction()
    if err != nil {
        log.Fatalf("初始化日志失败: %v", err)
    }
    defer logger.Sync()

    // 3. 初始化可观测性
    shutdown, err := observability.InitProvider(cfg.Observability)
    if err != nil {
        logger.Fatal("初始化可观测性失败", zap.Error(err))
    }
    defer shutdown()

    // 4. 初始化基础设施
    db, err := repository.NewPostgresDB(cfg.Database)
    if err != nil {
        logger.Fatal("连接数据库失败", zap.Error(err))
    }
    defer db.Close()

    // 5. 初始化服务
    userRepo := repository.NewUserRepository(db)
    userHandler := user.NewHandler(userRepo, logger)

    // 6. 设置路由
    router := setupRouter(userHandler)

    // 7. 启动服务器
    srv := &http.Server{
        Addr:    fmt.Sprintf(":%d", cfg.Server.Port),
        Handler: router,
    }

    // 8. 优雅关闭
    go func() {
        logger.Info("启动服务器", zap.Int("port", cfg.Server.Port))
        if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            logger.Fatal("服务器启动失败", zap.Error(err))
        }
    }()

    // 等待中断信号
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit

    logger.Info("关闭服务器...")

    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    if err := srv.Shutdown(ctx); err != nil {
        logger.Fatal("服务器强制关闭", zap.Error(err))
    }

    logger.Info("服务器已退出")
}

func setupRouter(userHandler *user.Handler) *gin.Engine {
    router := gin.New()
    
    // 中间件
    router.Use(gin.Recovery())
    router.Use(otelgin.Middleware("my-go-service"))
    
    // 健康检查
    router.GET("/health", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{"status": "ok"})
    })
    
    // API 路由
    api := router.Group("/api/v1")
    {
        users := api.Group("/users")
        {
            users.GET("/:id", userHandler.GetUser)
            users.POST("", userHandler.CreateUser)
            users.PUT("/:id", userHandler.UpdateUser)
            users.DELETE("/:id", userHandler.DeleteUser)
        }
    }
    
    return router
}
```

### 4. 配置管理

**internal/config/config.go**:

```go
package config

import (
    "fmt"
    "time"

    "github.com/spf13/viper"
)

// Config 应用配置
type Config struct {
    Server        ServerConfig
    Database      DatabaseConfig
    Redis         RedisConfig
    Kafka         KafkaConfig
    Observability ObservabilityConfig
}

// ServerConfig 服务器配置
type ServerConfig struct {
    Port         int           `mapstructure:"port"`
    ReadTimeout  time.Duration `mapstructure:"read_timeout"`
    WriteTimeout time.Duration `mapstructure:"write_timeout"`
    IdleTimeout  time.Duration `mapstructure:"idle_timeout"`
}

// DatabaseConfig 数据库配置
type DatabaseConfig struct {
    Host            string        `mapstructure:"host"`
    Port            int           `mapstructure:"port"`
    User            string        `mapstructure:"user"`
    Password        string        `mapstructure:"password"`
    Database        string        `mapstructure:"database"`
    MaxOpenConns    int           `mapstructure:"max_open_conns"`
    MaxIdleConns    int           `mapstructure:"max_idle_conns"`
    ConnMaxLifetime time.Duration `mapstructure:"conn_max_lifetime"`
}

// RedisConfig Redis 配置
type RedisConfig struct {
    Host     string `mapstructure:"host"`
    Port     int    `mapstructure:"port"`
    Password string `mapstructure:"password"`
    DB       int    `mapstructure:"db"`
}

// KafkaConfig Kafka 配置
type KafkaConfig struct {
    Brokers []string `mapstructure:"brokers"`
    Topic   string   `mapstructure:"topic"`
}

// ObservabilityConfig 可观测性配置
type ObservabilityConfig struct {
    ServiceName    string  `mapstructure:"service_name"`
    ServiceVersion string  `mapstructure:"service_version"`
    OTLPEndpoint   string  `mapstructure:"otlp_endpoint"`
    SamplingRate   float64 `mapstructure:"sampling_rate"`
    EnableMetrics  bool    `mapstructure:"enable_metrics"`
    EnableTracing  bool    `mapstructure:"enable_tracing"`
    EnableLogging  bool    `mapstructure:"enable_logging"`
}

// Load 加载配置
func Load() (*Config, error) {
    viper.SetConfigName("config")
    viper.SetConfigType("yaml")
    viper.AddConfigPath("./configs")
    viper.AddConfigPath(".")

    // 环境变量覆盖
    viper.AutomaticEnv()

    // 设置默认值
    setDefaults()

    if err := viper.ReadInConfig(); err != nil {
        return nil, fmt.Errorf("读取配置文件失败: %w", err)
    }

    var config Config
    if err := viper.Unmarshal(&config); err != nil {
        return nil, fmt.Errorf("解析配置失败: %w", err)
    }

    return &config, nil
}

func setDefaults() {
    // 服务器默认值
    viper.SetDefault("server.port", 8080)
    viper.SetDefault("server.read_timeout", 15*time.Second)
    viper.SetDefault("server.write_timeout", 15*time.Second)
    viper.SetDefault("server.idle_timeout", 60*time.Second)

    // 数据库默认值
    viper.SetDefault("database.max_open_conns", 25)
    viper.SetDefault("database.max_idle_conns", 5)
    viper.SetDefault("database.conn_max_lifetime", 5*time.Minute)

    // 可观测性默认值
    viper.SetDefault("observability.service_name", "my-go-service")
    viper.SetDefault("observability.service_version", "1.0.0")
    viper.SetDefault("observability.sampling_rate", 1.0)
    viper.SetDefault("observability.enable_metrics", true)
    viper.SetDefault("observability.enable_tracing", true)
    viper.SetDefault("observability.enable_logging", true)
}
```

**configs/config.dev.yaml**:

```yaml
server:
  port: 8080
  read_timeout: 15s
  write_timeout: 15s
  idle_timeout: 60s

database:
  host: localhost
  port: 5432
  user: postgres
  password: postgres
  database: myapp
  max_open_conns: 25
  max_idle_conns: 5
  conn_max_lifetime: 5m

redis:
  host: localhost
  port: 6379
  password: ""
  db: 0

kafka:
  brokers:
    - localhost:9092
  topic: my-topic

observability:
  service_name: my-go-service
  service_version: 1.0.0
  otlp_endpoint: http://localhost:4317
  sampling_rate: 1.0
  enable_metrics: true
  enable_tracing: true
  enable_logging: true
```

### 5. 可观测性初始化

**pkg/observability/tracing.go**:

```go
package observability

import (
    "context"
    "fmt"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
)

// InitProvider 初始化可观测性提供者
func InitProvider(cfg ObservabilityConfig) (func(), error) {
    ctx := context.Background()

    // 创建资源
    res, err := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName(cfg.ServiceName),
            semconv.ServiceVersion(cfg.ServiceVersion),
        ),
    )
    if err != nil {
        return nil, fmt.Errorf("创建资源失败: %w", err)
    }

    // 初始化追踪
    var tracerShutdown func()
    if cfg.EnableTracing {
        tracerShutdown, err = initTracer(ctx, cfg, res)
        if err != nil {
            return nil, fmt.Errorf("初始化追踪失败: %w", err)
        }
    }

    // 初始化指标
    var meterShutdown func()
    if cfg.EnableMetrics {
        meterShutdown, err = initMeter(ctx, cfg, res)
        if err != nil {
            if tracerShutdown != nil {
                tracerShutdown()
            }
            return nil, fmt.Errorf("初始化指标失败: %w", err)
        }
    }

    // 返回清理函数
    return func() {
        if tracerShutdown != nil {
            tracerShutdown()
        }
        if meterShutdown != nil {
            meterShutdown()
        }
    }, nil
}

func initTracer(ctx context.Context, cfg ObservabilityConfig, res *resource.Resource) (func(), error) {
    // 创建 OTLP 导出器
    exporter, err := otlptracegrpc.New(ctx,
        otlptracegrpc.WithEndpoint(cfg.OTLPEndpoint),
        otlptracegrpc.WithInsecure(),
    )
    if err != nil {
        return nil, err
    }

    // 创建追踪提供者
    tp := sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter),
        sdktrace.WithResource(res),
        sdktrace.WithSampler(sdktrace.TraceIDRatioBased(cfg.SamplingRate)),
    )

    otel.SetTracerProvider(tp)
    otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
        propagation.TraceContext{},
        propagation.Baggage{},
    ))

    return func() {
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        if err := tp.Shutdown(ctx); err != nil {
            fmt.Printf("关闭追踪提供者失败: %v\n", err)
        }
    }, nil
}

func initMeter(ctx context.Context, cfg ObservabilityConfig, res *resource.Resource) (func(), error) {
    // 指标初始化实现
    return func() {}, nil
}
```

---

## 领域驱动设计

### 6. 领域层

**internal/domain/user/user.go**:

```go
package user

import (
    "errors"
    "time"

    "github.com/google/uuid"
)

// User 用户领域模型
type User struct {
    ID        string
    Name      string
    Email     string
    CreatedAt time.Time
    UpdatedAt time.Time
}

// NewUser 创建新用户
func NewUser(name, email string) (*User, error) {
    if name == "" {
        return nil, errors.New("用户名不能为空")
    }
    if email == "" {
        return nil, errors.New("邮箱不能为空")
    }

    return &User{
        ID:        uuid.New().String(),
        Name:      name,
        Email:     email,
        CreatedAt: time.Now(),
        UpdatedAt: time.Now(),
    }, nil
}

// UpdateEmail 更新邮箱
func (u *User) UpdateEmail(email string) error {
    if email == "" {
        return errors.New("邮箱不能为空")
    }

    u.Email = email
    u.UpdatedAt = time.Now()
    return nil
}
```

**internal/domain/user/repository.go**:

```go
package user

import (
    "context"
)

// Repository 用户仓储接口
type Repository interface {
    Create(ctx context.Context, user *User) error
    FindByID(ctx context.Context, id string) (*User, error)
    Update(ctx context.Context, user *User) error
    Delete(ctx context.Context, id string) error
}
```

### 7. 应用层

**internal/application/user/handler.go**:

```go
package user

import (
    "net/http"

    "github.com/gin-gonic/gin"
    "github.com/yourorg/my-go-service/internal/domain/user"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
    "go.uber.org/zap"
)

// Handler 用户处理器
type Handler struct {
    repo   user.Repository
    logger *zap.Logger
    tracer trace.Tracer
}

// NewHandler 创建处理器
func NewHandler(repo user.Repository, logger *zap.Logger) *Handler {
    return &Handler{
        repo:   repo,
        logger: logger,
        tracer: otel.Tracer("user-handler"),
    }
}

// GetUser 获取用户
func (h *Handler) GetUser(c *gin.Context) {
    ctx := c.Request.Context()
    ctx, span := h.tracer.Start(ctx, "GetUser",
        trace.WithSpanKind(trace.SpanKindServer),
    )
    defer span.End()

    userID := c.Param("id")
    span.SetAttributes(attribute.String("user.id", userID))

    user, err := h.repo.FindByID(ctx, userID)
    if err != nil {
        span.RecordError(err)
        h.logger.Error("获取用户失败",
            zap.String("user_id", userID),
            zap.Error(err),
        )
        c.JSON(http.StatusNotFound, gin.H{"error": "用户不存在"})
        return
    }

    c.JSON(http.StatusOK, user)
}

// CreateUser 创建用户
func (h *Handler) CreateUser(c *gin.Context) {
    ctx := c.Request.Context()
    ctx, span := h.tracer.Start(ctx, "CreateUser")
    defer span.End()

    var req CreateUserRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        span.RecordError(err)
        c.JSON(http.StatusBadRequest, gin.H{"error": "无效的请求"})
        return
    }

    user, err := user.NewUser(req.Name, req.Email)
    if err != nil {
        span.RecordError(err)
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    if err := h.repo.Create(ctx, user); err != nil {
        span.RecordError(err)
        h.logger.Error("创建用户失败", zap.Error(err))
        c.JSON(http.StatusInternalServerError, gin.H{"error": "创建用户失败"})
        return
    }

    c.JSON(http.StatusCreated, user)
}

// UpdateUser 更新用户
func (h *Handler) UpdateUser(c *gin.Context) {
    // 实现更新逻辑
}

// DeleteUser 删除用户
func (h *Handler) DeleteUser(c *gin.Context) {
    // 实现删除逻辑
}
```

**internal/application/user/dto.go**:

```go
package user

// CreateUserRequest 创建用户请求
type CreateUserRequest struct {
    Name  string `json:"name" binding:"required"`
    Email string `json:"email" binding:"required,email"`
}

// UpdateUserRequest 更新用户请求
type UpdateUserRequest struct {
    Name  string `json:"name"`
    Email string `json:"email" binding:"omitempty,email"`
}
```

### 8. 基础设施层

**internal/infrastructure/repository/user_postgres.go**:

```go
package repository

import (
    "context"
    "database/sql"

    "github.com/yourorg/my-go-service/internal/domain/user"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// UserRepository 用户仓储实现
type UserRepository struct {
    db     *sql.DB
    tracer trace.Tracer
}

// NewUserRepository 创建用户仓储
func NewUserRepository(db *sql.DB) user.Repository {
    return &UserRepository{
        db:     db,
        tracer: otel.Tracer("user-repository"),
    }
}

// Create 创建用户
func (r *UserRepository) Create(ctx context.Context, u *user.User) error {
    ctx, span := r.tracer.Start(ctx, "UserRepository.Create",
        trace.WithAttributes(
            attribute.String("db.operation", "INSERT"),
            attribute.String("db.table", "users"),
        ),
    )
    defer span.End()

    query := `
        INSERT INTO users (id, name, email, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5)
    `

    _, err := r.db.ExecContext(ctx, query,
        u.ID, u.Name, u.Email, u.CreatedAt, u.UpdatedAt,
    )

    if err != nil {
        span.RecordError(err)
        return err
    }

    return nil
}

// FindByID 根据 ID 查找用户
func (r *UserRepository) FindByID(ctx context.Context, id string) (*user.User, error) {
    ctx, span := r.tracer.Start(ctx, "UserRepository.FindByID",
        trace.WithAttributes(
            attribute.String("db.operation", "SELECT"),
            attribute.String("db.table", "users"),
            attribute.String("user.id", id),
        ),
    )
    defer span.End()

    query := `
        SELECT id, name, email, created_at, updated_at
        FROM users
        WHERE id = $1
    `

    var u user.User
    err := r.db.QueryRowContext(ctx, query, id).Scan(
        &u.ID, &u.Name, &u.Email, &u.CreatedAt, &u.UpdatedAt,
    )

    if err != nil {
        span.RecordError(err)
        return nil, err
    }

    return &u, nil
}

// Update 更新用户
func (r *UserRepository) Update(ctx context.Context, u *user.User) error {
    // 实现更新逻辑
    return nil
}

// Delete 删除用户
func (r *UserRepository) Delete(ctx context.Context, id string) error {
    // 实现删除逻辑
    return nil
}
```

---

## 中间件和工具

### 9. HTTP 中间件

**internal/middleware/tracing.go**:

```go
package middleware

import (
    "github.com/gin-gonic/gin"
    "go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
)

// Tracing 追踪中间件
func Tracing(serviceName string) gin.HandlerFunc {
    return otelgin.Middleware(serviceName)
}
```

**internal/middleware/logging.go**:

```go
package middleware

import (
    "time"

    "github.com/gin-gonic/gin"
    "go.opentelemetry.io/otel/trace"
    "go.uber.org/zap"
)

// Logging 日志中间件
func Logging(logger *zap.Logger) gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()

        // 获取 trace ID
        span := trace.SpanFromContext(c.Request.Context())
        traceID := span.SpanContext().TraceID().String()

        c.Next()

        logger.Info("HTTP请求",
            zap.String("method", c.Request.Method),
            zap.String("path", c.Request.URL.Path),
            zap.Int("status", c.Writer.Status()),
            zap.Duration("duration", time.Since(start)),
            zap.String("trace_id", traceID),
        )
    }
}
```

### 10. gRPC 拦截器

**internal/middleware/grpc_interceptor.go**:

```go
package middleware

import (
    "context"
    "time"

    "google.golang.org/grpc"
    "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
    "go.uber.org/zap"
)

// GRPCTracingInterceptor gRPC 追踪拦截器
func GRPCTracingInterceptor() grpc.UnaryServerInterceptor {
    return otelgrpc.UnaryServerInterceptor()
}

// GRPCLoggingInterceptor gRPC 日志拦截器
func GRPCLoggingInterceptor(logger *zap.Logger) grpc.UnaryServerInterceptor {
    return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
        start := time.Now()

        resp, err := handler(ctx, req)

        logger.Info("gRPC请求",
            zap.String("method", info.FullMethod),
            zap.Duration("duration", time.Since(start)),
            zap.Bool("error", err != nil),
        )

        return resp, err
    }
}
```

---

## 测试策略

### 11. 单元测试模板

**internal/domain/user/user_test.go**:

```go
package user_test

import (
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/yourorg/my-go-service/internal/domain/user"
)

func TestNewUser(t *testing.T) {
    tests := []struct {
        name      string
        userName  string
        email     string
        wantErr   bool
        errMsg    string
    }{
        {
            name:     "有效用户",
            userName: "张三",
            email:    "zhangsan@example.com",
            wantErr:  false,
        },
        {
            name:     "空用户名",
            userName: "",
            email:    "zhangsan@example.com",
            wantErr:  true,
            errMsg:   "用户名不能为空",
        },
        {
            name:     "空邮箱",
            userName: "张三",
            email:    "",
            wantErr:  true,
            errMsg:   "邮箱不能为空",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            u, err := user.NewUser(tt.userName, tt.email)

            if tt.wantErr {
                assert.Error(t, err)
                assert.Nil(t, u)
                if tt.errMsg != "" {
                    assert.EqualError(t, err, tt.errMsg)
                }
            } else {
                assert.NoError(t, err)
                assert.NotNil(t, u)
                assert.NotEmpty(t, u.ID)
                assert.Equal(t, tt.userName, u.Name)
                assert.Equal(t, tt.email, u.Email)
            }
        })
    }
}
```

### 12. 集成测试模板

**test/integration/user_test.go**:

```go
package integration

import (
    "context"
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/wait"
)

func TestUserRepository_Integration(t *testing.T) {
    if testing.Short() {
        t.Skip("跳过集成测试")
    }

    ctx := context.Background()

    // 启动 PostgreSQL 容器
    req := testcontainers.ContainerRequest{
        Image:        "postgres:16",
        ExposedPorts: []string{"5432/tcp"},
        Env: map[string]string{
            "POSTGRES_USER":     "test",
            "POSTGRES_PASSWORD": "test",
            "POSTGRES_DB":       "testdb",
        },
        WaitingFor: wait.ForLog("database system is ready to accept connections"),
    }

    container, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
        ContainerRequest: req,
        Started:          true,
    })
    assert.NoError(t, err)
    defer container.Terminate(ctx)

    // 获取容器连接信息
    host, err := container.Host(ctx)
    assert.NoError(t, err)

    port, err := container.MappedPort(ctx, "5432")
    assert.NoError(t, err)

    // 运行测试
    t.Run("创建用户", func(t *testing.T) {
        // 测试逻辑
    })
}
```

---

## 部署配置

### 13. Dockerfile 模板

**deployments/docker/Dockerfile**:

```dockerfile
# 构建阶段
FROM golang:1.25.1-alpine AS builder

WORKDIR /build

# 安装依赖
RUN apk add --no-cache git ca-certificates tzdata

# 复制依赖文件
COPY go.mod go.sum ./
RUN go mod download

# 复制源代码
COPY . .

# 构建应用
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
    -ldflags="-w -s" \
    -o /app/server \
    ./cmd/server

# 运行阶段
FROM alpine:latest

# 安装 ca-certificates
RUN apk --no-cache add ca-certificates tzdata

WORKDIR /app

# 复制构建产物
COPY --from=builder /app/server .
COPY --from=builder /build/configs ./configs

# 创建非 root 用户
RUN addgroup -g 1000 app && \
    adduser -D -u 1000 -G app app && \
    chown -R app:app /app

USER app

EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1

ENTRYPOINT ["./server"]
```

### 14. Kubernetes 配置

**deployments/k8s/deployment.yaml**:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-go-service
  labels:
    app: my-go-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-go-service
  template:
    metadata:
      labels:
        app: my-go-service
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      containers:
      - name: my-go-service
        image: my-go-service:latest
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
          name: http
        env:
        - name: OBSERVABILITY_OTLP_ENDPOINT
          value: "otel-collector:4317"
        - name: DATABASE_HOST
          value: "postgres"
        - name: REDIS_HOST
          value: "redis"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 15
          periodSeconds: 20
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: my-go-service
spec:
  selector:
    app: my-go-service
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: ClusterIP
```

### 15. CI/CD 配置

**.github/workflows/ci.yaml**:

```yaml
name: CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: 设置 Go 环境
      uses: actions/setup-go@v5
      with:
        go-version: '1.25.1'

    - name: 下载依赖
      run: go mod download

    - name: 运行测试
      run: go test -v -race -coverprofile=coverage.out ./...

    - name: 上传覆盖率
      uses: codecov/codecov-action@v4
      with:
        files: ./coverage.out

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: 构建 Docker 镜像
      run: docker build -t my-go-service:${{ github.sha }} -f deployments/docker/Dockerfile .

    - name: 推送镜像
      if: github.ref == 'refs/heads/main'
      run: |
        echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
        docker push my-go-service:${{ github.sha }}
```

---

## 开发工具链

### 16. Makefile

**Makefile**:

```makefile
.PHONY: help build test run clean docker lint

# 变量
APP_NAME := my-go-service
VERSION := $(shell git describe --tags --always --dirty)
BUILD_TIME := $(shell date -u '+%Y-%m-%d_%H:%M:%S')
LDFLAGS := -w -s -X main.Version=$(VERSION) -X main.BuildTime=$(BUILD_TIME)

help: ## 显示帮助信息
 @grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-20s\033[0m %s\n", $$1, $$2}'

build: ## 构建应用
 @echo "构建 $(APP_NAME)..."
 @go build -ldflags="$(LDFLAGS)" -o bin/$(APP_NAME) ./cmd/server

test: ## 运行测试
 @echo "运行测试..."
 @go test -v -race -coverprofile=coverage.out ./...
 @go tool cover -html=coverage.out -o coverage.html

test-integration: ## 运行集成测试
 @echo "运行集成测试..."
 @go test -v -tags=integration ./test/integration/...

benchmark: ## 运行基准测试
 @echo "运行基准测试..."
 @go test -bench=. -benchmem ./...

run: ## 运行应用
 @echo "运行 $(APP_NAME)..."
 @go run ./cmd/server

clean: ## 清理构建产物
 @echo "清理..."
 @rm -rf bin/
 @rm -f coverage.out coverage.html

docker-build: ## 构建 Docker 镜像
 @echo "构建 Docker 镜像..."
 @docker build -t $(APP_NAME):$(VERSION) -f deployments/docker/Dockerfile .

docker-run: ## 运行 Docker 容器
 @docker run -p 8080:8080 $(APP_NAME):$(VERSION)

lint: ## 运行代码检查
 @echo "运行 golangci-lint..."
 @golangci-lint run ./...

fmt: ## 格式化代码
 @echo "格式化代码..."
 @go fmt ./...
 @goimports -w .

vet: ## 运行 go vet
 @echo "运行 go vet..."
 @go vet ./...

deps: ## 更新依赖
 @echo "更新依赖..."
 @go mod tidy
 @go mod download

proto: ## 生成 protobuf 代码
 @echo "生成 protobuf 代码..."
 @protoc --go_out=. --go-grpc_out=. api/proto/*.proto

.DEFAULT_GOAL := help
```

### 17. 代码质量工具

**.golangci.yml**:

```yaml
linters-settings:
  govet:
    check-shadowing: true
  gocyclo:
    min-complexity: 15
  dupl:
    threshold: 100
  goconst:
    min-len: 2
    min-occurrences: 2

linters:
  enable:
    - govet
    - errcheck
    - staticcheck
    - unused
    - gosimple
    - structcheck
    - varcheck
    - ineffassign
    - deadcode
    - typecheck
    - gocyclo
    - gofmt
    - goimports
    - misspell
    - unparam
    - goconst
    - dupl

run:
  timeout: 5m
  tests: true

issues:
  exclude-rules:
    - path: _test\.go
      linters:
        - gocyclo
        - errcheck
        - dupl
```

---

## 总结

本文档提供了完整的 Go 项目模板和工程最佳实践，包括：

### 项目结构

1. ✅ **标准目录布局** - 清晰的分层架构
2. ✅ **依赖管理** - go.mod 配置和版本控制
3. ✅ **配置管理** - Viper 配置加载和环境变量

### 核心实现

1. ✅ **主程序入口** - 优雅启动和关闭
2. ✅ **可观测性集成** - OpenTelemetry 完整配置
3. ✅ **领域驱动设计** - 清晰的业务逻辑分层

### 基础设施

1. ✅ **数据访问层** - Repository 模式实现
2. ✅ **中间件系统** - HTTP 和 gRPC 拦截器
3. ✅ **错误处理** - 统一的错误管理

### 测试和部署

1. ✅ **测试策略** - 单元、集成、端到端测试
2. ✅ **容器化** - Docker 多阶段构建
3. ✅ **Kubernetes** - 生产级部署配置
4. ✅ **CI/CD** - GitHub Actions 工作流

### 开发工具

1. ✅ **Makefile** - 自动化构建和测试
2. ✅ **代码质量** - Linter 配置和规范

### 相关文档

- [Go_1.25.1_完整集成指南.md](./01_Go_1.25.1_完整集成指南.md)
- [Go生产级部署与运维最佳实践.md](./07_Go生产级部署与运维最佳实践.md)
- [Go容器化与Kubernetes深度集成.md](./08_Go容器化与Kubernetes深度集成.md)
- [Go测试与基准测试完整指南.md](./04_Go测试与基准测试完整指南.md)
