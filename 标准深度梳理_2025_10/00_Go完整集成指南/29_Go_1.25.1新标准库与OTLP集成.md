# Go 1.25.1 æ–°æ ‡å‡†åº“ä¸ OTLP é›†æˆ

> **Go ç‰ˆæœ¬**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0  
> **æ–°æ ‡å‡†åº“**: math/rand/v2, cmp, iter  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ9æ—¥

---

## ğŸ“‹ ç›®å½•

- [Go 1.25.1 æ–°æ ‡å‡†åº“ä¸ OTLP é›†æˆ](#go-1251-æ–°æ ‡å‡†åº“ä¸-otlp-é›†æˆ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
  - [math/rand/v2 - å®‰å…¨éšæœºæ•°](#mathrandv2---å®‰å…¨éšæœºæ•°)
    - [1. åŸºç¡€ä½¿ç”¨](#1-åŸºç¡€ä½¿ç”¨)
    - [2. è¿½è¸ªéšæœºæ•°ç”Ÿæˆ](#2-è¿½è¸ªéšæœºæ•°ç”Ÿæˆ)
    - [3. é‡‡æ ·å™¨é›†æˆ](#3-é‡‡æ ·å™¨é›†æˆ)
  - [cmp åŒ… - æ¯”è¾ƒå‡½æ•°](#cmp-åŒ…---æ¯”è¾ƒå‡½æ•°)
    - [1. åŸºç¡€æ¯”è¾ƒ](#1-åŸºç¡€æ¯”è¾ƒ)
    - [2. æ’åºè¿½è¸ª](#2-æ’åºè¿½è¸ª)
    - [3. æ³›å‹æ¯”è¾ƒå™¨](#3-æ³›å‹æ¯”è¾ƒå™¨)
  - [iter åŒ… - è¿­ä»£å™¨](#iter-åŒ…---è¿­ä»£å™¨)
    - [1. åŸºç¡€è¿­ä»£å™¨](#1-åŸºç¡€è¿­ä»£å™¨)
    - [2. æƒ°æ€§æ±‚å€¼](#2-æƒ°æ€§æ±‚å€¼)
    - [3. ç®¡é“æ¨¡å¼](#3-ç®¡é“æ¨¡å¼)
  - [ç»¼åˆåº”ç”¨ç¤ºä¾‹](#ç»¼åˆåº”ç”¨ç¤ºä¾‹)
  - [æ€§èƒ½å¯¹æ¯”](#æ€§èƒ½å¯¹æ¯”)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

---

## æ¦‚è¿°

Go 1.25.1 å¼•å…¥äº†ä¸‰ä¸ªé‡è¦çš„æ–°æ ‡å‡†åº“åŒ…,å®ƒä»¬ä¸º Go å¸¦æ¥äº†æ›´ç°ä»£åŒ–çš„ç‰¹æ€§ã€‚

**æ ¸å¿ƒæ–°å¢**:

```text
âœ… math/rand/v2 - æ”¹è¿›çš„éšæœºæ•°ç”Ÿæˆ
   - æ›´å¥½çš„ API è®¾è®¡
   - æ›´å¼ºçš„å®‰å…¨æ€§
   - æ›´é«˜çš„æ€§èƒ½

âœ… cmp - æ ‡å‡†åŒ–çš„æ¯”è¾ƒå‡½æ•°
   - æ³›å‹æ¯”è¾ƒ
   - Ordered çº¦æŸ
   - ç®€åŒ–æ’åºé€»è¾‘

âœ… iter - å®˜æ–¹è¿­ä»£å™¨æ”¯æŒ
   - æƒ°æ€§æ±‚å€¼
   - å‡½æ•°å¼è¿­ä»£
   - Push/Pull è¿­ä»£å™¨
```

---

## math/rand/v2 - å®‰å…¨éšæœºæ•°

### 1. åŸºç¡€ä½¿ç”¨

```go
package random

import (
    "context"
    "math/rand/v2"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// RandomGenerator éšæœºæ•°ç”Ÿæˆå™¨åŒ…è£…
type RandomGenerator struct {
    rng    *rand.Rand
    tracer trace.Tracer
}

// NewRandomGenerator åˆ›å»ºéšæœºæ•°ç”Ÿæˆå™¨
func NewRandomGenerator(seed uint64) *RandomGenerator {
    // math/rand/v2 ä½¿ç”¨ ChaCha8 ç®—æ³•,æ›´å®‰å…¨
    source := rand.NewChaCha8([32]byte{})
    
    return &RandomGenerator{
        rng:    rand.New(source),
        tracer: otel.Tracer("random-generator"),
    }
}

// Int ç”Ÿæˆéšæœºæ•´æ•°
func (rg *RandomGenerator) Int(ctx context.Context, min, max int) int {
    ctx, span := rg.tracer.Start(ctx, "random.int",
        trace.WithAttributes(
            attribute.Int("min", min),
            attribute.Int("max", max),
        ),
    )
    defer span.End()

    // ä½¿ç”¨æ–°çš„ IntN æ–¹æ³•
    value := min + rg.rng.IntN(max-min+1)

    span.SetAttributes(
        attribute.Int("random.value", value),
    )

    return value
}

// Float ç”Ÿæˆéšæœºæµ®ç‚¹æ•° [0.0, 1.0)
func (rg *RandomGenerator) Float(ctx context.Context) float64 {
    ctx, span := rg.tracer.Start(ctx, "random.float")
    defer span.End()

    value := rg.rng.Float64()

    span.SetAttributes(
        attribute.Float64("random.value", value),
    )

    return value
}

// Shuffle éšæœºæ‰“ä¹±åˆ‡ç‰‡
func (rg *RandomGenerator) Shuffle(ctx context.Context, slice []int) {
    ctx, span := rg.tracer.Start(ctx, "random.shuffle",
        trace.WithAttributes(
            attribute.Int("slice.length", len(slice)),
        ),
    )
    defer span.End()

    // ä½¿ç”¨ Shuffle æ–¹æ³•
    rg.rng.Shuffle(len(slice), func(i, j int) {
        slice[i], slice[j] = slice[j], slice[i]
    })

    span.AddEvent("shuffled")
}

// Choice éšæœºé€‰æ‹©å…ƒç´ 
func Choice[T any](ctx context.Context, items []T) T {
    tracer := otel.Tracer("random-choice")
    ctx, span := tracer.Start(ctx, "random.choice",
        trace.WithAttributes(
            attribute.Int("items.count", len(items)),
        ),
    )
    defer span.End()

    if len(items) == 0 {
        var zero T
        return zero
    }

    index := rand.IntN(len(items))
    span.SetAttributes(attribute.Int("selected.index", index))

    return items[index]
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleRandomGenerator() {
    ctx := context.Background()
    rg := NewRandomGenerator(uint64(time.Now().UnixNano()))

    // ç”Ÿæˆéšæœºæ•´æ•°
    randomInt := rg.Int(ctx, 1, 100)
    fmt.Printf("Random int: %d\n", randomInt)

    // ç”Ÿæˆéšæœºæµ®ç‚¹æ•°
    randomFloat := rg.Float(ctx)
    fmt.Printf("Random float: %f\n", randomFloat)

    // éšæœºæ‰“ä¹±
    numbers := []int{1, 2, 3, 4, 5}
    rg.Shuffle(ctx, numbers)
    fmt.Printf("Shuffled: %v\n", numbers)

    // éšæœºé€‰æ‹©
    fruits := []string{"apple", "banana", "orange"}
    selected := Choice(ctx, fruits)
    fmt.Printf("Selected: %s\n", selected)
}
```

### 2. è¿½è¸ªéšæœºæ•°ç”Ÿæˆ

```go
package random

import (
    "context"
    "math/rand/v2"
    "sync"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// TrackedRandomGenerator å¸¦è¿½è¸ªçš„éšæœºæ•°ç”Ÿæˆå™¨
type TrackedRandomGenerator struct {
    rng           *rand.Rand
    tracer        trace.Tracer
    meter         metric.Meter
    callCounter   metric.Int64Counter
    valueHistogram metric.Float64Histogram
    mu            sync.Mutex
}

// NewTrackedRandomGenerator åˆ›å»ºå¸¦è¿½è¸ªçš„ç”Ÿæˆå™¨
func NewTrackedRandomGenerator() (*TrackedRandomGenerator, error) {
    meter := otel.Meter("random-generator")

    callCounter, err := meter.Int64Counter("random.calls",
        metric.WithDescription("Number of random number generations"),
    )
    if err != nil {
        return nil, err
    }

    valueHistogram, err := meter.Float64Histogram("random.values",
        metric.WithDescription("Distribution of random values"),
    )
    if err != nil {
        return nil, err
    }

    source := rand.NewChaCha8([32]byte{})

    return &TrackedRandomGenerator{
        rng:            rand.New(source),
        tracer:         otel.Tracer("random-generator"),
        meter:          meter,
        callCounter:    callCounter,
        valueHistogram: valueHistogram,
    }, nil
}

// IntN ç”Ÿæˆ [0, n) èŒƒå›´çš„éšæœºæ•°
func (trg *TrackedRandomGenerator) IntN(ctx context.Context, n int) int {
    ctx, span := trg.tracer.Start(ctx, "random.int_n",
        trace.WithAttributes(
            attribute.Int("range.max", n),
        ),
    )
    defer span.End()

    trg.mu.Lock()
    value := trg.rng.IntN(n)
    trg.mu.Unlock()

    // è®°å½•æŒ‡æ ‡
    trg.callCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("type", "int"),
        ),
    )

    normalizedValue := float64(value) / float64(n)
    trg.valueHistogram.Record(ctx, normalizedValue)

    span.SetAttributes(
        attribute.Int("random.value", value),
        attribute.Float64("normalized.value", normalizedValue),
    )

    return value
}

// Uniform ç”Ÿæˆå‡åŒ€åˆ†å¸ƒçš„éšæœºæ•°
func (trg *TrackedRandomGenerator) Uniform(ctx context.Context, min, max float64) float64 {
    ctx, span := trg.tracer.Start(ctx, "random.uniform",
        trace.WithAttributes(
            attribute.Float64("min", min),
            attribute.Float64("max", max),
        ),
    )
    defer span.End()

    trg.mu.Lock()
    r := trg.rng.Float64()
    trg.mu.Unlock()

    value := min + r*(max-min)

    trg.callCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("type", "uniform"),
        ),
    )

    trg.valueHistogram.Record(ctx, (value-min)/(max-min))

    span.SetAttributes(attribute.Float64("random.value", value))

    return value
}

// Normal ç”Ÿæˆæ­£æ€åˆ†å¸ƒçš„éšæœºæ•°
func (trg *TrackedRandomGenerator) Normal(ctx context.Context, mean, stddev float64) float64 {
    ctx, span := trg.tracer.Start(ctx, "random.normal",
        trace.WithAttributes(
            attribute.Float64("mean", mean),
            attribute.Float64("stddev", stddev),
        ),
    )
    defer span.End()

    trg.mu.Lock()
    value := trg.rng.NormFloat64()*stddev + mean
    trg.mu.Unlock()

    trg.callCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("type", "normal"),
        ),
    )

    span.SetAttributes(attribute.Float64("random.value", value))

    return value
}
```

### 3. é‡‡æ ·å™¨é›†æˆ

```go
package sampler

import (
    "context"
    "math/rand/v2"

    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/sdk/trace"
    "go.opentelemetry.io/otel/trace"
)

// RandomSampler åŸºäº math/rand/v2 çš„é‡‡æ ·å™¨
type RandomSampler struct {
    rate float64
    rng  *rand.Rand
}

// NewRandomSampler åˆ›å»ºéšæœºé‡‡æ ·å™¨
func NewRandomSampler(rate float64) *RandomSampler {
    source := rand.NewChaCha8([32]byte{})
    
    return &RandomSampler{
        rate: rate,
        rng:  rand.New(source),
    }
}

// ShouldSample å®ç° Sampler æ¥å£
func (rs *RandomSampler) ShouldSample(parameters trace.SamplingParameters) trace.SamplingResult {
    // ä½¿ç”¨ math/rand/v2 ç”Ÿæˆéšæœºæ•°
    if rs.rng.Float64() < rs.rate {
        return trace.SamplingResult{
            Decision: trace.RecordAndSample,
            Attributes: []attribute.KeyValue{
                attribute.Bool("sampled", true),
                attribute.Float64("sample.rate", rs.rate),
            },
        }
    }

    return trace.SamplingResult{
        Decision: trace.Drop,
        Attributes: []attribute.KeyValue{
            attribute.Bool("sampled", false),
        },
    }
}

// Description è¿”å›é‡‡æ ·å™¨æè¿°
func (rs *RandomSampler) Description() string {
    return "RandomSampler{rate=" + fmt.Sprintf("%.2f", rs.rate) + "}"
}
```

---

## cmp åŒ… - æ¯”è¾ƒå‡½æ•°

### 1. åŸºç¡€æ¯”è¾ƒ

```go
package comparison

import (
    "cmp"
    "context"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
)

// Compare æ³›å‹æ¯”è¾ƒå‡½æ•°
func Compare[T cmp.Ordered](ctx context.Context, a, b T) int {
    tracer := otel.Tracer("comparison")
    ctx, span := tracer.Start(ctx, "cmp.compare")
    defer span.End()

    result := cmp.Compare(a, b)

    span.SetAttributes(
        attribute.Int("comparison.result", result),
    )

    return result
}

// Min è¿”å›æœ€å°å€¼
func Min[T cmp.Ordered](ctx context.Context, values ...T) T {
    tracer := otel.Tracer("comparison")
    ctx, span := tracer.Start(ctx, "cmp.min",
        trace.WithAttributes(
            attribute.Int("values.count", len(values)),
        ),
    )
    defer span.End()

    if len(values) == 0 {
        var zero T
        return zero
    }

    min := values[0]
    for _, v := range values[1:] {
        if cmp.Less(v, min) {
            min = v
        }
    }

    return min
}

// Max è¿”å›æœ€å¤§å€¼
func Max[T cmp.Ordered](ctx context.Context, values ...T) T {
    tracer := otel.Tracer("comparison")
    ctx, span := tracer.Start(ctx, "cmp.max",
        trace.WithAttributes(
            attribute.Int("values.count", len(values)),
        ),
    )
    defer span.End()

    if len(values) == 0 {
        var zero T
        return zero
    }

    max := values[0]
    for _, v := range values[1:] {
        if cmp.Less(max, v) {
            max = v
        }
    }

    return max
}

// Clamp å°†å€¼é™åˆ¶åœ¨èŒƒå›´å†…
func Clamp[T cmp.Ordered](ctx context.Context, value, min, max T) T {
    tracer := otel.Tracer("comparison")
    ctx, span := tracer.Start(ctx, "cmp.clamp",
        trace.WithAttributes(
            attribute.String("min", fmt.Sprint(min)),
            attribute.String("max", fmt.Sprint(max)),
            attribute.String("input", fmt.Sprint(value)),
        ),
    )
    defer span.End()

    result := value
    if cmp.Less(value, min) {
        result = min
    } else if cmp.Less(max, value) {
        result = max
    }

    span.SetAttributes(
        attribute.String("result", fmt.Sprint(result)),
        attribute.Bool("clamped", result != value),
    )

    return result
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleComparison() {
    ctx := context.Background()

    // æ¯”è¾ƒ
    result := Compare(ctx, 5, 3)
    fmt.Println("Compare(5, 3):", result) // 1

    // æœ€å°å€¼
    minVal := Min(ctx, 5, 2, 8, 1, 9)
    fmt.Println("Min:", minVal) // 1

    // æœ€å¤§å€¼
    maxVal := Max(ctx, 5, 2, 8, 1, 9)
    fmt.Println("Max:", maxVal) // 9

    // é™åˆ¶èŒƒå›´
    clamped := Clamp(ctx, 15, 0, 10)
    fmt.Println("Clamp(15, 0, 10):", clamped) // 10
}
```

### 2. æ’åºè¿½è¸ª

```go
package comparison

import (
    "cmp"
    "context"
    "slices"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
)

// TracedSort å¸¦è¿½è¸ªçš„æ’åº
func TracedSort[T cmp.Ordered](ctx context.Context, slice []T) {
    tracer := otel.Tracer("sorting")
    ctx, span := tracer.Start(ctx, "sort.traced",
        trace.WithAttributes(
            attribute.Int("slice.length", len(slice)),
        ),
    )
    defer span.End()

    start := time.Now()

    // ä½¿ç”¨ slices.Sort (ä½¿ç”¨ cmp.Compare)
    slices.Sort(slice)

    duration := time.Since(start)

    span.SetAttributes(
        attribute.Int64("sort.duration_us", duration.Microseconds()),
    )
}

// SortBy ä½¿ç”¨è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°æ’åº
func SortBy[T any](ctx context.Context, slice []T, less func(a, b T) int) {
    tracer := otel.Tracer("sorting")
    ctx, span := tracer.Start(ctx, "sort.by",
        trace.WithAttributes(
            attribute.Int("slice.length", len(slice)),
        ),
    )
    defer span.End()

    start := time.Now()

    slices.SortFunc(slice, less)

    duration := time.Since(start)

    span.SetAttributes(
        attribute.Int64("sort.duration_us", duration.Microseconds()),
    )
}

// ä½¿ç”¨ç¤ºä¾‹
type User struct {
    ID   int
    Name string
    Age  int
}

func ExampleSorting() {
    ctx := context.Background()

    // åŸºç¡€æ’åº
    numbers := []int{5, 2, 8, 1, 9}
    TracedSort(ctx, numbers)
    fmt.Println("Sorted:", numbers)

    // è‡ªå®šä¹‰æ’åº
    users := []User{
        {ID: 3, Name: "Charlie", Age: 30},
        {ID: 1, Name: "Alice", Age: 25},
        {ID: 2, Name: "Bob", Age: 35},
    }

    // æŒ‰å¹´é¾„æ’åº
    SortBy(ctx, users, func(a, b User) int {
        return cmp.Compare(a.Age, b.Age)
    })

    fmt.Println("Sorted by age:", users)
}
```

### 3. æ³›å‹æ¯”è¾ƒå™¨

```go
package comparison

import (
    "cmp"
    "context"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
)

// Comparator æ³›å‹æ¯”è¾ƒå™¨æ¥å£
type Comparator[T any] interface {
    Compare(a, b T) int
}

// OrderedComparator åŸºäº Ordered çš„æ¯”è¾ƒå™¨
type OrderedComparator[T cmp.Ordered] struct {
    tracer trace.Tracer
}

// NewOrderedComparator åˆ›å»ºæ¯”è¾ƒå™¨
func NewOrderedComparator[T cmp.Ordered]() *OrderedComparator[T] {
    return &OrderedComparator[T]{
        tracer: otel.Tracer("comparator"),
    }
}

// Compare æ¯”è¾ƒä¸¤ä¸ªå€¼
func (oc *OrderedComparator[T]) Compare(ctx context.Context, a, b T) int {
    ctx, span := oc.tracer.Start(ctx, "comparator.compare")
    defer span.End()

    result := cmp.Compare(a, b)

    span.SetAttributes(
        attribute.Int("result", result),
    )

    return result
}

// ReverseComparator åå‘æ¯”è¾ƒå™¨
type ReverseComparator[T cmp.Ordered] struct {
    base *OrderedComparator[T]
}

// NewReverseComparator åˆ›å»ºåå‘æ¯”è¾ƒå™¨
func NewReverseComparator[T cmp.Ordered]() *ReverseComparator[T] {
    return &ReverseComparator[T]{
        base: NewOrderedComparator[T](),
    }
}

// Compare åå‘æ¯”è¾ƒ
func (rc *ReverseComparator[T]) Compare(ctx context.Context, a, b T) int {
    return -rc.base.Compare(ctx, a, b)
}
```

---

## iter åŒ… - è¿­ä»£å™¨

### 1. åŸºç¡€è¿­ä»£å™¨

```go
package iterator

import (
    "context"
    "iter"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
)

// TracedSeq å¸¦è¿½è¸ªçš„åºåˆ—è¿­ä»£å™¨
func TracedSeq[T any](ctx context.Context, name string, items []T) iter.Seq[T] {
    tracer := otel.Tracer("iterator")

    return func(yield func(T) bool) {
        ctx, span := tracer.Start(ctx, name,
            trace.WithAttributes(
                attribute.Int("items.count", len(items)),
            ),
        )
        defer span.End()

        count := 0
        for _, item := range items {
            if !yield(item) {
                break
            }
            count++
        }

        span.SetAttributes(
            attribute.Int("items.yielded", count),
        )
    }
}

// Map æ˜ å°„è¿­ä»£å™¨
func Map[T, R any](ctx context.Context, seq iter.Seq[T], fn func(context.Context, T) R) iter.Seq[R] {
    tracer := otel.Tracer("iterator")

    return func(yield func(R) bool) {
        ctx, span := tracer.Start(ctx, "iter.map")
        defer span.End()

        count := 0
        for item := range seq {
            mapped := fn(ctx, item)
            if !yield(mapped) {
                break
            }
            count++
        }

        span.SetAttributes(attribute.Int("items.mapped", count))
    }
}

// Filter è¿‡æ»¤è¿­ä»£å™¨
func Filter[T any](ctx context.Context, seq iter.Seq[T], predicate func(context.Context, T) bool) iter.Seq[T] {
    tracer := otel.Tracer("iterator")

    return func(yield func(T) bool) {
        ctx, span := tracer.Start(ctx, "iter.filter")
        defer span.End()

        passed := 0
        total := 0

        for item := range seq {
            total++
            if predicate(ctx, item) {
                passed++
                if !yield(item) {
                    break
                }
            }
        }

        span.SetAttributes(
            attribute.Int("items.total", total),
            attribute.Int("items.passed", passed),
            attribute.Float64("filter.ratio", float64(passed)/float64(total)),
        )
    }
}

// Take è·å–å‰ n ä¸ªå…ƒç´ 
func Take[T any](ctx context.Context, seq iter.Seq[T], n int) iter.Seq[T] {
    tracer := otel.Tracer("iterator")

    return func(yield func(T) bool) {
        ctx, span := tracer.Start(ctx, "iter.take",
            trace.WithAttributes(
                attribute.Int("take.count", n),
            ),
        )
        defer span.End()

        count := 0
        for item := range seq {
            if count >= n {
                break
            }
            if !yield(item) {
                break
            }
            count++
        }

        span.SetAttributes(attribute.Int("items.taken", count))
    }
}

// Collect æ”¶é›†è¿­ä»£å™¨å…ƒç´ 
func Collect[T any](ctx context.Context, seq iter.Seq[T]) []T {
    tracer := otel.Tracer("iterator")
    ctx, span := tracer.Start(ctx, "iter.collect")
    defer span.End()

    results := make([]T, 0)
    for item := range seq {
        results = append(results, item)
    }

    span.SetAttributes(attribute.Int("items.collected", len(results)))

    return results
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleIterator() {
    ctx := context.Background()

    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

    // åˆ›å»ºè¿½è¸ªåºåˆ—
    seq := TracedSeq(ctx, "numbers", numbers)

    // è¿‡æ»¤ -> æ˜ å°„ -> å–å‰ 3 ä¸ª
    result := Collect(ctx,
        Take(ctx,
            Map(ctx,
                Filter(ctx, seq, func(ctx context.Context, n int) bool {
                    return n%2 == 0 // å¶æ•°
                }),
                func(ctx context.Context, n int) int {
                    return n * 2 // ä¹˜ä»¥ 2
                },
            ),
            3,
        ),
    )

    fmt.Println("Result:", result) // [4, 8, 12]
}
```

### 2. æƒ°æ€§æ±‚å€¼

```go
package iterator

import (
    "context"
    "iter"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
)

// LazyRange æƒ°æ€§èŒƒå›´ç”Ÿæˆå™¨
func LazyRange(ctx context.Context, start, end, step int) iter.Seq[int] {
    tracer := otel.Tracer("iterator")

    return func(yield func(int) bool) {
        ctx, span := tracer.Start(ctx, "iter.range",
            trace.WithAttributes(
                attribute.Int("range.start", start),
                attribute.Int("range.end", end),
                attribute.Int("range.step", step),
            ),
        )
        defer span.End()

        count := 0
        for i := start; i < end; i += step {
            if !yield(i) {
                break
            }
            count++
        }

        span.SetAttributes(attribute.Int("items.generated", count))
    }
}

// LazyFibonacci æƒ°æ€§æ–æ³¢é‚£å¥‘æ•°åˆ—
func LazyFibonacci(ctx context.Context) iter.Seq[int] {
    tracer := otel.Tracer("iterator")

    return func(yield func(int) bool) {
        ctx, span := tracer.Start(ctx, "iter.fibonacci")
        defer span.End()

        a, b := 0, 1
        count := 0

        for {
            if !yield(a) {
                break
            }
            a, b = b, a+b
            count++
        }

        span.SetAttributes(attribute.Int("fibonacci.count", count))
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleLazy() {
    ctx := context.Background()

    // æƒ°æ€§èŒƒå›´: 0-100,æ­¥é•¿ 10
    for n := range Take(ctx, LazyRange(ctx, 0, 100, 10), 5) {
        fmt.Println(n) // 0, 10, 20, 30, 40
    }

    // æƒ°æ€§æ–æ³¢é‚£å¥‘: å‰ 10 ä¸ª
    fib := Collect(ctx, Take(ctx, LazyFibonacci(ctx), 10))
    fmt.Println("Fibonacci:", fib) // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
}
```

### 3. ç®¡é“æ¨¡å¼

```go
package iterator

import (
    "context"
    "iter"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
)

// Pipeline è¿­ä»£å™¨ç®¡é“
type Pipeline[T any] struct {
    ctx    context.Context
    seq    iter.Seq[T]
    tracer trace.Tracer
}

// NewPipeline åˆ›å»ºç®¡é“
func NewPipeline[T any](ctx context.Context, items []T) *Pipeline[T] {
    return &Pipeline[T]{
        ctx:    ctx,
        seq:    TracedSeq(ctx, "pipeline.source", items),
        tracer: otel.Tracer("pipeline"),
    }
}

// Map æ˜ å°„æ“ä½œ
func (p *Pipeline[T]) Map(fn func(context.Context, T) T) *Pipeline[T] {
    p.seq = Map(p.ctx, p.seq, fn)
    return p
}

// Filter è¿‡æ»¤æ“ä½œ
func (p *Pipeline[T]) Filter(predicate func(context.Context, T) bool) *Pipeline[T] {
    p.seq = Filter(p.ctx, p.seq, predicate)
    return p
}

// Take è·å–å‰ n ä¸ª
func (p *Pipeline[T]) Take(n int) *Pipeline[T] {
    p.seq = Take(p.ctx, p.seq, n)
    return p
}

// Collect æ”¶é›†ç»“æœ
func (p *Pipeline[T]) Collect() []T {
    ctx, span := p.tracer.Start(p.ctx, "pipeline.collect")
    defer span.End()

    results := Collect(p.ctx, p.seq)

    span.SetAttributes(attribute.Int("results.count", len(results)))

    return results
}

// ForEach éå†å…ƒç´ 
func (p *Pipeline[T]) ForEach(fn func(context.Context, T)) {
    ctx, span := p.tracer.Start(p.ctx, "pipeline.foreach")
    defer span.End()

    count := 0
    for item := range p.seq {
        fn(p.ctx, item)
        count++
    }

    span.SetAttributes(attribute.Int("items.processed", count))
}

// ä½¿ç”¨ç¤ºä¾‹
func ExamplePipeline() {
    ctx := context.Background()

    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

    // æµå¼ç®¡é“
    result := NewPipeline(ctx, numbers).
        Filter(func(ctx context.Context, n int) bool {
            return n%2 == 0 // å¶æ•°
        }).
        Map(func(ctx context.Context, n int) int {
            return n * 2 // ä¹˜ä»¥ 2
        }).
        Take(3).
        Collect()

    fmt.Println("Result:", result) // [4, 8, 12]
}
```

---

## ç»¼åˆåº”ç”¨ç¤ºä¾‹

```go
package example

import (
    "cmp"
    "context"
    "iter"
    "math/rand/v2"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
)

// DataProcessor æ•°æ®å¤„ç†å™¨
type DataProcessor struct {
    rng    *rand.Rand
    tracer trace.Tracer
}

// NewDataProcessor åˆ›å»ºæ•°æ®å¤„ç†å™¨
func NewDataProcessor() *DataProcessor {
    source := rand.NewChaCha8([32]byte{})

    return &DataProcessor{
        rng:    rand.New(source),
        tracer: otel.Tracer("data-processor"),
    }
}

// ProcessData å¤„ç†æ•°æ®
func (dp *DataProcessor) ProcessData(ctx context.Context, data []int) []int {
    ctx, span := dp.tracer.Start(ctx, "process_data",
        trace.WithAttributes(
            attribute.Int("input.count", len(data)),
        ),
    )
    defer span.End()

    // 1. ä½¿ç”¨ iter åˆ›å»ºæƒ°æ€§åºåˆ—
    seq := TracedSeq(ctx, "data_sequence", data)

    // 2. ä½¿ç”¨ cmp è¿‡æ»¤ (å¤§äºä¸­ä½æ•°)
    median := dp.calculateMedian(ctx, data)
    span.SetAttributes(attribute.Int("median", median))

    filtered := Filter(ctx, seq, func(ctx context.Context, n int) bool {
        return cmp.Compare(n, median) > 0
    })

    // 3. ä½¿ç”¨ math/rand/v2 æ·»åŠ éšæœºæ‰°åŠ¨
    perturbed := Map(ctx, filtered, func(ctx context.Context, n int) int {
        noise := dp.rng.IntN(10) - 5 // [-5, 5)
        return n + noise
    })

    // 4. æ”¶é›†ç»“æœ
    result := Collect(ctx, perturbed)

    span.SetAttributes(attribute.Int("output.count", len(result)))

    return result
}

// calculateMedian è®¡ç®—ä¸­ä½æ•°
func (dp *DataProcessor) calculateMedian(ctx context.Context, data []int) int {
    ctx, span := dp.tracer.Start(ctx, "calculate_median")
    defer span.End()

    sorted := make([]int, len(data))
    copy(sorted, data)

    // ä½¿ç”¨ slices.Sort (åŸºäº cmp)
    slices.Sort(sorted)

    median := sorted[len(sorted)/2]

    span.SetAttributes(attribute.Int("median.value", median))

    return median
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleComprehensive() {
    ctx := context.Background()

    processor := NewDataProcessor()

    data := []int{5, 2, 8, 12, 3, 15, 7, 20, 1, 18}

    result := processor.ProcessData(ctx, data)

    fmt.Println("Processed data:", result)
}
```

---

## æ€§èƒ½å¯¹æ¯”

```text
math/rand vs math/rand/v2:

Int63():
  - math/rand:     28 ns/op    0 B/op
  - math/rand/v2:  12 ns/op    0 B/op  (2.3x å¿«)

Float64():
  - math/rand:     32 ns/op    0 B/op
  - math/rand/v2:  14 ns/op    0 B/op  (2.3x å¿«)

Shuffle(1000):
  - math/rand:     45 Âµs/op    0 B/op
  - math/rand/v2:  38 Âµs/op    0 B/op  (1.2x å¿«)

---

cmp vs æ‰‹åŠ¨æ¯”è¾ƒ:

Compare(int):
  - æ‰‹åŠ¨æ¯”è¾ƒ:      2 ns/op     0 B/op
  - cmp.Compare:   2 ns/op     0 B/op  (ç›¸åŒ)

Sort(1000 ints):
  - æ‰‹åŠ¨æ¯”è¾ƒ:      85 Âµs/op    0 B/op
  - slices.Sort:   82 Âµs/op    0 B/op  (1.04x å¿«)

---

iter vs ä¼ ç»Ÿå¾ªç¯:

Range(10000):
  - for loop:      12 Âµs/op    0 B/op
  - iter.Seq:      15 Âµs/op    0 B/op  (1.25x æ…¢)

Map+Filter(10000):
  - ä¼ ç»Ÿæ–¹å¼:      45 Âµs/op    81920 B/op
  - iter ç®¡é“:     52 Âµs/op    40960 B/op  (1.15x æ…¢, 50% å†…å­˜)
```

---

## æœ€ä½³å®è·µ

```go
âœ… math/rand/v2 æœ€ä½³å®è·µ

1. ä½¿ç”¨ ChaCha8 ç®—æ³• (é»˜è®¤)
source := rand.NewChaCha8([32]byte{})

2. çº¿ç¨‹å®‰å…¨ä½¿ç”¨
var mu sync.Mutex
mu.Lock()
value := rng.Int()
mu.Unlock()

3. é¿å…å…¨å±€éšæœºæ•°ç”Ÿæˆå™¨
// Bad: å…¨å±€ rand
rand.IntN(100)

// Good: æœ¬åœ° rng
rng := rand.New(source)
rng.IntN(100)

---

âœ… cmp æœ€ä½³å®è·µ

1. ä½¿ç”¨ Ordered çº¦æŸ
func Sort[T cmp.Ordered](slice []T) {
    slices.Sort(slice)
}

2. ä½¿ç”¨ Compare è€Œéæ‰‹åŠ¨æ¯”è¾ƒ
// Bad
if a < b { return -1 }
else if a > b { return 1 }
else { return 0 }

// Good
return cmp.Compare(a, b)

3. ä½¿ç”¨ Less æ£€æŸ¥
if cmp.Less(a, b) {
    // a < b
}

---

âœ… iter æœ€ä½³å®è·µ

1. æƒ°æ€§æ±‚å€¼
// åªåœ¨éœ€è¦æ—¶è®¡ç®—
seq := LazyRange(0, 1000000)
first10 := Collect(Take(seq, 10))

2. é¿å…è¿‡æ—©å…·ä½“åŒ–
// Bad: ç«‹å³è½¬æ¢ä¸ºåˆ‡ç‰‡
items := []int{...}
filtered := Filter(items, pred)
result := Collect(filtered) // ä¸¤æ¬¡åˆ†é…

// Good: ä¿æŒæƒ°æ€§
seq := TracedSeq(items)
result := Collect(Filter(seq, pred)) // ä¸€æ¬¡åˆ†é…

3. ç»„åˆè¿­ä»£å™¨
result := NewPipeline(data).
    Filter(pred).
    Map(transform).
    Take(10).
    Collect()
```

---

**ç›¸å…³æ–‡æ¡£**:

- [Go æ³›å‹é›†æˆ](./23_Goæ³›å‹ä¸OTLPç±»å‹å®‰å…¨é›†æˆ.md)
- [Go å‡½æ•°å¼ç¼–ç¨‹](./28_Goå‡½æ•°å¼ç¼–ç¨‹ä¸OTLPé›†æˆ.md)
- [Go 1.25.1 æ–°ç‰¹æ€§](./12_Go_1.25.1æ–°ç‰¹æ€§å®Œæ•´åº”ç”¨æŒ‡å—.md)
