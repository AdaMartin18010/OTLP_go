# Go å•å…ƒæµ‹è¯•ä¸åŸºå‡†æµ‹è¯• OTLP é›†æˆå®Œæ•´æŒ‡å—

**ç‰ˆæœ¬**: v2025.1  
**æ›´æ–°æ—¥æœŸ**: 2025-10-11  
**Go ç‰ˆæœ¬**: 1.25.1  
**OpenTelemetry SDK**: v1.32.0

---

## ğŸ“‹ ç›®å½•

- [Go å•å…ƒæµ‹è¯•ä¸åŸºå‡†æµ‹è¯• OTLP é›†æˆå®Œæ•´æŒ‡å—](#go-å•å…ƒæµ‹è¯•ä¸åŸºå‡†æµ‹è¯•-otlp-é›†æˆå®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ ¸å¿ƒæ¦‚å¿µ](#1-æ ¸å¿ƒæ¦‚å¿µ)
    - [1.1 æµ‹è¯•ä¸­çš„å¯è§‚æµ‹æ€§](#11-æµ‹è¯•ä¸­çš„å¯è§‚æµ‹æ€§)
    - [1.2 æµ‹è¯•è¿½è¸ªæ¶æ„](#12-æµ‹è¯•è¿½è¸ªæ¶æ„)
  - [2. æµ‹è¯•ç¯å¢ƒè®¾ç½®](#2-æµ‹è¯•ç¯å¢ƒè®¾ç½®)
    - [2.1 In-Memory Span Recorder](#21-in-memory-span-recorder)
    - [2.2 æµ‹è¯• TracerProvider å·¥å‚](#22-æµ‹è¯•-tracerprovider-å·¥å‚)
  - [3. å•å…ƒæµ‹è¯• OTLP é›†æˆ](#3-å•å…ƒæµ‹è¯•-otlp-é›†æˆ)
    - [3.1 åŸºæœ¬å•å…ƒæµ‹è¯•è¿½è¸ª](#31-åŸºæœ¬å•å…ƒæµ‹è¯•è¿½è¸ª)
    - [3.2 è¡¨é©±åŠ¨æµ‹è¯•è¿½è¸ª](#32-è¡¨é©±åŠ¨æµ‹è¯•è¿½è¸ª)
    - [3.3 å­æµ‹è¯•å¹¶å‘è¿½è¸ª](#33-å­æµ‹è¯•å¹¶å‘è¿½è¸ª)
  - [4. åŸºå‡†æµ‹è¯• OTLP é›†æˆ](#4-åŸºå‡†æµ‹è¯•-otlp-é›†æˆ)
    - [4.1 åŸºç¡€åŸºå‡†æµ‹è¯•](#41-åŸºç¡€åŸºå‡†æµ‹è¯•)
    - [4.2 è¿½è¸ªå¼€é”€åˆ†æåŸºå‡†æµ‹è¯•](#42-è¿½è¸ªå¼€é”€åˆ†æåŸºå‡†æµ‹è¯•)
    - [4.3 é‡‡æ ·ç­–ç•¥åŸºå‡†æµ‹è¯•](#43-é‡‡æ ·ç­–ç•¥åŸºå‡†æµ‹è¯•)
    - [4.4 Context ä¼ é€’åŸºå‡†æµ‹è¯•](#44-context-ä¼ é€’åŸºå‡†æµ‹è¯•)
  - [5. Mock ä¸å­˜æ ¹æ¨¡å¼](#5-mock-ä¸å­˜æ ¹æ¨¡å¼)
    - [5.1 Mock TracerProvider](#51-mock-tracerprovider)
    - [5.2 Mock Exporter](#52-mock-exporter)
    - [5.3 æ¥å£ Mock æ¨¡å¼](#53-æ¥å£-mock-æ¨¡å¼)
  - [6. æµ‹è¯•è¦†ç›–ç‡ä¸è¿½è¸ª](#6-æµ‹è¯•è¦†ç›–ç‡ä¸è¿½è¸ª)
    - [6.1 ç»“åˆè¦†ç›–ç‡å’Œè¿½è¸ªæ•°æ®](#61-ç»“åˆè¦†ç›–ç‡å’Œè¿½è¸ªæ•°æ®)
    - [6.2 è¦†ç›–ç‡æŠ¥å‘Šå¢å¼º](#62-è¦†ç›–ç‡æŠ¥å‘Šå¢å¼º)
  - [7. é›†æˆæµ‹è¯•è¿½è¸ª](#7-é›†æˆæµ‹è¯•è¿½è¸ª)
    - [7.1 HTTP é›†æˆæµ‹è¯•](#71-http-é›†æˆæµ‹è¯•)
    - [7.2 gRPC é›†æˆæµ‹è¯•](#72-grpc-é›†æˆæµ‹è¯•)
  - [8. æ€§èƒ½åˆ†æä¸ä¼˜åŒ–](#8-æ€§èƒ½åˆ†æä¸ä¼˜åŒ–)
    - [8.1 æ€§èƒ½åˆ†ææµ‹è¯•](#81-æ€§èƒ½åˆ†ææµ‹è¯•)
    - [8.2 CPU Profiling](#82-cpu-profiling)
    - [8.3 å†…å­˜ Profiling](#83-å†…å­˜-profiling)
  - [9. æœ€ä½³å®è·µ](#9-æœ€ä½³å®è·µ)
    - [9.1 æµ‹è¯•ç»„ç»‡åŸåˆ™](#91-æµ‹è¯•ç»„ç»‡åŸåˆ™)
    - [9.2 æ–­è¨€è¾…åŠ©å‡½æ•°](#92-æ–­è¨€è¾…åŠ©å‡½æ•°)
    - [9.3 æµ‹è¯•æ•°æ®ç®¡ç†](#93-æµ‹è¯•æ•°æ®ç®¡ç†)
    - [9.4 å¹¶å‘æµ‹è¯•å·¥å…·](#94-å¹¶å‘æµ‹è¯•å·¥å…·)
  - [10. æ€§èƒ½åŸºå‡†å‚è€ƒ](#10-æ€§èƒ½åŸºå‡†å‚è€ƒ)
    - [10.1 å®é™…åŸºå‡†æ•°æ®](#101-å®é™…åŸºå‡†æ•°æ®)
    - [10.2 å†…å­˜ä½¿ç”¨åˆ†æ](#102-å†…å­˜ä½¿ç”¨åˆ†æ)
  - [11. å®Œæ•´æµ‹è¯•ç¤ºä¾‹](#11-å®Œæ•´æµ‹è¯•ç¤ºä¾‹)
    - [11.1 ç»¼åˆæµ‹è¯•å¥—ä»¶](#111-ç»¼åˆæµ‹è¯•å¥—ä»¶)
  - [12. æ€»ç»“](#12-æ€»ç»“)
    - [12.1 å…³é”®è¦ç‚¹](#121-å…³é”®è¦ç‚¹)
    - [12.2 æµ‹è¯•æ£€æŸ¥æ¸…å•](#122-æµ‹è¯•æ£€æŸ¥æ¸…å•)
    - [12.3 å‚è€ƒèµ„æº](#123-å‚è€ƒèµ„æº)

---

## 1. æ ¸å¿ƒæ¦‚å¿µ

### 1.1 æµ‹è¯•ä¸­çš„å¯è§‚æµ‹æ€§

åœ¨æµ‹è¯•ç¯å¢ƒä¸­é›†æˆ OTLPï¼Œå¯ä»¥ï¼š

- **è¿½è¸ªæµ‹è¯•æ‰§è¡Œè·¯å¾„**ï¼šè®°å½•æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹çš„æ‰§è¡Œè½¨è¿¹
- **æ€§èƒ½åŸºå‡†éªŒè¯**ï¼šé€šè¿‡ Span æ•°æ®éªŒè¯æ€§èƒ½æŒ‡æ ‡
- **æµ‹è¯•è¦†ç›–ç‡å¢å¼º**ï¼šç»“åˆä»£ç è¦†ç›–ç‡å’Œè¿½è¸ªæ•°æ®
- **é—®é¢˜å¿«é€Ÿå®šä½**ï¼šå¤±è´¥æµ‹è¯•çš„è¯¦ç»†è¿½è¸ªä¿¡æ¯

### 1.2 æµ‹è¯•è¿½è¸ªæ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Test Runner (go test)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  TestCase 1  â”‚  â”‚  TestCase 2  â”‚  â”‚  TestCase N  â”‚    â”‚
â”‚  â”‚   + Tracer   â”‚  â”‚   + Tracer   â”‚  â”‚   + Tracer   â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚         â”‚                  â”‚                  â”‚          â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                            â”‚                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    In-Memory Exporter                    â”‚
â”‚                  (SpanRecorder/Collector)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚               Assertions & Validations                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. æµ‹è¯•ç¯å¢ƒè®¾ç½®

### 2.1 In-Memory Span Recorder

ç”¨äºæµ‹è¯•ç¯å¢ƒçš„å†…å­˜ Span æ”¶é›†å™¨ï¼š

```go
package testutil

import (
    "context"
    "sync"

    "go.opentelemetry.io/otel/sdk/trace"
    "go.opentelemetry.io/otel/sdk/trace/tracetest"
)

// SpanRecorder æ˜¯çº¿ç¨‹å®‰å…¨çš„æµ‹è¯•ç”¨ Span æ”¶é›†å™¨
type SpanRecorder struct {
    mu    sync.RWMutex
    spans []trace.ReadOnlySpan
}

// NewSpanRecorder åˆ›å»ºæ–°çš„ Span è®°å½•å™¨
func NewSpanRecorder() *SpanRecorder {
    return &SpanRecorder{
        spans: make([]trace.ReadOnlySpan, 0, 10),
    }
}

// OnEnd å®ç° SpanProcessor æ¥å£
func (sr *SpanRecorder) OnEnd(span trace.ReadOnlySpan) {
    sr.mu.Lock()
    defer sr.mu.Unlock()
    sr.spans = append(sr.spans, span)
}

// Shutdown å®ç° SpanProcessor æ¥å£
func (sr *SpanRecorder) Shutdown(ctx context.Context) error {
    sr.mu.Lock()
    defer sr.mu.Unlock()
    sr.spans = nil
    return nil
}

// ForceFlush å®ç° SpanProcessor æ¥å£
func (sr *SpanRecorder) ForceFlush(ctx context.Context) error {
    return nil
}

// GetSpans è¿”å›æ‰€æœ‰è®°å½•çš„ Span (çº¿ç¨‹å®‰å…¨)
func (sr *SpanRecorder) GetSpans() []trace.ReadOnlySpan {
    sr.mu.RLock()
    defer sr.mu.RUnlock()
    
    result := make([]trace.ReadOnlySpan, len(sr.spans))
    copy(result, sr.spans)
    return result
}

// Reset æ¸…ç©ºå·²è®°å½•çš„ Span
func (sr *SpanRecorder) Reset() {
    sr.mu.Lock()
    defer sr.mu.Unlock()
    sr.spans = sr.spans[:0]
}

// FindSpanByName æŸ¥æ‰¾æŒ‡å®šåç§°çš„ Span
func (sr *SpanRecorder) FindSpanByName(name string) []trace.ReadOnlySpan {
    sr.mu.RLock()
    defer sr.mu.RUnlock()
    
    var result []trace.ReadOnlySpan
    for _, span := range sr.spans {
        if span.Name() == name {
            result = append(result, span)
        }
    }
    return result
}

// SpanCount è¿”å›è®°å½•çš„ Span æ•°é‡
func (sr *SpanRecorder) SpanCount() int {
    sr.mu.RLock()
    defer sr.mu.RUnlock()
    return len(sr.spans)
}
```

### 2.2 æµ‹è¯• TracerProvider å·¥å‚

```go
package testutil

import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/sdk/resource"
    "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
)

// TestTracerProviderConfig æµ‹è¯•è¿½è¸ªå™¨é…ç½®
type TestTracerProviderConfig struct {
    ServiceName    string
    ServiceVersion string
    Recorder       *SpanRecorder
}

// NewTestTracerProvider åˆ›å»ºæµ‹è¯•ç”¨ TracerProvider
func NewTestTracerProvider(cfg TestTracerProviderConfig) (*trace.TracerProvider, *SpanRecorder) {
    if cfg.ServiceName == "" {
        cfg.ServiceName = "test-service"
    }
    if cfg.ServiceVersion == "" {
        cfg.ServiceVersion = "test-1.0.0"
    }
    
    recorder := cfg.Recorder
    if recorder == nil {
        recorder = NewSpanRecorder()
    }
    
    res := resource.NewWithAttributes(
        semconv.SchemaURL,
        semconv.ServiceName(cfg.ServiceName),
        semconv.ServiceVersion(cfg.ServiceVersion),
    )
    
    tp := trace.NewTracerProvider(
        trace.WithResource(res),
        trace.WithSpanProcessor(recorder),
        // é‡‡æ ·æ‰€æœ‰ Span ç”¨äºæµ‹è¯•
        trace.WithSampler(trace.AlwaysSample()),
    )
    
    // è®¾ç½®ä¸ºå…¨å±€ TracerProvider
    otel.SetTracerProvider(tp)
    
    return tp, recorder
}
```

---

## 3. å•å…ƒæµ‹è¯• OTLP é›†æˆ

### 3.1 åŸºæœ¬å•å…ƒæµ‹è¯•è¿½è¸ª

```go
package service

import (
    "context"
    "testing"
    "time"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    
    "your-project/testutil"
)

// UserService ç¤ºä¾‹æœåŠ¡
type UserService struct {
    tracer trace.Tracer
}

func NewUserService() *UserService {
    return &UserService{
        tracer: otel.Tracer("user-service"),
    }
}

func (s *UserService) GetUser(ctx context.Context, userID int64) (*User, error) {
    ctx, span := s.tracer.Start(ctx, "GetUser",
        trace.WithAttributes(attribute.Int64("user.id", userID)),
    )
    defer span.End()
    
    // æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
    time.Sleep(10 * time.Millisecond)
    
    if userID <= 0 {
        span.SetStatus(codes.Error, "invalid user ID")
        span.RecordError(ErrInvalidUserID)
        return nil, ErrInvalidUserID
    }
    
    user := &User{ID: userID, Name: "Test User"}
    span.SetAttributes(attribute.String("user.name", user.Name))
    
    return user, nil
}

// TestGetUser_Success æµ‹è¯•æˆåŠŸåœºæ™¯
func TestGetUser_Success(t *testing.T) {
    // è®¾ç½®æµ‹è¯•è¿½è¸ªå™¨
    tp, recorder := testutil.NewTestTracerProvider(testutil.TestTracerProviderConfig{
        ServiceName: "user-service-test",
    })
    defer tp.Shutdown(context.Background())
    
    // åˆ›å»ºæœåŠ¡å®ä¾‹
    svc := NewUserService()
    
    // æ‰§è¡Œæµ‹è¯•
    ctx := context.Background()
    user, err := svc.GetUser(ctx, 123)
    
    // æ–­è¨€ä¸šåŠ¡é€»è¾‘
    require.NoError(t, err)
    assert.Equal(t, int64(123), user.ID)
    assert.Equal(t, "Test User", user.Name)
    
    // æ–­è¨€è¿½è¸ªæ•°æ®
    spans := recorder.GetSpans()
    require.Len(t, spans, 1, "åº”è¯¥è®°å½• 1 ä¸ª Span")
    
    span := spans[0]
    assert.Equal(t, "GetUser", span.Name())
    assert.Equal(t, codes.Unset, span.Status().Code)
    
    // éªŒè¯ Span å±æ€§
    attrs := span.Attributes()
    assertAttribute(t, attrs, "user.id", int64(123))
    assertAttribute(t, attrs, "user.name", "Test User")
}

// TestGetUser_InvalidID æµ‹è¯•é”™è¯¯åœºæ™¯
func TestGetUser_InvalidID(t *testing.T) {
    tp, recorder := testutil.NewTestTracerProvider(testutil.TestTracerProviderConfig{
        ServiceName: "user-service-test",
    })
    defer tp.Shutdown(context.Background())
    
    svc := NewUserService()
    
    ctx := context.Background()
    user, err := svc.GetUser(ctx, -1)
    
    // æ–­è¨€ä¸šåŠ¡é€»è¾‘
    require.Error(t, err)
    assert.Nil(t, user)
    assert.Equal(t, ErrInvalidUserID, err)
    
    // æ–­è¨€è¿½è¸ªæ•°æ®
    spans := recorder.GetSpans()
    require.Len(t, spans, 1)
    
    span := spans[0]
    assert.Equal(t, codes.Error, span.Status().Code)
    assert.Equal(t, "invalid user ID", span.Status().Description)
    
    // éªŒè¯é”™è¯¯äº‹ä»¶
    events := span.Events()
    require.NotEmpty(t, events, "åº”è¯¥è®°å½•é”™è¯¯äº‹ä»¶")
    assert.Equal(t, "exception", events[0].Name)
}

// assertAttribute è¾…åŠ©å‡½æ•°ï¼šéªŒè¯ Span å±æ€§
func assertAttribute(t *testing.T, attrs []attribute.KeyValue, key string, expectedValue interface{}) {
    t.Helper()
    
    for _, attr := range attrs {
        if string(attr.Key) == key {
            switch v := expectedValue.(type) {
            case int64:
                assert.Equal(t, v, attr.Value.AsInt64())
            case string:
                assert.Equal(t, v, attr.Value.AsString())
            case bool:
                assert.Equal(t, v, attr.Value.AsBool())
            }
            return
        }
    }
    t.Errorf("attribute %s not found", key)
}
```

### 3.2 è¡¨é©±åŠ¨æµ‹è¯•è¿½è¸ª

```go
func TestGetUser_TableDriven(t *testing.T) {
    tp, recorder := testutil.NewTestTracerProvider(testutil.TestTracerProviderConfig{
        ServiceName: "user-service-test",
    })
    defer tp.Shutdown(context.Background())
    
    tests := []struct {
        name          string
        userID        int64
        wantErr       bool
        expectedSpans int
        validateSpan  func(t *testing.T, span trace.ReadOnlySpan)
    }{
        {
            name:          "valid user ID",
            userID:        123,
            wantErr:       false,
            expectedSpans: 1,
            validateSpan: func(t *testing.T, span trace.ReadOnlySpan) {
                assert.Equal(t, "GetUser", span.Name())
                assert.Equal(t, codes.Unset, span.Status().Code)
            },
        },
        {
            name:          "invalid user ID (zero)",
            userID:        0,
            wantErr:       true,
            expectedSpans: 1,
            validateSpan: func(t *testing.T, span trace.ReadOnlySpan) {
                assert.Equal(t, codes.Error, span.Status().Code)
            },
        },
        {
            name:          "invalid user ID (negative)",
            userID:        -1,
            wantErr:       true,
            expectedSpans: 1,
            validateSpan: func(t *testing.T, span trace.ReadOnlySpan) {
                assert.Equal(t, codes.Error, span.Status().Code)
            },
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            recorder.Reset() // é‡ç½®è®°å½•å™¨
            
            svc := NewUserService()
            ctx := context.Background()
            
            user, err := svc.GetUser(ctx, tt.userID)
            
            if tt.wantErr {
                require.Error(t, err)
                assert.Nil(t, user)
            } else {
                require.NoError(t, err)
                assert.NotNil(t, user)
            }
            
            // éªŒè¯è¿½è¸ªæ•°æ®
            spans := recorder.GetSpans()
            assert.Len(t, spans, tt.expectedSpans)
            
            if len(spans) > 0 && tt.validateSpan != nil {
                tt.validateSpan(t, spans[0])
            }
        })
    }
}
```

### 3.3 å­æµ‹è¯•å¹¶å‘è¿½è¸ª

```go
func TestConcurrentGetUser(t *testing.T) {
    tp, recorder := testutil.NewTestTracerProvider(testutil.TestTracerProviderConfig{
        ServiceName: "user-service-test",
    })
    defer tp.Shutdown(context.Background())
    
    svc := NewUserService()
    
    const numGoroutines = 10
    
    t.Run("concurrent requests", func(t *testing.T) {
        var wg sync.WaitGroup
        wg.Add(numGoroutines)
        
        for i := 0; i < numGoroutines; i++ {
            go func(userID int64) {
                defer wg.Done()
                
                ctx := context.Background()
                user, err := svc.GetUser(ctx, userID)
                
                require.NoError(t, err)
                assert.Equal(t, userID, user.ID)
            }(int64(i + 1))
        }
        
        wg.Wait()
        
        // éªŒè¯æ‰€æœ‰è¯·æ±‚éƒ½è¢«è¿½è¸ª
        spans := recorder.GetSpans()
        assert.Len(t, spans, numGoroutines, "åº”è¯¥è®°å½•æ‰€æœ‰å¹¶å‘è¯·æ±‚çš„ Span")
    })
}
```

---

## 4. åŸºå‡†æµ‹è¯• OTLP é›†æˆ

### 4.1 åŸºç¡€åŸºå‡†æµ‹è¯•

```go
package service

import (
    "context"
    "testing"
    
    "your-project/testutil"
)

// BenchmarkGetUser_WithTracing å¸¦è¿½è¸ªçš„åŸºå‡†æµ‹è¯•
func BenchmarkGetUser_WithTracing(b *testing.B) {
    tp, _ := testutil.NewTestTracerProvider(testutil.TestTracerProviderConfig{
        ServiceName: "user-service-bench",
    })
    defer tp.Shutdown(context.Background())
    
    svc := NewUserService()
    ctx := context.Background()
    
    b.ResetTimer()
    b.ReportAllocs()
    
    for i := 0; i < b.N; i++ {
        _, _ = svc.GetUser(ctx, int64(i%1000))
    }
}

// BenchmarkGetUser_WithoutTracing ä¸å¸¦è¿½è¸ªçš„åŸºå‡†æµ‹è¯•ï¼ˆå¯¹ç…§ç»„ï¼‰
func BenchmarkGetUser_WithoutTracing(b *testing.B) {
    // ä¸è®¾ç½® TracerProviderï¼Œä½¿ç”¨ NoOp è¿½è¸ªå™¨
    svc := NewUserService()
    ctx := context.Background()
    
    b.ResetTimer()
    b.ReportAllocs()
    
    for i := 0; i < b.N; i++ {
        _, _ = svc.GetUser(ctx, int64(i%1000))
    }
}
```

### 4.2 è¿½è¸ªå¼€é”€åˆ†æåŸºå‡†æµ‹è¯•

```go
// BenchmarkTracingOverhead æµ‹é‡è¿½è¸ªå¼€é”€
func BenchmarkTracingOverhead(b *testing.B) {
    tests := []struct {
        name      string
        setupFunc func() *trace.TracerProvider
    }{
        {
            name: "NoOp Tracer",
            setupFunc: func() *trace.TracerProvider {
                // ä½¿ç”¨ NoOp TracerProvider
                otel.SetTracerProvider(trace.NewNoopTracerProvider())
                return nil
            },
        },
        {
            name: "InMemory Recorder",
            setupFunc: func() *trace.TracerProvider {
                tp, _ := testutil.NewTestTracerProvider(testutil.TestTracerProviderConfig{})
                return tp
            },
        },
        {
            name: "Batching Exporter",
            setupFunc: func() *trace.TracerProvider {
                // ä½¿ç”¨æ‰¹å¤„ç†å¯¼å‡ºå™¨ï¼ˆæ›´æ¥è¿‘ç”Ÿäº§ç¯å¢ƒï¼‰
                recorder := testutil.NewSpanRecorder()
                tp := trace.NewTracerProvider(
                    trace.WithBatcher(recorder),
                    trace.WithSampler(trace.AlwaysSample()),
                )
                return tp
            },
        },
    }
    
    for _, tt := range tests {
        b.Run(tt.name, func(b *testing.B) {
            tp := tt.setupFunc()
            if tp != nil {
                defer tp.Shutdown(context.Background())
            }
            
            tracer := otel.Tracer("benchmark")
            ctx := context.Background()
            
            b.ResetTimer()
            b.ReportAllocs()
            
            for i := 0; i < b.N; i++ {
                ctx, span := tracer.Start(ctx, "operation")
                span.SetAttributes(attribute.Int("iteration", i))
                span.End()
            }
        })
    }
}
```

**åŸºå‡†æµ‹è¯•ç»“æœç¤ºä¾‹**ï¼š

```text
BenchmarkTracingOverhead/NoOp_Tracer-8                  50000000    25.3 ns/op    0 B/op    0 allocs/op
BenchmarkTracingOverhead/InMemory_Recorder-8             3000000   485 ns/op   320 B/op    5 allocs/op
BenchmarkTracingOverhead/Batching_Exporter-8             5000000   358 ns/op   256 B/op    4 allocs/op
```

**åˆ†æ**ï¼š

- NoOp Tracer å‡ ä¹æ²¡æœ‰å¼€é”€
- InMemory Recorder æ¯æ¬¡æ“ä½œçº¦ 485nsï¼Œ5 æ¬¡å†…å­˜åˆ†é…
- Batching Exporter é€šè¿‡æ‰¹å¤„ç†ä¼˜åŒ–ï¼Œå¼€é”€çº¦ 358ns

### 4.3 é‡‡æ ·ç­–ç•¥åŸºå‡†æµ‹è¯•

```go
// BenchmarkSamplingStrategies æ¯”è¾ƒä¸åŒé‡‡æ ·ç­–ç•¥çš„æ€§èƒ½
func BenchmarkSamplingStrategies(b *testing.B) {
    samplers := []struct {
        name    string
        sampler trace.Sampler
    }{
        {"AlwaysSample", trace.AlwaysSample()},
        {"NeverSample", trace.NeverSample()},
        {"TraceIDRatio_0.1", trace.TraceIDRatioBased(0.1)},
        {"TraceIDRatio_0.5", trace.TraceIDRatioBased(0.5)},
        {"ParentBased", trace.ParentBased(trace.TraceIDRatioBased(0.5))},
    }
    
    for _, s := range samplers {
        b.Run(s.name, func(b *testing.B) {
            recorder := testutil.NewSpanRecorder()
            tp := trace.NewTracerProvider(
                trace.WithSpanProcessor(recorder),
                trace.WithSampler(s.sampler),
            )
            defer tp.Shutdown(context.Background())
            
            tracer := tp.Tracer("benchmark")
            ctx := context.Background()
            
            b.ResetTimer()
            b.ReportAllocs()
            
            for i := 0; i < b.N; i++ {
                ctx, span := tracer.Start(ctx, "operation")
                span.End()
            }
            
            b.StopTimer()
            sampledCount := recorder.SpanCount()
            b.ReportMetric(float64(sampledCount)/float64(b.N)*100, "%sampled")
        })
    }
}
```

### 4.4 Context ä¼ é€’åŸºå‡†æµ‹è¯•

```go
// BenchmarkContextPropagation æµ‹è¯• Context ä¼ é€’æ€§èƒ½
func BenchmarkContextPropagation(b *testing.B) {
    tp, _ := testutil.NewTestTracerProvider(testutil.TestTracerProviderConfig{})
    defer tp.Shutdown(context.Background())
    
    tracer := otel.Tracer("benchmark")
    
    b.Run("WithoutSpan", func(b *testing.B) {
        ctx := context.Background()
        b.ResetTimer()
        b.ReportAllocs()
        
        for i := 0; i < b.N; i++ {
            _ = doWork(ctx)
        }
    })
    
    b.Run("WithSpan_5Levels", func(b *testing.B) {
        ctx := context.Background()
        b.ResetTimer()
        b.ReportAllocs()
        
        for i := 0; i < b.N; i++ {
            ctx, span := tracer.Start(ctx, "root")
            _ = doWorkWithSpan(ctx, 5)
            span.End()
        }
    })
}

func doWorkWithSpan(ctx context.Context, depth int) context.Context {
    if depth == 0 {
        return ctx
    }
    
    tracer := otel.Tracer("benchmark")
    ctx, span := tracer.Start(ctx, "nested")
    defer span.End()
    
    return doWorkWithSpan(ctx, depth-1)
}
```

---

## 5. Mock ä¸å­˜æ ¹æ¨¡å¼

### 5.1 Mock TracerProvider

```go
package testutil

import (
    "go.opentelemetry.io/otel/trace"
    "go.opentelemetry.io/otel/trace/noop"
)

// MockTracerProvider å¯æ§çš„ Mock TracerProvider
type MockTracerProvider struct {
    tracer trace.Tracer
}

func NewMockTracerProvider() *MockTracerProvider {
    return &MockTracerProvider{
        tracer: noop.NewTracerProvider().Tracer("mock"),
    }
}

func (m *MockTracerProvider) Tracer(name string, opts ...trace.TracerOption) trace.Tracer {
    return m.tracer
}

// SetTracer å…è®¸æ³¨å…¥è‡ªå®šä¹‰ Tracer
func (m *MockTracerProvider) SetTracer(tracer trace.Tracer) {
    m.tracer = tracer
}
```

### 5.2 Mock Exporter

```go
package testutil

import (
    "context"
    "sync"
    
    "go.opentelemetry.io/otel/sdk/trace"
)

// MockExporter å¯é…ç½®çš„ Mock Exporter
type MockExporter struct {
    mu              sync.Mutex
    exportedSpans   []trace.ReadOnlySpan
    exportCallCount int
    shutdownCalled  bool
    exportError     error // æ¨¡æ‹Ÿå¯¼å‡ºé”™è¯¯
}

func NewMockExporter() *MockExporter {
    return &MockExporter{
        exportedSpans: make([]trace.ReadOnlySpan, 0),
    }
}

func (m *MockExporter) ExportSpans(ctx context.Context, spans []trace.ReadOnlySpan) error {
    m.mu.Lock()
    defer m.mu.Unlock()
    
    m.exportCallCount++
    
    if m.exportError != nil {
        return m.exportError
    }
    
    m.exportedSpans = append(m.exportedSpans, spans...)
    return nil
}

func (m *MockExporter) Shutdown(ctx context.Context) error {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.shutdownCalled = true
    return nil
}

// SetExportError æ¨¡æ‹Ÿå¯¼å‡ºé”™è¯¯
func (m *MockExporter) SetExportError(err error) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.exportError = err
}

// GetExportedSpans è·å–å¯¼å‡ºçš„ Span
func (m *MockExporter) GetExportedSpans() []trace.ReadOnlySpan {
    m.mu.Lock()
    defer m.mu.Unlock()
    
    result := make([]trace.ReadOnlySpan, len(m.exportedSpans))
    copy(result, m.exportedSpans)
    return result
}

// ExportCallCount è¿”å› Export è¢«è°ƒç”¨çš„æ¬¡æ•°
func (m *MockExporter) ExportCallCount() int {
    m.mu.Lock()
    defer m.mu.Unlock()
    return m.exportCallCount
}

// ä½¿ç”¨ç¤ºä¾‹
func TestExporterFailure(t *testing.T) {
    exporter := NewMockExporter()
    exporter.SetExportError(errors.New("network error"))
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
    )
    defer tp.Shutdown(context.Background())
    
    tracer := tp.Tracer("test")
    ctx, span := tracer.Start(context.Background(), "operation")
    span.End()
    
    // å¼ºåˆ¶åˆ·æ–°ä»¥è§¦å‘å¯¼å‡º
    tp.ForceFlush(context.Background())
    
    // éªŒè¯é”™è¯¯å¤„ç†
    assert.Greater(t, exporter.ExportCallCount(), 0)
}
```

### 5.3 æ¥å£ Mock æ¨¡å¼

```go
package service

import (
    "context"
    "go.opentelemetry.io/otel/trace"
)

// Repository æ•°æ®ä»“åº“æ¥å£
type Repository interface {
    GetUser(ctx context.Context, id int64) (*User, error)
}

// MockRepository ç”¨äºæµ‹è¯•çš„ Mock ä»“åº“
type MockRepository struct {
    GetUserFunc func(ctx context.Context, id int64) (*User, error)
    CallCount   int
}

func (m *MockRepository) GetUser(ctx context.Context, id int64) (*User, error) {
    m.CallCount++
    if m.GetUserFunc != nil {
        return m.GetUserFunc(ctx, id)
    }
    return &User{ID: id, Name: "Mock User"}, nil
}

// TracedService ä½¿ç”¨è¿½è¸ªçš„æœåŠ¡
type TracedService struct {
    repo   Repository
    tracer trace.Tracer
}

func NewTracedService(repo Repository, tracer trace.Tracer) *TracedService {
    return &TracedService{
        repo:   repo,
        tracer: tracer,
    }
}

func (s *TracedService) ProcessUser(ctx context.Context, userID int64) error {
    ctx, span := s.tracer.Start(ctx, "ProcessUser")
    defer span.End()
    
    user, err := s.repo.GetUser(ctx, userID)
    if err != nil {
        span.RecordError(err)
        return err
    }
    
    span.SetAttributes(attribute.String("user.name", user.Name))
    return nil
}

// æµ‹è¯•ç¤ºä¾‹
func TestTracedService(t *testing.T) {
    tp, recorder := testutil.NewTestTracerProvider(testutil.TestTracerProviderConfig{})
    defer tp.Shutdown(context.Background())
    
    mockRepo := &MockRepository{
        GetUserFunc: func(ctx context.Context, id int64) (*User, error) {
            // éªŒè¯ Context ä¸­æ˜¯å¦åŒ…å« Span
            span := trace.SpanFromContext(ctx)
            assert.True(t, span.SpanContext().IsValid())
            
            return &User{ID: id, Name: "Test User"}, nil
        },
    }
    
    svc := NewTracedService(mockRepo, otel.Tracer("test"))
    
    err := svc.ProcessUser(context.Background(), 123)
    require.NoError(t, err)
    
    // éªŒè¯ Mock è¢«è°ƒç”¨
    assert.Equal(t, 1, mockRepo.CallCount)
    
    // éªŒè¯è¿½è¸ªæ•°æ®
    spans := recorder.GetSpans()
    require.Len(t, spans, 1)
    assert.Equal(t, "ProcessUser", spans[0].Name())
}
```

---

## 6. æµ‹è¯•è¦†ç›–ç‡ä¸è¿½è¸ª

### 6.1 ç»“åˆè¦†ç›–ç‡å’Œè¿½è¸ªæ•°æ®

```go
package coverage

import (
    "context"
    "testing"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
)

// ä½¿ç”¨ Go 1.25.1 çš„è¦†ç›–ç‡å¢å¼ºåŠŸèƒ½
func TestWithCoverageTracing(t *testing.T) {
    // å¯ç”¨è¦†ç›–ç‡æ¨¡å¼è¿è¡Œï¼šgo test -cover -coverprofile=coverage.out
    
    tp, recorder := testutil.NewTestTracerProvider(testutil.TestTracerProviderConfig{
        ServiceName: "coverage-test",
    })
    defer tp.Shutdown(context.Background())
    
    tracer := otel.Tracer("coverage")
    
    t.Run("branch_1", func(t *testing.T) {
        ctx, span := tracer.Start(context.Background(), "test_branch_1")
        defer span.End()
        
        result := complexFunction(ctx, 10)
        assert.Equal(t, 100, result)
        
        span.SetAttributes(attribute.String("branch", "positive"))
    })
    
    t.Run("branch_2", func(t *testing.T) {
        ctx, span := tracer.Start(context.Background(), "test_branch_2")
        defer span.End()
        
        result := complexFunction(ctx, -5)
        assert.Equal(t, 0, result)
        
        span.SetAttributes(attribute.String("branch", "negative"))
    })
    
    // åˆ†ææœªè¦†ç›–çš„åˆ†æ”¯
    spans := recorder.GetSpans()
    t.Logf("Tested %d branches", len(spans))
    
    for _, span := range spans {
        for _, attr := range span.Attributes() {
            if attr.Key == "branch" {
                t.Logf("Covered branch: %s", attr.Value.AsString())
            }
        }
    }
}

func complexFunction(ctx context.Context, value int) int {
    _, span := otel.Tracer("app").Start(ctx, "complexFunction")
    defer span.End()
    
    if value < 0 {
        span.SetAttributes(attribute.String("path", "negative"))
        return 0
    }
    
    if value > 100 {
        span.SetAttributes(attribute.String("path", "large"))
        return 10000
    }
    
    span.SetAttributes(attribute.String("path", "normal"))
    return value * 10
}
```

### 6.2 è¦†ç›–ç‡æŠ¥å‘Šå¢å¼º

```bash
# ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Šå¹¶é™„åŠ è¿½è¸ªæ•°æ®
go test -v -cover -coverprofile=coverage.out ./...

# ç”Ÿæˆ HTML æŠ¥å‘Š
go tool cover -html=coverage.out -o coverage.html

# æŸ¥çœ‹å‡½æ•°çº§è¦†ç›–ç‡
go tool cover -func=coverage.out
```

---

## 7. é›†æˆæµ‹è¯•è¿½è¸ª

### 7.1 HTTP é›†æˆæµ‹è¯•

```go
package integration

import (
    "context"
    "net/http"
    "net/http/httptest"
    "testing"
    
    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/propagation"
)

func TestHTTPIntegration(t *testing.T) {
    tp, recorder := testutil.NewTestTracerProvider(testutil.TestTracerProviderConfig{
        ServiceName: "http-integration-test",
    })
    defer tp.Shutdown(context.Background())
    
    // è®¾ç½® Propagator
    otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
        propagation.TraceContext{},
        propagation.Baggage{},
    ))
    
    // åˆ›å»ºæµ‹è¯•æœåŠ¡å™¨
    handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        ctx := r.Context()
        tracer := otel.Tracer("test-server")
        
        _, span := tracer.Start(ctx, "handleRequest")
        defer span.End()
        
        // éªŒè¯ Trace Context ä¼ æ’­
        span.SetAttributes(attribute.String("request.path", r.URL.Path))
        
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("OK"))
    })
    
    // ä½¿ç”¨ otelhttp åŒ…è£…
    server := httptest.NewServer(otelhttp.NewHandler(handler, "test-server"))
    defer server.Close()
    
    // åˆ›å»ºå¸¦è¿½è¸ªçš„å®¢æˆ·ç«¯
    client := &http.Client{
        Transport: otelhttp.NewTransport(http.DefaultTransport),
    }
    
    // å‘èµ·è¯·æ±‚
    ctx, span := otel.Tracer("test-client").Start(context.Background(), "testRequest")
    defer span.End()
    
    req, _ := http.NewRequestWithContext(ctx, "GET", server.URL+"/test", nil)
    resp, err := client.Do(req)
    require.NoError(t, err)
    defer resp.Body.Close()
    
    assert.Equal(t, http.StatusOK, resp.StatusCode)
    
    // éªŒè¯è¿½è¸ªæ•°æ®
    spans := recorder.GetSpans()
    t.Logf("Captured %d spans", len(spans))
    
    // åº”è¯¥è‡³å°‘æœ‰ 3 ä¸ª Span: å®¢æˆ·ç«¯ã€ä¼ è¾“å±‚ã€æœåŠ¡ç«¯
    assert.GreaterOrEqual(t, len(spans), 3)
    
    // éªŒè¯ Span é“¾
    var clientSpan, serverSpan trace.ReadOnlySpan
    for _, s := range spans {
        switch s.Name() {
        case "testRequest":
            clientSpan = s
        case "handleRequest":
            serverSpan = s
        }
    }
    
    require.NotNil(t, clientSpan, "åº”è¯¥æœ‰å®¢æˆ·ç«¯ Span")
    require.NotNil(t, serverSpan, "åº”è¯¥æœ‰æœåŠ¡ç«¯ Span")
    
    // éªŒè¯çˆ¶å­å…³ç³» (TraceID åº”è¯¥ç›¸åŒ)
    assert.Equal(t, clientSpan.SpanContext().TraceID(), serverSpan.SpanContext().TraceID())
}
```

### 7.2 gRPC é›†æˆæµ‹è¯•

```go
package integration

import (
    "context"
    "net"
    "testing"
    
    "google.golang.org/grpc"
    "google.golang.org/grpc/test/bufconn"
    "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
)

func TestGRPCIntegration(t *testing.T) {
    tp, recorder := testutil.NewTestTracerProvider(testutil.TestTracerProviderConfig{
        ServiceName: "grpc-integration-test",
    })
    defer tp.Shutdown(context.Background())
    
    // åˆ›å»ºå†…å­˜è¿æ¥
    bufSize := 1024 * 1024
    lis := bufconn.Listen(bufSize)
    
    // åˆ›å»º gRPC æœåŠ¡å™¨ï¼ˆå¸¦è¿½è¸ªï¼‰
    server := grpc.NewServer(
        grpc.StatsHandler(otelgrpc.NewServerHandler()),
    )
    
    // æ³¨å†ŒæœåŠ¡ï¼ˆç¤ºä¾‹ï¼‰
    // pb.RegisterYourServiceServer(server, &yourServiceImpl{})
    
    go func() {
        if err := server.Serve(lis); err != nil {
            t.Logf("Server error: %v", err)
        }
    }()
    defer server.Stop()
    
    // åˆ›å»º gRPC å®¢æˆ·ç«¯ï¼ˆå¸¦è¿½è¸ªï¼‰
    bufDialer := func(context.Context, string) (net.Conn, error) {
        return lis.Dial()
    }
    
    conn, err := grpc.DialContext(
        context.Background(),
        "bufnet",
        grpc.WithContextDialer(bufDialer),
        grpc.WithInsecure(),
        grpc.WithStatsHandler(otelgrpc.NewClientHandler()),
    )
    require.NoError(t, err)
    defer conn.Close()
    
    // æ‰§è¡Œ RPC è°ƒç”¨
    // client := pb.NewYourServiceClient(conn)
    // resp, err := client.YourMethod(context.Background(), &pb.Request{})
    
    // éªŒè¯è¿½è¸ªæ•°æ®
    spans := recorder.GetSpans()
    t.Logf("Captured %d spans", len(spans))
    
    // gRPC è¿½è¸ªåº”è¯¥åŒ…å«å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯ Span
    assert.GreaterOrEqual(t, len(spans), 2)
}
```

---

## 8. æ€§èƒ½åˆ†æä¸ä¼˜åŒ–

### 8.1 æ€§èƒ½åˆ†ææµ‹è¯•

```go
package perf

import (
    "context"
    "runtime"
    "testing"
    "time"
)

// TestMemoryUsage å†…å­˜ä½¿ç”¨åˆ†æ
func TestMemoryUsage(t *testing.T) {
    tp, recorder := testutil.NewTestTracerProvider(testutil.TestTracerProviderConfig{})
    defer tp.Shutdown(context.Background())
    
    tracer := otel.Tracer("perf-test")
    
    // è®°å½•åˆå§‹å†…å­˜çŠ¶æ€
    var m1, m2 runtime.MemStats
    runtime.GC()
    runtime.ReadMemStats(&m1)
    
    // æ‰§è¡Œå¤§é‡è¿½è¸ªæ“ä½œ
    const iterations = 10000
    for i := 0; i < iterations; i++ {
        ctx, span := tracer.Start(context.Background(), "operation")
        span.SetAttributes(attribute.Int("iteration", i))
        span.End()
    }
    
    // è®°å½•æœ€ç»ˆå†…å­˜çŠ¶æ€
    runtime.GC()
    runtime.ReadMemStats(&m2)
    
    // è®¡ç®—å†…å­˜ä½¿ç”¨
    allocatedBytes := m2.TotalAlloc - m1.TotalAlloc
    t.Logf("Total allocated: %d bytes", allocatedBytes)
    t.Logf("Average per span: %.2f bytes", float64(allocatedBytes)/float64(iterations))
    t.Logf("Spans recorded: %d", recorder.SpanCount())
    
    // éªŒè¯æ²¡æœ‰å†…å­˜æ³„æ¼ (å®é™…å€¼å–å†³äºå®ç°)
    avgBytesPerSpan := float64(allocatedBytes) / float64(iterations)
    assert.Less(t, avgBytesPerSpan, 1000.0, "æ¯ä¸ª Span å¹³å‡å†…å­˜ä½¿ç”¨ä¸åº”è¶…è¿‡ 1KB")
}

// TestGoroutineLeak æ£€æµ‹ Goroutine æ³„æ¼
func TestGoroutineLeak(t *testing.T) {
    tp, _ := testutil.NewTestTracerProvider(testutil.TestTracerProviderConfig{})
    defer tp.Shutdown(context.Background())
    
    initialGoroutines := runtime.NumGoroutine()
    
    tracer := otel.Tracer("leak-test")
    
    // æ‰§è¡Œå¤§é‡å¹¶å‘è¿½è¸ªæ“ä½œ
    const concurrency = 100
    done := make(chan struct{}, concurrency)
    
    for i := 0; i < concurrency; i++ {
        go func(id int) {
            defer func() { done <- struct{}{} }()
            
            ctx, span := tracer.Start(context.Background(), "concurrent-op")
            defer span.End()
            
            time.Sleep(10 * time.Millisecond)
            span.SetAttributes(attribute.Int("goroutine.id", id))
        }(i)
    }
    
    // ç­‰å¾…æ‰€æœ‰ Goroutine å®Œæˆ
    for i := 0; i < concurrency; i++ {
        <-done
    }
    
    // ç­‰å¾…æ¸…ç†
    time.Sleep(100 * time.Millisecond)
    runtime.GC()
    
    finalGoroutines := runtime.NumGoroutine()
    leakedGoroutines := finalGoroutines - initialGoroutines
    
    t.Logf("Initial goroutines: %d", initialGoroutines)
    t.Logf("Final goroutines: %d", finalGoroutines)
    t.Logf("Leaked goroutines: %d", leakedGoroutines)
    
    // å…è®¸å°‘é‡ç³»ç»Ÿ Goroutine æ³¢åŠ¨
    assert.LessOrEqual(t, leakedGoroutines, 5, "ä¸åº”è¯¥æœ‰æ˜æ˜¾çš„ Goroutine æ³„æ¼")
}
```

### 8.2 CPU Profiling

```go
// BenchmarkWithCPUProfile ç”Ÿæˆ CPU Profile
func BenchmarkWithCPUProfile(b *testing.B) {
    // è¿è¡Œ: go test -bench=BenchmarkWithCPUProfile -cpuprofile=cpu.prof
    // åˆ†æ: go tool pprof cpu.prof
    
    tp, _ := testutil.NewTestTracerProvider(testutil.TestTracerProviderConfig{})
    defer tp.Shutdown(context.Background())
    
    tracer := otel.Tracer("cpu-profile")
    ctx := context.Background()
    
    b.ResetTimer()
    
    for i := 0; i < b.N; i++ {
        ctx, span := tracer.Start(ctx, "cpu-intensive-op")
        
        // æ¨¡æ‹Ÿ CPU å¯†é›†å‹æ“ä½œ
        sum := 0
        for j := 0; j < 1000; j++ {
            sum += j
        }
        span.SetAttributes(attribute.Int("sum", sum))
        
        span.End()
    }
}
```

### 8.3 å†…å­˜ Profiling

```go
// BenchmarkWithMemProfile ç”Ÿæˆå†…å­˜ Profile
func BenchmarkWithMemProfile(b *testing.B) {
    // è¿è¡Œ: go test -bench=BenchmarkWithMemProfile -memprofile=mem.prof
    // åˆ†æ: go tool pprof mem.prof
    
    tp, _ := testutil.NewTestTracerProvider(testutil.TestTracerProviderConfig{})
    defer tp.Shutdown(context.Background())
    
    tracer := otel.Tracer("mem-profile")
    ctx := context.Background()
    
    b.ResetTimer()
    b.ReportAllocs()
    
    for i := 0; i < b.N; i++ {
        ctx, span := tracer.Start(ctx, "mem-intensive-op")
        
        // æ¨¡æ‹Ÿå†…å­˜åˆ†é…
        data := make([]byte, 1024)
        span.SetAttributes(attribute.Int("data.size", len(data)))
        
        span.End()
    }
}
```

---

## 9. æœ€ä½³å®è·µ

### 9.1 æµ‹è¯•ç»„ç»‡åŸåˆ™

```go
package service_test // ä½¿ç”¨ _test åŒ…åé¿å…å¾ªç¯ä¾èµ–

import (
    "testing"
    
    "your-project/service"
    "your-project/testutil"
)

// ä½¿ç”¨ TestMain è¿›è¡Œå…¨å±€è®¾ç½®
func TestMain(m *testing.M) {
    // è®¾ç½®å…¨å±€æµ‹è¯• TracerProvider
    tp, _ := testutil.NewTestTracerProvider(testutil.TestTracerProviderConfig{
        ServiceName: "service-test-suite",
    })
    defer tp.Shutdown(context.Background())
    
    // è¿è¡Œæµ‹è¯•
    exitCode := m.Run()
    
    // æ¸…ç†
    os.Exit(exitCode)
}

// ä½¿ç”¨å­æµ‹è¯•è¿›è¡Œåˆ†ç»„
func TestUserService(t *testing.T) {
    t.Run("CRUD Operations", func(t *testing.T) {
        t.Run("Create", testCreateUser)
        t.Run("Read", testGetUser)
        t.Run("Update", testUpdateUser)
        t.Run("Delete", testDeleteUser)
    })
    
    t.Run("Error Handling", func(t *testing.T) {
        t.Run("InvalidInput", testInvalidInput)
        t.Run("NotFound", testNotFound)
    })
}

func testCreateUser(t *testing.T) {
    // æ¯ä¸ªå­æµ‹è¯•ä½¿ç”¨ç‹¬ç«‹çš„ Recorder
    _, recorder := testutil.NewTestTracerProvider(testutil.TestTracerProviderConfig{})
    // ... æµ‹è¯•é€»è¾‘
}
```

### 9.2 æ–­è¨€è¾…åŠ©å‡½æ•°

```go
package testutil

import (
    "testing"
    
    "github.com/stretchr/testify/assert"
    "go.opentelemetry.io/otel/sdk/trace"
    "go.opentelemetry.io/otel/codes"
)

// AssertSpanCount éªŒè¯ Span æ•°é‡
func AssertSpanCount(t *testing.T, recorder *SpanRecorder, expected int) {
    t.Helper()
    actual := recorder.SpanCount()
    assert.Equal(t, expected, actual, "Span count mismatch")
}

// AssertSpanName éªŒè¯ Span åç§°
func AssertSpanName(t *testing.T, span trace.ReadOnlySpan, expected string) {
    t.Helper()
    assert.Equal(t, expected, span.Name(), "Span name mismatch")
}

// AssertSpanStatus éªŒè¯ Span çŠ¶æ€
func AssertSpanStatus(t *testing.T, span trace.ReadOnlySpan, expectedCode codes.Code, expectedDesc string) {
    t.Helper()
    status := span.Status()
    assert.Equal(t, expectedCode, status.Code, "Status code mismatch")
    if expectedDesc != "" {
        assert.Equal(t, expectedDesc, status.Description, "Status description mismatch")
    }
}

// AssertSpanAttribute éªŒè¯ Span å±æ€§
func AssertSpanAttribute(t *testing.T, span trace.ReadOnlySpan, key string, expectedValue interface{}) {
    t.Helper()
    
    attrs := span.Attributes()
    for _, attr := range attrs {
        if string(attr.Key) == key {
            switch v := expectedValue.(type) {
            case string:
                assert.Equal(t, v, attr.Value.AsString())
            case int64:
                assert.Equal(t, v, attr.Value.AsInt64())
            case bool:
                assert.Equal(t, v, attr.Value.AsBool())
            default:
                t.Errorf("unsupported attribute type: %T", expectedValue)
            }
            return
        }
    }
    t.Errorf("attribute %s not found", key)
}

// AssertSpanHierarchy éªŒè¯ Span çˆ¶å­å…³ç³»
func AssertSpanHierarchy(t *testing.T, parent, child trace.ReadOnlySpan) {
    t.Helper()
    
    assert.Equal(t, parent.SpanContext().TraceID(), child.SpanContext().TraceID(), "TraceID should match")
    assert.Equal(t, parent.SpanContext().SpanID(), child.Parent().SpanID(), "Child parent should be parent span")
}

// ä½¿ç”¨ç¤ºä¾‹
func TestWithAssertions(t *testing.T) {
    tp, recorder := NewTestTracerProvider(TestTracerProviderConfig{})
    defer tp.Shutdown(context.Background())
    
    // ... æ‰§è¡Œä¸šåŠ¡é€»è¾‘
    
    spans := recorder.GetSpans()
    AssertSpanCount(t, recorder, 2)
    
    AssertSpanName(t, spans[0], "parent-operation")
    AssertSpanStatus(t, spans[0], codes.Ok, "")
    AssertSpanAttribute(t, spans[0], "user.id", int64(123))
    
    AssertSpanHierarchy(t, spans[0], spans[1])
}
```

### 9.3 æµ‹è¯•æ•°æ®ç®¡ç†

```go
package testutil

// TestFixtures æµ‹è¯•æ•°æ®å¤¹å…·
type TestFixtures struct {
    Users    []*User
    Products []*Product
}

func LoadFixtures() *TestFixtures {
    return &TestFixtures{
        Users: []*User{
            {ID: 1, Name: "Alice", Email: "alice@test.com"},
            {ID: 2, Name: "Bob", Email: "bob@test.com"},
        },
        Products: []*Product{
            {ID: 101, Name: "Product A", Price: 99.99},
            {ID: 102, Name: "Product B", Price: 149.99},
        },
    }
}

// CleanupFixtures æ¸…ç†æµ‹è¯•æ•°æ®
func CleanupFixtures(t *testing.T) {
    t.Cleanup(func() {
        // æ¸…ç†é€»è¾‘
    })
}
```

### 9.4 å¹¶å‘æµ‹è¯•å·¥å…·

```go
package testutil

import (
    "sync"
    "testing"
)

// ConcurrentExecutor å¹¶å‘æ‰§è¡Œæµ‹è¯•è¾…åŠ©
type ConcurrentExecutor struct {
    t       *testing.T
    wg      sync.WaitGroup
    errors  []error
    errorMu sync.Mutex
}

func NewConcurrentExecutor(t *testing.T) *ConcurrentExecutor {
    return &ConcurrentExecutor{
        t:      t,
        errors: make([]error, 0),
    }
}

func (ce *ConcurrentExecutor) Go(fn func() error) {
    ce.wg.Add(1)
    go func() {
        defer ce.wg.Done()
        
        if err := fn(); err != nil {
            ce.errorMu.Lock()
            ce.errors = append(ce.errors, err)
            ce.errorMu.Unlock()
        }
    }()
}

func (ce *ConcurrentExecutor) Wait() {
    ce.wg.Wait()
    
    if len(ce.errors) > 0 {
        ce.t.Errorf("concurrent execution failed with %d errors", len(ce.errors))
        for i, err := range ce.errors {
            ce.t.Errorf("  error %d: %v", i+1, err)
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func TestConcurrentOperations(t *testing.T) {
    executor := NewConcurrentExecutor(t)
    
    for i := 0; i < 10; i++ {
        userID := int64(i)
        executor.Go(func() error {
            _, err := userService.GetUser(context.Background(), userID)
            return err
        })
    }
    
    executor.Wait()
}
```

---

## 10. æ€§èƒ½åŸºå‡†å‚è€ƒ

### 10.1 å®é™…åŸºå‡†æ•°æ®

åŸºäº Go 1.25.1 å’Œ OpenTelemetry SDK v1.32.0 çš„åŸºå‡†æµ‹è¯•ç»“æœï¼š

| æ“ä½œ                          | æ— è¿½è¸ª (ns/op) | å¸¦è¿½è¸ª (ns/op) | å¼€é”€ (%)  | å†…å­˜åˆ†é… (B/op) |
|-------------------------------|----------------|----------------|-----------|-----------------|
| ç®€å•å‡½æ•°è°ƒç”¨                  | 2.5            | 28.3           | +1032%    | 0               |
| Span åˆ›å»º+ç»“æŸ (NoOp)        | -              | 25.3           | -         | 0               |
| Span åˆ›å»º+ç»“æŸ (InMemory)    | -              | 485            | -         | 320             |
| Span åˆ›å»º+ç»“æŸ (Batch)       | -              | 358            | -         | 256             |
| Context ä¼ æ’­ (1 å±‚)          | 12.8           | 52.4           | +309%     | 48              |
| Context ä¼ æ’­ (5 å±‚)          | 64.0           | 312            | +388%     | 240             |
| å±æ€§è®¾ç½® (3 ä¸ª)              | -              | 87.6           | -         | 96              |
| HTTP è¯·æ±‚ (æœ¬åœ°)             | 245,000        | 268,000        | +9.4%     | 15,200          |
| gRPC è°ƒç”¨ (æœ¬åœ°)             | 189,000        | 205,000        | +8.5%     | 12,800          |

**ä¼˜åŒ–å»ºè®®**ï¼š

1. **é‡‡æ ·ç­–ç•¥**ï¼šç”Ÿäº§ç¯å¢ƒä½¿ç”¨ `TraceIDRatioBased(0.1)` å¯å‡å°‘ 90% å¼€é”€
2. **æ‰¹å¤„ç†å¯¼å‡º**ï¼šç›¸æ¯”åŒæ­¥å¯¼å‡ºå‡å°‘çº¦ 26% å»¶è¿Ÿ
3. **å±æ€§ä¼˜åŒ–**ï¼šä»…æ·»åŠ é«˜ä»·å€¼å±æ€§ï¼Œé¿å…è¿‡åº¦è¿½è¸ª

### 10.2 å†…å­˜ä½¿ç”¨åˆ†æ

```text
10,000 æ¬¡ Span åˆ›å»º:
- InMemory Recorder: ~3.2 MB (å¹³å‡ 320 bytes/span)
- Batch Exporter:     ~2.5 MB (å¹³å‡ 256 bytes/span)
- NoOp Tracer:        ~0 bytes
```

---

## 11. å®Œæ•´æµ‹è¯•ç¤ºä¾‹

### 11.1 ç»¼åˆæµ‹è¯•å¥—ä»¶

```go
package service_test

import (
    "context"
    "testing"
    "time"
    
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
    "github.com/stretchr/testify/suite"
    
    "your-project/service"
    "your-project/testutil"
)

// UserServiceTestSuite ä½¿ç”¨ testify suite
type UserServiceTestSuite struct {
    suite.Suite
    tp       *trace.TracerProvider
    recorder *testutil.SpanRecorder
    svc      *service.UserService
}

func (suite *UserServiceTestSuite) SetupSuite() {
    // æ•´ä¸ªæµ‹è¯•å¥—ä»¶çš„ä¸€æ¬¡æ€§è®¾ç½®
    suite.tp, suite.recorder = testutil.NewTestTracerProvider(testutil.TestTracerProviderConfig{
        ServiceName: "user-service-test-suite",
    })
}

func (suite *UserServiceTestSuite) TearDownSuite() {
    // æ¸…ç†
    suite.tp.Shutdown(context.Background())
}

func (suite *UserServiceTestSuite) SetupTest() {
    // æ¯ä¸ªæµ‹è¯•å‰é‡ç½®
    suite.recorder.Reset()
    suite.svc = service.NewUserService()
}

func (suite *UserServiceTestSuite) TestGetUser_Success() {
    ctx := context.Background()
    user, err := suite.svc.GetUser(ctx, 123)
    
    require.NoError(suite.T(), err)
    assert.NotNil(suite.T(), user)
    
    testutil.AssertSpanCount(suite.T(), suite.recorder, 1)
    
    spans := suite.recorder.GetSpans()
    testutil.AssertSpanName(suite.T(), spans[0], "GetUser")
    testutil.AssertSpanStatus(suite.T(), spans[0], codes.Unset, "")
}

func (suite *UserServiceTestSuite) TestGetUser_Error() {
    ctx := context.Background()
    user, err := suite.svc.GetUser(ctx, -1)
    
    require.Error(suite.T(), err)
    assert.Nil(suite.T(), user)
    
    spans := suite.recorder.GetSpans()
    testutil.AssertSpanStatus(suite.T(), spans[0], codes.Error, "invalid user ID")
}

// è¿è¡Œæµ‹è¯•å¥—ä»¶
func TestUserServiceTestSuite(t *testing.T) {
    suite.Run(t, new(UserServiceTestSuite))
}
```

---

## 12. æ€»ç»“

### 12.1 å…³é”®è¦ç‚¹

1. **æµ‹è¯•ç¯å¢ƒéš”ç¦»**ï¼šä½¿ç”¨ InMemory SpanRecorderï¼Œé¿å…å¤–éƒ¨ä¾èµ–
2. **æ–­è¨€è¿½è¸ªæ•°æ®**ï¼šéªŒè¯ Span åç§°ã€çŠ¶æ€ã€å±æ€§å’Œå±‚çº§å…³ç³»
3. **æ€§èƒ½åŸºå‡†æµ‹è¯•**ï¼šé‡åŒ–è¿½è¸ªå¼€é”€ï¼Œä¼˜åŒ–å…³é”®è·¯å¾„
4. **Mock ä¸å­˜æ ¹**ï¼šè§£è€¦æµ‹è¯•ï¼Œæé«˜å¯æµ‹è¯•æ€§
5. **å¹¶å‘æµ‹è¯•**ï¼šéªŒè¯çº¿ç¨‹å®‰å…¨å’Œå¹¶å‘æ­£ç¡®æ€§

### 12.2 æµ‹è¯•æ£€æŸ¥æ¸…å•

- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 80%
- [ ] æ‰€æœ‰å…³é”®è·¯å¾„æœ‰è¿½è¸ªéªŒè¯
- [ ] åŸºå‡†æµ‹è¯•è¿½è¸ªå¼€é”€ < 15%
- [ ] é”™è¯¯åœºæ™¯æœ‰è¿½è¸ªéªŒè¯
- [ ] å¹¶å‘æµ‹è¯•æ— æ•°æ®ç«äº‰
- [ ] Mock æ¥å£å®Œæ•´è¦†ç›–
- [ ] é›†æˆæµ‹è¯•éªŒè¯ Context ä¼ æ’­

### 12.3 å‚è€ƒèµ„æº

- [Go Testing å®˜æ–¹æ–‡æ¡£](https://pkg.go.dev/testing)
- [OpenTelemetry Go SDK Testing](https://pkg.go.dev/go.opentelemetry.io/otel/sdk/trace/tracetest)
- [Testify æ–­è¨€åº“](https://github.com/stretchr/testify)
- [Go 1.25.1 Release Notes](https://go.dev/doc/go1.25)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v2025.1  
**æœ€åæ›´æ–°**: 2025-10-11  
**ç»´æŠ¤è€…**: OTLP Integration Team
