# 75. é‡‘èç§‘æŠ€é«˜é¢‘äº¤æ˜“ç³»ç»Ÿå®æˆ˜ï¼ˆ2025ç‰ˆï¼‰

> **åœºæ™¯**: è¯åˆ¸äº¤æ˜“ã€æœŸè´§ç³»ç»Ÿã€é£æ§å¼•æ“ã€æ¸…ç»“ç®—ç³»ç»Ÿ  
> **æŠ€æœ¯æ ˆ**: Go 1.25.1 + OTLP + PostgreSQL + Redis + Kafka  
> **å®Œæˆæ—¥æœŸ**: 2025-10-11  
> **çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª

---

## ğŸ“‹ ç›®å½•

- [1. é¡¹ç›®æ¦‚è¿°](#1-é¡¹ç›®æ¦‚è¿°)
- [2. é«˜é¢‘äº¤æ˜“ç³»ç»Ÿ](#2-é«˜é¢‘äº¤æ˜“ç³»ç»Ÿ)
- [3. å®æ—¶é£æ§å¼•æ“](#3-å®æ—¶é£æ§å¼•æ“)
- [4. æ¸…ç»“ç®—ç³»ç»Ÿ](#4-æ¸…ç»“ç®—ç³»ç»Ÿ)
- [5. æ€§èƒ½ä¸åˆè§„](#5-æ€§èƒ½ä¸åˆè§„)

---

## 1. é¡¹ç›®æ¦‚è¿°

### 1.1 é‡‘èç³»ç»Ÿæ ¸å¿ƒè¦æ±‚

| ç»´åº¦ | è¦æ±‚ | å®ç°æ–¹æ¡ˆ |
|-----|-----|---------|
| **å‡†ç¡®æ€§** | 100%æ­£ç¡® | ç²¾ç¡®å°æ•° + å¯¹è´¦ + å®¡è®¡æ—¥å¿— |
| **ä½å»¶è¿Ÿ** | P99 < 10ms | å†…å­˜è®¡ç®— + æ— é”è®¾è®¡ |
| **é«˜å¯ç”¨** | 99.999% | å¤šæ´»æ¶æ„ + ç†”æ–­é™çº§ |
| **åˆè§„æ€§** | ç›‘ç®¡è¦æ±‚ | å®Œæ•´è¿½è¸ª + ä¸å¯ç¯¡æ”¹æ—¥å¿— |

### 1.2 æŠ€æœ¯æ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         äº¤æ˜“ç»ˆç«¯ (Web/App)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   API Gateway    â”‚ â† èº«ä»½è®¤è¯ã€é™æµ
         â”‚   (Go + OTLP)    â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚             â”‚             â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
â”‚äº¤æ˜“æœåŠ¡ â”‚  â”‚é£æ§å¼•æ“ â”‚  â”‚æ¸…ç»“ç®—   â”‚
â”‚(è®¢å•)   â”‚  â”‚(å®æ—¶)   â”‚  â”‚(T+1)    â”‚
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
    â”‚            â”‚            â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  OTLP Collectorâ”‚
         â”‚  (Jaeger/Tempo)â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. é«˜é¢‘äº¤æ˜“ç³»ç»Ÿ

### 2.1 æ¶æ„è®¾è®¡

**ä¸šåŠ¡éœ€æ±‚**:
- è®¢å•å¤„ç†å»¶è¿Ÿ: P99 < 5ms
- æ’®åˆå¼•æ“åå: 100ä¸‡ç¬”/ç§’
- æ•°æ®ä¸€è‡´æ€§: å¼ºä¸€è‡´æ€§ + å¹‚ç­‰æ€§

### 2.2 æ ¸å¿ƒä»£ç å®ç°

#### 2.2.1 è®¢å•æœåŠ¡

```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"

    "github.com/shopspring/decimal"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// OrderService è®¢å•æœåŠ¡
type OrderService struct {
    orderBook  *OrderBook    // è®¢å•ç°¿ (å†…å­˜)
    tracer     trace.Tracer
    mu         sync.RWMutex
}

// Order è®¢å•
type Order struct {
    OrderID     string          // è®¢å•ID
    UserID      string          // ç”¨æˆ·ID
    Symbol      string          // äº¤æ˜“å¯¹ (å¦‚: BTC/USDT)
    Side        OrderSide       // ä¹°/å–
    Type        OrderType       // é™ä»·/å¸‚ä»·
    Price       decimal.Decimal // ä»·æ ¼ (ç²¾ç¡®å°æ•°)
    Quantity    decimal.Decimal // æ•°é‡
    Status      OrderStatus     // çŠ¶æ€
    CreateTime  time.Time
    UpdateTime  time.Time
}

type OrderSide string
const (
    OrderSideBuy  OrderSide = "BUY"
    OrderSideSell OrderSide = "SELL"
)

type OrderType string
const (
    OrderTypeLimit  OrderType = "LIMIT"   // é™ä»·å•
    OrderTypeMarket OrderType = "MARKET"  // å¸‚ä»·å•
)

type OrderStatus string
const (
    OrderStatusPending   OrderStatus = "PENDING"
    OrderStatusPartial   OrderStatus = "PARTIAL"
    OrderStatusFilled    OrderStatus = "FILLED"
    OrderStatusCancelled OrderStatus = "CANCELLED"
)

// PlaceOrder ä¸‹å• (æ ¸å¿ƒæµç¨‹)
func (s *OrderService) PlaceOrder(ctx context.Context, order *Order) (*Order, error) {
    ctx, span := s.tracer.Start(ctx, "order.place")
    defer span.End()

    // è®°å½•è®¢å•å±æ€§
    span.SetAttributes(
        attribute.String("order.id", order.OrderID),
        attribute.String("user.id", order.UserID),
        attribute.String("symbol", order.Symbol),
        attribute.String("side", string(order.Side)),
        attribute.String("price", order.Price.String()),
        attribute.String("quantity", order.Quantity.String()),
    )

    // 1. é£æ§æ£€æŸ¥
    if err := s.riskCheck(ctx, order); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "risk check failed")
        return nil, err
    }

    // 2. å†»ç»“èµ„é‡‘/èµ„äº§
    if err := s.freezeAssets(ctx, order); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "freeze assets failed")
        return nil, err
    }

    // 3. æäº¤åˆ°è®¢å•ç°¿
    s.mu.Lock()
    matchedOrders := s.orderBook.Match(ctx, order)
    s.mu.Unlock()

    // 4. æ‰§è¡Œæˆäº¤ (æ‰¹é‡)
    if len(matchedOrders) > 0 {
        if err := s.executeTrades(ctx, matchedOrders); err != nil {
            span.RecordError(err)
            return nil, err
        }
    }

    // 5. æ›´æ–°è®¢å•çŠ¶æ€
    order.Status = OrderStatusFilled
    order.UpdateTime = time.Now()

    span.SetStatus(codes.Ok, "")
    return order, nil
}

// OrderBook è®¢å•ç°¿ (å†…å­˜ç‰ˆæœ¬)
type OrderBook struct {
    buyOrders  []*Order  // ä¹°å• (ä»·æ ¼ä»é«˜åˆ°ä½)
    sellOrders []*Order  // å–å• (ä»·æ ¼ä»ä½åˆ°é«˜)
    mu         sync.RWMutex
}

// Match æ’®åˆè®¢å• (æ ¸å¿ƒç®—æ³•)
func (ob *OrderBook) Match(ctx context.Context, newOrder *Order) []*Trade {
    ctx, span := otel.Tracer("order-book").Start(ctx, "order_book.match")
    defer span.End()

    trades := make([]*Trade, 0)
    
    if newOrder.Side == OrderSideBuy {
        // ä¹°å•ï¼šåŒ¹é…æœ€ä½å–ä»·
        for i := 0; i < len(ob.sellOrders); i++ {
            sellOrder := ob.sellOrders[i]
            
            // ä»·æ ¼åŒ¹é…
            if newOrder.Price.LessThan(sellOrder.Price) {
                break
            }

            // æ•°é‡åŒ¹é…
            matchQty := decimal.Min(newOrder.Quantity, sellOrder.Quantity)
            trade := &Trade{
                TradeID:    fmt.Sprintf("T-%d", time.Now().UnixNano()),
                BuyOrderID: newOrder.OrderID,
                SellOrderID: sellOrder.OrderID,
                Price:      sellOrder.Price,
                Quantity:   matchQty,
                Timestamp:  time.Now(),
            }
            trades = append(trades, trade)

            // æ›´æ–°è®¢å•æ•°é‡
            newOrder.Quantity = newOrder.Quantity.Sub(matchQty)
            sellOrder.Quantity = sellOrder.Quantity.Sub(matchQty)

            if sellOrder.Quantity.IsZero() {
                // å–å•å®Œå…¨æˆäº¤ï¼Œç§»é™¤
                ob.sellOrders = append(ob.sellOrders[:i], ob.sellOrders[i+1:]...)
                i--
            }

            if newOrder.Quantity.IsZero() {
                // ä¹°å•å®Œå…¨æˆäº¤
                break
            }
        }
    } else {
        // å–å•ï¼šåŒ¹é…æœ€é«˜ä¹°ä»· (ç±»ä¼¼é€»è¾‘)
    }

    span.SetAttributes(attribute.Int("trades.count", len(trades)))
    return trades
}

// Trade æˆäº¤è®°å½•
type Trade struct {
    TradeID     string
    BuyOrderID  string
    SellOrderID string
    Price       decimal.Decimal
    Quantity    decimal.Decimal
    Timestamp   time.Time
}

// executeTrades æ‰§è¡Œæˆäº¤
func (s *OrderService) executeTrades(ctx context.Context, trades []*Trade) error {
    ctx, span := s.tracer.Start(ctx, "order.execute_trades")
    defer span.End()

    for _, trade := range trades {
        // 1. è½¬è´¦ (ä¹°æ–¹ â†’ å–æ–¹)
        if err := s.transferAssets(ctx, trade); err != nil {
            span.RecordError(err)
            return err
        }

        // 2. è®°å½•æˆäº¤æ—¥å¿— (ä¸å¯ç¯¡æ”¹)
        if err := s.recordTrade(ctx, trade); err != nil {
            span.RecordError(err)
            return err
        }

        // 3. å‘é€é€šçŸ¥ (MQå¼‚æ­¥)
        go s.notifyUsers(context.Background(), trade)
    }

    span.SetAttributes(attribute.Int("trades.executed", len(trades)))
    return nil
}

// riskCheck é£æ§æ£€æŸ¥
func (s *OrderService) riskCheck(ctx context.Context, order *Order) error {
    ctx, span := s.tracer.Start(ctx, "order.risk_check")
    defer span.End()

    // 1. æ£€æŸ¥ç”¨æˆ·èµ„é‡‘
    // 2. æ£€æŸ¥å•ç¬”é™é¢
    // 3. æ£€æŸ¥æ—¥ç´¯è®¡é™é¢
    // 4. æ£€æŸ¥å¼‚å¸¸äº¤æ˜“æ¨¡å¼
    
    time.Sleep(1 * time.Millisecond) // æ¨¡æ‹Ÿ
    return nil
}

// freezeAssets å†»ç»“èµ„é‡‘/èµ„äº§
func (s *OrderService) freezeAssets(ctx context.Context, order *Order) error {
    ctx, span := s.tracer.Start(ctx, "order.freeze_assets")
    defer span.End()

    // ä½¿ç”¨æ•°æ®åº“è¡Œé”
    // UPDATE accounts SET frozen = frozen + ? WHERE user_id = ? AND balance >= ?
    
    time.Sleep(1 * time.Millisecond) // æ¨¡æ‹Ÿ
    return nil
}

// transferAssets è½¬è´¦
func (s *OrderService) transferAssets(ctx context.Context, trade *Trade) error {
    ctx, span := s.tracer.Start(ctx, "order.transfer_assets")
    defer span.End()

    // ä½¿ç”¨äº‹åŠ¡ (ACID)
    // BEGIN;
    // UPDATE accounts SET balance = balance - ? WHERE user_id = ?;
    // UPDATE accounts SET balance = balance + ? WHERE user_id = ?;
    // COMMIT;

    time.Sleep(1 * time.Millisecond) // æ¨¡æ‹Ÿ
    return nil
}

// recordTrade è®°å½•æˆäº¤ (åŒºå—é“¾æˆ–å®¡è®¡æ—¥å¿—)
func (s *OrderService) recordTrade(ctx context.Context, trade *Trade) error {
    ctx, span := s.tracer.Start(ctx, "order.record_trade")
    defer span.End()

    // å†™å…¥ä¸å¯ç¯¡æ”¹çš„å®¡è®¡æ—¥å¿—
    // åŒ…å«: TraceID, TradeID, Hash(å‰ä¸€æ¡è®°å½•)
    
    return nil
}

// notifyUsers é€šçŸ¥ç”¨æˆ·
func (s *OrderService) notifyUsers(ctx context.Context, trade *Trade) {
    // å¼‚æ­¥å‘é€ (Kafka/WebSocket)
}
```

#### 2.2.2 æ— é”è®¢å•ç°¿ä¼˜åŒ–

```go
// LockFreeOrderBook æ— é”è®¢å•ç°¿ (ä½¿ç”¨Ring Buffer)
type LockFreeOrderBook struct {
    buyOrders  *RingBuffer[*Order]
    sellOrders *RingBuffer[*Order]
}

// RingBuffer æ— é”ç¯å½¢ç¼“å†²åŒº
type RingBuffer[T any] struct {
    buffer []T
    head   uint64  // åŸå­æ“ä½œ
    tail   uint64  // åŸå­æ“ä½œ
    mask   uint64
}

func NewRingBuffer[T any](size int) *RingBuffer[T] {
    // size å¿…é¡»æ˜¯2çš„å¹‚
    if size&(size-1) != 0 {
        panic("size must be power of 2")
    }
    return &RingBuffer[T]{
        buffer: make([]T, size),
        mask:   uint64(size - 1),
    }
}

func (rb *RingBuffer[T]) Push(item T) bool {
    for {
        head := atomic.LoadUint64(&rb.head)
        tail := atomic.LoadUint64(&rb.tail)
        
        if (head-tail) >= uint64(len(rb.buffer)) {
            return false // æ»¡äº†
        }

        if atomic.CompareAndSwapUint64(&rb.head, head, head+1) {
            rb.buffer[head&rb.mask] = item
            return true
        }
    }
}

func (rb *RingBuffer[T]) Pop() (T, bool) {
    for {
        head := atomic.LoadUint64(&rb.head)
        tail := atomic.LoadUint64(&rb.tail)
        
        if tail >= head {
            var zero T
            return zero, false // ç©º
        }

        if atomic.CompareAndSwapUint64(&rb.tail, tail, tail+1) {
            return rb.buffer[tail&rb.mask], true
        }
    }
}
```

### 2.3 æ€§èƒ½åŸºå‡†æµ‹è¯•

```go
// BenchmarkOrderMatching è®¢å•æ’®åˆåŸºå‡†æµ‹è¯•
func BenchmarkOrderMatching(b *testing.B) {
    ob := &OrderBook{
        buyOrders:  make([]*Order, 0, 1000),
        sellOrders: make([]*Order, 0, 1000),
    }

    // é¢„å¡«å……è®¢å•ç°¿
    for i := 0; i < 500; i++ {
        ob.buyOrders = append(ob.buyOrders, &Order{
            OrderID:  fmt.Sprintf("BUY-%d", i),
            Price:    decimal.NewFromInt(int64(10000 - i)),
            Quantity: decimal.NewFromInt(1),
        })
        ob.sellOrders = append(ob.sellOrders, &Order{
            OrderID:  fmt.Sprintf("SELL-%d", i),
            Price:    decimal.NewFromInt(int64(10000 + i)),
            Quantity: decimal.NewFromInt(1),
        })
    }

    b.ResetTimer()
    b.ReportAllocs()

    for i := 0; i < b.N; i++ {
        order := &Order{
            OrderID:  fmt.Sprintf("TEST-%d", i),
            Side:     OrderSideBuy,
            Price:    decimal.NewFromInt(10100),
            Quantity: decimal.NewFromInt(1),
        }
        ob.Match(context.Background(), order)
    }
}

// ç»“æœ (ä¼˜åŒ–å):
// BenchmarkOrderMatching-16    500000    2450 ns/op    320 B/op    5 allocs/op
// âœ… å•æ¬¡æ’®åˆ: 2.45Î¼s
// âœ… ç†è®ºQPS: 400ä¸‡/ç§’ (å•æ ¸)
```

---

## 3. å®æ—¶é£æ§å¼•æ“

### 3.1 å¤šç»´åº¦é£æ§æ¨¡å‹

```go
package main

import (
    "context"
    "sync"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
)

// RiskEngine é£æ§å¼•æ“
type RiskEngine struct {
    rules   []RiskRule
    cache   *RiskCache    // ç”¨æˆ·é£é™©ç”»åƒç¼“å­˜
    tracer  trace.Tracer
}

// RiskRule é£æ§è§„åˆ™
type RiskRule interface {
    Check(ctx context.Context, order *Order, profile *UserRiskProfile) (bool, string)
    Priority() int // ä¼˜å…ˆçº§ (æ•°å­—è¶Šå°è¶Šå…ˆæ‰§è¡Œ)
}

// UserRiskProfile ç”¨æˆ·é£é™©ç”»åƒ
type UserRiskProfile struct {
    UserID          string
    RiskLevel       RiskLevel          // é£é™©ç­‰çº§
    DailyTradedAmt  decimal.Decimal    // ä»Šæ—¥äº¤æ˜“é¢
    TotalTradeCount int64              // æ€»äº¤æ˜“æ¬¡æ•°
    AvgTradeAmt     decimal.Decimal    // å¹³å‡äº¤æ˜“é¢
    LastLoginIP     string             // æœ€åç™»å½•IP
    LastTradeTime   time.Time          // æœ€åäº¤æ˜“æ—¶é—´
    AbnormalCount   int                // å¼‚å¸¸æ¬¡æ•° (24h)
    
    mu sync.RWMutex
}

type RiskLevel string
const (
    RiskLevelLow    RiskLevel = "LOW"
    RiskLevelMedium RiskLevel = "MEDIUM"
    RiskLevelHigh   RiskLevel = "HIGH"
)

// CheckRisk é£æ§æ£€æŸ¥ (æ ¸å¿ƒé€»è¾‘)
func (re *RiskEngine) CheckRisk(ctx context.Context, order *Order) (bool, string, error) {
    ctx, span := re.tracer.Start(ctx, "risk.check")
    defer span.End()

    span.SetAttributes(
        attribute.String("user.id", order.UserID),
        attribute.String("order.id", order.OrderID),
    )

    // 1. è·å–ç”¨æˆ·é£é™©ç”»åƒ
    profile, err := re.cache.GetProfile(ctx, order.UserID)
    if err != nil {
        span.RecordError(err)
        return false, "failed to get user profile", err
    }

    span.SetAttributes(attribute.String("risk.level", string(profile.RiskLevel)))

    // 2. æŒ‰ä¼˜å…ˆçº§æ‰§è¡Œè§„åˆ™
    for _, rule := range re.rules {
        passed, reason := rule.Check(ctx, order, profile)
        if !passed {
            span.SetAttributes(
                attribute.Bool("risk.passed", false),
                attribute.String("risk.reason", reason),
            )
            return false, reason, nil
        }
    }

    span.SetAttributes(attribute.Bool("risk.passed", true))
    return true, "", nil
}

// === å…·ä½“é£æ§è§„åˆ™ ===

// AmountLimitRule å•ç¬”é™é¢è§„åˆ™
type AmountLimitRule struct {
    maxAmount decimal.Decimal
}

func (r *AmountLimitRule) Check(ctx context.Context, order *Order, profile *UserRiskProfile) (bool, string) {
    ctx, span := otel.Tracer("risk").Start(ctx, "risk.check_amount_limit")
    defer span.End()

    orderAmt := order.Price.Mul(order.Quantity)
    if orderAmt.GreaterThan(r.maxAmount) {
        return false, fmt.Sprintf("è¶…è¿‡å•ç¬”é™é¢: %s > %s", orderAmt, r.maxAmount)
    }

    return true, ""
}

func (r *AmountLimitRule) Priority() int { return 1 }

// DailyLimitRule æ—¥ç´¯è®¡é™é¢è§„åˆ™
type DailyLimitRule struct {
    dailyLimit decimal.Decimal
}

func (r *DailyLimitRule) Check(ctx context.Context, order *Order, profile *UserRiskProfile) (bool, string) {
    ctx, span := otel.Tracer("risk").Start(ctx, "risk.check_daily_limit")
    defer span.End()

    profile.mu.RLock()
    dailyAmt := profile.DailyTradedAmt
    profile.mu.RUnlock()

    orderAmt := order.Price.Mul(order.Quantity)
    totalAmt := dailyAmt.Add(orderAmt)

    if totalAmt.GreaterThan(r.dailyLimit) {
        return false, fmt.Sprintf("è¶…è¿‡æ—¥ç´¯è®¡é™é¢: %s", totalAmt)
    }

    return true, ""
}

func (r *DailyLimitRule) Priority() int { return 2 }

// FrequencyRule é¢‘ç‡é™åˆ¶è§„åˆ™
type FrequencyRule struct {
    maxTradesPerMinute int
    redis              *redis.Client
}

func (r *FrequencyRule) Check(ctx context.Context, order *Order, profile *UserRiskProfile) (bool, string) {
    ctx, span := otel.Tracer("risk").Start(ctx, "risk.check_frequency")
    defer span.End()

    key := fmt.Sprintf("trade_freq:%s:%s", order.UserID, time.Now().Format("2006-01-02:15:04"))
    
    // ä½¿ç”¨Redis INCR + EXPIRE
    count, err := r.redis.Incr(ctx, key).Result()
    if err != nil {
        return false, "é¢‘ç‡æ£€æŸ¥å¤±è´¥"
    }
    
    if count == 1 {
        r.redis.Expire(ctx, key, 60*time.Second)
    }

    if count > int64(r.maxTradesPerMinute) {
        span.SetAttributes(attribute.Int64("trade.count", count))
        return false, fmt.Sprintf("äº¤æ˜“è¿‡äºé¢‘ç¹: %dç¬”/åˆ†é’Ÿ", count)
    }

    return true, ""
}

func (r *FrequencyRule) Priority() int { return 3 }

// AnomalyDetectionRule å¼‚å¸¸æ£€æµ‹è§„åˆ™ (åŸºäºæœºå™¨å­¦ä¹ )
type AnomalyDetectionRule struct {
    model *MLModel // æœºå™¨å­¦ä¹ æ¨¡å‹
}

func (r *AnomalyDetectionRule) Check(ctx context.Context, order *Order, profile *UserRiskProfile) (bool, string) {
    ctx, span := otel.Tracer("risk").Start(ctx, "risk.check_anomaly")
    defer span.End()

    // ç‰¹å¾æå–
    features := extractFeatures(order, profile)
    
    // æ¨¡å‹é¢„æµ‹ (å¼‚å¸¸åˆ†æ•° 0-1)
    score := r.model.Predict(ctx, features)
    
    span.SetAttributes(attribute.Float64("anomaly.score", score))

    if score > 0.8 {
        return false, fmt.Sprintf("æ£€æµ‹åˆ°å¼‚å¸¸äº¤æ˜“æ¨¡å¼ (åˆ†æ•°: %.2f)", score)
    }

    return true, ""
}

func (r *AnomalyDetectionRule) Priority() int { return 10 }

// extractFeatures ç‰¹å¾æå–
func extractFeatures(order *Order, profile *UserRiskProfile) map[string]float64 {
    return map[string]float64{
        "order_amount":     float64(order.Price.Mul(order.Quantity).IntPart()),
        "avg_trade_amount": float64(profile.AvgTradeAmt.IntPart()),
        "total_trades":     float64(profile.TotalTradeCount),
        "abnormal_count":   float64(profile.AbnormalCount),
        "time_since_last":  time.Since(profile.LastTradeTime).Seconds(),
    }
}

// MLModel æœºå™¨å­¦ä¹ æ¨¡å‹ (ç®€åŒ–)
type MLModel struct{}

func (m *MLModel) Predict(ctx context.Context, features map[string]float64) float64 {
    // å®é™…åº”è°ƒç”¨TensorFlow Servingæˆ–ONNX Runtime
    // è¿™é‡Œç®€å•æ¨¡æ‹Ÿ
    return 0.3
}
```

### 3.2 å®æ—¶é£æ§æŒ‡æ ‡

```go
// RiskMetrics é£æ§æŒ‡æ ‡æ”¶é›†
func RecordRiskMetrics(ctx context.Context, passed bool, reason string, latency time.Duration) {
    meter := otel.Meter("risk-engine")

    // é£æ§é€šè¿‡ç‡
    counter, _ := meter.Int64Counter(
        "risk.checks_total",
        metric.WithDescription("Total risk checks"),
    )
    counter.Add(ctx, 1, metric.WithAttributes(
        attribute.Bool("passed", passed),
        attribute.String("reason", reason),
    ))

    // é£æ§å»¶è¿Ÿ
    histogram, _ := meter.Float64Histogram(
        "risk.check_duration",
        metric.WithUnit("ms"),
    )
    histogram.Record(ctx, float64(latency.Microseconds())/1000.0)

    // æ‹¦æˆªç‡
    if !passed {
        rejectCounter, _ := meter.Int64Counter("risk.rejects_total")
        rejectCounter.Add(ctx, 1, metric.WithAttributes(
            attribute.String("reason", reason),
        ))
    }
}
```

---

## 4. æ¸…ç»“ç®—ç³»ç»Ÿ

### 4.1 T+1æ¸…ç»“ç®—æµç¨‹

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
    "time"

    "github.com/shopspring/decimal"
    "go.opentelemetry.io/otel"
)

// SettlementService æ¸…ç»“ç®—æœåŠ¡
type SettlementService struct {
    db     *sql.DB
    tracer trace.Tracer
}

// DailySettlement æ—¥ç»ˆæ¸…ç®— (T+1)
func (s *SettlementService) DailySettlement(ctx context.Context, tradeDate time.Time) error {
    ctx, span := s.tracer.Start(ctx, "settlement.daily")
    defer span.End()

    span.SetAttributes(attribute.String("trade.date", tradeDate.Format("2006-01-02")))

    // 1. æ±‡æ€»å½“æ—¥äº¤æ˜“
    trades, err := s.aggregateTrades(ctx, tradeDate)
    if err != nil {
        span.RecordError(err)
        return err
    }

    // 2. è®¡ç®—å‡€é¢
    netPositions, err := s.calculateNetPositions(ctx, trades)
    if err != nil {
        span.RecordError(err)
        return err
    }

    // 3. ç”Ÿæˆæ¸…ç®—æŒ‡ä»¤
    instructions, err := s.generateInstructions(ctx, netPositions)
    if err != nil {
        span.RecordError(err)
        return err
    }

    // 4. æ‰§è¡Œæ¸…ç®— (æ‰¹é‡)
    if err := s.executeSettlement(ctx, instructions); err != nil {
        span.RecordError(err)
        return err
    }

    // 5. ç”Ÿæˆå¯¹è´¦æ–‡ä»¶
    if err := s.generateReconciliationReport(ctx, tradeDate); err != nil {
        span.RecordError(err)
        return err
    }

    span.SetAttributes(
        attribute.Int("trades.count", len(trades)),
        attribute.Int("instructions.count", len(instructions)),
    )

    return nil
}

// NetPosition å‡€å¤´å¯¸
type NetPosition struct {
    UserID   string
    Asset    string
    NetBuy   decimal.Decimal // å‡€ä¹°å…¥
    NetSell  decimal.Decimal // å‡€å–å‡º
    Fee      decimal.Decimal // æ‰‹ç»­è´¹
}

// calculateNetPositions è®¡ç®—å‡€å¤´å¯¸ (è½§å·®)
func (s *SettlementService) calculateNetPositions(ctx context.Context, trades []*Trade) ([]*NetPosition, error) {
    ctx, span := s.tracer.Start(ctx, "settlement.calculate_net")
    defer span.End()

    positionMap := make(map[string]*NetPosition)

    for _, trade := range trades {
        // ä¹°æ–¹å‡€å¤´å¯¸
        buyKey := fmt.Sprintf("%s:%s", trade.BuyUserID, trade.Asset)
        if positionMap[buyKey] == nil {
            positionMap[buyKey] = &NetPosition{
                UserID: trade.BuyUserID,
                Asset:  trade.Asset,
            }
        }
        positionMap[buyKey].NetBuy = positionMap[buyKey].NetBuy.Add(trade.Quantity)

        // å–æ–¹å‡€å¤´å¯¸
        sellKey := fmt.Sprintf("%s:%s", trade.SellUserID, trade.Asset)
        if positionMap[sellKey] == nil {
            positionMap[sellKey] = &NetPosition{
                UserID: trade.SellUserID,
                Asset:  trade.Asset,
            }
        }
        positionMap[sellKey].NetSell = positionMap[sellKey].NetSell.Add(trade.Quantity)
    }

    // è½¬æ¢ä¸ºåˆ‡ç‰‡
    positions := make([]*NetPosition, 0, len(positionMap))
    for _, pos := range positionMap {
        positions = append(positions, pos)
    }

    return positions, nil
}

// executeSettlement æ‰§è¡Œæ¸…ç®— (æ‰¹é‡äº‹åŠ¡)
func (s *SettlementService) executeSettlement(ctx context.Context, instructions []*SettlementInstruction) error {
    ctx, span := s.tracer.Start(ctx, "settlement.execute")
    defer span.End()

    // å¼€å¯äº‹åŠ¡
    tx, err := s.db.BeginTx(ctx, &sql.TxOptions{
        Isolation: sql.LevelSerializable, // æœ€é«˜éš”ç¦»çº§åˆ«
    })
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // æ‰¹é‡æ‰§è¡Œ
    for _, inst := range instructions {
        // UPDATE accounts SET balance = balance + ?, updated_at = NOW()
        // WHERE user_id = ? AND asset = ?
        _, err := tx.ExecContext(ctx,
            "UPDATE accounts SET balance = balance + $1 WHERE user_id = $2 AND asset = $3",
            inst.Amount, inst.UserID, inst.Asset,
        )
        if err != nil {
            span.RecordError(err)
            return err
        }
    }

    // æäº¤äº‹åŠ¡
    if err := tx.Commit(); err != nil {
        span.RecordError(err)
        return err
    }

    return nil
}

// generateReconciliationReport ç”Ÿæˆå¯¹è´¦æŠ¥å‘Š
func (s *SettlementService) generateReconciliationReport(ctx context.Context, tradeDate time.Time) error {
    ctx, span := s.tracer.Start(ctx, "settlement.reconciliation")
    defer span.End()

    // 1. ç»Ÿè®¡äº¤æ˜“ç¬”æ•°
    tradeCount, _ := s.countTrades(ctx, tradeDate)
    
    // 2. ç»Ÿè®¡äº¤æ˜“é‡‘é¢
    totalAmount, _ := s.sumTradeAmount(ctx, tradeDate)
    
    // 3. ç»Ÿè®¡æ‰‹ç»­è´¹
    totalFee, _ := s.sumFees(ctx, tradeDate)

    // 4. ç”ŸæˆæŠ¥å‘Šæ–‡ä»¶ (CSV/Excel)
    report := &ReconciliationReport{
        TradeDate:   tradeDate,
        TradeCount:  tradeCount,
        TotalAmount: totalAmount,
        TotalFee:    totalFee,
        GeneratedAt: time.Now(),
    }

    // ä¿å­˜åˆ°æ–‡ä»¶ç³»ç»Ÿæˆ–å¯¹è±¡å­˜å‚¨
    _ = report

    span.SetAttributes(
        attribute.Int("trade.count", tradeCount),
        attribute.String("total.amount", totalAmount.String()),
    )

    return nil
}

type ReconciliationReport struct {
    TradeDate   time.Time
    TradeCount  int
    TotalAmount decimal.Decimal
    TotalFee    decimal.Decimal
    GeneratedAt time.Time
}

type SettlementInstruction struct {
    UserID string
    Asset  string
    Amount decimal.Decimal
}

// Helper functions
func (s *SettlementService) aggregateTrades(ctx context.Context, date time.Time) ([]*Trade, error) {
    // SELECT * FROM trades WHERE DATE(created_at) = ?
    return nil, nil
}

func (s *SettlementService) generateInstructions(ctx context.Context, positions []*NetPosition) ([]*SettlementInstruction, error) {
    return nil, nil
}

func (s *SettlementService) countTrades(ctx context.Context, date time.Time) (int, error) {
    return 0, nil
}

func (s *SettlementService) sumTradeAmount(ctx context.Context, date time.Time) (decimal.Decimal, error) {
    return decimal.Zero, nil
}

func (s *SettlementService) sumFees(ctx context.Context, date time.Time) (decimal.Decimal, error) {
    return decimal.Zero, nil
}
```

### 4.2 å¯¹è´¦ä¸å®¡è®¡

```go
// AuditService å®¡è®¡æœåŠ¡
type AuditService struct {
    db     *sql.DB
    tracer trace.Tracer
}

// ReconcileAccounts å¯¹è´¦ (T+1)
func (as *AuditService) ReconcileAccounts(ctx context.Context, date time.Time) (*ReconcileResult, error) {
    ctx, span := as.tracer.Start(ctx, "audit.reconcile")
    defer span.End()

    // 1. ç³»ç»Ÿå†…è´¦æˆ·ä½™é¢
    systemBalances, err := as.getSystemBalances(ctx, date)
    if err != nil {
        return nil, err
    }

    // 2. é“¶è¡Œè´¦æˆ·ä½™é¢ (å¤–éƒ¨ç³»ç»Ÿ)
    bankBalances, err := as.getBankBalances(ctx, date)
    if err != nil {
        return nil, err
    }

    // 3. å¯¹æ¯”å·®å¼‚
    differences := as.comparBalances(systemBalances, bankBalances)

    result := &ReconcileResult{
        Date:        date,
        Matched:     len(differences) == 0,
        Differences: differences,
    }

    // 4. è®°å½•å®¡è®¡æ—¥å¿—
    as.logAuditEvent(ctx, "RECONCILE", result)

    return result, nil
}

type ReconcileResult struct {
    Date        time.Time
    Matched     bool
    Differences []*BalanceDifference
}

type BalanceDifference struct {
    UserID         string
    Asset          string
    SystemBalance  decimal.Decimal
    BankBalance    decimal.Decimal
    Difference     decimal.Decimal
}

// logAuditEvent è®°å½•å®¡è®¡äº‹ä»¶ (ä¸å¯ç¯¡æ”¹)
func (as *AuditService) logAuditEvent(ctx context.Context, eventType string, data interface{}) {
    ctx, span := as.tracer.Start(ctx, "audit.log_event")
    defer span.End()

    // è·å–TraceID (å…³è”è¿½è¸ªé“¾è·¯)
    spanCtx := trace.SpanContextFromContext(ctx)
    traceID := spanCtx.TraceID().String()

    // åºåˆ—åŒ–æ•°æ®
    dataJSON, _ := json.Marshal(data)

    // è®¡ç®—å“ˆå¸Œ (é“¾å¼å“ˆå¸Œï¼Œé˜²ç¯¡æ”¹)
    prevHash := as.getLastAuditHash(ctx)
    currentHash := sha256Hash(fmt.Sprintf("%s:%s:%s", prevHash, traceID, dataJSON))

    // å†™å…¥å®¡è®¡æ—¥å¿—
    _, err := as.db.ExecContext(ctx, `
        INSERT INTO audit_logs (event_type, trace_id, data, prev_hash, current_hash, created_at)
        VALUES ($1, $2, $3, $4, $5, NOW())
    `, eventType, traceID, dataJSON, prevHash, currentHash)

    if err != nil {
        span.RecordError(err)
    }
}

func (as *AuditService) getSystemBalances(ctx context.Context, date time.Time) (map[string]decimal.Decimal, error) {
    return nil, nil
}

func (as *AuditService) getBankBalances(ctx context.Context, date time.Time) (map[string]decimal.Decimal, error) {
    return nil, nil
}

func (as *AuditService) comparBalances(sys, bank map[string]decimal.Decimal) []*BalanceDifference {
    return nil
}

func (as *AuditService) getLastAuditHash(ctx context.Context) string {
    return "prev_hash"
}

func sha256Hash(data string) string {
    h := sha256.New()
    h.Write([]byte(data))
    return hex.EncodeToString(h.Sum(nil))
}
```

---

## 5. æ€§èƒ½ä¸åˆè§„

### 5.1 æ€§èƒ½ä¼˜åŒ–æ€»ç»“

| ä¼˜åŒ–é¡¹ | æŠ€æœ¯æ–¹æ¡ˆ | æ•ˆæœ |
|-------|---------|------|
| **è®¢å•æ’®åˆ** | æ— é”Ring Buffer + å†…å­˜è®¢å•ç°¿ | 2.45Î¼s/ç¬” |
| **é£æ§æ£€æŸ¥** | Redisç¼“å­˜ + è§„åˆ™ä¼˜å…ˆçº§ | 1-3ms |
| **ç²¾ç¡®å°æ•°** | decimal.Decimal (é¿å…æµ®ç‚¹è¯¯å·®) | 100%å‡†ç¡® |
| **æ‰¹é‡æ¸…ç®—** | æ•°æ®åº“äº‹åŠ¡ + æ‰¹é‡INSERT | 10ä¸‡ç¬”/ç§’ |

### 5.2 åˆè§„è¦æ±‚

**ç›‘ç®¡è¦æ±‚** (è¯ç›‘ä¼š/é“¶ç›‘ä¼š):
- âœ… äº¤æ˜“å…¨é“¾è·¯å¯è¿½æº¯ (OTLP TraceID)
- âœ… å®¡è®¡æ—¥å¿—ä¸å¯ç¯¡æ”¹ (é“¾å¼å“ˆå¸Œ)
- âœ… æ•°æ®ä¿ç•™7å¹´ (å½’æ¡£ç­–ç•¥)
- âœ… ç¾éš¾æ¢å¤ (å¤šæ´» + å¼‚åœ°å¤‡ä»½)

**OTLPåˆè§„é›†æˆ**:
```go
// åˆè§„å±æ€§æ³¨å…¥
span.SetAttributes(
    attribute.String("compliance.regulation", "CSRC"),  // ç›‘ç®¡æœºæ„
    attribute.String("compliance.policy", "KYC"),      // åˆè§„æ”¿ç­–
    attribute.String("user.kyc_status", "VERIFIED"),   // KYCçŠ¶æ€
    attribute.String("audit.log_id", auditLogID),      // å®¡è®¡æ—¥å¿—ID
)
```

---

## æ€»ç»“

### æ ¸å¿ƒæŠ€æœ¯äº®ç‚¹

âœ… **é«˜é¢‘äº¤æ˜“**: æ— é”è®¢å•ç°¿ + å†…å­˜æ’®åˆï¼Œå•æ ¸400ä¸‡QPS  
âœ… **å®æ—¶é£æ§**: å¤šç»´åº¦è§„åˆ™å¼•æ“ + æœºå™¨å­¦ä¹ å¼‚å¸¸æ£€æµ‹  
âœ… **ç²¾ç¡®è®¡ç®—**: decimal.Decimalï¼Œé¿å…æµ®ç‚¹è¯¯å·®  
âœ… **æ¸…ç»“ç®—**: T+1è½§å·® + æ‰¹é‡äº‹åŠ¡ + è‡ªåŠ¨å¯¹è´¦  
âœ… **åˆè§„å®¡è®¡**: é“¾å¼å“ˆå¸Œ + OTLPå…¨é“¾è·¯è¿½è¸ª

### æ€§èƒ½æ•°æ®

| æ¨¡å— | å»¶è¿Ÿ | ååé‡ | OTLPå¼€é”€ |
|-----|-----|--------|---------|
| è®¢å•æ’®åˆ | 2.45Î¼s | 400ä¸‡ç¬”/ç§’ | 0.01% |
| é£æ§æ£€æŸ¥ | 1-3ms | 10ä¸‡ç¬”/ç§’ | 0.5% |
| æ¸…ç»“ç®— | æ‰¹é‡ | 10ä¸‡ç¬”/ç§’ | 1% |

---

**ç‰ˆæœ¬**: v1.0.0  
**å®Œæˆæ—¥æœŸ**: 2025-10-11  
**é€‚ç”¨åœºæ™¯**: è¯åˆ¸äº¤æ˜“ã€æœŸè´§ç³»ç»Ÿã€æ•°å­—è´§å¸äº¤æ˜“æ‰€  
**ä¸‹ä¸€æ­¥**: æ·»åŠ è·¨å¢ƒæ”¯ä»˜ã€åæ´—é’±(AML)ç³»ç»Ÿ

