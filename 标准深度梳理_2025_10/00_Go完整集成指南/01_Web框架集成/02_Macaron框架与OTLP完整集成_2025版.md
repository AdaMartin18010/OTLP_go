# Macaron Ê°ÜÊû∂‰∏é OTLP ÂÆåÊï¥ÈõÜÊàêÔºà2025ÁâàÔºâ

> **Macaron ÁâàÊú¨**: v1.5.0  
> **Go ÁâàÊú¨**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0  
> **ÊúÄÂêéÊõ¥Êñ∞**: 2025-10-11  
> **ÊñáÊ°£Áä∂ÊÄÅ**: ‚úÖ Áîü‰∫ßÂèÇËÄÉ

---

## üìã ÁõÆÂΩï

- [Macaron Ê°ÜÊû∂‰∏é OTLP ÂÆåÊï¥ÈõÜÊàêÔºà2025ÁâàÔºâ](#macaron-Ê°ÜÊû∂‰∏é-otlp-ÂÆåÊï¥ÈõÜÊàê2025Áâà)
  - [üìã ÁõÆÂΩï](#-ÁõÆÂΩï)
  - [1. Macaron Ê°ÜÊû∂Ê¶ÇËø∞](#1-macaron-Ê°ÜÊû∂Ê¶ÇËø∞)
    - [1.1 Ê°ÜÊû∂ÁâπÁÇπ](#11-Ê°ÜÊû∂ÁâπÁÇπ)
    - [1.2 ÈÄÇÁî®Âú∫ÊôØ](#12-ÈÄÇÁî®Âú∫ÊôØ)
    - [1.3 ÊÄßËÉΩÂØπÊØî](#13-ÊÄßËÉΩÂØπÊØî)
  - [2. Âø´ÈÄüÂºÄÂßã](#2-Âø´ÈÄüÂºÄÂßã)
    - [2.1 ‰æùËµñÂÆâË£Ö](#21-‰æùËµñÂÆâË£Ö)
    - [2.2 Âü∫Á°ÄÈÖçÁΩÆ](#22-Âü∫Á°ÄÈÖçÁΩÆ)
    - [2.3 OTLP ÂàùÂßãÂåñ](#23-otlp-ÂàùÂßãÂåñ)
  - [3. OTLP ‰∏≠Èó¥‰ª∂ÈõÜÊàê](#3-otlp-‰∏≠Èó¥‰ª∂ÈõÜÊàê)
    - [3.1 ËøΩË∏™‰∏≠Èó¥‰ª∂](#31-ËøΩË∏™‰∏≠Èó¥‰ª∂)
    - [3.2 ÊåáÊ†á‰∏≠Èó¥‰ª∂](#32-ÊåáÊ†á‰∏≠Èó¥‰ª∂)
    - [3.3 Êó•Âøó‰∏≠Èó¥‰ª∂](#33-Êó•Âøó‰∏≠Èó¥‰ª∂)
  - [4. ÂÆåÊï¥Á§∫‰æã](#4-ÂÆåÊï¥Á§∫‰æã)
    - [4.1 Áî®Êà∑ÊúçÂä°](#41-Áî®Êà∑ÊúçÂä°)
    - [4.2 ËÆ¢ÂçïÊúçÂä°](#42-ËÆ¢ÂçïÊúçÂä°)
    - [4.3 ‰∏≠Èó¥‰ª∂Ê†à](#43-‰∏≠Èó¥‰ª∂Ê†à)
  - [5. È´òÁ∫ßÁâπÊÄß](#5-È´òÁ∫ßÁâπÊÄß)
    - [5.1 Ê®°ÊùøÊ∏≤ÊüìËøΩË∏™](#51-Ê®°ÊùøÊ∏≤ÊüìËøΩË∏™)
    - [5.2 ‰ºöËØùÁÆ°ÁêÜËøΩË∏™](#52-‰ºöËØùÁÆ°ÁêÜËøΩË∏™)
    - [5.3 ÈùôÊÄÅÊñá‰ª∂ËøΩË∏™](#53-ÈùôÊÄÅÊñá‰ª∂ËøΩË∏™)
  - [6. ÊÄßËÉΩ‰ºòÂåñ](#6-ÊÄßËÉΩ‰ºòÂåñ)
    - [6.1 ÈááÊ†∑Á≠ñÁï•](#61-ÈááÊ†∑Á≠ñÁï•)
    - [6.2 ÊâπÂ§ÑÁêÜ‰ºòÂåñ](#62-ÊâπÂ§ÑÁêÜ‰ºòÂåñ)
    - [6.3 ÂÜÖÂ≠ò‰ºòÂåñ](#63-ÂÜÖÂ≠ò‰ºòÂåñ)
  - [7. Áîü‰∫ßÈÉ®ÁΩ≤](#7-Áîü‰∫ßÈÉ®ÁΩ≤)
    - [7.1 Docker ÈÉ®ÁΩ≤](#71-docker-ÈÉ®ÁΩ≤)
    - [7.2 Kubernetes ÈÉ®ÁΩ≤](#72-kubernetes-ÈÉ®ÁΩ≤)
    - [7.3 ÁõëÊéßÈÖçÁΩÆ](#73-ÁõëÊéßÈÖçÁΩÆ)
  - [8. ‰∏é Gitea ÈõÜÊàêÔºàÂÆûÊàòÊ°à‰æãÔºâ](#8-‰∏é-gitea-ÈõÜÊàêÂÆûÊàòÊ°à‰æã)
    - [8.1 Gitea Êû∂ÊûÑ](#81-gitea-Êû∂ÊûÑ)
    - [8.2 ËøΩË∏™ÈõÜÊàê](#82-ËøΩË∏™ÈõÜÊàê)
  - [9. ÊÄªÁªì](#9-ÊÄªÁªì)
    - [9.1 ‰ºòÂäø‰∏éÂä£Âäø](#91-‰ºòÂäø‰∏éÂä£Âäø)
    - [9.2 ÊúÄ‰Ω≥ÂÆûË∑µ](#92-ÊúÄ‰Ω≥ÂÆûË∑µ)

---

## 1. Macaron Ê°ÜÊû∂Ê¶ÇËø∞

### 1.1 Ê°ÜÊû∂ÁâπÁÇπ

**Macaron** ÊòØ‰∏Ä‰∏™Ê®°ÂùóÂåñÁöÑ Go Web Ê°ÜÊû∂ÔºåÁî±ÂõΩ‰∫∫ÂºÄÂèëÔºåË¢´ Gitea„ÄÅGogs Á≠âÁü•ÂêçÈ°πÁõÆ‰ΩøÁî®„ÄÇ

```text
‚úÖ Ê†∏ÂøÉÁâπÊÄß:
  - Ê®°ÂùóÂåñËÆæËÆ° - Êèí‰ª∂ÂºèÊû∂ÊûÑ
  - ‰æùËµñÊ≥®ÂÖ• - Á±ª‰ºº Martini ‰ΩÜÊõ¥ËΩªÈáè
  - ‰∏≠Èó¥‰ª∂ÁîüÊÄÅ - ‰∏∞ÂØåÁöÑÂÆòÊñπ‰∏≠Èó¥‰ª∂
  - Ê®°ÊùøÂºïÊìé - ÂÜÖÁΩÆÂ§öÁßçÊ®°ÊùøÊîØÊåÅ
  - ‰ºöËØùÁÆ°ÁêÜ - ÂºÄÁÆ±Âç≥Áî®
  - ÂõΩÈôÖÂåñÊîØÊåÅ - i18n ÂÆåÊï¥ÊîØÊåÅ

üìä Áîü‰∫ß‰ΩøÁî®:
  - Gitea (Git ÊúçÂä°)
  - Gogs (Git ÊúçÂä°)
  - ‰∏≠Â∞èÂûã Web Â∫îÁî®
```

### 1.2 ÈÄÇÁî®Âú∫ÊôØ

```go
// ‚úÖ ÈÄÇÂêàÂú∫ÊôØ
scenarios := []string{
    "‰º†Áªü Web Â∫îÁî®",
    "ÂÜÖÂÆπÁÆ°ÁêÜÁ≥ªÁªü",
    "ÂêéÂè∞ÁÆ°ÁêÜÁïåÈù¢",
    "ÈúÄË¶ÅÊ®°ÊùøÊ∏≤ÊüìÁöÑÂ∫îÁî®",
    "‰∏≠Â∞èÂûãÈ°πÁõÆ",
}

// ‚ö†Ô∏è ‰∏çÈÄÇÂêàÂú∫ÊôØ
notSuitable := []string{
    "È´òÂπ∂Âèë API ÊúçÂä°",      // Êé®Ëçê Gin/Fiber
    "ÂæÆÊúçÂä°Êû∂ÊûÑ",           // Êé®Ëçê Go-Kit/Kratos
    "ÂÆûÊó∂ÈÄö‰ø°",             // Êé®Ëçê Gorilla WebSocket
    "GraphQL ÊúçÂä°",         // Êé®Ëçê gqlgen
}
```

### 1.3 ÊÄßËÉΩÂØπÊØî

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Ê°ÜÊû∂      ‚îÇ  RPS      ‚îÇ Âª∂Ëøü(ms)  ‚îÇ ÂÜÖÂ≠ò(MB)   ‚îÇ CPU‰ΩøÁî®Áéá  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Macaron     ‚îÇ  15,000   ‚îÇ    3.5    ‚îÇ    45      ‚îÇ    35%     ‚îÇ
‚îÇ Gin         ‚îÇ  50,000   ‚îÇ    1.2    ‚îÇ    30      ‚îÇ    25%     ‚îÇ
‚îÇ Echo        ‚îÇ  45,000   ‚îÇ    1.3    ‚îÇ    28      ‚îÇ    24%     ‚îÇ
‚îÇ Chi         ‚îÇ  40,000   ‚îÇ    1.5    ‚îÇ    25      ‚îÇ    23%     ‚îÇ
‚îÇ Fiber       ‚îÇ  55,000   ‚îÇ    1.0    ‚îÇ    32      ‚îÇ    26%     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

ËØ¥Êòé: Macaron ÊÄßËÉΩÈÄÇ‰∏≠ÔºåÈÄÇÂêàÂÜÖÂÆπÂûãÂ∫îÁî®
```

---

## 2. Âø´ÈÄüÂºÄÂßã

### 2.1 ‰æùËµñÂÆâË£Ö

```bash
# Macaron Ê°ÜÊû∂
go get -u gopkg.in/macaron.v1

# OTLP ‰æùËµñ
go get go.opentelemetry.io/otel@v1.32.0
go get go.opentelemetry.io/otel/sdk@v1.32.0
go get go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc@v1.32.0
go get go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc@v1.32.0

# Macaron ‰∏≠Èó¥‰ª∂
go get gopkg.in/macaron.v1/modules/cache
go get gopkg.in/macaron.v1/modules/session
go get gopkg.in/macaron.v1/modules/i18n
```

### 2.2 Âü∫Á°ÄÈÖçÁΩÆ

```go
package main

import (
    "context"
    "log"
    "time"
    
    "gopkg.in/macaron.v1"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/sdk/resource"
    "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// MacaronApp Macaron Â∫îÁî®
type MacaronApp struct {
    *macaron.Macaron
    tp *trace.TracerProvider
}

// NewMacaronApp ÂàõÂª∫ Macaron Â∫îÁî®
func NewMacaronApp() *MacaronApp {
    m := macaron.Classic()
    
    app := &MacaronApp{
        Macaron: m,
    }
    
    return app
}
```

### 2.3 OTLP ÂàùÂßãÂåñ

```go
// InitOTLP ÂàùÂßãÂåñ OpenTelemetry
func (app *MacaronApp) InitOTLP(ctx context.Context, serviceName string) error {
    // ÂàõÂª∫ OTLP exporter
    exporter, err := otlptracegrpc.New(ctx,
        otlptracegrpc.WithEndpoint("localhost:4317"),
        otlptracegrpc.WithInsecure(),
    )
    if err != nil {
        return fmt.Errorf("failed to create exporter: %w", err)
    }
    
    // ÂàõÂª∫ resource
    res, err := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName(serviceName),
            semconv.ServiceVersion("1.0.0"),
            attribute.String("environment", "production"),
            attribute.String("framework", "macaron"),
        ),
    )
    if err != nil {
        return fmt.Errorf("failed to create resource: %w", err)
    }
    
    // ÂàõÂª∫ TracerProvider
    app.tp = trace.NewTracerProvider(
        trace.WithBatcher(exporter,
            trace.WithBatchTimeout(5*time.Second),
            trace.WithMaxExportBatchSize(512),
        ),
        trace.WithResource(res),
        trace.WithSampler(trace.ParentBased(
            trace.TraceIDRatioBased(0.1), // 10% ÈááÊ†∑
        )),
    )
    
    // ËÆæÁΩÆÂÖ®Â±Ä TracerProvider
    otel.SetTracerProvider(app.tp)
    
    // ËÆæÁΩÆÂÖ®Â±Ä Propagator
    otel.SetTextMapPropagator(
        propagation.NewCompositeTextMapPropagator(
            propagation.TraceContext{},
            propagation.Baggage{},
        ),
    )
    
    return nil
}

// Shutdown ‰ºòÈõÖÂÖ≥Èó≠
func (app *MacaronApp) Shutdown(ctx context.Context) error {
    if app.tp != nil {
        return app.tp.Shutdown(ctx)
    }
    return nil
}
```

---

## 3. OTLP ‰∏≠Èó¥‰ª∂ÈõÜÊàê

### 3.1 ËøΩË∏™‰∏≠Èó¥‰ª∂

```go
package middleware

import (
    "fmt"
    "time"
    
    "gopkg.in/macaron.v1"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// OTLPTracing OTLP ËøΩË∏™‰∏≠Èó¥‰ª∂
func OTLPTracing(serviceName string) macaron.Handler {
    tracer := otel.Tracer(serviceName)
    propagator := otel.GetTextMapPropagator()
    
    return func(ctx *macaron.Context) {
        // ÊèêÂèñ‰∏äÊ∏∏ trace context
        parentCtx := propagator.Extract(ctx.Req.Context(), 
            propagation.HeaderCarrier(ctx.Req.Header))
        
        // ÂàõÂª∫ span
        spanName := fmt.Sprintf("%s %s", ctx.Req.Method, ctx.Req.URL.Path)
        spanCtx, span := tracer.Start(parentCtx, spanName,
            trace.WithSpanKind(trace.SpanKindServer),
            trace.WithAttributes(
                semconv.HTTPMethodKey.String(ctx.Req.Method),
                semconv.HTTPRouteKey.String(ctx.Req.URL.Path),
                semconv.HTTPSchemeKey.String(ctx.Req.URL.Scheme),
                semconv.HTTPTargetKey.String(ctx.Req.URL.RequestURI()),
                semconv.NetHostNameKey.String(ctx.Req.Host),
                semconv.HTTPUserAgentKey.String(ctx.Req.UserAgent()),
                attribute.String("http.client_ip", ctx.RemoteAddr()),
            ),
        )
        defer span.End()
        
        // Â∞Ü context ‰øùÂ≠òÂà∞ Macaron context
        ctx.Req = ctx.Req.WithContext(spanCtx)
        ctx.Data["otel_span"] = span
        ctx.Data["otel_context"] = spanCtx
        
        // ËÆ∞ÂΩïËØ∑Ê±ÇÂºÄÂßãÊó∂Èó¥
        start := time.Now()
        
        // ÁªßÁª≠Â§ÑÁêÜËØ∑Ê±Ç
        ctx.Next()
        
        // ËÆ∞ÂΩïÂìçÂ∫î‰ø°ÊÅØ
        duration := time.Since(start)
        statusCode := ctx.Resp.Status()
        
        span.SetAttributes(
            semconv.HTTPStatusCodeKey.Int(statusCode),
            attribute.Int64("http.response_time_ms", duration.Milliseconds()),
            attribute.Int("http.response_size", ctx.Resp.Size()),
        )
        
        // ËÆæÁΩÆ span Áä∂ÊÄÅ
        if statusCode >= 400 {
            span.SetStatus(codes.Error, fmt.Sprintf("HTTP %d", statusCode))
        } else {
            span.SetStatus(codes.Ok, "")
        }
        
        // Ê≥®ÂÖ• trace context Âà∞ÂìçÂ∫îÂ§¥
        propagator.Inject(spanCtx, propagation.HeaderCarrier(ctx.Resp.Header()))
    }
}

// GetSpan ‰ªé Macaron context Ëé∑Âèñ span
func GetSpan(ctx *macaron.Context) trace.Span {
    if span, ok := ctx.Data["otel_span"].(trace.Span); ok {
        return span
    }
    return trace.SpanFromContext(ctx.Req.Context())
}

// GetContext ‰ªé Macaron context Ëé∑Âèñ context
func GetContext(ctx *macaron.Context) context.Context {
    if spanCtx, ok := ctx.Data["otel_context"].(context.Context); ok {
        return spanCtx
    }
    return ctx.Req.Context()
}
```

### 3.2 ÊåáÊ†á‰∏≠Èó¥‰ª∂

```go
// OTLPMetrics OTLP ÊåáÊ†á‰∏≠Èó¥‰ª∂
func OTLPMetrics(serviceName string) macaron.Handler {
    meter := otel.Meter(serviceName)
    
    // ÂàõÂª∫ÊåáÊ†á
    requestCounter, _ := meter.Int64Counter(
        "http.server.requests",
        metric.WithDescription("Total HTTP requests"),
    )
    
    requestDuration, _ := meter.Float64Histogram(
        "http.server.duration",
        metric.WithDescription("HTTP request duration"),
        metric.WithUnit("ms"),
    )
    
    activeRequests, _ := meter.Int64UpDownCounter(
        "http.server.active_requests",
        metric.WithDescription("Active HTTP requests"),
    )
    
    requestSize, _ := meter.Int64Histogram(
        "http.server.request_size",
        metric.WithDescription("HTTP request size"),
        metric.WithUnit("bytes"),
    )
    
    responseSize, _ := meter.Int64Histogram(
        "http.server.response_size",
        metric.WithDescription("HTTP response size"),
        metric.WithUnit("bytes"),
    )
    
    return func(ctx *macaron.Context) {
        start := time.Now()
        reqCtx := GetContext(ctx)
        
        // Â¢ûÂä†Ê¥ªË∑ÉËØ∑Ê±ÇÊï∞
        activeRequests.Add(reqCtx, 1,
            metric.WithAttributes(
                attribute.String("http.method", ctx.Req.Method),
                attribute.String("http.route", ctx.Req.URL.Path),
            ),
        )
        
        // ËÆ∞ÂΩïËØ∑Ê±ÇÂ§ßÂ∞è
        if ctx.Req.ContentLength > 0 {
            requestSize.Record(reqCtx, ctx.Req.ContentLength,
                metric.WithAttributes(
                    attribute.String("http.method", ctx.Req.Method),
                    attribute.String("http.route", ctx.Req.URL.Path),
                ),
            )
        }
        
        ctx.Next()
        
        duration := time.Since(start).Milliseconds()
        statusCode := ctx.Resp.Status()
        
        attrs := []attribute.KeyValue{
            attribute.String("http.method", ctx.Req.Method),
            attribute.String("http.route", ctx.Req.URL.Path),
            attribute.Int("http.status_code", statusCode),
        }
        
        // ËÆ∞ÂΩïÊåáÊ†á
        requestCounter.Add(reqCtx, 1, metric.WithAttributes(attrs...))
        requestDuration.Record(reqCtx, float64(duration), metric.WithAttributes(attrs...))
        
        // ËÆ∞ÂΩïÂìçÂ∫îÂ§ßÂ∞è
        responseSize.Record(reqCtx, int64(ctx.Resp.Size()), metric.WithAttributes(attrs...))
        
        // ÂáèÂ∞ëÊ¥ªË∑ÉËØ∑Ê±ÇÊï∞
        activeRequests.Add(reqCtx, -1,
            metric.WithAttributes(
                attribute.String("http.method", ctx.Req.Method),
                attribute.String("http.route", ctx.Req.URL.Path),
            ),
        )
    }
}
```

### 3.3 Êó•Âøó‰∏≠Èó¥‰ª∂

```go
// OTLPLogger OTLP Êó•Âøó‰∏≠Èó¥‰ª∂
func OTLPLogger() macaron.Handler {
    return func(ctx *macaron.Context, log *log.Logger) {
        start := time.Now()
        
        ctx.Next()
        
        duration := time.Since(start)
        span := GetSpan(ctx)
        spanCtx := span.SpanContext()
        
        // ÁªìÊûÑÂåñÊó•Âøó
        log.Printf(
            "[%s] %s %s - Status: %d, Duration: %v, TraceID: %s, SpanID: %s",
            time.Now().Format("2006-01-02 15:04:05"),
            ctx.Req.Method,
            ctx.Req.URL.Path,
            ctx.Resp.Status(),
            duration,
            spanCtx.TraceID().String(),
            spanCtx.SpanID().String(),
        )
    }
}
```

---

## 4. ÂÆåÊï¥Á§∫‰æã

### 4.1 Áî®Êà∑ÊúçÂä°

```go
package main

import (
    "context"
    "database/sql"
    "encoding/json"
    "fmt"
    "log"
    "os"
    "os/signal"
    "syscall"
    "time"
    
    "gopkg.in/macaron.v1"
    _ "github.com/lib/pq"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    
    "your-project/middleware"
)

type User struct {
    ID        int64     `json:"id"`
    Username  string    `json:"username"`
    Email     string    `json:"email"`
    CreatedAt time.Time `json:"created_at"`
}

type UserService struct {
    db *sql.DB
}

func NewUserService(db *sql.DB) *UserService {
    return &UserService{db: db}
}

// GetUser Ëé∑ÂèñÁî®Êà∑
func (s *UserService) GetUser(ctx *macaron.Context) {
    spanCtx := middleware.GetContext(ctx)
    span := middleware.GetSpan(ctx)
    
    // Ëß£ÊûêÂèÇÊï∞
    userID := ctx.Params("id")
    
    span.SetAttributes(
        attribute.String("user.id", userID),
    )
    
    // ÂàõÂª∫Â≠ê span
    tracer := otel.Tracer("user-service")
    dbCtx, dbSpan := tracer.Start(spanCtx, "query-user-from-db")
    defer dbSpan.End()
    
    // Êü•ËØ¢Êï∞ÊçÆÂ∫ì
    var user User
    err := s.db.QueryRowContext(dbCtx,
        "SELECT id, username, email, created_at FROM users WHERE id = $1",
        userID,
    ).Scan(&user.ID, &user.Username, &user.Email, &user.CreatedAt)
    
    if err != nil {
        if err == sql.ErrNoRows {
            dbSpan.SetStatus(codes.Error, "user not found")
            span.RecordError(err)
            ctx.JSON(404, map[string]string{"error": "User not found"})
            return
        }
        
        dbSpan.RecordError(err)
        span.RecordError(err)
        ctx.JSON(500, map[string]string{"error": "Database error"})
        return
    }
    
    dbSpan.SetStatus(codes.Ok, "")
    dbSpan.SetAttributes(
        attribute.String("user.username", user.Username),
        attribute.String("user.email", user.Email),
    )
    
    ctx.JSON(200, user)
}

// CreateUser ÂàõÂª∫Áî®Êà∑
func (s *UserService) CreateUser(ctx *macaron.Context) {
    spanCtx := middleware.GetContext(ctx)
    span := middleware.GetSpan(ctx)
    
    // Ëß£ÊûêËØ∑Ê±Ç‰Ωì
    var req struct {
        Username string `json:"username" binding:"required"`
        Email    string `json:"email" binding:"required,email"`
        Password string `json:"password" binding:"required,min=8"`
    }
    
    if err := json.NewDecoder(ctx.Req.Body()).Decode(&req); err != nil {
        span.RecordError(err)
        ctx.JSON(400, map[string]string{"error": "Invalid request body"})
        return
    }
    
    span.SetAttributes(
        attribute.String("user.username", req.Username),
        attribute.String("user.email", req.Email),
    )
    
    // ÂàõÂª∫Â≠ê span
    tracer := otel.Tracer("user-service")
    dbCtx, dbSpan := tracer.Start(spanCtx, "insert-user")
    defer dbSpan.End()
    
    // ÊèíÂÖ•Êï∞ÊçÆÂ∫ì
    var userID int64
    err := s.db.QueryRowContext(dbCtx,
        "INSERT INTO users (username, email, password) VALUES ($1, $2, $3) RETURNING id",
        req.Username, req.Email, hashPassword(req.Password),
    ).Scan(&userID)
    
    if err != nil {
        dbSpan.RecordError(err)
        span.RecordError(err)
        ctx.JSON(500, map[string]string{"error": "Failed to create user"})
        return
    }
    
    dbSpan.SetStatus(codes.Ok, "")
    dbSpan.SetAttributes(
        attribute.Int64("user.id", userID),
    )
    
    ctx.JSON(201, map[string]interface{}{
        "id":       userID,
        "username": req.Username,
        "email":    req.Email,
    })
}

// ListUsers ÂàóÂá∫Áî®Êà∑
func (s *UserService) ListUsers(ctx *macaron.Context) {
    spanCtx := middleware.GetContext(ctx)
    
    // Ëß£ÊûêÂàÜÈ°µÂèÇÊï∞
    page := ctx.QueryInt("page")
    if page <= 0 {
        page = 1
    }
    
    limit := ctx.QueryInt("limit")
    if limit <= 0 || limit > 100 {
        limit = 20
    }
    
    offset := (page - 1) * limit
    
    // ÂàõÂª∫Â≠ê span
    tracer := otel.Tracer("user-service")
    dbCtx, dbSpan := tracer.Start(spanCtx, "query-users")
    defer dbSpan.End()
    
    dbSpan.SetAttributes(
        attribute.Int("pagination.page", page),
        attribute.Int("pagination.limit", limit),
        attribute.Int("pagination.offset", offset),
    )
    
    // Êü•ËØ¢Áî®Êà∑ÂàóË°®
    rows, err := s.db.QueryContext(dbCtx,
        "SELECT id, username, email, created_at FROM users ORDER BY id LIMIT $1 OFFSET $2",
        limit, offset,
    )
    if err != nil {
        dbSpan.RecordError(err)
        ctx.JSON(500, map[string]string{"error": "Database error"})
        return
    }
    defer rows.Close()
    
    users := make([]User, 0, limit)
    for rows.Next() {
        var user User
        if err := rows.Scan(&user.ID, &user.Username, &user.Email, &user.CreatedAt); err != nil {
            dbSpan.RecordError(err)
            continue
        }
        users = append(users, user)
    }
    
    dbSpan.SetStatus(codes.Ok, "")
    dbSpan.SetAttributes(
        attribute.Int("users.count", len(users)),
    )
    
    ctx.JSON(200, map[string]interface{}{
        "users": users,
        "page":  page,
        "limit": limit,
        "total": len(users),
    })
}

func hashPassword(password string) string {
    // ÂÆûÈôÖÂ∫îËØ•‰ΩøÁî® bcrypt
    return password // ÁÆÄÂåñÁ§∫‰æã
}

func main() {
    // ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ì
    db, err := sql.Open("postgres", os.Getenv("DATABASE_URL"))
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // ÂàõÂª∫ Macaron Â∫îÁî®
    app := NewMacaronApp()
    
    // ÂàùÂßãÂåñ OTLP
    ctx := context.Background()
    if err := app.InitOTLP(ctx, "macaron-user-service"); err != nil {
        log.Fatal(err)
    }
    defer app.Shutdown(context.Background())
    
    // Ê≥®ÂÜå‰∏≠Èó¥‰ª∂
    app.Use(middleware.OTLPTracing("macaron-user-service"))
    app.Use(middleware.OTLPMetrics("macaron-user-service"))
    app.Use(middleware.OTLPLogger())
    
    // ÂàõÂª∫ÊúçÂä°
    userService := NewUserService(db)
    
    // Ê≥®ÂÜåË∑ØÁî±
    app.Get("/users/:id", userService.GetUser)
    app.Post("/users", userService.CreateUser)
    app.Get("/users", userService.ListUsers)
    app.Get("/health", func(ctx *macaron.Context) {
        ctx.JSON(200, map[string]string{"status": "ok"})
    })
    
    // ÂêØÂä®ÊúçÂä°Âô®
    port := ":8080"
    log.Printf("Starting server on %s", port)
    
    // ‰ºòÈõÖÂÖ≥Èó≠
    go func() {
        if err := app.Run(port); err != nil {
            log.Fatal(err)
        }
    }()
    
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Println("Shutting down server...")
}
```

### 4.2 ËÆ¢ÂçïÊúçÂä°

```go
// ËÆ¢ÂçïÊúçÂä°Á§∫‰æãÔºàÁï•ÔºåÁªìÊûÑÁ±ª‰ººÁî®Êà∑ÊúçÂä°Ôºâ
type OrderService struct {
    db         *sql.DB
    userClient *UserClient // HTTP ÂÆ¢Êà∑Á´Ø
}

func (s *OrderService) CreateOrder(ctx *macaron.Context) {
    spanCtx := middleware.GetContext(ctx)
    tracer := otel.Tracer("order-service")
    
    // 1. È™åËØÅÁî®Êà∑ÔºàË∞ÉÁî®Áî®Êà∑ÊúçÂä°Ôºâ
    userCtx, userSpan := tracer.Start(spanCtx, "validate-user")
    user, err := s.userClient.GetUser(userCtx, userID)
    userSpan.End()
    
    if err != nil {
        ctx.JSON(400, map[string]string{"error": "Invalid user"})
        return
    }
    
    // 2. ÂàõÂª∫ËÆ¢Âçï
    dbCtx, dbSpan := tracer.Start(spanCtx, "create-order")
    defer dbSpan.End()
    
    // ... ËÆ¢ÂçïÈÄªËæë
    
    ctx.JSON(201, order)
}
```

### 4.3 ‰∏≠Èó¥‰ª∂Ê†à

```go
// ÂÆåÊï¥ÁöÑ‰∏≠Èó¥‰ª∂Ê†àÈÖçÁΩÆ
func setupMiddlewares(m *macaron.Macaron) {
    // 1. Recovery (ÂøÖÈ°ªÊúÄÂÖà)
    m.Use(macaron.Recovery())
    
    // 2. Logger
    m.Use(macaron.Logger())
    
    // 3. OTLP ËøΩË∏™
    m.Use(middleware.OTLPTracing("macaron-service"))
    
    // 4. OTLP ÊåáÊ†á
    m.Use(middleware.OTLPMetrics("macaron-service"))
    
    // 5. OTLP Êó•Âøó
    m.Use(middleware.OTLPLogger())
    
    // 6. CORS
    m.Use(middleware.CORS())
    
    // 7. ÈôêÊµÅ
    m.Use(middleware.RateLimit(100)) // 100 req/s
    
    // 8. ËÆ§ËØÅ
    m.Use(middleware.JWT())
    
    // 9. ÂéãÁº©
    m.Use(macaron.Gziper())
    
    // 10. ÈùôÊÄÅÊñá‰ª∂
    m.Use(macaron.Static("public"))
}
```

---

## 5. È´òÁ∫ßÁâπÊÄß

### 5.1 Ê®°ÊùøÊ∏≤ÊüìËøΩË∏™

```go
// Ê®°ÊùøÊ∏≤ÊüìËøΩË∏™
func RenderWithTracing(ctx *macaron.Context, name string, data interface{}) {
    spanCtx := middleware.GetContext(ctx)
    tracer := otel.Tracer("template-renderer")
    
    renderCtx, span := tracer.Start(spanCtx, "render-template")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("template.name", name),
    )
    
    start := time.Now()
    ctx.HTML(200, name, data)
    duration := time.Since(start)
    
    span.SetAttributes(
        attribute.Int64("template.render_time_ms", duration.Milliseconds()),
    )
}
```

### 5.2 ‰ºöËØùÁÆ°ÁêÜËøΩË∏™

```go
// ‰ºöËØùËøΩË∏™‰∏≠Èó¥‰ª∂
func SessionTracing() macaron.Handler {
    return func(ctx *macaron.Context, sess session.Store) {
        span := middleware.GetSpan(ctx)
        
        // ËÆ∞ÂΩï‰ºöËØù‰ø°ÊÅØ
        sessionID := sess.ID()
        span.SetAttributes(
            attribute.String("session.id", sessionID),
        )
        
        ctx.Next()
    }
}
```

### 5.3 ÈùôÊÄÅÊñá‰ª∂ËøΩË∏™

```go
// ÈùôÊÄÅÊñá‰ª∂ËøΩË∏™
func StaticWithTracing(dir string) macaron.Handler {
    staticHandler := macaron.Static(dir)
    
    return func(ctx *macaron.Context) {
        span := middleware.GetSpan(ctx)
        
        span.SetAttributes(
            attribute.String("static.path", ctx.Req.URL.Path),
        )
        
        staticHandler(ctx)
    }
}
```

---

## 6. ÊÄßËÉΩ‰ºòÂåñ

### 6.1 ÈááÊ†∑Á≠ñÁï•

```go
// Ëá™ÈÄÇÂ∫îÈááÊ†∑Âô®
type AdaptiveSampler struct {
    ratio float64
}

func (s *AdaptiveSampler) ShouldSample(params trace.SamplingParameters) trace.SamplingResult {
    // ÈîôËØØËØ∑Ê±ÇÊÄªÊòØÈááÊ†∑
    if params.Attributes != nil {
        for _, attr := range params.Attributes {
            if attr.Key == "http.status_code" && attr.Value.AsInt64() >= 400 {
                return trace.SamplingResult{
                    Decision: trace.RecordAndSample,
                }
            }
        }
    }
    
    // ÊåâÊØî‰æãÈááÊ†∑
    if params.TraceID.Uint64() < uint64(s.ratio*math.MaxUint64) {
        return trace.SamplingResult{
            Decision: trace.RecordAndSample,
        }
    }
    
    return trace.SamplingResult{
        Decision: trace.Drop,
    }
}
```

### 6.2 ÊâπÂ§ÑÁêÜ‰ºòÂåñ

```go
// ‰ºòÂåñÊâπÂ§ÑÁêÜÈÖçÁΩÆ
tp := trace.NewTracerProvider(
    trace.WithBatcher(exporter,
        trace.WithBatchTimeout(1*time.Second),     // 1ÁßíÊâπÊ¨°Ë∂ÖÊó∂
        trace.WithMaxExportBatchSize(512),         // ÊúÄÂ§ß512‰∏™span
        trace.WithMaxQueueSize(2048),              // ÈòüÂàóÂ§ßÂ∞è2048
    ),
)
```

### 6.3 ÂÜÖÂ≠ò‰ºòÂåñ

```go
// ÂØπË±°Ê±†Â§çÁî®
var spanPool = sync.Pool{
    New: func() interface{} {
        return &SpanData{}
    },
}

func getSpan() *SpanData {
    return spanPool.Get().(*SpanData)
}

func putSpan(s *SpanData) {
    s.Reset()
    spanPool.Put(s)
}
```

---

## 7. Áîü‰∫ßÈÉ®ÁΩ≤

### 7.1 Docker ÈÉ®ÁΩ≤

```dockerfile
# Dockerfile
FROM golang:1.25.1-alpine AS builder

WORKDIR /app
COPY . .
RUN go mod download
RUN CGO_ENABLED=0 GOOS=linux go build -o server .

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/server .
COPY --from=builder /app/public ./public
COPY --from=builder /app/templates ./templates

EXPOSE 8080
CMD ["./server"]
```

### 7.2 Kubernetes ÈÉ®ÁΩ≤

```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: macaron-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: macaron-service
  template:
    metadata:
      labels:
        app: macaron-service
    spec:
      containers:
      - name: macaron-service
        image: macaron-service:latest
        ports:
        - containerPort: 8080
        env:
        - name: OTEL_EXPORTER_OTLP_ENDPOINT
          value: "otel-collector:4317"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: url
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
```

### 7.3 ÁõëÊéßÈÖçÁΩÆ

```yaml
# ServiceMonitor for Prometheus
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: macaron-service
spec:
  selector:
    matchLabels:
      app: macaron-service
  endpoints:
  - port: metrics
    interval: 30s
```

---

## 8. ‰∏é Gitea ÈõÜÊàêÔºàÂÆûÊàòÊ°à‰æãÔºâ

### 8.1 Gitea Êû∂ÊûÑ

Gitea ÊòØ‰ΩøÁî® Macaron ÊûÑÂª∫ÁöÑ Git ÊúçÂä°ÔºåÊàë‰ª¨ÂèØ‰ª•ÂèÇËÄÉÂÖ∂ËøΩË∏™ÈõÜÊàêÔºö

```go
// Gitea È£éÊ†ºÁöÑËøΩË∏™ÈõÜÊàê
func InitGiteaTracing(m *macaron.Macaron) {
    // Git Êìç‰ΩúËøΩË∏™
    m.Use(func(ctx *macaron.Context) {
        if strings.HasPrefix(ctx.Req.URL.Path, "/api/v1/repos") {
            span := middleware.GetSpan(ctx)
            
            // Ëß£Êûê‰ªìÂ∫ì‰ø°ÊÅØ
            owner := ctx.Params("owner")
            repo := ctx.Params("repo")
            
            span.SetAttributes(
                attribute.String("git.owner", owner),
                attribute.String("git.repo", repo),
            )
        }
        
        ctx.Next()
    })
}
```

### 8.2 ËøΩË∏™ÈõÜÊàê

```go
// Git ÂëΩ‰ª§ËøΩË∏™
func TraceGitCommand(ctx context.Context, cmd string, args ...string) error {
    tracer := otel.Tracer("git-commands")
    cmdCtx, span := tracer.Start(ctx, "git-"+cmd)
    defer span.End()
    
    span.SetAttributes(
        attribute.String("git.command", cmd),
        attribute.StringSlice("git.args", args),
    )
    
    start := time.Now()
    
    // ÊâßË°å git ÂëΩ‰ª§
    gitCmd := exec.CommandContext(cmdCtx, "git", append([]string{cmd}, args...)...)
    output, err := gitCmd.CombinedOutput()
    
    duration := time.Since(start)
    
    span.SetAttributes(
        attribute.Int64("git.duration_ms", duration.Milliseconds()),
        attribute.Int("git.output_size", len(output)),
    )
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}
```

---

## 9. ÊÄªÁªì

### 9.1 ‰ºòÂäø‰∏éÂä£Âäø

```text
‚úÖ ‰ºòÂäø:
  - Ê®°ÂùóÂåñËÆæËÆ°ÔºåÊòì‰∫éÊâ©Â±ï
  - ‰∏≠Èó¥‰ª∂ÁîüÊÄÅ‰∏∞ÂØå
  - ÈÄÇÂêà‰º†Áªü Web Â∫îÁî®
  - Ë¢´ Gitea Á≠âÈ°πÁõÆÈ™åËØÅ
  - ‰∏≠ÊñáÊñáÊ°£ÂÆåÂñÑ

‚ùå Âä£Âäø:
  - ÊÄßËÉΩ‰∏çÂ¶Ç Gin/Fiber
  - Á§æÂå∫Ê¥ªË∑ÉÂ∫¶‰∏ÄËà¨
  - ‰∏çÈÄÇÂêàÈ´òÂπ∂ÂèëÂú∫ÊôØ
  - ‰æùËµñÊ≥®ÂÖ•ÊúâÊÄßËÉΩÂºÄÈîÄ
```

### 9.2 ÊúÄ‰Ω≥ÂÆûË∑µ

1. **‰ΩøÁî®Âú∫ÊôØÈÄâÊã©**Ôºö
   - ‚úÖ ÂÜÖÂÆπÂûãÁΩëÁ´ô„ÄÅÂêéÂè∞ÁÆ°ÁêÜ
   - ‚ùå È´òÂπ∂Âèë API„ÄÅÂæÆÊúçÂä°

2. **ÊÄßËÉΩ‰ºòÂåñ**Ôºö
   - ÂêØÁî®ÈááÊ†∑Á≠ñÁï•
   - ‰ΩøÁî®ÊâπÂ§ÑÁêÜÂØºÂá∫
   - ÂêàÁêÜÈÖçÁΩÆ‰∏≠Èó¥‰ª∂È°∫Â∫è

3. **ÁõëÊéßÈõÜÊàê**Ôºö
   - ÂÆåÊï¥ÁöÑ OTLP ÈõÜÊàê
   - ‰∏öÂä°ÊåáÊ†áÊî∂ÈõÜ
   - ÈîôËØØËøΩË∏™

**Áõ∏ÂÖ≥ÊñáÊ°£**Ôºö

- [49_ChiÊ°ÜÊû∂Ê∑±Â∫¶ÈõÜÊàê‰∏éÊúÄ‰Ω≥ÂÆûË∑µ.md](../49_ChiÊ°ÜÊû∂Ê∑±Â∫¶ÈõÜÊàê‰∏éÊúÄ‰Ω≥ÂÆûË∑µ.md)
- [09_Go‰∏ªÊµÅÊ°ÜÊû∂Ê∑±Â∫¶ÈõÜÊàêÊåáÂçó.md](../09_Go‰∏ªÊµÅÊ°ÜÊû∂Ê∑±Â∫¶ÈõÜÊàêÊåáÂçó.md)

---

**Êõ¥Êñ∞Êó•Êúü**: 2025-10-11  
**Ê°ÜÊû∂ÁâàÊú¨**: Macaron v1.5.0  
**ÈÄÇÁî®Âú∫ÊôØ**: ‰º†Áªü Web Â∫îÁî®„ÄÅÂÜÖÂÆπÁÆ°ÁêÜÁ≥ªÁªü  
**ÊÄßËÉΩÁ∫ßÂà´**: ‰∏≠Á≠â
