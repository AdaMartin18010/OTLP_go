# 76. æ•…éšœæ’æŸ¥å®Œæ•´æŒ‡å—ï¼ˆ2025ç‰ˆï¼‰

> **ç›®æ ‡**: å¿«é€Ÿå®šä½å’Œè§£å†³ Go + OTLP é›†æˆä¸­çš„å¸¸è§é—®é¢˜  
> **é€‚ç”¨**: å¼€å‘ã€æµ‹è¯•ã€ç”Ÿäº§ç¯å¢ƒ  
> **å®Œæˆæ—¥æœŸ**: 2025-10-11

---

## ğŸ“‹ ç›®å½•

- [76. æ•…éšœæ’æŸ¥å®Œæ•´æŒ‡å—ï¼ˆ2025ç‰ˆï¼‰](#76-æ•…éšœæ’æŸ¥å®Œæ•´æŒ‡å—2025ç‰ˆ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å¿«é€Ÿè¯Šæ–­æµç¨‹](#1-å¿«é€Ÿè¯Šæ–­æµç¨‹)
    - [1.1 é—®é¢˜åˆ†ç±»å†³ç­–æ ‘](#11-é—®é¢˜åˆ†ç±»å†³ç­–æ ‘)
    - [1.2 åŸºç¡€æ£€æŸ¥æ¸…å•](#12-åŸºç¡€æ£€æŸ¥æ¸…å•)
    - [1.3 æ—¥å¿—çº§åˆ«è°ƒæ•´](#13-æ—¥å¿—çº§åˆ«è°ƒæ•´)
  - [2. OTLPè¿½è¸ªé—®é¢˜](#2-otlpè¿½è¸ªé—®é¢˜)
    - [2.1 çœ‹ä¸åˆ°è¿½è¸ªæ•°æ®](#21-çœ‹ä¸åˆ°è¿½è¸ªæ•°æ®)
      - [é—®é¢˜ï¼šJaeger UI ä¸­æ²¡æœ‰æ•°æ®](#é—®é¢˜jaeger-ui-ä¸­æ²¡æœ‰æ•°æ®)
    - [2.2 Span ä¸¢å¤±æˆ–ä¸å®Œæ•´](#22-span-ä¸¢å¤±æˆ–ä¸å®Œæ•´)
      - [é—®é¢˜ï¼šéƒ¨åˆ† Span ç¼ºå¤±](#é—®é¢˜éƒ¨åˆ†-span-ç¼ºå¤±)
    - [2.3 è¿½è¸ªé“¾è·¯æ–­è£‚](#23-è¿½è¸ªé“¾è·¯æ–­è£‚)
      - [é—®é¢˜ï¼šå¾®æœåŠ¡é—´è¿½è¸ªä¸è¿ç»­](#é—®é¢˜å¾®æœåŠ¡é—´è¿½è¸ªä¸è¿ç»­)
  - [3. æ€§èƒ½é—®é¢˜å®šä½](#3-æ€§èƒ½é—®é¢˜å®šä½)
    - [3.1 å»¶è¿Ÿè¿‡é«˜](#31-å»¶è¿Ÿè¿‡é«˜)
      - [é—®é¢˜ï¼šP99 å»¶è¿Ÿä» 50ms å‡è‡³ 500ms](#é—®é¢˜p99-å»¶è¿Ÿä»-50ms-å‡è‡³-500ms)
    - [3.2 ååé‡ä¸‹é™](#32-ååé‡ä¸‹é™)
      - [é—®é¢˜ï¼šQPSä»50Ké™è‡³30K](#é—®é¢˜qpsä»50ké™è‡³30k)
  - [4. å†…å­˜é—®é¢˜æ’æŸ¥](#4-å†…å­˜é—®é¢˜æ’æŸ¥)
    - [4.1 å†…å­˜æ³„æ¼](#41-å†…å­˜æ³„æ¼)
      - [é—®é¢˜ï¼šå†…å­˜æŒç»­å¢é•¿ï¼ŒOOM Killed](#é—®é¢˜å†…å­˜æŒç»­å¢é•¿oom-killed)
    - [4.2 GCå‹åŠ›è¿‡å¤§](#42-gcå‹åŠ›è¿‡å¤§)
      - [é—®é¢˜ï¼šGCæš‚åœæ—¶é—´ \> 100ms](#é—®é¢˜gcæš‚åœæ—¶é—´--100ms)
  - [5. ç½‘ç»œè¿æ¥é—®é¢˜](#5-ç½‘ç»œè¿æ¥é—®é¢˜)
    - [5.1 è¿æ¥è¶…æ—¶](#51-è¿æ¥è¶…æ—¶)
      - [é—®é¢˜ï¼šcontext deadline exceeded](#é—®é¢˜context-deadline-exceeded)
    - [5.2 è¿æ¥æ± è€—å°½](#52-è¿æ¥æ± è€—å°½)
      - [é—®é¢˜ï¼šconnection pool exhausted](#é—®é¢˜connection-pool-exhausted)
  - [6. ç”Ÿäº§ç¯å¢ƒç´§æ€¥é—®é¢˜](#6-ç”Ÿäº§ç¯å¢ƒç´§æ€¥é—®é¢˜)
    - [6.1 æœåŠ¡é›ªå´©](#61-æœåŠ¡é›ªå´©)
      - [ç—‡çŠ¶ï¼šçº§è”æ•…éšœï¼Œå¤šä¸ªæœåŠ¡å®•æœº](#ç—‡çŠ¶çº§è”æ•…éšœå¤šä¸ªæœåŠ¡å®•æœº)
    - [6.2 å†…å­˜OOM](#62-å†…å­˜oom)
      - [ç—‡çŠ¶ï¼šPodè¢«Killedï¼ŒExit Code 137](#ç—‡çŠ¶podè¢«killedexit-code-137)
  - [7. å¸¸è§é—®é¢˜FAQ](#7-å¸¸è§é—®é¢˜faq)
    - [7.1 OTLPç›¸å…³](#71-otlpç›¸å…³)
    - [7.2 æ€§èƒ½ç›¸å…³](#72-æ€§èƒ½ç›¸å…³)
    - [7.3 éƒ¨ç½²ç›¸å…³](#73-éƒ¨ç½²ç›¸å…³)
  - [8. æ’æŸ¥å·¥å…·æ¸…å•](#8-æ’æŸ¥å·¥å…·æ¸…å•)
    - [8.1 å‘½ä»¤è¡Œå·¥å…·](#81-å‘½ä»¤è¡Œå·¥å…·)
    - [8.2 åœ¨çº¿å·¥å…·](#82-åœ¨çº¿å·¥å…·)
  - [9. æ€»ç»“](#9-æ€»ç»“)
    - [9.1 æœ€ä½³å®è·µ](#91-æœ€ä½³å®è·µ)
    - [9.2 ç´§æ€¥è”ç³»æµç¨‹](#92-ç´§æ€¥è”ç³»æµç¨‹)

---

## 1. å¿«é€Ÿè¯Šæ–­æµç¨‹

### 1.1 é—®é¢˜åˆ†ç±»å†³ç­–æ ‘

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           æ•…éšœç°è±¡                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                       â”‚           â”‚
    â–¼                       â–¼           â–¼
çœ‹ä¸åˆ°è¿½è¸ªæ•°æ®          æ€§èƒ½ä¸‹é™      æœåŠ¡å´©æºƒ
    â”‚                       â”‚           â”‚
    â–¼                       â–¼           â–¼
[ç¬¬2èŠ‚]                 [ç¬¬3èŠ‚]      [ç¬¬6èŠ‚]
OTLPè¿½è¸ªé—®é¢˜            æ€§èƒ½é—®é¢˜      ç´§æ€¥é—®é¢˜
```

### 1.2 åŸºç¡€æ£€æŸ¥æ¸…å•

```bash
#!/bin/bash
# å¿«é€Ÿè¯Šæ–­è„šæœ¬

echo "=== Go + OTLP å¿«é€Ÿè¯Šæ–­ ==="

# 1. æ£€æŸ¥æœåŠ¡çŠ¶æ€
echo "1. æ£€æŸ¥æœåŠ¡è¿è¡ŒçŠ¶æ€..."
ps aux | grep -E '(app|service)' || echo "âŒ æœåŠ¡æœªè¿è¡Œ"

# 2. æ£€æŸ¥ç«¯å£ç›‘å¬
echo "2. æ£€æŸ¥ç«¯å£ç›‘å¬..."
netstat -tuln | grep -E '(8080|9090|4317|4318)' || echo "âŒ ç«¯å£æœªç›‘å¬"

# 3. æ£€æŸ¥OTLP Collector
echo "3. æ£€æŸ¥OTLP Collector..."
curl -s http://localhost:13133/health | jq . || echo "âŒ Collectorä¸å¯è¾¾"

# 4. æ£€æŸ¥èµ„æºä½¿ç”¨
echo "4. æ£€æŸ¥èµ„æºä½¿ç”¨..."
echo "CPU: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}')%"
echo "å†…å­˜: $(free -h | awk '/^Mem:/ {print $3 "/" $2}')"

# 5. æ£€æŸ¥æ—¥å¿—é”™è¯¯
echo "5. æ£€æŸ¥æœ€è¿‘é”™è¯¯..."
tail -n 50 /var/log/app.log | grep -i error

# 6. æ£€æŸ¥ç½‘ç»œè¿æ¥
echo "6. æ£€æŸ¥OTLPè¿æ¥..."
telnet localhost 4317 || echo "âŒ æ— æ³•è¿æ¥åˆ°Collector"

echo "=== è¯Šæ–­å®Œæˆ ==="
```

### 1.3 æ—¥å¿—çº§åˆ«è°ƒæ•´

```go
package main

import (
    "os"
    
    "go.uber.org/zap"
    "go.uber.org/zap/zapcore"
)

// åŠ¨æ€è°ƒæ•´æ—¥å¿—çº§åˆ«ï¼ˆç”¨äºæ’æŸ¥é—®é¢˜ï¼‰
func SetupDebugLogger() *zap.Logger {
    // ç”Ÿäº§ç¯å¢ƒé€šå¸¸ç”¨ Info
    // æ’æŸ¥é—®é¢˜æ—¶ä¸´æ—¶è°ƒæ•´ä¸º Debug
    level := zapcore.InfoLevel
    if os.Getenv("DEBUG") == "true" {
        level = zapcore.DebugLevel
    }
    
    config := zap.NewProductionConfig()
    config.Level = zap.NewAtomicLevelAt(level)
    config.EncoderConfig.TimeKey = "timestamp"
    config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
    
    logger, _ := config.Build()
    return logger
}

// ä¸´æ—¶å¯ç”¨ Debug æ—¥å¿—
// export DEBUG=true && ./app
```

---

## 2. OTLPè¿½è¸ªé—®é¢˜

### 2.1 çœ‹ä¸åˆ°è¿½è¸ªæ•°æ®

#### é—®é¢˜ï¼šJaeger UI ä¸­æ²¡æœ‰æ•°æ®

**ç—‡çŠ¶**:

```text
âœ… æœåŠ¡æ­£å¸¸è¿è¡Œ
âœ… æ— é”™è¯¯æ—¥å¿—
âŒ Jaeger UI æ— è¿½è¸ªæ•°æ®
```

**è¯Šæ–­æ­¥éª¤**:

```bash
# Step 1: éªŒè¯ Exporter é…ç½®
echo "æ£€æŸ¥ OTLP Endpoint..."
curl -v http://localhost:4318/v1/traces

# Step 2: æ£€æŸ¥é‡‡æ ·ç‡
echo "å½“å‰é‡‡æ ·é…ç½®:"
echo "OTEL_TRACES_SAMPLER=$OTEL_TRACES_SAMPLER"
echo "OTEL_TRACES_SAMPLER_ARG=$OTEL_TRACES_SAMPLER_ARG"

# Step 3: æµ‹è¯•å‘é€Span
cat <<EOF | grpcurl -plaintext -d @ localhost:4317 opentelemetry.proto.collector.trace.v1.TraceService/Export
{
  "resource_spans": [{
    "resource": {
      "attributes": [{
        "key": "service.name",
        "value": {"string_value": "test"}
      }]
    },
    "scope_spans": [{
      "spans": [{
        "name": "test-span",
        "trace_id": "00000000000000000000000000000001",
        "span_id": "0000000000000001",
        "start_time_unix_nano": $(date +%s%N),
        "end_time_unix_nano": $(date +%s%N)
      }]
    }]
  }]
}
EOF
```

**å¸¸è§åŸå›  & è§£å†³æ–¹æ¡ˆ**:

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     åŸå›             â”‚       ç—‡çŠ¶           â”‚       è§£å†³æ–¹æ¡ˆ       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. é‡‡æ ·ç‡ä¸º0        â”‚ æ— ä»»ä½•Span          â”‚ è°ƒæ•´é‡‡æ ·ç‡ä¸º0.01+    â”‚
â”‚ 2. Endpointé”™è¯¯     â”‚ è¿æ¥è¶…æ—¶            â”‚ æ£€æŸ¥åœ°å€å’Œç«¯å£       â”‚
â”‚ 3. Contextæœªä¼ æ’­    â”‚ åªæœ‰éƒ¨åˆ†Span        â”‚ æ£€æŸ¥propagatoré…ç½®   â”‚
â”‚ 4. SpanæœªEnd()      â”‚ Spanæ°¸ä¸å¯¼å‡º        â”‚ ç¡®ä¿defer span.End() â”‚
â”‚ 5. Collectorå®•æœº    â”‚ è¿æ¥æ‹’ç»            â”‚ é‡å¯Collector        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**è§£å†³æ–¹æ¡ˆ 1: æ£€æŸ¥é‡‡æ ·é…ç½®**:

```go
package main

import (
    "context"
    "fmt"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/sdk/trace"
)

func DiagnoseSampler(ctx context.Context) {
    tp := otel.GetTracerProvider().(*trace.TracerProvider)
    tracer := tp.Tracer("diagnostic")
    
    // åˆ›å»ºæµ‹è¯•Span
    _, span := tracer.Start(ctx, "test-span")
    defer span.End()
    
    // æ£€æŸ¥æ˜¯å¦è¢«é‡‡æ ·
    if span.SpanContext().IsSampled() {
        fmt.Println("âœ… Spanå·²è¢«é‡‡æ ·")
    } else {
        fmt.Println("âŒ Spanæœªè¢«é‡‡æ · - æ£€æŸ¥é‡‡æ ·å™¨é…ç½®!")
    }
    
    // è¾“å‡ºTraceIDå’ŒSpanID
    fmt.Printf("TraceID: %s\n", span.SpanContext().TraceID().String())
    fmt.Printf("SpanID: %s\n", span.SpanContext().SpanID().String())
}

// ä¸´æ—¶ä½¿ç”¨ AlwaysSample æ’æŸ¥é—®é¢˜
func UseAlwaysSampleForDebug() *trace.TracerProvider {
    return trace.NewTracerProvider(
        trace.WithSampler(trace.AlwaysSample()), // â­ 100% é‡‡æ ·
        // ... å…¶ä»–é…ç½®
    )
}
```

**è§£å†³æ–¹æ¡ˆ 2: éªŒè¯ Context ä¼ æ’­**:

```go
package main

import (
    "context"
    "net/http"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/propagation"
)

// ä¸­é—´ä»¶ï¼šæ‰“å° TraceID
func TraceIDMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        ctx := r.Context()
        span := trace.SpanFromContext(ctx)
        
        traceID := span.SpanContext().TraceID().String()
        fmt.Printf("â­ TraceID: %s\n", traceID)
        
        // æ·»åŠ åˆ°å“åº”å¤´ï¼ˆä¾¿äºè°ƒè¯•ï¼‰
        w.Header().Set("X-Trace-ID", traceID)
        
        next.ServeHTTP(w, r)
    })
}

// è¯Šæ–­ï¼šæ£€æŸ¥ Propagator
func DiagnosePropagator() {
    propagator := otel.GetTextMapPropagator()
    
    // åˆ›å»ºæµ‹è¯•Context
    ctx := context.Background()
    ctx, span := otel.Tracer("test").Start(ctx, "test")
    defer span.End()
    
    // æ¨¡æ‹ŸHTTPä¼ æ’­
    carrier := propagation.MapCarrier{}
    propagator.Inject(ctx, carrier)
    
    // è¾“å‡ºHeaders
    fmt.Println("ä¼ æ’­çš„Headers:")
    for k, v := range carrier {
        fmt.Printf("  %s: %s\n", k, v)
    }
    
    // åº”è¯¥åŒ…å« traceparent
    if _, ok := carrier["traceparent"]; !ok {
        fmt.Println("âŒ ç¼ºå°‘ traceparent - æ£€æŸ¥Propagatoré…ç½®!")
    }
}
```

### 2.2 Span ä¸¢å¤±æˆ–ä¸å®Œæ•´

#### é—®é¢˜ï¼šéƒ¨åˆ† Span ç¼ºå¤±

**è¯Šæ–­å·¥å…·**:

```go
package diagnostic

import (
    "context"
    "sync"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

// SpanTracker è¿½è¸ªæ‰€æœ‰åˆ›å»ºçš„Span
type SpanTracker struct {
    mu      sync.Mutex
    spans   map[string]*SpanInfo
    missing []string
}

type SpanInfo struct {
    Name      string
    TraceID   string
    SpanID    string
    StartTime time.Time
    EndTime   *time.Time
    Exported  bool
}

func NewSpanTracker() *SpanTracker {
    return &SpanTracker{
        spans: make(map[string]*SpanInfo),
    }
}

// TrackSpan è¿½è¸ªSpan
func (st *SpanTracker) TrackSpan(span trace.Span) {
    st.mu.Lock()
    defer st.mu.Unlock()
    
    spanID := span.SpanContext().SpanID().String()
    st.spans[spanID] = &SpanInfo{
        Name:      span.SpanContext().TraceID().String(),
        TraceID:   span.SpanContext().TraceID().String(),
        SpanID:    spanID,
        StartTime: time.Now(),
    }
}

// MarkExported æ ‡è®°å·²å¯¼å‡º
func (st *SpanTracker) MarkExported(spanID string) {
    st.mu.Lock()
    defer st.mu.Unlock()
    
    if info, ok := st.spans[spanID]; ok {
        info.Exported = true
    }
}

// CheckMissing æ£€æŸ¥ä¸¢å¤±çš„Span
func (st *SpanTracker) CheckMissing() []string {
    st.mu.Lock()
    defer st.mu.Unlock()
    
    var missing []string
    for spanID, info := range st.spans {
        if !info.Exported && time.Since(info.StartTime) > 10*time.Second {
            missing = append(missing, spanID)
        }
    }
    
    return missing
}
```

### 2.3 è¿½è¸ªé“¾è·¯æ–­è£‚

#### é—®é¢˜ï¼šå¾®æœåŠ¡é—´è¿½è¸ªä¸è¿ç»­

**ç—‡çŠ¶**:

```text
Service A (TraceID: abc123)
    â†“
Service B (TraceID: def456)  âŒ ä¸åŒçš„TraceID
```

**æ’æŸ¥æ­¥éª¤**:

```bash
# 1. æ£€æŸ¥ HTTP ä¼ æ’­
curl -v http://service-a/api/test \
  -H "traceparent: 00-00000000000000000000000000000001-0000000000000001-01"

# æŸ¥çœ‹å“åº”å¤´æ˜¯å¦åŒ…å«ç›¸åŒçš„TraceID

# 2. æŠ“åŒ…åˆ†æ
tcpdump -i any -A "host service-b and port 8080" | grep traceparent
```

**è§£å†³æ–¹æ¡ˆ**:

```go
package main

import (
    "net/http"
    
    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/propagation"
)

// HTTP Clientï¼ˆè‡ªåŠ¨æ³¨å…¥ï¼‰
func NewHTTPClient() *http.Client {
    return &http.Client{
        Transport: otelhttp.NewTransport(
            http.DefaultTransport,
            otelhttp.WithPropagators(otel.GetTextMapPropagator()), // â­ å…³é”®
        ),
    }
}

// HTTP Serverï¼ˆè‡ªåŠ¨æå–ï¼‰
func NewHTTPServer() *http.ServeMux {
    mux := http.NewServeMux()
    
    // ä½¿ç”¨ otelhttp.NewHandler åŒ…è£…
    mux.Handle("/api/", otelhttp.NewHandler(
        http.HandlerFunc(handler),
        "api-handler",
        otelhttp.WithPropagators(otel.GetTextMapPropagator()), // â­ å…³é”®
    ))
    
    return mux
}

// æ‰‹åŠ¨æå–ï¼ˆç”¨äºè°ƒè¯•ï¼‰
func ExtractAndPrint(r *http.Request) {
    propagator := otel.GetTextMapPropagator()
    ctx := propagator.Extract(r.Context(), propagation.HeaderCarrier(r.Header))
    
    span := trace.SpanFromContext(ctx)
    traceID := span.SpanContext().TraceID().String()
    
    fmt.Printf("æå–çš„TraceID: %s\n", traceID)
    
    if traceID == "00000000000000000000000000000000" {
        fmt.Println("âŒ TraceIDæ— æ•ˆ - æœªä¼ æ’­!")
    }
}
```

---

## 3. æ€§èƒ½é—®é¢˜å®šä½

### 3.1 å»¶è¿Ÿè¿‡é«˜

#### é—®é¢˜ï¼šP99 å»¶è¿Ÿä» 50ms å‡è‡³ 500ms

**è¯Šæ–­æ­¥éª¤**:

```bash
# 1. å®æ—¶ç«ç„°å›¾
go tool pprof -http=:8081 http://localhost:6060/debug/pprof/profile?seconds=30

# 2. è¿½è¸ªçƒ­ç‚¹å‡½æ•°
go test -bench=. -cpuprofile=cpu.out
go tool pprof cpu.out

# 3. æŸ¥çœ‹Jaegerè¿½è¸ª
# æŒ‰å»¶è¿Ÿæ’åºï¼Œæ‰¾å‡ºæ…¢è¯·æ±‚
```

**å¸¸è§åŸå› **:

| åŸå›  | ç‰¹å¾ | è§£å†³æ–¹æ¡ˆ |
|------|------|---------|
| **æ•°æ®åº“æ…¢æŸ¥è¯¢** | ç‰¹å®šSpanå»¶è¿Ÿé«˜ | æ·»åŠ ç´¢å¼•ã€ä¼˜åŒ–SQL |
| **GCæš‚åœ** | å‘¨æœŸæ€§å»¶è¿Ÿå³°å€¼ | è°ƒæ•´GOGCã€å‡å°‘åˆ†é… |
| **é”ç«äº‰** | å¹¶å‘ä¸‹å»¶è¿Ÿçº¿æ€§å¢é•¿ | å‡å°é”ç²’åº¦ã€åˆ†ç‰‡é” |
| **ç½‘ç»œIO** | ç‰¹å®šæœåŠ¡è°ƒç”¨æ…¢ | å¢åŠ è¶…æ—¶ã€é‡è¯•ã€ç†”æ–­ |
| **è¿‡åº¦é‡‡æ ·** | å…¨å±€å»¶è¿Ÿå‡é«˜ | é™ä½é‡‡æ ·ç‡ |

**è§£å†³æ–¹æ¡ˆï¼šå®šä½æ…¢ Span**:

```go
package main

import (
    "context"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// SlowSpanDetector æ…¢Spanæ£€æµ‹å™¨
type SlowSpanDetector struct {
    threshold time.Duration
    tracer    trace.Tracer
}

func NewSlowSpanDetector(threshold time.Duration) *SlowSpanDetector {
    return &SlowSpanDetector{
        threshold: threshold,
        tracer:    otel.Tracer("slow-detector"),
    }
}

// WrapWithDetection åŒ…è£…å‡½æ•°ï¼Œè‡ªåŠ¨æ£€æµ‹æ…¢è°ƒç”¨
func (d *SlowSpanDetector) WrapWithDetection(
    ctx context.Context,
    name string,
    fn func(context.Context) error,
) error {
    ctx, span := d.tracer.Start(ctx, name)
    defer span.End()
    
    start := time.Now()
    err := fn(ctx)
    duration := time.Since(start)
    
    // è®°å½•duration
    span.SetAttributes(
        attribute.Int64("duration_ms", duration.Milliseconds()),
    )
    
    // æ…¢è°ƒç”¨å‘Šè­¦
    if duration > d.threshold {
        span.SetAttributes(
            attribute.Bool("slow_call", true),
        )
        
        // è®°å½•åˆ°æ—¥å¿—
        log.Printf("âš ï¸ æ…¢è°ƒç”¨æ£€æµ‹: %s took %v (threshold: %v)\n",
            name, duration, d.threshold)
    }
    
    return err
}
```

### 3.2 ååé‡ä¸‹é™

#### é—®é¢˜ï¼šQPSä»50Ké™è‡³30K

**è¯Šæ–­å‘½ä»¤**:

```bash
# 1. CPU Profiling
curl http://localhost:6060/debug/pprof/profile?seconds=30 > cpu.prof
go tool pprof cpu.prof

# 2. Goroutine æ•°é‡
curl http://localhost:6060/debug/pprof/goroutine?debug=1 | grep "goroutine profile:" -A 1

# 3. æŸ¥çœ‹é”ç«äº‰
go test -bench=. -mutexprofile=mutex.out
go tool pprof mutex.out
```

**æ€§èƒ½å¯¹æ¯”å·¥å…·**:

```go
package benchmark

import (
    "context"
    "testing"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/sdk/trace"
)

// BenchmarkWithOTLP å¯¹æ¯”å¼€å¯OTLPå‰å
func BenchmarkNoOTLP(b *testing.B) {
    b.ResetTimer()
    b.ReportAllocs()
    
    for i := 0; i < b.N; i++ {
        processRequest()
    }
}

func BenchmarkWithOTLP(b *testing.B) {
    // åˆå§‹åŒ–OTLP
    tp := trace.NewTracerProvider()
    otel.SetTracerProvider(tp)
    
    tracer := otel.Tracer("benchmark")
    
    b.ResetTimer()
    b.ReportAllocs()
    
    for i := 0; i < b.N; i++ {
        ctx, span := tracer.Start(context.Background(), "process")
        processRequest()
        span.End()
    }
}

// è¿è¡Œå¯¹æ¯”:
// go test -bench=. -benchmem
//
// BenchmarkNoOTLP-8     50000   25000 ns/op   512 B/op   8 allocs/op
// BenchmarkWithOTLP-8   46000   26200 ns/op   842 B/op  14 allocs/op
//
// å¼€é”€: +4.8% QPS, +64% å†…å­˜åˆ†é…
```

---

## 4. å†…å­˜é—®é¢˜æ’æŸ¥

### 4.1 å†…å­˜æ³„æ¼

#### é—®é¢˜ï¼šå†…å­˜æŒç»­å¢é•¿ï¼ŒOOM Killed

**è¯Šæ–­æ­¥éª¤**:

```bash
# 1. å†…å­˜å¿«ç…§ï¼ˆé—´éš”1å°æ—¶ï¼‰
curl http://localhost:6060/debug/pprof/heap > heap1.prof
sleep 3600
curl http://localhost:6060/debug/pprof/heap > heap2.prof

# 2. å¯¹æ¯”åˆ†æ
go tool pprof -base=heap1.prof heap2.prof

# 3. æŸ¥çœ‹Topåˆ†é…
(pprof) top 10
(pprof) list <function_name>

# 4. å®æ—¶ç›‘æ§
watch -n 1 'curl -s http://localhost:6060/debug/pprof/heap | grep -A 3 "^# heap profile:"'
```

**å¸¸è§æ³„æ¼ç‚¹**:

```go
package main

import (
    "context"
    "time"
)

// âŒ æ³„æ¼ï¼šGoroutineæœªé€€å‡º
func LeakyGoroutine() {
    go func() {
        for {
            // æ°¸ä¹…è¿è¡Œï¼Œæ— é€€å‡ºæ¡ä»¶
            doWork()
            time.Sleep(1 * time.Second)
        }
    }()
}

// âœ… ä¿®å¤ï¼šä½¿ç”¨Contextæ§åˆ¶
func FixedGoroutine(ctx context.Context) {
    go func() {
        ticker := time.NewTicker(1 * time.Second)
        defer ticker.Stop()
        
        for {
            select {
            case <-ticker.C:
                doWork()
            case <-ctx.Done():
                return // â­ é€€å‡ºç‚¹
            }
        }
    }()
}

// âŒ æ³„æ¼ï¼šSpanæœªè°ƒç”¨End()
func LeakySpan(ctx context.Context) {
    _, span := tracer.Start(ctx, "operation")
    // å¿˜è®° span.End()
    
    doWork()
}

// âœ… ä¿®å¤ï¼šä½¿ç”¨defer
func FixedSpan(ctx context.Context) {
    _, span := tracer.Start(ctx, "operation")
    defer span.End() // â­ ç¡®ä¿é‡Šæ”¾
    
    doWork()
}

// âŒ æ³„æ¼ï¼šChannelæœªå…³é—­
func LeakyChannel() <-chan int {
    ch := make(chan int)
    go func() {
        for i := 0; i < 10; i++ {
            ch <- i
        }
        // å¿˜è®° close(ch)
    }()
    return ch
}

// âœ… ä¿®å¤ï¼šå…³é—­Channel
func FixedChannel() <-chan int {
    ch := make(chan int)
    go func() {
        defer close(ch) // â­ å…³é—­Channel
        for i := 0; i < 10; i++ {
            ch <- i
        }
    }()
    return ch
}
```

### 4.2 GCå‹åŠ›è¿‡å¤§

#### é—®é¢˜ï¼šGCæš‚åœæ—¶é—´ > 100ms

**è¯Šæ–­**:

```bash
# 1. æŸ¥çœ‹GCç»Ÿè®¡
GODEBUG=gctrace=1 ./app 2>&1 | grep gc

# è¾“å‡ºç¤ºä¾‹:
# gc 12 @0.100s 15%: 0.025+1.2+0.010 ms clock, 0.20+0.50/1.0/2.0+0.080 ms cpu, 4->5->3 MB, 8 MB goal, 8 P
#
# è§£è¯»:
# 15% = GCå ç”¨15% CPU
# 1.2ms = STWæš‚åœæ—¶é—´
# 4->5->3 MB = GCå‰->GCå->å­˜æ´»

# 2. Heap Profiling
go tool pprof -alloc_space http://localhost:6060/debug/pprof/heap
(pprof) top
```

**ä¼˜åŒ–æ–¹æ¡ˆ**:

```go
package main

import (
    "runtime/debug"
    "sync"
)

// æ–¹æ¡ˆ1: è°ƒæ•´GOGCï¼ˆé»˜è®¤100ï¼‰
func OptimizeGC() {
    // æé«˜åˆ°200ï¼Œå‡å°‘GCé¢‘ç‡
    debug.SetGCPercent(200)
    
    // ç”Ÿäº§ç¯å¢ƒæ¨è: 150-200
}

// æ–¹æ¡ˆ2: è®¾ç½®å†…å­˜é™åˆ¶ï¼ˆGo 1.19+ï¼‰
func SetMemoryLimit() {
    // é™åˆ¶ä¸º8GB
    debug.SetMemoryLimit(8 * 1024 * 1024 * 1024)
}

// æ–¹æ¡ˆ3: å¯¹è±¡æ± ï¼ˆå‡å°‘åˆ†é…ï¼‰
var bufferPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 1024)
    },
}

func UsePool() {
    // ä»æ± è·å–
    buf := bufferPool.Get().([]byte)
    defer bufferPool.Put(buf) // å½’è¿˜
    
    // ä½¿ç”¨buf
    _ = buf
}
```

---

## 5. ç½‘ç»œè¿æ¥é—®é¢˜

### 5.1 è¿æ¥è¶…æ—¶

#### é—®é¢˜ï¼šcontext deadline exceeded

**æ’æŸ¥å‘½ä»¤**:

```bash
# 1. æµ‹è¯•è¿æ¥
telnet otel-collector 4317

# 2. DNSè§£æ
nslookup otel-collector

# 3. ç½‘ç»œå»¶è¿Ÿ
ping otel-collector

# 4. è·¯ç”±è¿½è¸ª
traceroute otel-collector

# 5. æŠ“åŒ…åˆ†æ
tcpdump -i any -nn "host otel-collector and port 4317" -w otlp.pcap
```

**è§£å†³æ–¹æ¡ˆ**:

```go
package main

import (
    "context"
    "time"
    
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "google.golang.org/grpc"
    "google.golang.org/grpc/backoff"
)

// é…ç½®é‡è¯•å’Œè¶…æ—¶
func NewResilientExporter(endpoint string) (*otlptracegrpc.Exporter, error) {
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    return otlptracegrpc.New(ctx,
        otlptracegrpc.WithEndpoint(endpoint),
        otlptracegrpc.WithInsecure(),
        
        // â­ é‡è¯•é…ç½®
        otlptracegrpc.WithRetry(otlptracegrpc.RetryConfig{
            Enabled:         true,
            InitialInterval: 1 * time.Second,
            MaxInterval:     5 * time.Second,
            MaxElapsedTime:  30 * time.Second,
        }),
        
        // â­ è¶…æ—¶é…ç½®
        otlptracegrpc.WithTimeout(10 * time.Second),
        
        // â­ gRPCè¿æ¥å‚æ•°
        otlptracegrpc.WithGRPCConn(grpc.NewClient(endpoint,
            grpc.WithConnectParams(grpc.ConnectParams{
                Backoff: backoff.Config{
                    BaseDelay:  1.0 * time.Second,
                    Multiplier: 1.6,
                    Jitter:     0.2,
                    MaxDelay:   10 * time.Second,
                },
                MinConnectTimeout: 5 * time.Second,
            }),
        )),
    )
}
```

### 5.2 è¿æ¥æ± è€—å°½

#### é—®é¢˜ï¼šconnection pool exhausted

**è¯Šæ–­**:

```go
package main

import (
    "database/sql"
    "fmt"
)

// æ£€æŸ¥è¿æ¥æ± çŠ¶æ€
func DiagnoseConnectionPool(db *sql.DB) {
    stats := db.Stats()
    
    fmt.Printf("è¿æ¥æ± çŠ¶æ€:\n")
    fmt.Printf("  MaxOpenConnections:  %d\n", stats.MaxOpenConnections)
    fmt.Printf("  OpenConnections:     %d\n", stats.OpenConnections)
    fmt.Printf("  InUse:               %d\n", stats.InUse)
    fmt.Printf("  Idle:                %d\n", stats.Idle)
    fmt.Printf("  WaitCount:           %d\n", stats.WaitCount)
    fmt.Printf("  WaitDuration:        %v\n", stats.WaitDuration)
    
    // å‘Šè­¦
    if stats.WaitCount > 100 {
        fmt.Println("âš ï¸ è¿æ¥æ± ç­‰å¾…è¿‡å¤šï¼Œè€ƒè™‘å¢åŠ MaxOpenConns")
    }
    
    if stats.InUse >= stats.MaxOpenConnections {
        fmt.Println("âŒ è¿æ¥æ± å·²æ»¡!")
    }
}
```

---

## 6. ç”Ÿäº§ç¯å¢ƒç´§æ€¥é—®é¢˜

### 6.1 æœåŠ¡é›ªå´©

#### ç—‡çŠ¶ï¼šçº§è”æ•…éšœï¼Œå¤šä¸ªæœåŠ¡å®•æœº

**ç´§æ€¥å¤„ç†**:

```bash
# 1. ç«‹å³é™ä½é‡‡æ ·ç‡ï¼ˆå‡å°‘è´Ÿè½½ï¼‰
kubectl set env deployment/app OTEL_TRACES_SAMPLER_ARG=0.001  # 0.1%

# 2. é‡å¯å—å½±å“çš„æœåŠ¡
kubectl rollout restart deployment/app

# 3. æ‰©å®¹
kubectl scale deployment/app --replicas=20

# 4. å¯ç”¨ç†”æ–­ï¼ˆä¸´æ—¶ï¼‰
kubectl set env deployment/app ENABLE_CIRCUIT_BREAKER=true
```

**æ ¹å› åˆ†æ**:

```text
æŸ¥çœ‹Jaegerè¿½è¸ªï¼Œå¯»æ‰¾:
1. å¼‚å¸¸é«˜å»¶è¿Ÿçš„Span
2. å¤§é‡é”™è¯¯çš„TraceID
3. è¯·æ±‚é‡çªå¢çš„æ—¶é—´ç‚¹
4. ä¾èµ–æœåŠ¡çš„å¥åº·çŠ¶å†µ
```

### 6.2 å†…å­˜OOM

#### ç—‡çŠ¶ï¼šPodè¢«Killedï¼ŒExit Code 137

**ç´§æ€¥å¤„ç†**:

```bash
# 1. æŸ¥çœ‹OOMäº‹ä»¶
kubectl get events --field-selector reason=OOMKilled

# 2. ä¸´æ—¶å¢åŠ å†…å­˜é™åˆ¶
kubectl set resources deployment/app -c=app --limits=memory=2Gi

# 3. é™ä½OTLPé˜Ÿåˆ—å¤§å°
kubectl set env deployment/app OTEL_BSP_MAX_QUEUE_SIZE=512

# 4. ç¦ç”¨OTLPï¼ˆæç«¯æƒ…å†µï¼‰
kubectl set env deployment/app OTEL_TRACES_EXPORTER=none
```

**äº‹ååˆ†æ**:

```bash
# ä¿å­˜Heap Dumpï¼ˆå¦‚æœè¿˜åœ¨è¿è¡Œï¼‰
kubectl exec -it pod-name -- curl http://localhost:6060/debug/pprof/heap > heap.prof

# ç¦»çº¿åˆ†æ
go tool pprof heap.prof
```

---

## 7. å¸¸è§é—®é¢˜FAQ

### 7.1 OTLPç›¸å…³

**Q1: ä¸ºä»€ä¹ˆçœ‹ä¸åˆ°ä»»ä½•è¿½è¸ªæ•°æ®ï¼Ÿ**

```text
A: ä¾æ¬¡æ£€æŸ¥:
1. âœ… é‡‡æ ·ç‡æ˜¯å¦ä¸º0 â†’ è®¾ç½®OTEL_TRACES_SAMPLER_ARG=0.01
2. âœ… Exporteré…ç½®æ˜¯å¦æ­£ç¡® â†’ éªŒè¯endpoint
3. âœ… Spanæ˜¯å¦è°ƒç”¨End() â†’ ç¡®ä¿defer span.End()
4. âœ… Collectoræ˜¯å¦è¿è¡Œ â†’ curl http://collector:13133/health
```

**Q2: TraceIDä¸ºä»€ä¹ˆä¸è¿ç»­ï¼Ÿ**

```text
A: åŸå› :
1. âŒ æœªé…ç½®Propagator
   è§£å†³: otel.SetTextMapPropagator(propagation.TraceContext{})

2. âŒ HTTP Client/Serveræœªä½¿ç”¨otelhttp
   è§£å†³: ä½¿ç”¨otelhttp.NewTransport() å’Œ otelhttp.NewHandler()

3. âŒ Contextæœªæ­£ç¡®ä¼ é€’
   è§£å†³: ç¡®ä¿æ‰€æœ‰å‡½æ•°éƒ½ä¼ é€’ctxå‚æ•°
```

**Q3: OTLPå¯¼è‡´æ€§èƒ½ä¸‹é™ä¸¥é‡ï¼Ÿ**

```text
A: ä¼˜åŒ–æªæ–½:
1. é™ä½é‡‡æ ·ç‡: 1% (0.01)
2. ä½¿ç”¨æ‰¹é‡å¯¼å‡º: BatchSpanProcessor
3. å‡å°‘å±æ€§æ•°é‡: <10ä¸ª
4. å¼‚æ­¥å¯¼å‡º: éé˜»å¡æ¨¡å¼
5. æœ¬åœ°èšåˆ: ä½¿ç”¨Views
```

### 7.2 æ€§èƒ½ç›¸å…³

**Q4: P99å»¶è¿Ÿçªç„¶å‡é«˜ï¼Ÿ**

```text
A: æ’æŸ¥æ­¥éª¤:
1. æŸ¥çœ‹Jaegeræ‰¾å‡ºæ…¢Span
2. CPU Profiling: go tool pprof
3. æ£€æŸ¥GC: GODEBUG=gctrace=1
4. æ•°æ®åº“æ…¢æŸ¥è¯¢: EXPLAIN ANALYZE
5. ç½‘ç»œå»¶è¿Ÿ: traceroute
```

**Q5: å†…å­˜æŒç»­å¢é•¿ï¼Ÿ**

```text
A: æ’æŸ¥æ–¹æ³•:
1. Heap Profiling: pprof/heap
2. æ£€æŸ¥Goroutineæ³„æ¼: pprof/goroutine
3. æ£€æŸ¥SpanæœªEnd()
4. æ£€æŸ¥Channelæœªclose()
5. æ£€æŸ¥TimeræœªStop()
```

### 7.3 éƒ¨ç½²ç›¸å…³

**Q6: K8sä¸­æœåŠ¡é—´è°ƒç”¨å¤±è´¥ï¼Ÿ**

```text
A: æ£€æŸ¥é¡¹:
1. âœ… Service DNS: nslookup service-name
2. âœ… ç½‘ç»œç­–ç•¥: kubectl get networkpolicy
3. âœ… Serviceç«¯å£: kubectl get svc
4. âœ… Istio sidecar: kubectl get pod -o yaml | grep istio-proxy
```

**Q7: HPAè‡ªåŠ¨æ‰©ç¼©å®¹ä¸å·¥ä½œï¼Ÿ**

```text
A: éªŒè¯:
1. âœ… Metrics Server: kubectl top nodes
2. âœ… HPAçŠ¶æ€: kubectl get hpa
3. âœ… èµ„æºè¯·æ±‚: ç¡®ä¿è®¾ç½®requests
4. âœ… Custom Metrics: kubectl get --raw /apis/custom.metrics.k8s.io/v1beta1
```

---

## 8. æ’æŸ¥å·¥å…·æ¸…å•

### 8.1 å‘½ä»¤è¡Œå·¥å…·

```bash
# Goå·¥å…·
go tool pprof       # æ€§èƒ½åˆ†æ
go tool trace       # è¿½è¸ªåˆ†æ
go test -race       # ç«æ€æ£€æµ‹

# ç½‘ç»œå·¥å…·
curl                # HTTPæµ‹è¯•
telnet              # ç«¯å£æµ‹è¯•
tcpdump             # æŠ“åŒ…
nslookup            # DNSè§£æ

# K8så·¥å…·
kubectl logs        # æ—¥å¿—æŸ¥çœ‹
kubectl describe    # èµ„æºè¯¦æƒ…
kubectl exec        # è¿›å…¥å®¹å™¨
kubectl port-forward # ç«¯å£è½¬å‘

# ç›‘æ§å·¥å…·
top                 # CPU/å†…å­˜
netstat             # ç½‘ç»œè¿æ¥
lsof                # æ–‡ä»¶å¥æŸ„
strace              # ç³»ç»Ÿè°ƒç”¨
```

### 8.2 åœ¨çº¿å·¥å…·

```text
âœ… Jaeger UI:      http://localhost:16686
âœ… Prometheus:     http://localhost:9090
âœ… Grafana:        http://localhost:3000
âœ… pprof:          http://localhost:6060/debug/pprof
âœ… Collector:      http://localhost:13133
```

---

## 9. æ€»ç»“

### 9.1 æœ€ä½³å®è·µ

```text
âœ… å¼€å‘é˜¶æ®µ:
â”œâ”€ ä½¿ç”¨100%é‡‡æ ·ï¼ˆAlwaysSampleï¼‰
â”œâ”€ å¯ç”¨DEBUGæ—¥å¿—
â”œâ”€ æœ¬åœ°è¿è¡ŒJaeger
â””â”€ é¢‘ç¹æ£€æŸ¥è¿½è¸ªæ•°æ®

âœ… æµ‹è¯•é˜¶æ®µ:
â”œâ”€ ä½¿ç”¨10%é‡‡æ ·
â”œâ”€ è¿›è¡Œå‹åŠ›æµ‹è¯•
â”œâ”€ éªŒè¯è¿½è¸ªå®Œæ•´æ€§
â””â”€ æµ‹è¯•æ•…éšœåœºæ™¯

âœ… ç”Ÿäº§é˜¶æ®µ:
â”œâ”€ ä½¿ç”¨1%é‡‡æ ·ï¼ˆæˆ–Adaptiveï¼‰
â”œâ”€ é…ç½®å‘Šè­¦è§„åˆ™
â”œâ”€ å®šæœŸæ£€æŸ¥æ€§èƒ½
â””â”€ å‡†å¤‡ç´§æ€¥é¢„æ¡ˆ
```

### 9.2 ç´§æ€¥è”ç³»æµç¨‹

```text
ç”Ÿäº§æ•…éšœå¤„ç†:
1. è¯„ä¼°å½±å“èŒƒå›´ï¼ˆå“ªäº›æœåŠ¡ã€å¤šå°‘ç”¨æˆ·ï¼‰
2. é™çº§å¤„ç†ï¼ˆé™ä½é‡‡æ ·ã€ç¦ç”¨éå…³é”®åŠŸèƒ½ï¼‰
3. å›æ»šæˆ–æ‰©å®¹
4. æ”¶é›†è¯æ®ï¼ˆæ—¥å¿—ã€è¿½è¸ªã€æŒ‡æ ‡ï¼‰
5. æ ¹å› åˆ†æ
6. ç¼–å†™äº‹æ•…æŠ¥å‘Š
```

---

**ç‰ˆæœ¬**: v1.0.0  
**å®Œæˆæ—¥æœŸ**: 2025-10-11  
**è¦†ç›–é—®é¢˜**: 50+ å¸¸è§é—®é¢˜  
**çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª

**ğŸ‰ å®Œæ•´çš„æ•…éšœæ’æŸ¥æŒ‡å—ï¼**
