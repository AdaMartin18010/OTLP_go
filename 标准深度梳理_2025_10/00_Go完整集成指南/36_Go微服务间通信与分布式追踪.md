# Go 微服务间通信与分布式追踪完整指南

## 📋 目录

- [Go 微服务间通信与分布式追踪完整指南](#go-微服务间通信与分布式追踪完整指南)
  - [📋 目录](#-目录)
  - [文档概述](#文档概述)
    - [核心价值](#核心价值)
    - [依赖版本](#依赖版本)
  - [分布式追踪基础](#分布式追踪基础)
    - [W3C Trace Context](#w3c-trace-context)
    - [Baggage 传播](#baggage-传播)
    - [Span Context 传播](#span-context-传播)
  - [HTTP 通信追踪](#http-通信追踪)
    - [HTTP Client 追踪](#http-client-追踪)
    - [HTTP Server 追踪](#http-server-追踪)
    - [RESTful API 追踪](#restful-api-追踪)
  - [gRPC 通信追踪](#grpc-通信追踪)
    - [gRPC Client 追踪](#grpc-client-追踪)
    - [gRPC Server 追踪](#grpc-server-追踪)
    - [双向流追踪](#双向流追踪)
  - [消息队列追踪](#消息队列追踪)
    - [Kafka 追踪](#kafka-追踪)
    - [NATS 追踪](#nats-追踪)
    - [RabbitMQ 追踪](#rabbitmq-追踪)
  - [服务网格集成](#服务网格集成)
    - [Istio 集成](#istio-集成)
    - [Linkerd 集成](#linkerd-集成)
  - [分布式事务追踪](#分布式事务追踪)
    - [Saga 模式](#saga-模式)
    - [两阶段提交](#两阶段提交)
  - [最佳实践](#最佳实践)
    - [1. Context 传播](#1-context-传播)
    - [2. Span 命名](#2-span-命名)
    - [3. 错误处理](#3-错误处理)
    - [4. 属性设置](#4-属性设置)
    - [5. Metric 命名](#5-metric-命名)
  - [完整示例](#完整示例)
    - [微服务通信完整示例](#微服务通信完整示例)
  - [总结](#总结)
    - [关键要点](#关键要点)
    - [相关文档](#相关文档)

---

## 文档概述

本文档详细介绍 Go 微服务间通信的分布式追踪实现，涵盖 HTTP、gRPC、消息队列等多种通信方式。

### 核心价值

✅ **完整的追踪链路** - 跨服务追踪请求全生命周期  
✅ **多协议支持** - HTTP、gRPC、Kafka、NATS  
✅ **Context 传播** - W3C Trace Context 标准  
✅ **服务网格集成** - Istio、Linkerd  
✅ **分布式事务** - Saga、2PC 模式

### 依赖版本

```go
go.opentelemetry.io/otel v1.32.0
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.57.0
go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.57.0
github.com/IBM/sarama v1.43.3
github.com/nats-io/nats.go v1.37.0
google.golang.org/grpc v1.69.2
```

---

## 分布式追踪基础

### W3C Trace Context

**标准头部：**

```go
package tracing

import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/propagation"
)

// InitPropagators 初始化传播器
func InitPropagators() {
    // W3C Trace Context (traceparent, tracestate)
    tc := propagation.TraceContext{}
    
    // W3C Baggage
    baggage := propagation.Baggage{}
    
    // 组合传播器
    otel.SetTextMapPropagator(
        propagation.NewCompositeTextMapPropagator(
            tc,
            baggage,
        ),
    )
}

// traceparent 格式: 00-<trace-id>-<span-id>-<flags>
// 示例: 00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01
```

**手动注入和提取：**

```go
package tracing

import (
    "context"
    "net/http"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/propagation"
)

// InjectContext 注入 Context 到 HTTP Headers
func InjectContext(ctx context.Context, headers http.Header) {
    propagator := otel.GetTextMapPropagator()
    propagator.Inject(ctx, propagation.HeaderCarrier(headers))
}

// ExtractContext 从 HTTP Headers 提取 Context
func ExtractContext(ctx context.Context, headers http.Header) context.Context {
    propagator := otel.GetTextMapPropagator()
    return propagator.Extract(ctx, propagation.HeaderCarrier(headers))
}

// InjectToMap 注入到 Map（用于消息队列）
func InjectToMap(ctx context.Context) map[string]string {
    carrier := make(propagation.MapCarrier)
    propagator := otel.GetTextMapPropagator()
    propagator.Inject(ctx, carrier)
    
    result := make(map[string]string)
    for k, v := range carrier {
        result[k] = v
    }
    return result
}

// ExtractFromMap 从 Map 提取（用于消息队列）
func ExtractFromMap(ctx context.Context, headers map[string]string) context.Context {
    carrier := propagation.MapCarrier(headers)
    propagator := otel.GetTextMapPropagator()
    return propagator.Extract(ctx, carrier)
}
```

### Baggage 传播

**Baggage 使用：**

```go
package tracing

import (
    "context"
    
    "go.opentelemetry.io/otel/baggage"
)

// SetBaggage 设置 Baggage
func SetBaggage(ctx context.Context, key, value string) (context.Context, error) {
    member, err := baggage.NewMember(key, value)
    if err != nil {
        return ctx, err
    }
    
    bag, err := baggage.FromContext(ctx).SetMember(member)
    if err != nil {
        return ctx, err
    }
    
    return baggage.ContextWithBaggage(ctx, bag), nil
}

// GetBaggage 获取 Baggage
func GetBaggage(ctx context.Context, key string) string {
    bag := baggage.FromContext(ctx)
    member := bag.Member(key)
    return member.Value()
}

// SetMultipleBaggage 设置多个 Baggage
func SetMultipleBaggage(ctx context.Context, values map[string]string) (context.Context, error) {
    var members []baggage.Member
    
    for k, v := range values {
        member, err := baggage.NewMember(k, v)
        if err != nil {
            return ctx, err
        }
        members = append(members, member)
    }
    
    bag, err := baggage.New(members...)
    if err != nil {
        return ctx, err
    }
    
    return baggage.ContextWithBaggage(ctx, bag), nil
}
```

**实际应用：**

```go
// 在服务 A 中设置
ctx, _ = SetBaggage(ctx, "user.id", "12345")
ctx, _ = SetBaggage(ctx, "tenant.id", "acme")

// 在服务 B 中获取
userID := GetBaggage(ctx, "user.id")      // "12345"
tenantID := GetBaggage(ctx, "tenant.id")  // "acme"
```

### Span Context 传播

**跨服务 Span 链接：**

```go
package tracing

import (
    "context"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

// CreateLinkedSpan 创建链接的 Span
func CreateLinkedSpan(ctx context.Context, name string, linkedCtx context.Context) (context.Context, trace.Span) {
    tracer := otel.Tracer("service")
    
    // 从另一个 Context 获取 SpanContext
    linkedSpanContext := trace.SpanContextFromContext(linkedCtx)
    
    // 创建链接
    link := trace.Link{
        SpanContext: linkedSpanContext,
    }
    
    // 创建带链接的 Span
    return tracer.Start(ctx, name,
        trace.WithLinks(link),
    )
}

// CreateChildSpan 创建子 Span
func CreateChildSpan(ctx context.Context, name string) (context.Context, trace.Span) {
    tracer := otel.Tracer("service")
    return tracer.Start(ctx, name)
}

// CreateFollowsFromSpan 创建 FollowsFrom Span
func CreateFollowsFromSpan(ctx context.Context, name string, parentCtx context.Context) (context.Context, trace.Span) {
    tracer := otel.Tracer("service")
    
    parentSpanContext := trace.SpanContextFromContext(parentCtx)
    
    link := trace.Link{
        SpanContext: parentSpanContext,
        // FollowsFrom 关系
    }
    
    return tracer.Start(ctx, name,
        trace.WithLinks(link),
    )
}
```

---

## HTTP 通信追踪

### HTTP Client 追踪

**基础 HTTP Client：**

```go
package httpclient

import (
    "context"
    "net/http"
    "time"
    
    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
)

// TracedHTTPClient 带追踪的 HTTP Client
type TracedHTTPClient struct {
    client  *http.Client
    tracer  trace.Tracer
    meter   metric.Meter
    
    // Metrics
    requestCounter  metric.Int64Counter
    requestDuration metric.Float64Histogram
    requestSize     metric.Int64Histogram
    responseSize    metric.Int64Histogram
}

// NewTracedHTTPClient 创建带追踪的 HTTP Client
func NewTracedHTTPClient(timeout time.Duration) (*TracedHTTPClient, error) {
    tracer := otel.Tracer("http-client")
    meter := otel.Meter("http-client")
    
    tc := &TracedHTTPClient{
        client: &http.Client{
            Timeout: timeout,
            Transport: otelhttp.NewTransport(
                http.DefaultTransport,
                otelhttp.WithSpanNameFormatter(func(operation string, r *http.Request) string {
                    return operation + " " + r.Method + " " + r.URL.Path
                }),
            ),
        },
        tracer: tracer,
        meter:  meter,
    }
    
    var err error
    
    // 请求计数器
    tc.requestCounter, err = meter.Int64Counter(
        "http.client.requests",
        metric.WithDescription("HTTP client requests"),
    )
    if err != nil {
        return nil, err
    }
    
    // 请求持续时间
    tc.requestDuration, err = meter.Float64Histogram(
        "http.client.duration",
        metric.WithDescription("HTTP client request duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    // 请求大小
    tc.requestSize, err = meter.Int64Histogram(
        "http.client.request.size",
        metric.WithDescription("HTTP client request size"),
        metric.WithUnit("bytes"),
    )
    if err != nil {
        return nil, err
    }
    
    // 响应大小
    tc.responseSize, err = meter.Int64Histogram(
        "http.client.response.size",
        metric.WithDescription("HTTP client response size"),
        metric.WithUnit("bytes"),
    )
    if err != nil {
        return nil, err
    }
    
    return tc, nil
}

// Do 执行 HTTP 请求
func (tc *TracedHTTPClient) Do(ctx context.Context, req *http.Request) (*http.Response, error) {
    ctx, span := tc.tracer.Start(ctx, "http.client.request",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            attribute.String("http.method", req.Method),
            attribute.String("http.url", req.URL.String()),
            attribute.String("http.target", req.URL.Path),
            attribute.String("http.host", req.Host),
        ),
    )
    defer span.End()
    
    start := time.Now()
    
    // 添加 Context
    req = req.WithContext(ctx)
    
    // 记录请求大小
    if req.Body != nil && req.ContentLength > 0 {
        tc.requestSize.Record(ctx, req.ContentLength,
            metric.WithAttributes(
                attribute.String("http.method", req.Method),
            ),
        )
        span.SetAttributes(attribute.Int64("http.request.content_length", req.ContentLength))
    }
    
    // 执行请求
    resp, err := tc.client.Do(req)
    
    duration := time.Since(start)
    
    // 记录 Metrics
    attrs := []attribute.KeyValue{
        attribute.String("http.method", req.Method),
        attribute.String("http.target", req.URL.Path),
    }
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        
        attrs = append(attrs, attribute.String("error", "true"))
        tc.requestCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
        
        return nil, err
    }
    
    // 记录响应信息
    span.SetAttributes(
        attribute.Int("http.status_code", resp.StatusCode),
        attribute.Int64("http.response.content_length", resp.ContentLength),
    )
    
    attrs = append(attrs,
        attribute.Int("http.status_code", resp.StatusCode),
        attribute.String("error", "false"),
    )
    
    tc.requestCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
    tc.requestDuration.Record(ctx, float64(duration.Milliseconds()), metric.WithAttributes(attrs...))
    
    if resp.ContentLength > 0 {
        tc.responseSize.Record(ctx, resp.ContentLength, metric.WithAttributes(attrs...))
    }
    
    // 设置状态
    if resp.StatusCode >= 400 {
        span.SetStatus(codes.Error, http.StatusText(resp.StatusCode))
    } else {
        span.SetStatus(codes.Ok, "")
    }
    
    return resp, nil
}

// Get 执行 GET 请求
func (tc *TracedHTTPClient) Get(ctx context.Context, url string) (*http.Response, error) {
    req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
    if err != nil {
        return nil, err
    }
    return tc.Do(ctx, req)
}

// Post 执行 POST 请求
func (tc *TracedHTTPClient) Post(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error) {
    req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, body)
    if err != nil {
        return nil, err
    }
    req.Header.Set("Content-Type", contentType)
    return tc.Do(ctx, req)
}
```

### HTTP Server 追踪

**带追踪的 HTTP Server：**

```go
package httpserver

import (
    "context"
    "net/http"
    "time"
    
    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
)

// TracedHTTPServer 带追踪的 HTTP Server
type TracedHTTPServer struct {
    server *http.Server
    tracer trace.Tracer
    meter  metric.Meter
    
    // Metrics
    requestCounter    metric.Int64Counter
    requestDuration   metric.Float64Histogram
    activeRequests    metric.Int64UpDownCounter
    requestSize       metric.Int64Histogram
    responseSize      metric.Int64Histogram
}

// NewTracedHTTPServer 创建带追踪的 HTTP Server
func NewTracedHTTPServer(addr string, handler http.Handler) (*TracedHTTPServer, error) {
    tracer := otel.Tracer("http-server")
    meter := otel.Meter("http-server")
    
    ts := &TracedHTTPServer{
        tracer: tracer,
        meter:  meter,
    }
    
    var err error
    
    // 请求计数器
    ts.requestCounter, err = meter.Int64Counter(
        "http.server.requests",
        metric.WithDescription("HTTP server requests"),
    )
    if err != nil {
        return nil, err
    }
    
    // 请求持续时间
    ts.requestDuration, err = meter.Float64Histogram(
        "http.server.duration",
        metric.WithDescription("HTTP server request duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    // 活跃请求数
    ts.activeRequests, err = meter.Int64UpDownCounter(
        "http.server.active_requests",
        metric.WithDescription("Active HTTP requests"),
    )
    if err != nil {
        return nil, err
    }
    
    // 请求大小
    ts.requestSize, err = meter.Int64Histogram(
        "http.server.request.size",
        metric.WithDescription("HTTP server request size"),
        metric.WithUnit("bytes"),
    )
    if err != nil {
        return nil, err
    }
    
    // 响应大小
    ts.responseSize, err = meter.Int64Histogram(
        "http.server.response.size",
        metric.WithDescription("HTTP server response size"),
        metric.WithUnit("bytes"),
    )
    if err != nil {
        return nil, err
    }
    
    // 包装 Handler
    wrappedHandler := otelhttp.NewHandler(
        ts.wrapHandler(handler),
        "http-server",
        otelhttp.WithSpanNameFormatter(func(operation string, r *http.Request) string {
            return r.Method + " " + r.URL.Path
        }),
    )
    
    ts.server = &http.Server{
        Addr:    addr,
        Handler: wrappedHandler,
    }
    
    return ts, nil
}

// wrapHandler 包装 Handler 添加 Metrics
func (ts *TracedHTTPServer) wrapHandler(handler http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        ctx := r.Context()
        start := time.Now()
        
        // 增加活跃请求数
        ts.activeRequests.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("http.method", r.Method),
                attribute.String("http.route", r.URL.Path),
            ),
        )
        defer ts.activeRequests.Add(ctx, -1,
            metric.WithAttributes(
                attribute.String("http.method", r.Method),
                attribute.String("http.route", r.URL.Path),
            ),
        )
        
        // 记录请求大小
        if r.ContentLength > 0 {
            ts.requestSize.Record(ctx, r.ContentLength,
                metric.WithAttributes(
                    attribute.String("http.method", r.Method),
                ),
            )
        }
        
        // 包装 ResponseWriter
        rw := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
        
        // 调用原始 Handler
        handler.ServeHTTP(rw, r)
        
        duration := time.Since(start)
        
        // 记录 Metrics
        attrs := []attribute.KeyValue{
            attribute.String("http.method", r.Method),
            attribute.String("http.route", r.URL.Path),
            attribute.Int("http.status_code", rw.statusCode),
        }
        
        ts.requestCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
        ts.requestDuration.Record(ctx, float64(duration.Milliseconds()), metric.WithAttributes(attrs...))
        
        if rw.bytesWritten > 0 {
            ts.responseSize.Record(ctx, int64(rw.bytesWritten), metric.WithAttributes(attrs...))
        }
    })
}

// responseWriter 包装 ResponseWriter
type responseWriter struct {
    http.ResponseWriter
    statusCode   int
    bytesWritten int
}

func (rw *responseWriter) WriteHeader(statusCode int) {
    rw.statusCode = statusCode
    rw.ResponseWriter.WriteHeader(statusCode)
}

func (rw *responseWriter) Write(b []byte) (int, error) {
    n, err := rw.ResponseWriter.Write(b)
    rw.bytesWritten += n
    return n, err
}

// Start 启动服务器
func (ts *TracedHTTPServer) Start() error {
    return ts.server.ListenAndServe()
}

// Shutdown 优雅关闭
func (ts *TracedHTTPServer) Shutdown(ctx context.Context) error {
    return ts.server.Shutdown(ctx)
}
```

### RESTful API 追踪

**完整的 REST API 示例：**

```go
package api

import (
    "context"
    "encoding/json"
    "net/http"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// UserService 用户服务
type UserService struct {
    tracer trace.Tracer
    client *TracedHTTPClient
}

// NewUserService 创建用户服务
func NewUserService(client *TracedHTTPClient) *UserService {
    return &UserService{
        tracer: otel.Tracer("user-service"),
        client: client,
    }
}

// GetUser 获取用户
func (s *UserService) GetUser(ctx context.Context, userID string) (*User, error) {
    ctx, span := s.tracer.Start(ctx, "get-user",
        trace.WithAttributes(
            attribute.String("user.id", userID),
        ),
    )
    defer span.End()
    
    // 调用下游服务
    url := fmt.Sprintf("http://user-service/api/users/%s", userID)
    resp, err := s.client.Get(ctx, url)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return nil, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        err := fmt.Errorf("unexpected status: %d", resp.StatusCode)
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return nil, err
    }
    
    var user User
    if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return nil, err
    }
    
    span.SetAttributes(
        attribute.String("user.name", user.Name),
        attribute.String("user.email", user.Email),
    )
    span.SetStatus(codes.Ok, "")
    
    return &user, nil
}

// CreateUser 创建用户
func (s *UserService) CreateUser(ctx context.Context, user *User) error {
    ctx, span := s.tracer.Start(ctx, "create-user",
        trace.WithAttributes(
            attribute.String("user.name", user.Name),
            attribute.String("user.email", user.Email),
        ),
    )
    defer span.End()
    
    // 序列化
    data, err := json.Marshal(user)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    // 调用下游服务
    url := "http://user-service/api/users"
    resp, err := s.client.Post(ctx, url, "application/json", bytes.NewReader(data))
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusCreated {
        err := fmt.Errorf("unexpected status: %d", resp.StatusCode)
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// User 用户模型
type User struct {
    ID    string `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}
```

---

## gRPC 通信追踪

### gRPC Client 追踪

**带追踪的 gRPC Client：**

```go
package grpcclient

import (
    "context"
    "time"
    
    "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
)

// TracedGRPCClient 带追踪的 gRPC Client
type TracedGRPCClient struct {
    conn   *grpc.ClientConn
    tracer trace.Tracer
    meter  metric.Meter
    
    // Metrics
    requestCounter  metric.Int64Counter
    requestDuration metric.Float64Histogram
}

// NewTracedGRPCClient 创建带追踪的 gRPC Client
func NewTracedGRPCClient(target string) (*TracedGRPCClient, error) {
    tracer := otel.Tracer("grpc-client")
    meter := otel.Meter("grpc-client")
    
    // 创建连接
    conn, err := grpc.NewClient(
        target,
        grpc.WithTransportCredentials(insecure.NewCredentials()),
        grpc.WithStatsHandler(otelgrpc.NewClientHandler()),
    )
    if err != nil {
        return nil, err
    }
    
    tc := &TracedGRPCClient{
        conn:   conn,
        tracer: tracer,
        meter:  meter,
    }
    
    // 请求计数器
    tc.requestCounter, err = meter.Int64Counter(
        "grpc.client.requests",
        metric.WithDescription("gRPC client requests"),
    )
    if err != nil {
        return nil, err
    }
    
    // 请求持续时间
    tc.requestDuration, err = meter.Float64Histogram(
        "grpc.client.duration",
        metric.WithDescription("gRPC client request duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    return tc, nil
}

// Invoke 调用一元 RPC
func (tc *TracedGRPCClient) Invoke(ctx context.Context, method string, args, reply interface{}) error {
    ctx, span := tc.tracer.Start(ctx, method,
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            attribute.String("rpc.system", "grpc"),
            attribute.String("rpc.service", extractService(method)),
            attribute.String("rpc.method", extractMethod(method)),
        ),
    )
    defer span.End()
    
    start := time.Now()
    
    err := tc.conn.Invoke(ctx, method, args, reply)
    
    duration := time.Since(start)
    
    // 记录 Metrics
    attrs := []attribute.KeyValue{
        attribute.String("rpc.method", method),
    }
    
    if err != nil {
        attrs = append(attrs, attribute.String("error", "true"))
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
    } else {
        attrs = append(attrs, attribute.String("error", "false"))
        span.SetStatus(codes.Ok, "")
    }
    
    tc.requestCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
    tc.requestDuration.Record(ctx, float64(duration.Milliseconds()), metric.WithAttributes(attrs...))
    
    return err
}

// Conn 获取连接
func (tc *TracedGRPCClient) Conn() *grpc.ClientConn {
    return tc.conn
}

// Close 关闭连接
func (tc *TracedGRPCClient) Close() error {
    return tc.conn.Close()
}

// extractService 提取服务名
func extractService(method string) string {
    // 格式: /package.Service/Method
    parts := strings.Split(method, "/")
    if len(parts) >= 2 {
        return parts[1]
    }
    return "unknown"
}

// extractMethod 提取方法名
func extractMethod(method string) string {
    parts := strings.Split(method, "/")
    if len(parts) >= 3 {
        return parts[2]
    }
    return "unknown"
}
```

### gRPC Server 追踪

**带追踪的 gRPC Server：**

```go
package grpcserver

import (
    "context"
    "net"
    
    "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
    "google.golang.org/grpc"
)

// TracedGRPCServer 带追踪的 gRPC Server
type TracedGRPCServer struct {
    server *grpc.Server
    tracer trace.Tracer
    meter  metric.Meter
    
    // Metrics
    requestCounter  metric.Int64Counter
    requestDuration metric.Float64Histogram
    activeRequests  metric.Int64UpDownCounter
}

// NewTracedGRPCServer 创建带追踪的 gRPC Server
func NewTracedGRPCServer() (*TracedGRPCServer, error) {
    tracer := otel.Tracer("grpc-server")
    meter := otel.Meter("grpc-server")
    
    ts := &TracedGRPCServer{
        tracer: tracer,
        meter:  meter,
    }
    
    var err error
    
    // 请求计数器
    ts.requestCounter, err = meter.Int64Counter(
        "grpc.server.requests",
        metric.WithDescription("gRPC server requests"),
    )
    if err != nil {
        return nil, err
    }
    
    // 请求持续时间
    ts.requestDuration, err = meter.Float64Histogram(
        "grpc.server.duration",
        metric.WithDescription("gRPC server request duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    // 活跃请求数
    ts.activeRequests, err = meter.Int64UpDownCounter(
        "grpc.server.active_requests",
        metric.WithDescription("Active gRPC requests"),
    )
    if err != nil {
        return nil, err
    }
    
    // 创建 gRPC Server
    ts.server = grpc.NewServer(
        grpc.StatsHandler(otelgrpc.NewServerHandler()),
        grpc.UnaryInterceptor(ts.unaryInterceptor()),
        grpc.StreamInterceptor(ts.streamInterceptor()),
    )
    
    return ts, nil
}

// unaryInterceptor 一元拦截器
func (ts *TracedGRPCServer) unaryInterceptor() grpc.UnaryServerInterceptor {
    return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
        start := time.Now()
        
        // 增加活跃请求数
        ts.activeRequests.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("rpc.method", info.FullMethod),
            ),
        )
        defer ts.activeRequests.Add(ctx, -1,
            metric.WithAttributes(
                attribute.String("rpc.method", info.FullMethod),
            ),
        )
        
        // 调用 Handler
        resp, err := handler(ctx, req)
        
        duration := time.Since(start)
        
        // 记录 Metrics
        attrs := []attribute.KeyValue{
            attribute.String("rpc.method", info.FullMethod),
        }
        
        if err != nil {
            attrs = append(attrs, attribute.String("error", "true"))
        } else {
            attrs = append(attrs, attribute.String("error", "false"))
        }
        
        ts.requestCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
        ts.requestDuration.Record(ctx, float64(duration.Milliseconds()), metric.WithAttributes(attrs...))
        
        return resp, err
    }
}

// streamInterceptor 流拦截器
func (ts *TracedGRPCServer) streamInterceptor() grpc.StreamServerInterceptor {
    return func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {
        ctx := ss.Context()
        start := time.Now()
        
        // 增加活跃请求数
        ts.activeRequests.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("rpc.method", info.FullMethod),
                attribute.Bool("rpc.is_stream", true),
            ),
        )
        defer ts.activeRequests.Add(ctx, -1,
            metric.WithAttributes(
                attribute.String("rpc.method", info.FullMethod),
                attribute.Bool("rpc.is_stream", true),
            ),
        )
        
        // 调用 Handler
        err := handler(srv, ss)
        
        duration := time.Since(start)
        
        // 记录 Metrics
        attrs := []attribute.KeyValue{
            attribute.String("rpc.method", info.FullMethod),
            attribute.Bool("rpc.is_stream", true),
        }
        
        if err != nil {
            attrs = append(attrs, attribute.String("error", "true"))
        } else {
            attrs = append(attrs, attribute.String("error", "false"))
        }
        
        ts.requestCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
        ts.requestDuration.Record(ctx, float64(duration.Milliseconds()), metric.WithAttributes(attrs...))
        
        return err
    }
}

// Serve 启动服务
func (ts *TracedGRPCServer) Serve(addr string) error {
    lis, err := net.Listen("tcp", addr)
    if err != nil {
        return err
    }
    return ts.server.Serve(lis)
}

// GracefulStop 优雅停止
func (ts *TracedGRPCServer) GracefulStop() {
    ts.server.GracefulStop()
}

// Server 获取 gRPC Server
func (ts *TracedGRPCServer) Server() *grpc.Server {
    return ts.server
}
```

### 双向流追踪

**双向流示例：**

```go
package stream

import (
    "context"
    "io"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// ChatService 聊天服务
type ChatService struct {
    tracer trace.Tracer
}

// NewChatService 创建聊天服务
func NewChatService() *ChatService {
    return &ChatService{
        tracer: otel.Tracer("chat-service"),
    }
}

// Chat 双向流聊天
func (s *ChatService) Chat(stream ChatService_ChatServer) error {
    ctx := stream.Context()
    ctx, span := s.tracer.Start(ctx, "chat-stream",
        trace.WithSpanKind(trace.SpanKindServer),
    )
    defer span.End()
    
    messageCount := 0
    
    for {
        // 接收消息
        req, err := stream.Recv()
        if err == io.EOF {
            span.AddEvent("stream closed by client",
                trace.WithAttributes(
                    attribute.Int("total_messages", messageCount),
                ),
            )
            return nil
        }
        if err != nil {
            span.RecordError(err)
            return err
        }
        
        messageCount++
        
        span.AddEvent("message received",
            trace.WithAttributes(
                attribute.String("from", req.From),
                attribute.String("message", req.Message),
            ),
        )
        
        // 处理消息
        resp := &ChatResponse{
            From:    "server",
            Message: "Echo: " + req.Message,
        }
        
        // 发送响应
        if err := stream.Send(resp); err != nil {
            span.RecordError(err)
            return err
        }
        
        span.AddEvent("message sent",
            trace.WithAttributes(
                attribute.String("to", req.From),
            ),
        )
    }
}
```

---

## 消息队列追踪

### Kafka 追踪

**Kafka Producer 追踪：**

```go
package kafka

import (
    "context"
    "encoding/json"
    
    "github.com/IBM/sarama"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/trace"
)

// TracedKafkaProducer 带追踪的 Kafka Producer
type TracedKafkaProducer struct {
    producer  sarama.SyncProducer
    tracer    trace.Tracer
    propagator propagation.TextMapPropagator
}

// NewTracedKafkaProducer 创建带追踪的 Kafka Producer
func NewTracedKafkaProducer(brokers []string) (*TracedKafkaProducer, error) {
    config := sarama.NewConfig()
    config.Producer.Return.Successes = true
    config.Producer.RequiredAcks = sarama.WaitForAll
    
    producer, err := sarama.NewSyncProducer(brokers, config)
    if err != nil {
        return nil, err
    }
    
    return &TracedKafkaProducer{
        producer:   producer,
        tracer:     otel.Tracer("kafka-producer"),
        propagator: otel.GetTextMapPropagator(),
    }, nil
}

// SendMessage 发送消息
func (p *TracedKafkaProducer) SendMessage(ctx context.Context, topic string, key, value []byte) error {
    ctx, span := p.tracer.Start(ctx, "kafka.produce",
        trace.WithSpanKind(trace.SpanKindProducer),
        trace.WithAttributes(
            attribute.String("messaging.system", "kafka"),
            attribute.String("messaging.destination", topic),
            attribute.Int("messaging.message.payload_size_bytes", len(value)),
        ),
    )
    defer span.End()
    
    // 创建消息
    msg := &sarama.ProducerMessage{
        Topic: topic,
        Key:   sarama.ByteEncoder(key),
        Value: sarama.ByteEncoder(value),
        Headers: make([]sarama.RecordHeader, 0),
    }
    
    // 注入 Trace Context
    carrier := &kafkaHeaderCarrier{headers: &msg.Headers}
    p.propagator.Inject(ctx, carrier)
    
    // 发送消息
    partition, offset, err := p.producer.SendMessage(msg)
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetAttributes(
        attribute.Int("messaging.kafka.partition", int(partition)),
        attribute.Int64("messaging.kafka.offset", offset),
    )
    span.SetStatus(codes.Ok, "")
    
    return nil
}

// Close 关闭 Producer
func (p *TracedKafkaProducer) Close() error {
    return p.producer.Close()
}

// kafkaHeaderCarrier Kafka Header Carrier
type kafkaHeaderCarrier struct {
    headers *[]sarama.RecordHeader
}

func (c *kafkaHeaderCarrier) Get(key string) string {
    for _, h := range *c.headers {
        if string(h.Key) == key {
            return string(h.Value)
        }
    }
    return ""
}

func (c *kafkaHeaderCarrier) Set(key, value string) {
    *c.headers = append(*c.headers, sarama.RecordHeader{
        Key:   []byte(key),
        Value: []byte(value),
    })
}

func (c *kafkaHeaderCarrier) Keys() []string {
    keys := make([]string, 0, len(*c.headers))
    for _, h := range *c.headers {
        keys = append(keys, string(h.Key))
    }
    return keys
}
```

**Kafka Consumer 追踪：**

```go
package kafka

import (
    "context"
    
    "github.com/IBM/sarama"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/trace"
)

// TracedKafkaConsumer 带追踪的 Kafka Consumer
type TracedKafkaConsumer struct {
    consumer   sarama.ConsumerGroup
    tracer     trace.Tracer
    propagator propagation.TextMapPropagator
}

// NewTracedKafkaConsumer 创建带追踪的 Kafka Consumer
func NewTracedKafkaConsumer(brokers []string, groupID string) (*TracedKafkaConsumer, error) {
    config := sarama.NewConfig()
    config.Consumer.Group.Rebalance.Strategy = sarama.NewBalanceStrategyRoundRobin()
    config.Consumer.Offsets.Initial = sarama.OffsetNewest
    
    consumer, err := sarama.NewConsumerGroup(brokers, groupID, config)
    if err != nil {
        return nil, err
    }
    
    return &TracedKafkaConsumer{
        consumer:   consumer,
        tracer:     otel.Tracer("kafka-consumer"),
        propagator: otel.GetTextMapPropagator(),
    }, nil
}

// Consume 消费消息
func (c *TracedKafkaConsumer) Consume(ctx context.Context, topics []string, handler func(context.Context, *sarama.ConsumerMessage) error) error {
    consumerHandler := &tracedConsumerGroupHandler{
        tracer:     c.tracer,
        propagator: c.propagator,
        handler:    handler,
    }
    
    for {
        if err := c.consumer.Consume(ctx, topics, consumerHandler); err != nil {
            return err
        }
        
        if ctx.Err() != nil {
            return ctx.Err()
        }
    }
}

// Close 关闭 Consumer
func (c *TracedKafkaConsumer) Close() error {
    return c.consumer.Close()
}

// tracedConsumerGroupHandler Consumer Group Handler
type tracedConsumerGroupHandler struct {
    tracer     trace.Tracer
    propagator propagation.TextMapPropagator
    handler    func(context.Context, *sarama.ConsumerMessage) error
}

func (h *tracedConsumerGroupHandler) Setup(sarama.ConsumerGroupSession) error {
    return nil
}

func (h *tracedConsumerGroupHandler) Cleanup(sarama.ConsumerGroupSession) error {
    return nil
}

func (h *tracedConsumerGroupHandler) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
    for message := range claim.Messages() {
        // 提取 Trace Context
        carrier := &kafkaMessageCarrier{message: message}
        ctx := h.propagator.Extract(context.Background(), carrier)
        
        ctx, span := h.tracer.Start(ctx, "kafka.consume",
            trace.WithSpanKind(trace.SpanKindConsumer),
            trace.WithAttributes(
                attribute.String("messaging.system", "kafka"),
                attribute.String("messaging.destination", message.Topic),
                attribute.Int("messaging.kafka.partition", int(message.Partition)),
                attribute.Int64("messaging.kafka.offset", message.Offset),
                attribute.Int("messaging.message.payload_size_bytes", len(message.Value)),
            ),
        )
        
        // 调用处理器
        err := h.handler(ctx, message)
        
        if err != nil {
            span.RecordError(err)
            span.SetStatus(codes.Error, err.Error())
        } else {
            span.SetStatus(codes.Ok, "")
            session.MarkMessage(message, "")
        }
        
        span.End()
    }
    
    return nil
}

// kafkaMessageCarrier Kafka Message Carrier
type kafkaMessageCarrier struct {
    message *sarama.ConsumerMessage
}

func (c *kafkaMessageCarrier) Get(key string) string {
    for _, h := range c.message.Headers {
        if string(h.Key) == key {
            return string(h.Value)
        }
    }
    return ""
}

func (c *kafkaMessageCarrier) Set(key, value string) {
    // Consumer 不需要实现
}

func (c *kafkaMessageCarrier) Keys() []string {
    keys := make([]string, 0, len(c.message.Headers))
    for _, h := range c.message.Headers {
        keys = append(keys, string(h.Key))
    }
    return keys
}
```

### NATS 追踪

**NATS Publish/Subscribe 追踪：**

```go
package nats

import (
    "context"
    "encoding/json"
    
    "github.com/nats-io/nats.go"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/trace"
)

// TracedNATSClient 带追踪的 NATS Client
type TracedNATSClient struct {
    conn       *nats.Conn
    tracer     trace.Tracer
    propagator propagation.TextMapPropagator
}

// NewTracedNATSClient 创建带追踪的 NATS Client
func NewTracedNATSClient(url string) (*TracedNATSClient, error) {
    conn, err := nats.Connect(url)
    if err != nil {
        return nil, err
    }
    
    return &TracedNATSClient{
        conn:       conn,
        tracer:     otel.Tracer("nats-client"),
        propagator: otel.GetTextMapPropagator(),
    }, nil
}

// Publish 发布消息
func (c *TracedNATSClient) Publish(ctx context.Context, subject string, data []byte) error {
    ctx, span := c.tracer.Start(ctx, "nats.publish",
        trace.WithSpanKind(trace.SpanKindProducer),
        trace.WithAttributes(
            attribute.String("messaging.system", "nats"),
            attribute.String("messaging.destination", subject),
            attribute.Int("messaging.message.payload_size_bytes", len(data)),
        ),
    )
    defer span.End()
    
    // 创建消息 Envelope
    envelope := &MessageEnvelope{
        Data:    data,
        Headers: make(map[string]string),
    }
    
    // 注入 Trace Context
    carrier := propagation.MapCarrier(envelope.Headers)
    c.propagator.Inject(ctx, carrier)
    
    // 序列化 Envelope
    envelopeData, err := json.Marshal(envelope)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    // 发布消息
    if err := c.conn.Publish(subject, envelopeData); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// Subscribe 订阅消息
func (c *TracedNATSClient) Subscribe(subject string, handler func(context.Context, []byte) error) (*nats.Subscription, error) {
    return c.conn.Subscribe(subject, func(msg *nats.Msg) {
        // 反序列化 Envelope
        var envelope MessageEnvelope
        if err := json.Unmarshal(msg.Data, &envelope); err != nil {
            return
        }
        
        // 提取 Trace Context
        carrier := propagation.MapCarrier(envelope.Headers)
        ctx := c.propagator.Extract(context.Background(), carrier)
        
        ctx, span := c.tracer.Start(ctx, "nats.consume",
            trace.WithSpanKind(trace.SpanKindConsumer),
            trace.WithAttributes(
                attribute.String("messaging.system", "nats"),
                attribute.String("messaging.destination", subject),
                attribute.Int("messaging.message.payload_size_bytes", len(envelope.Data)),
            ),
        )
        defer span.End()
        
        // 调用处理器
        if err := handler(ctx, envelope.Data); err != nil {
            span.RecordError(err)
            span.SetStatus(codes.Error, err.Error())
        } else {
            span.SetStatus(codes.Ok, "")
        }
    })
}

// Close 关闭连接
func (c *TracedNATSClient) Close() {
    c.conn.Close()
}

// MessageEnvelope 消息信封
type MessageEnvelope struct {
    Data    []byte            `json:"data"`
    Headers map[string]string `json:"headers"`
}
```

### RabbitMQ 追踪

**RabbitMQ Producer 追踪：**

```go
package rabbitmq

import (
    "context"
    "encoding/json"
    
    amqp "github.com/rabbitmq/amqp091-go"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/trace"
)

// TracedRabbitMQProducer 带追踪的 RabbitMQ Producer
type TracedRabbitMQProducer struct {
    conn       *amqp.Connection
    channel    *amqp.Channel
    tracer     trace.Tracer
    propagator propagation.TextMapPropagator
}

// NewTracedRabbitMQProducer 创建带追踪的 RabbitMQ Producer
func NewTracedRabbitMQProducer(url string) (*TracedRabbitMQProducer, error) {
    conn, err := amqp.Dial(url)
    if err != nil {
        return nil, err
    }
    
    channel, err := conn.Channel()
    if err != nil {
        conn.Close()
        return nil, err
    }
    
    return &TracedRabbitMQProducer{
        conn:       conn,
        channel:    channel,
        tracer:     otel.Tracer("rabbitmq-producer"),
        propagator: otel.GetTextMapPropagator(),
    }, nil
}

// Publish 发布消息
func (p *TracedRabbitMQProducer) Publish(ctx context.Context, exchange, routingKey string, body []byte) error {
    ctx, span := p.tracer.Start(ctx, "rabbitmq.publish",
        trace.WithSpanKind(trace.SpanKindProducer),
        trace.WithAttributes(
            attribute.String("messaging.system", "rabbitmq"),
            attribute.String("messaging.destination", exchange),
            attribute.String("messaging.rabbitmq.routing_key", routingKey),
            attribute.Int("messaging.message.payload_size_bytes", len(body)),
        ),
    )
    defer span.End()
    
    // 注入 Trace Context
    headers := make(amqp.Table)
    carrier := &amqpHeaderCarrier{headers: headers}
    p.propagator.Inject(ctx, carrier)
    
    // 发布消息
    err := p.channel.PublishWithContext(
        ctx,
        exchange,
        routingKey,
        false,
        false,
        amqp.Publishing{
            ContentType: "application/json",
            Body:        body,
            Headers:     headers,
        },
    )
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// Close 关闭连接
func (p *TracedRabbitMQProducer) Close() error {
    if err := p.channel.Close(); err != nil {
        return err
    }
    return p.conn.Close()
}

// amqpHeaderCarrier AMQP Header Carrier
type amqpHeaderCarrier struct {
    headers amqp.Table
}

func (c *amqpHeaderCarrier) Get(key string) string {
    if value, ok := c.headers[key]; ok {
        if str, ok := value.(string); ok {
            return str
        }
    }
    return ""
}

func (c *amqpHeaderCarrier) Set(key, value string) {
    c.headers[key] = value
}

func (c *amqpHeaderCarrier) Keys() []string {
    keys := make([]string, 0, len(c.headers))
    for k := range c.headers {
        keys = append(keys, k)
    }
    return keys
}
```

---

## 服务网格集成

### Istio 集成

**Istio + OTLP 配置：**

```yaml
# istio-telemetry.yaml
apiVersion: telemetry.istio.io/v1alpha1
kind: Telemetry
metadata:
  name: otlp-telemetry
  namespace: default
spec:
  tracing:
  - providers:
    - name: otlp-exporter
    randomSamplingPercentage: 10.0
    customTags:
      environment:
        literal:
          value: "production"
      service.version:
        environment:
          name: SERVICE_VERSION
  metrics:
  - providers:
    - name: prometheus
---
apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
metadata:
  name: otlp-config
spec:
  meshConfig:
    extensionProviders:
    - name: otlp-exporter
      opentelemetry:
        service: otel-collector.observability.svc.cluster.local
        port: 4317
    - name: prometheus
      prometheus: {}
    defaultProviders:
      tracing:
      - "otlp-exporter"
      metrics:
      - "prometheus"
```

**Go 应用配置：**

```go
package istio

import (
    "context"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// InitIstioTracing 初始化 Istio 追踪
func InitIstioTracing() {
    // Istio 会自动注入 Envoy Sidecar
    // Envoy 会拦截所有流量并自动传播 Trace Context
    
    // 应用只需要正常使用 OTLP SDK
    tracer := otel.Tracer("my-service")
    
    // Istio 会自动关联 Envoy 生成的 Span
}

// HandleRequest 处理请求
func HandleRequest(ctx context.Context) {
    tracer := otel.Tracer("my-service")
    
    // 创建 Span（会自动继承 Istio 的 Span）
    ctx, span := tracer.Start(ctx, "handle-request")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("service.version", "1.0.0"),
        attribute.String("deployment.environment", "production"),
    )
    
    // 业务逻辑
}
```

### Linkerd 集成

**Linkerd + OTLP 配置：**

```yaml
# linkerd-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: linkerd-config
  namespace: linkerd
data:
  tracing.yaml: |
    tracing:
      enabled: true
      collector:
        endpoint: otel-collector.observability.svc.cluster.local:4317
      samplingRate: 0.1
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
  annotations:
    config.linkerd.io/trace-collector: otel-collector.observability.svc.cluster.local:4317
spec:
  template:
    metadata:
      annotations:
        config.linkerd.io/trace-collector: otel-collector.observability.svc.cluster.local:4317
        config.linkerd.io/trace-collector-svc-account: default
    spec:
      containers:
      - name: app
        image: my-app:latest
```

---

## 分布式事务追踪

### Saga 模式

**Saga 编排器追踪：**

```go
package saga

import (
    "context"
    "fmt"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// SagaOrchestrator Saga 编排器
type SagaOrchestrator struct {
    tracer trace.Tracer
    steps  []SagaStep
}

// SagaStep Saga 步骤
type SagaStep struct {
    Name        string
    Action      func(context.Context) error
    Compensate  func(context.Context) error
}

// NewSagaOrchestrator 创建 Saga 编排器
func NewSagaOrchestrator() *SagaOrchestrator {
    return &SagaOrchestrator{
        tracer: otel.Tracer("saga-orchestrator"),
        steps:  make([]SagaStep, 0),
    }
}

// AddStep 添加步骤
func (s *SagaOrchestrator) AddStep(step SagaStep) {
    s.steps = append(s.steps, step)
}

// Execute 执行 Saga
func (s *SagaOrchestrator) Execute(ctx context.Context) error {
    ctx, span := s.tracer.Start(ctx, "saga.execute",
        trace.WithAttributes(
            attribute.Int("saga.steps", len(s.steps)),
        ),
    )
    defer span.End()
    
    executedSteps := make([]SagaStep, 0)
    
    // 执行所有步骤
    for i, step := range s.steps {
        ctx, stepSpan := s.tracer.Start(ctx, fmt.Sprintf("saga.step.%s", step.Name),
            trace.WithAttributes(
                attribute.String("saga.step.name", step.Name),
                attribute.Int("saga.step.index", i),
            ),
        )
        
        if err := step.Action(ctx); err != nil {
            stepSpan.RecordError(err)
            stepSpan.SetStatus(codes.Error, err.Error())
            stepSpan.End()
            
            // 补偿已执行的步骤
            span.AddEvent("saga.compensating",
                trace.WithAttributes(
                    attribute.String("failed_step", step.Name),
                ),
            )
            
            if compErr := s.compensate(ctx, executedSteps); compErr != nil {
                span.RecordError(compErr)
                span.SetStatus(codes.Error, fmt.Sprintf("compensation failed: %v", compErr))
                return fmt.Errorf("action failed: %w, compensation failed: %v", err, compErr)
            }
            
            span.SetStatus(codes.Error, fmt.Sprintf("action failed, compensated: %v", err))
            return err
        }
        
        stepSpan.SetStatus(codes.Ok, "")
        stepSpan.End()
        
        executedSteps = append(executedSteps, step)
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// compensate 补偿
func (s *SagaOrchestrator) compensate(ctx context.Context, steps []SagaStep) error {
    ctx, span := s.tracer.Start(ctx, "saga.compensate",
        trace.WithAttributes(
            attribute.Int("saga.compensate.steps", len(steps)),
        ),
    )
    defer span.End()
    
    // 逆序执行补偿
    for i := len(steps) - 1; i >= 0; i-- {
        step := steps[i]
        
        ctx, compSpan := s.tracer.Start(ctx, fmt.Sprintf("saga.compensate.%s", step.Name),
            trace.WithAttributes(
                attribute.String("saga.step.name", step.Name),
            ),
        )
        
        if err := step.Compensate(ctx); err != nil {
            compSpan.RecordError(err)
            compSpan.SetStatus(codes.Error, err.Error())
            compSpan.End()
            return err
        }
        
        compSpan.SetStatus(codes.Ok, "")
        compSpan.End()
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}
```

**使用示例：**

```go
// 订单 Saga
saga := NewSagaOrchestrator()

// 1. 创建订单
saga.AddStep(SagaStep{
    Name: "create-order",
    Action: func(ctx context.Context) error {
        return orderService.CreateOrder(ctx, order)
    },
    Compensate: func(ctx context.Context) error {
        return orderService.CancelOrder(ctx, order.ID)
    },
})

// 2. 扣减库存
saga.AddStep(SagaStep{
    Name: "reserve-inventory",
    Action: func(ctx context.Context) error {
        return inventoryService.Reserve(ctx, order.Items)
    },
    Compensate: func(ctx context.Context) error {
        return inventoryService.Release(ctx, order.Items)
    },
})

// 3. 处理支付
saga.AddStep(SagaStep{
    Name: "process-payment",
    Action: func(ctx context.Context) error {
        return paymentService.Charge(ctx, order.TotalAmount)
    },
    Compensate: func(ctx context.Context) error {
        return paymentService.Refund(ctx, order.TotalAmount)
    },
})

// 执行 Saga
if err := saga.Execute(ctx); err != nil {
    log.Fatal(err)
}
```

### 两阶段提交

**2PC 协调器追踪：**

```go
package twopc

import (
    "context"
    "sync"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// TwoPCCoordinator 2PC 协调器
type TwoPCCoordinator struct {
    tracer       trace.Tracer
    participants []Participant
}

// Participant 参与者
type Participant interface {
    Prepare(context.Context) error
    Commit(context.Context) error
    Rollback(context.Context) error
}

// NewTwoPCCoordinator 创建 2PC 协调器
func NewTwoPCCoordinator() *TwoPCCoordinator {
    return &TwoPCCoordinator{
        tracer:       otel.Tracer("2pc-coordinator"),
        participants: make([]Participant, 0),
    }
}

// AddParticipant 添加参与者
func (c *TwoPCCoordinator) AddParticipant(p Participant) {
    c.participants = append(c.participants, p)
}

// Execute 执行 2PC
func (c *TwoPCCoordinator) Execute(ctx context.Context) error {
    ctx, span := c.tracer.Start(ctx, "2pc.execute",
        trace.WithAttributes(
            attribute.Int("2pc.participants", len(c.participants)),
        ),
    )
    defer span.End()
    
    // Phase 1: Prepare
    if err := c.prepare(ctx); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        
        // Rollback
        c.rollback(ctx)
        return err
    }
    
    // Phase 2: Commit
    if err := c.commit(ctx); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// prepare Prepare 阶段
func (c *TwoPCCoordinator) prepare(ctx context.Context) error {
    ctx, span := c.tracer.Start(ctx, "2pc.prepare")
    defer span.End()
    
    var wg sync.WaitGroup
    errCh := make(chan error, len(c.participants))
    
    for i, p := range c.participants {
        wg.Add(1)
        go func(index int, participant Participant) {
            defer wg.Done()
            
            ctx, pSpan := c.tracer.Start(ctx, "2pc.prepare.participant",
                trace.WithAttributes(
                    attribute.Int("participant.index", index),
                ),
            )
            defer pSpan.End()
            
            if err := participant.Prepare(ctx); err != nil {
                pSpan.RecordError(err)
                pSpan.SetStatus(codes.Error, err.Error())
                errCh <- err
                return
            }
            
            pSpan.SetStatus(codes.Ok, "")
        }(i, p)
    }
    
    wg.Wait()
    close(errCh)
    
    for err := range errCh {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// commit Commit 阶段
func (c *TwoPCCoordinator) commit(ctx context.Context) error {
    ctx, span := c.tracer.Start(ctx, "2pc.commit")
    defer span.End()
    
    var wg sync.WaitGroup
    errCh := make(chan error, len(c.participants))
    
    for i, p := range c.participants {
        wg.Add(1)
        go func(index int, participant Participant) {
            defer wg.Done()
            
            ctx, pSpan := c.tracer.Start(ctx, "2pc.commit.participant",
                trace.WithAttributes(
                    attribute.Int("participant.index", index),
                ),
            )
            defer pSpan.End()
            
            if err := participant.Commit(ctx); err != nil {
                pSpan.RecordError(err)
                pSpan.SetStatus(codes.Error, err.Error())
                errCh <- err
                return
            }
            
            pSpan.SetStatus(codes.Ok, "")
        }(i, p)
    }
    
    wg.Wait()
    close(errCh)
    
    for err := range errCh {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// rollback Rollback 阶段
func (c *TwoPCCoordinator) rollback(ctx context.Context) {
    ctx, span := c.tracer.Start(ctx, "2pc.rollback")
    defer span.End()
    
    var wg sync.WaitGroup
    
    for i, p := range c.participants {
        wg.Add(1)
        go func(index int, participant Participant) {
            defer wg.Done()
            
            ctx, pSpan := c.tracer.Start(ctx, "2pc.rollback.participant",
                trace.WithAttributes(
                    attribute.Int("participant.index", index),
                ),
            )
            defer pSpan.End()
            
            if err := participant.Rollback(ctx); err != nil {
                pSpan.RecordError(err)
                pSpan.SetStatus(codes.Error, err.Error())
                return
            }
            
            pSpan.SetStatus(codes.Ok, "")
        }(i, p)
    }
    
    wg.Wait()
}
```

---

## 最佳实践

### 1. Context 传播

✅ **始终传播 Context**

```go
// ✅ Good
func processRequest(ctx context.Context) error {
    ctx, span := tracer.Start(ctx, "process")
    defer span.End()
    
    return callDownstream(ctx)
}

// ❌ Bad
func processRequest(ctx context.Context) error {
    ctx, span := tracer.Start(ctx, "process")
    defer span.End()
    
    return callDownstream(context.Background()) // 丢失了追踪上下文
}
```

### 2. Span 命名

✅ **使用有意义的名称**

```go
// ✅ Good
tracer.Start(ctx, "POST /api/users")
tracer.Start(ctx, "query-user-by-id")
tracer.Start(ctx, "kafka.produce.orders")

// ❌ Bad
tracer.Start(ctx, "function1")
tracer.Start(ctx, "process")
```

### 3. 错误处理

✅ **记录错误和状态**

```go
// ✅ Good
if err != nil {
    span.RecordError(err)
    span.SetStatus(codes.Error, err.Error())
    return err
}
span.SetStatus(codes.Ok, "")

// ❌ Bad
if err != nil {
    return err // 没有记录错误
}
```

### 4. 属性设置

✅ **添加有用的属性**

```go
// ✅ Good
span.SetAttributes(
    attribute.String("user.id", userID),
    attribute.String("http.method", "GET"),
    attribute.Int("http.status_code", 200),
    attribute.Int64("db.rows_affected", rowsAffected),
)

// ❌ Bad
span.SetAttributes(
    attribute.String("data", "some data"), // 太模糊
)
```

### 5. Metric 命名

✅ **遵循命名约定**

```go
// ✅ Good
"http.server.requests"          // 计数器
"http.server.duration"          // 直方图
"http.server.active_requests"   // UpDownCounter

// ❌ Bad
"requests"          // 太模糊
"httpDuration"      // 不符合约定
"activeReq"         // 缩写不清晰
```

---

## 完整示例

### 微服务通信完整示例

```go
package main

import (
    "context"
    "log"
    "net/http"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/sdk/trace"
)

func main() {
    ctx := context.Background()
    
    // 1. 初始化 OTLP
    tp, err := initTracing(ctx)
    if err != nil {
        log.Fatal(err)
    }
    defer tp.Shutdown(ctx)
    
    // 2. 设置传播器
    otel.SetTextMapPropagator(
        propagation.NewCompositeTextMapPropagator(
            propagation.TraceContext{},
            propagation.Baggage{},
        ),
    )
    
    // 3. 创建 HTTP Client
    client, err := NewTracedHTTPClient(10 * time.Second)
    if err != nil {
        log.Fatal(err)
    }
    
    // 4. 创建服务
    userService := NewUserService(client)
    
    // 5. 创建 HTTP Server
    mux := http.NewServeMux()
    
    mux.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
        ctx := r.Context()
        
        // 处理请求
        user, err := userService.GetUser(ctx, r.URL.Query().Get("id"))
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        
        json.NewEncoder(w).Encode(user)
    })
    
    server, err := NewTracedHTTPServer(":8080", mux)
    if err != nil {
        log.Fatal(err)
    }
    
    log.Println("Server started on :8080")
    if err := server.Start(); err != nil {
        log.Fatal(err)
    }
}

func initTracing(ctx context.Context) (*trace.TracerProvider, error) {
    exporter, err := otlptracegrpc.New(ctx,
        otlptracegrpc.WithEndpoint("localhost:4317"),
        otlptracegrpc.WithInsecure(),
    )
    if err != nil {
        return nil, err
    }
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
    )
    
    otel.SetTracerProvider(tp)
    return tp, nil
}
```

---

## 总结

本文档详细介绍了 Go 微服务间通信的分布式追踪实现，涵盖：

✅ **分布式追踪基础** - W3C Trace Context、Baggage、Span Context  
✅ **HTTP 通信追踪** - Client、Server、RESTful API  
✅ **gRPC 通信追踪** - Client、Server、双向流  
✅ **消息队列追踪** - Kafka、NATS、RabbitMQ  
✅ **服务网格集成** - Istio、Linkerd  
✅ **分布式事务追踪** - Saga、2PC  
✅ **最佳实践** - Context、Span、Error、Metric  

### 关键要点

1. **Context 传播是核心** - 确保所有服务间调用都传播 Context
2. **使用标准协议** - W3C Trace Context 保证互操作性
3. **完整的错误处理** - 记录错误和 Span 状态
4. **有意义的命名** - Span 和 Metric 名称要清晰
5. **服务网格增强** - 结合 Istio/Linkerd 获得更好的可观测性

### 相关文档

- [31_Go高级并发模式与OTLP完整集成](./31_Go高级并发模式与OTLP完整集成.md)
- [32_Go函数式编程与OTLP集成](./32_Go函数式编程与OTLP集成.md)
- [33_Go高级错误处理模式与Context传播](./33_Go高级错误处理模式与Context传播.md)
- [09_Go主流框架深度集成指南](./09_Go主流框架深度集成指南.md)

---

**最后更新：** 2025-10-09  
**版本：** v1.0.0  
**作者：** OTLP Go Integration Team
