# Go å¾®æœåŠ¡é—´é€šä¿¡ä¸åˆ†å¸ƒå¼è¿½è¸ªå®Œæ•´æŒ‡å—

## ğŸ“‹ ç›®å½•

- [Go å¾®æœåŠ¡é—´é€šä¿¡ä¸åˆ†å¸ƒå¼è¿½è¸ªå®Œæ•´æŒ‡å—](#go-å¾®æœåŠ¡é—´é€šä¿¡ä¸åˆ†å¸ƒå¼è¿½è¸ªå®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ–‡æ¡£æ¦‚è¿°](#æ–‡æ¡£æ¦‚è¿°)
    - [æ ¸å¿ƒä»·å€¼](#æ ¸å¿ƒä»·å€¼)
    - [ä¾èµ–ç‰ˆæœ¬](#ä¾èµ–ç‰ˆæœ¬)
  - [åˆ†å¸ƒå¼è¿½è¸ªåŸºç¡€](#åˆ†å¸ƒå¼è¿½è¸ªåŸºç¡€)
    - [W3C Trace Context](#w3c-trace-context)
    - [Baggage ä¼ æ’­](#baggage-ä¼ æ’­)
    - [Span Context ä¼ æ’­](#span-context-ä¼ æ’­)
  - [HTTP é€šä¿¡è¿½è¸ª](#http-é€šä¿¡è¿½è¸ª)
    - [HTTP Client è¿½è¸ª](#http-client-è¿½è¸ª)
    - [HTTP Server è¿½è¸ª](#http-server-è¿½è¸ª)
    - [RESTful API è¿½è¸ª](#restful-api-è¿½è¸ª)
  - [gRPC é€šä¿¡è¿½è¸ª](#grpc-é€šä¿¡è¿½è¸ª)
    - [gRPC Client è¿½è¸ª](#grpc-client-è¿½è¸ª)
    - [gRPC Server è¿½è¸ª](#grpc-server-è¿½è¸ª)
    - [åŒå‘æµè¿½è¸ª](#åŒå‘æµè¿½è¸ª)
  - [æ¶ˆæ¯é˜Ÿåˆ—è¿½è¸ª](#æ¶ˆæ¯é˜Ÿåˆ—è¿½è¸ª)
    - [Kafka è¿½è¸ª](#kafka-è¿½è¸ª)
    - [NATS è¿½è¸ª](#nats-è¿½è¸ª)
    - [RabbitMQ è¿½è¸ª](#rabbitmq-è¿½è¸ª)
  - [æœåŠ¡ç½‘æ ¼é›†æˆ](#æœåŠ¡ç½‘æ ¼é›†æˆ)
    - [Istio é›†æˆ](#istio-é›†æˆ)
    - [Linkerd é›†æˆ](#linkerd-é›†æˆ)
  - [åˆ†å¸ƒå¼äº‹åŠ¡è¿½è¸ª](#åˆ†å¸ƒå¼äº‹åŠ¡è¿½è¸ª)
    - [Saga æ¨¡å¼](#saga-æ¨¡å¼)
    - [ä¸¤é˜¶æ®µæäº¤](#ä¸¤é˜¶æ®µæäº¤)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [1. Context ä¼ æ’­](#1-context-ä¼ æ’­)
    - [2. Span å‘½å](#2-span-å‘½å)
    - [3. é”™è¯¯å¤„ç†](#3-é”™è¯¯å¤„ç†)
    - [4. å±æ€§è®¾ç½®](#4-å±æ€§è®¾ç½®)
    - [5. Metric å‘½å](#5-metric-å‘½å)
  - [å®Œæ•´ç¤ºä¾‹](#å®Œæ•´ç¤ºä¾‹)
    - [å¾®æœåŠ¡é€šä¿¡å®Œæ•´ç¤ºä¾‹](#å¾®æœåŠ¡é€šä¿¡å®Œæ•´ç¤ºä¾‹)
  - [æ€»ç»“](#æ€»ç»“)
    - [å…³é”®è¦ç‚¹](#å…³é”®è¦ç‚¹)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)

---

## æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç» Go å¾®æœåŠ¡é—´é€šä¿¡çš„åˆ†å¸ƒå¼è¿½è¸ªå®ç°ï¼Œæ¶µç›– HTTPã€gRPCã€æ¶ˆæ¯é˜Ÿåˆ—ç­‰å¤šç§é€šä¿¡æ–¹å¼ã€‚

### æ ¸å¿ƒä»·å€¼

âœ… **å®Œæ•´çš„è¿½è¸ªé“¾è·¯** - è·¨æœåŠ¡è¿½è¸ªè¯·æ±‚å…¨ç”Ÿå‘½å‘¨æœŸ  
âœ… **å¤šåè®®æ”¯æŒ** - HTTPã€gRPCã€Kafkaã€NATS  
âœ… **Context ä¼ æ’­** - W3C Trace Context æ ‡å‡†  
âœ… **æœåŠ¡ç½‘æ ¼é›†æˆ** - Istioã€Linkerd  
âœ… **åˆ†å¸ƒå¼äº‹åŠ¡** - Sagaã€2PC æ¨¡å¼

### ä¾èµ–ç‰ˆæœ¬

```go
go.opentelemetry.io/otel v1.32.0
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.57.0
go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.57.0
github.com/IBM/sarama v1.43.3
github.com/nats-io/nats.go v1.37.0
google.golang.org/grpc v1.69.2
```

---

## åˆ†å¸ƒå¼è¿½è¸ªåŸºç¡€

### W3C Trace Context

**æ ‡å‡†å¤´éƒ¨ï¼š**

```go
package tracing

import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/propagation"
)

// InitPropagators åˆå§‹åŒ–ä¼ æ’­å™¨
func InitPropagators() {
    // W3C Trace Context (traceparent, tracestate)
    tc := propagation.TraceContext{}
    
    // W3C Baggage
    baggage := propagation.Baggage{}
    
    // ç»„åˆä¼ æ’­å™¨
    otel.SetTextMapPropagator(
        propagation.NewCompositeTextMapPropagator(
            tc,
            baggage,
        ),
    )
}

// traceparent æ ¼å¼: 00-<trace-id>-<span-id>-<flags>
// ç¤ºä¾‹: 00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01
```

**æ‰‹åŠ¨æ³¨å…¥å’Œæå–ï¼š**

```go
package tracing

import (
    "context"
    "net/http"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/propagation"
)

// InjectContext æ³¨å…¥ Context åˆ° HTTP Headers
func InjectContext(ctx context.Context, headers http.Header) {
    propagator := otel.GetTextMapPropagator()
    propagator.Inject(ctx, propagation.HeaderCarrier(headers))
}

// ExtractContext ä» HTTP Headers æå– Context
func ExtractContext(ctx context.Context, headers http.Header) context.Context {
    propagator := otel.GetTextMapPropagator()
    return propagator.Extract(ctx, propagation.HeaderCarrier(headers))
}

// InjectToMap æ³¨å…¥åˆ° Mapï¼ˆç”¨äºæ¶ˆæ¯é˜Ÿåˆ—ï¼‰
func InjectToMap(ctx context.Context) map[string]string {
    carrier := make(propagation.MapCarrier)
    propagator := otel.GetTextMapPropagator()
    propagator.Inject(ctx, carrier)
    
    result := make(map[string]string)
    for k, v := range carrier {
        result[k] = v
    }
    return result
}

// ExtractFromMap ä» Map æå–ï¼ˆç”¨äºæ¶ˆæ¯é˜Ÿåˆ—ï¼‰
func ExtractFromMap(ctx context.Context, headers map[string]string) context.Context {
    carrier := propagation.MapCarrier(headers)
    propagator := otel.GetTextMapPropagator()
    return propagator.Extract(ctx, carrier)
}
```

### Baggage ä¼ æ’­

**Baggage ä½¿ç”¨ï¼š**

```go
package tracing

import (
    "context"
    
    "go.opentelemetry.io/otel/baggage"
)

// SetBaggage è®¾ç½® Baggage
func SetBaggage(ctx context.Context, key, value string) (context.Context, error) {
    member, err := baggage.NewMember(key, value)
    if err != nil {
        return ctx, err
    }
    
    bag, err := baggage.FromContext(ctx).SetMember(member)
    if err != nil {
        return ctx, err
    }
    
    return baggage.ContextWithBaggage(ctx, bag), nil
}

// GetBaggage è·å– Baggage
func GetBaggage(ctx context.Context, key string) string {
    bag := baggage.FromContext(ctx)
    member := bag.Member(key)
    return member.Value()
}

// SetMultipleBaggage è®¾ç½®å¤šä¸ª Baggage
func SetMultipleBaggage(ctx context.Context, values map[string]string) (context.Context, error) {
    var members []baggage.Member
    
    for k, v := range values {
        member, err := baggage.NewMember(k, v)
        if err != nil {
            return ctx, err
        }
        members = append(members, member)
    }
    
    bag, err := baggage.New(members...)
    if err != nil {
        return ctx, err
    }
    
    return baggage.ContextWithBaggage(ctx, bag), nil
}
```

**å®é™…åº”ç”¨ï¼š**

```go
// åœ¨æœåŠ¡ A ä¸­è®¾ç½®
ctx, _ = SetBaggage(ctx, "user.id", "12345")
ctx, _ = SetBaggage(ctx, "tenant.id", "acme")

// åœ¨æœåŠ¡ B ä¸­è·å–
userID := GetBaggage(ctx, "user.id")      // "12345"
tenantID := GetBaggage(ctx, "tenant.id")  // "acme"
```

### Span Context ä¼ æ’­

**è·¨æœåŠ¡ Span é“¾æ¥ï¼š**

```go
package tracing

import (
    "context"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

// CreateLinkedSpan åˆ›å»ºé“¾æ¥çš„ Span
func CreateLinkedSpan(ctx context.Context, name string, linkedCtx context.Context) (context.Context, trace.Span) {
    tracer := otel.Tracer("service")
    
    // ä»å¦ä¸€ä¸ª Context è·å– SpanContext
    linkedSpanContext := trace.SpanContextFromContext(linkedCtx)
    
    // åˆ›å»ºé“¾æ¥
    link := trace.Link{
        SpanContext: linkedSpanContext,
    }
    
    // åˆ›å»ºå¸¦é“¾æ¥çš„ Span
    return tracer.Start(ctx, name,
        trace.WithLinks(link),
    )
}

// CreateChildSpan åˆ›å»ºå­ Span
func CreateChildSpan(ctx context.Context, name string) (context.Context, trace.Span) {
    tracer := otel.Tracer("service")
    return tracer.Start(ctx, name)
}

// CreateFollowsFromSpan åˆ›å»º FollowsFrom Span
func CreateFollowsFromSpan(ctx context.Context, name string, parentCtx context.Context) (context.Context, trace.Span) {
    tracer := otel.Tracer("service")
    
    parentSpanContext := trace.SpanContextFromContext(parentCtx)
    
    link := trace.Link{
        SpanContext: parentSpanContext,
        // FollowsFrom å…³ç³»
    }
    
    return tracer.Start(ctx, name,
        trace.WithLinks(link),
    )
}
```

---

## HTTP é€šä¿¡è¿½è¸ª

### HTTP Client è¿½è¸ª

**åŸºç¡€ HTTP Clientï¼š**

```go
package httpclient

import (
    "context"
    "net/http"
    "time"
    
    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
)

// TracedHTTPClient å¸¦è¿½è¸ªçš„ HTTP Client
type TracedHTTPClient struct {
    client  *http.Client
    tracer  trace.Tracer
    meter   metric.Meter
    
    // Metrics
    requestCounter  metric.Int64Counter
    requestDuration metric.Float64Histogram
    requestSize     metric.Int64Histogram
    responseSize    metric.Int64Histogram
}

// NewTracedHTTPClient åˆ›å»ºå¸¦è¿½è¸ªçš„ HTTP Client
func NewTracedHTTPClient(timeout time.Duration) (*TracedHTTPClient, error) {
    tracer := otel.Tracer("http-client")
    meter := otel.Meter("http-client")
    
    tc := &TracedHTTPClient{
        client: &http.Client{
            Timeout: timeout,
            Transport: otelhttp.NewTransport(
                http.DefaultTransport,
                otelhttp.WithSpanNameFormatter(func(operation string, r *http.Request) string {
                    return operation + " " + r.Method + " " + r.URL.Path
                }),
            ),
        },
        tracer: tracer,
        meter:  meter,
    }
    
    var err error
    
    // è¯·æ±‚è®¡æ•°å™¨
    tc.requestCounter, err = meter.Int64Counter(
        "http.client.requests",
        metric.WithDescription("HTTP client requests"),
    )
    if err != nil {
        return nil, err
    }
    
    // è¯·æ±‚æŒç»­æ—¶é—´
    tc.requestDuration, err = meter.Float64Histogram(
        "http.client.duration",
        metric.WithDescription("HTTP client request duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    // è¯·æ±‚å¤§å°
    tc.requestSize, err = meter.Int64Histogram(
        "http.client.request.size",
        metric.WithDescription("HTTP client request size"),
        metric.WithUnit("bytes"),
    )
    if err != nil {
        return nil, err
    }
    
    // å“åº”å¤§å°
    tc.responseSize, err = meter.Int64Histogram(
        "http.client.response.size",
        metric.WithDescription("HTTP client response size"),
        metric.WithUnit("bytes"),
    )
    if err != nil {
        return nil, err
    }
    
    return tc, nil
}

// Do æ‰§è¡Œ HTTP è¯·æ±‚
func (tc *TracedHTTPClient) Do(ctx context.Context, req *http.Request) (*http.Response, error) {
    ctx, span := tc.tracer.Start(ctx, "http.client.request",
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            attribute.String("http.method", req.Method),
            attribute.String("http.url", req.URL.String()),
            attribute.String("http.target", req.URL.Path),
            attribute.String("http.host", req.Host),
        ),
    )
    defer span.End()
    
    start := time.Now()
    
    // æ·»åŠ  Context
    req = req.WithContext(ctx)
    
    // è®°å½•è¯·æ±‚å¤§å°
    if req.Body != nil && req.ContentLength > 0 {
        tc.requestSize.Record(ctx, req.ContentLength,
            metric.WithAttributes(
                attribute.String("http.method", req.Method),
            ),
        )
        span.SetAttributes(attribute.Int64("http.request.content_length", req.ContentLength))
    }
    
    // æ‰§è¡Œè¯·æ±‚
    resp, err := tc.client.Do(req)
    
    duration := time.Since(start)
    
    // è®°å½• Metrics
    attrs := []attribute.KeyValue{
        attribute.String("http.method", req.Method),
        attribute.String("http.target", req.URL.Path),
    }
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        
        attrs = append(attrs, attribute.String("error", "true"))
        tc.requestCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
        
        return nil, err
    }
    
    // è®°å½•å“åº”ä¿¡æ¯
    span.SetAttributes(
        attribute.Int("http.status_code", resp.StatusCode),
        attribute.Int64("http.response.content_length", resp.ContentLength),
    )
    
    attrs = append(attrs,
        attribute.Int("http.status_code", resp.StatusCode),
        attribute.String("error", "false"),
    )
    
    tc.requestCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
    tc.requestDuration.Record(ctx, float64(duration.Milliseconds()), metric.WithAttributes(attrs...))
    
    if resp.ContentLength > 0 {
        tc.responseSize.Record(ctx, resp.ContentLength, metric.WithAttributes(attrs...))
    }
    
    // è®¾ç½®çŠ¶æ€
    if resp.StatusCode >= 400 {
        span.SetStatus(codes.Error, http.StatusText(resp.StatusCode))
    } else {
        span.SetStatus(codes.Ok, "")
    }
    
    return resp, nil
}

// Get æ‰§è¡Œ GET è¯·æ±‚
func (tc *TracedHTTPClient) Get(ctx context.Context, url string) (*http.Response, error) {
    req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
    if err != nil {
        return nil, err
    }
    return tc.Do(ctx, req)
}

// Post æ‰§è¡Œ POST è¯·æ±‚
func (tc *TracedHTTPClient) Post(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error) {
    req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, body)
    if err != nil {
        return nil, err
    }
    req.Header.Set("Content-Type", contentType)
    return tc.Do(ctx, req)
}
```

### HTTP Server è¿½è¸ª

**å¸¦è¿½è¸ªçš„ HTTP Serverï¼š**

```go
package httpserver

import (
    "context"
    "net/http"
    "time"
    
    "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
)

// TracedHTTPServer å¸¦è¿½è¸ªçš„ HTTP Server
type TracedHTTPServer struct {
    server *http.Server
    tracer trace.Tracer
    meter  metric.Meter
    
    // Metrics
    requestCounter    metric.Int64Counter
    requestDuration   metric.Float64Histogram
    activeRequests    metric.Int64UpDownCounter
    requestSize       metric.Int64Histogram
    responseSize      metric.Int64Histogram
}

// NewTracedHTTPServer åˆ›å»ºå¸¦è¿½è¸ªçš„ HTTP Server
func NewTracedHTTPServer(addr string, handler http.Handler) (*TracedHTTPServer, error) {
    tracer := otel.Tracer("http-server")
    meter := otel.Meter("http-server")
    
    ts := &TracedHTTPServer{
        tracer: tracer,
        meter:  meter,
    }
    
    var err error
    
    // è¯·æ±‚è®¡æ•°å™¨
    ts.requestCounter, err = meter.Int64Counter(
        "http.server.requests",
        metric.WithDescription("HTTP server requests"),
    )
    if err != nil {
        return nil, err
    }
    
    // è¯·æ±‚æŒç»­æ—¶é—´
    ts.requestDuration, err = meter.Float64Histogram(
        "http.server.duration",
        metric.WithDescription("HTTP server request duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    // æ´»è·ƒè¯·æ±‚æ•°
    ts.activeRequests, err = meter.Int64UpDownCounter(
        "http.server.active_requests",
        metric.WithDescription("Active HTTP requests"),
    )
    if err != nil {
        return nil, err
    }
    
    // è¯·æ±‚å¤§å°
    ts.requestSize, err = meter.Int64Histogram(
        "http.server.request.size",
        metric.WithDescription("HTTP server request size"),
        metric.WithUnit("bytes"),
    )
    if err != nil {
        return nil, err
    }
    
    // å“åº”å¤§å°
    ts.responseSize, err = meter.Int64Histogram(
        "http.server.response.size",
        metric.WithDescription("HTTP server response size"),
        metric.WithUnit("bytes"),
    )
    if err != nil {
        return nil, err
    }
    
    // åŒ…è£… Handler
    wrappedHandler := otelhttp.NewHandler(
        ts.wrapHandler(handler),
        "http-server",
        otelhttp.WithSpanNameFormatter(func(operation string, r *http.Request) string {
            return r.Method + " " + r.URL.Path
        }),
    )
    
    ts.server = &http.Server{
        Addr:    addr,
        Handler: wrappedHandler,
    }
    
    return ts, nil
}

// wrapHandler åŒ…è£… Handler æ·»åŠ  Metrics
func (ts *TracedHTTPServer) wrapHandler(handler http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        ctx := r.Context()
        start := time.Now()
        
        // å¢åŠ æ´»è·ƒè¯·æ±‚æ•°
        ts.activeRequests.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("http.method", r.Method),
                attribute.String("http.route", r.URL.Path),
            ),
        )
        defer ts.activeRequests.Add(ctx, -1,
            metric.WithAttributes(
                attribute.String("http.method", r.Method),
                attribute.String("http.route", r.URL.Path),
            ),
        )
        
        // è®°å½•è¯·æ±‚å¤§å°
        if r.ContentLength > 0 {
            ts.requestSize.Record(ctx, r.ContentLength,
                metric.WithAttributes(
                    attribute.String("http.method", r.Method),
                ),
            )
        }
        
        // åŒ…è£… ResponseWriter
        rw := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
        
        // è°ƒç”¨åŸå§‹ Handler
        handler.ServeHTTP(rw, r)
        
        duration := time.Since(start)
        
        // è®°å½• Metrics
        attrs := []attribute.KeyValue{
            attribute.String("http.method", r.Method),
            attribute.String("http.route", r.URL.Path),
            attribute.Int("http.status_code", rw.statusCode),
        }
        
        ts.requestCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
        ts.requestDuration.Record(ctx, float64(duration.Milliseconds()), metric.WithAttributes(attrs...))
        
        if rw.bytesWritten > 0 {
            ts.responseSize.Record(ctx, int64(rw.bytesWritten), metric.WithAttributes(attrs...))
        }
    })
}

// responseWriter åŒ…è£… ResponseWriter
type responseWriter struct {
    http.ResponseWriter
    statusCode   int
    bytesWritten int
}

func (rw *responseWriter) WriteHeader(statusCode int) {
    rw.statusCode = statusCode
    rw.ResponseWriter.WriteHeader(statusCode)
}

func (rw *responseWriter) Write(b []byte) (int, error) {
    n, err := rw.ResponseWriter.Write(b)
    rw.bytesWritten += n
    return n, err
}

// Start å¯åŠ¨æœåŠ¡å™¨
func (ts *TracedHTTPServer) Start() error {
    return ts.server.ListenAndServe()
}

// Shutdown ä¼˜é›…å…³é—­
func (ts *TracedHTTPServer) Shutdown(ctx context.Context) error {
    return ts.server.Shutdown(ctx)
}
```

### RESTful API è¿½è¸ª

**å®Œæ•´çš„ REST API ç¤ºä¾‹ï¼š**

```go
package api

import (
    "context"
    "encoding/json"
    "net/http"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// UserService ç”¨æˆ·æœåŠ¡
type UserService struct {
    tracer trace.Tracer
    client *TracedHTTPClient
}

// NewUserService åˆ›å»ºç”¨æˆ·æœåŠ¡
func NewUserService(client *TracedHTTPClient) *UserService {
    return &UserService{
        tracer: otel.Tracer("user-service"),
        client: client,
    }
}

// GetUser è·å–ç”¨æˆ·
func (s *UserService) GetUser(ctx context.Context, userID string) (*User, error) {
    ctx, span := s.tracer.Start(ctx, "get-user",
        trace.WithAttributes(
            attribute.String("user.id", userID),
        ),
    )
    defer span.End()
    
    // è°ƒç”¨ä¸‹æ¸¸æœåŠ¡
    url := fmt.Sprintf("http://user-service/api/users/%s", userID)
    resp, err := s.client.Get(ctx, url)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return nil, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        err := fmt.Errorf("unexpected status: %d", resp.StatusCode)
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return nil, err
    }
    
    var user User
    if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return nil, err
    }
    
    span.SetAttributes(
        attribute.String("user.name", user.Name),
        attribute.String("user.email", user.Email),
    )
    span.SetStatus(codes.Ok, "")
    
    return &user, nil
}

// CreateUser åˆ›å»ºç”¨æˆ·
func (s *UserService) CreateUser(ctx context.Context, user *User) error {
    ctx, span := s.tracer.Start(ctx, "create-user",
        trace.WithAttributes(
            attribute.String("user.name", user.Name),
            attribute.String("user.email", user.Email),
        ),
    )
    defer span.End()
    
    // åºåˆ—åŒ–
    data, err := json.Marshal(user)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    // è°ƒç”¨ä¸‹æ¸¸æœåŠ¡
    url := "http://user-service/api/users"
    resp, err := s.client.Post(ctx, url, "application/json", bytes.NewReader(data))
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusCreated {
        err := fmt.Errorf("unexpected status: %d", resp.StatusCode)
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// User ç”¨æˆ·æ¨¡å‹
type User struct {
    ID    string `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}
```

---

## gRPC é€šä¿¡è¿½è¸ª

### gRPC Client è¿½è¸ª

**å¸¦è¿½è¸ªçš„ gRPC Clientï¼š**

```go
package grpcclient

import (
    "context"
    "time"
    
    "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
)

// TracedGRPCClient å¸¦è¿½è¸ªçš„ gRPC Client
type TracedGRPCClient struct {
    conn   *grpc.ClientConn
    tracer trace.Tracer
    meter  metric.Meter
    
    // Metrics
    requestCounter  metric.Int64Counter
    requestDuration metric.Float64Histogram
}

// NewTracedGRPCClient åˆ›å»ºå¸¦è¿½è¸ªçš„ gRPC Client
func NewTracedGRPCClient(target string) (*TracedGRPCClient, error) {
    tracer := otel.Tracer("grpc-client")
    meter := otel.Meter("grpc-client")
    
    // åˆ›å»ºè¿æ¥
    conn, err := grpc.NewClient(
        target,
        grpc.WithTransportCredentials(insecure.NewCredentials()),
        grpc.WithStatsHandler(otelgrpc.NewClientHandler()),
    )
    if err != nil {
        return nil, err
    }
    
    tc := &TracedGRPCClient{
        conn:   conn,
        tracer: tracer,
        meter:  meter,
    }
    
    // è¯·æ±‚è®¡æ•°å™¨
    tc.requestCounter, err = meter.Int64Counter(
        "grpc.client.requests",
        metric.WithDescription("gRPC client requests"),
    )
    if err != nil {
        return nil, err
    }
    
    // è¯·æ±‚æŒç»­æ—¶é—´
    tc.requestDuration, err = meter.Float64Histogram(
        "grpc.client.duration",
        metric.WithDescription("gRPC client request duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    return tc, nil
}

// Invoke è°ƒç”¨ä¸€å…ƒ RPC
func (tc *TracedGRPCClient) Invoke(ctx context.Context, method string, args, reply interface{}) error {
    ctx, span := tc.tracer.Start(ctx, method,
        trace.WithSpanKind(trace.SpanKindClient),
        trace.WithAttributes(
            attribute.String("rpc.system", "grpc"),
            attribute.String("rpc.service", extractService(method)),
            attribute.String("rpc.method", extractMethod(method)),
        ),
    )
    defer span.End()
    
    start := time.Now()
    
    err := tc.conn.Invoke(ctx, method, args, reply)
    
    duration := time.Since(start)
    
    // è®°å½• Metrics
    attrs := []attribute.KeyValue{
        attribute.String("rpc.method", method),
    }
    
    if err != nil {
        attrs = append(attrs, attribute.String("error", "true"))
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
    } else {
        attrs = append(attrs, attribute.String("error", "false"))
        span.SetStatus(codes.Ok, "")
    }
    
    tc.requestCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
    tc.requestDuration.Record(ctx, float64(duration.Milliseconds()), metric.WithAttributes(attrs...))
    
    return err
}

// Conn è·å–è¿æ¥
func (tc *TracedGRPCClient) Conn() *grpc.ClientConn {
    return tc.conn
}

// Close å…³é—­è¿æ¥
func (tc *TracedGRPCClient) Close() error {
    return tc.conn.Close()
}

// extractService æå–æœåŠ¡å
func extractService(method string) string {
    // æ ¼å¼: /package.Service/Method
    parts := strings.Split(method, "/")
    if len(parts) >= 2 {
        return parts[1]
    }
    return "unknown"
}

// extractMethod æå–æ–¹æ³•å
func extractMethod(method string) string {
    parts := strings.Split(method, "/")
    if len(parts) >= 3 {
        return parts[2]
    }
    return "unknown"
}
```

### gRPC Server è¿½è¸ª

**å¸¦è¿½è¸ªçš„ gRPC Serverï¼š**

```go
package grpcserver

import (
    "context"
    "net"
    
    "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
    "google.golang.org/grpc"
)

// TracedGRPCServer å¸¦è¿½è¸ªçš„ gRPC Server
type TracedGRPCServer struct {
    server *grpc.Server
    tracer trace.Tracer
    meter  metric.Meter
    
    // Metrics
    requestCounter  metric.Int64Counter
    requestDuration metric.Float64Histogram
    activeRequests  metric.Int64UpDownCounter
}

// NewTracedGRPCServer åˆ›å»ºå¸¦è¿½è¸ªçš„ gRPC Server
func NewTracedGRPCServer() (*TracedGRPCServer, error) {
    tracer := otel.Tracer("grpc-server")
    meter := otel.Meter("grpc-server")
    
    ts := &TracedGRPCServer{
        tracer: tracer,
        meter:  meter,
    }
    
    var err error
    
    // è¯·æ±‚è®¡æ•°å™¨
    ts.requestCounter, err = meter.Int64Counter(
        "grpc.server.requests",
        metric.WithDescription("gRPC server requests"),
    )
    if err != nil {
        return nil, err
    }
    
    // è¯·æ±‚æŒç»­æ—¶é—´
    ts.requestDuration, err = meter.Float64Histogram(
        "grpc.server.duration",
        metric.WithDescription("gRPC server request duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    // æ´»è·ƒè¯·æ±‚æ•°
    ts.activeRequests, err = meter.Int64UpDownCounter(
        "grpc.server.active_requests",
        metric.WithDescription("Active gRPC requests"),
    )
    if err != nil {
        return nil, err
    }
    
    // åˆ›å»º gRPC Server
    ts.server = grpc.NewServer(
        grpc.StatsHandler(otelgrpc.NewServerHandler()),
        grpc.UnaryInterceptor(ts.unaryInterceptor()),
        grpc.StreamInterceptor(ts.streamInterceptor()),
    )
    
    return ts, nil
}

// unaryInterceptor ä¸€å…ƒæ‹¦æˆªå™¨
func (ts *TracedGRPCServer) unaryInterceptor() grpc.UnaryServerInterceptor {
    return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
        start := time.Now()
        
        // å¢åŠ æ´»è·ƒè¯·æ±‚æ•°
        ts.activeRequests.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("rpc.method", info.FullMethod),
            ),
        )
        defer ts.activeRequests.Add(ctx, -1,
            metric.WithAttributes(
                attribute.String("rpc.method", info.FullMethod),
            ),
        )
        
        // è°ƒç”¨ Handler
        resp, err := handler(ctx, req)
        
        duration := time.Since(start)
        
        // è®°å½• Metrics
        attrs := []attribute.KeyValue{
            attribute.String("rpc.method", info.FullMethod),
        }
        
        if err != nil {
            attrs = append(attrs, attribute.String("error", "true"))
        } else {
            attrs = append(attrs, attribute.String("error", "false"))
        }
        
        ts.requestCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
        ts.requestDuration.Record(ctx, float64(duration.Milliseconds()), metric.WithAttributes(attrs...))
        
        return resp, err
    }
}

// streamInterceptor æµæ‹¦æˆªå™¨
func (ts *TracedGRPCServer) streamInterceptor() grpc.StreamServerInterceptor {
    return func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {
        ctx := ss.Context()
        start := time.Now()
        
        // å¢åŠ æ´»è·ƒè¯·æ±‚æ•°
        ts.activeRequests.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("rpc.method", info.FullMethod),
                attribute.Bool("rpc.is_stream", true),
            ),
        )
        defer ts.activeRequests.Add(ctx, -1,
            metric.WithAttributes(
                attribute.String("rpc.method", info.FullMethod),
                attribute.Bool("rpc.is_stream", true),
            ),
        )
        
        // è°ƒç”¨ Handler
        err := handler(srv, ss)
        
        duration := time.Since(start)
        
        // è®°å½• Metrics
        attrs := []attribute.KeyValue{
            attribute.String("rpc.method", info.FullMethod),
            attribute.Bool("rpc.is_stream", true),
        }
        
        if err != nil {
            attrs = append(attrs, attribute.String("error", "true"))
        } else {
            attrs = append(attrs, attribute.String("error", "false"))
        }
        
        ts.requestCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
        ts.requestDuration.Record(ctx, float64(duration.Milliseconds()), metric.WithAttributes(attrs...))
        
        return err
    }
}

// Serve å¯åŠ¨æœåŠ¡
func (ts *TracedGRPCServer) Serve(addr string) error {
    lis, err := net.Listen("tcp", addr)
    if err != nil {
        return err
    }
    return ts.server.Serve(lis)
}

// GracefulStop ä¼˜é›…åœæ­¢
func (ts *TracedGRPCServer) GracefulStop() {
    ts.server.GracefulStop()
}

// Server è·å– gRPC Server
func (ts *TracedGRPCServer) Server() *grpc.Server {
    return ts.server
}
```

### åŒå‘æµè¿½è¸ª

**åŒå‘æµç¤ºä¾‹ï¼š**

```go
package stream

import (
    "context"
    "io"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// ChatService èŠå¤©æœåŠ¡
type ChatService struct {
    tracer trace.Tracer
}

// NewChatService åˆ›å»ºèŠå¤©æœåŠ¡
func NewChatService() *ChatService {
    return &ChatService{
        tracer: otel.Tracer("chat-service"),
    }
}

// Chat åŒå‘æµèŠå¤©
func (s *ChatService) Chat(stream ChatService_ChatServer) error {
    ctx := stream.Context()
    ctx, span := s.tracer.Start(ctx, "chat-stream",
        trace.WithSpanKind(trace.SpanKindServer),
    )
    defer span.End()
    
    messageCount := 0
    
    for {
        // æ¥æ”¶æ¶ˆæ¯
        req, err := stream.Recv()
        if err == io.EOF {
            span.AddEvent("stream closed by client",
                trace.WithAttributes(
                    attribute.Int("total_messages", messageCount),
                ),
            )
            return nil
        }
        if err != nil {
            span.RecordError(err)
            return err
        }
        
        messageCount++
        
        span.AddEvent("message received",
            trace.WithAttributes(
                attribute.String("from", req.From),
                attribute.String("message", req.Message),
            ),
        )
        
        // å¤„ç†æ¶ˆæ¯
        resp := &ChatResponse{
            From:    "server",
            Message: "Echo: " + req.Message,
        }
        
        // å‘é€å“åº”
        if err := stream.Send(resp); err != nil {
            span.RecordError(err)
            return err
        }
        
        span.AddEvent("message sent",
            trace.WithAttributes(
                attribute.String("to", req.From),
            ),
        )
    }
}
```

---

## æ¶ˆæ¯é˜Ÿåˆ—è¿½è¸ª

### Kafka è¿½è¸ª

**Kafka Producer è¿½è¸ªï¼š**

```go
package kafka

import (
    "context"
    "encoding/json"
    
    "github.com/IBM/sarama"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/trace"
)

// TracedKafkaProducer å¸¦è¿½è¸ªçš„ Kafka Producer
type TracedKafkaProducer struct {
    producer  sarama.SyncProducer
    tracer    trace.Tracer
    propagator propagation.TextMapPropagator
}

// NewTracedKafkaProducer åˆ›å»ºå¸¦è¿½è¸ªçš„ Kafka Producer
func NewTracedKafkaProducer(brokers []string) (*TracedKafkaProducer, error) {
    config := sarama.NewConfig()
    config.Producer.Return.Successes = true
    config.Producer.RequiredAcks = sarama.WaitForAll
    
    producer, err := sarama.NewSyncProducer(brokers, config)
    if err != nil {
        return nil, err
    }
    
    return &TracedKafkaProducer{
        producer:   producer,
        tracer:     otel.Tracer("kafka-producer"),
        propagator: otel.GetTextMapPropagator(),
    }, nil
}

// SendMessage å‘é€æ¶ˆæ¯
func (p *TracedKafkaProducer) SendMessage(ctx context.Context, topic string, key, value []byte) error {
    ctx, span := p.tracer.Start(ctx, "kafka.produce",
        trace.WithSpanKind(trace.SpanKindProducer),
        trace.WithAttributes(
            attribute.String("messaging.system", "kafka"),
            attribute.String("messaging.destination", topic),
            attribute.Int("messaging.message.payload_size_bytes", len(value)),
        ),
    )
    defer span.End()
    
    // åˆ›å»ºæ¶ˆæ¯
    msg := &sarama.ProducerMessage{
        Topic: topic,
        Key:   sarama.ByteEncoder(key),
        Value: sarama.ByteEncoder(value),
        Headers: make([]sarama.RecordHeader, 0),
    }
    
    // æ³¨å…¥ Trace Context
    carrier := &kafkaHeaderCarrier{headers: &msg.Headers}
    p.propagator.Inject(ctx, carrier)
    
    // å‘é€æ¶ˆæ¯
    partition, offset, err := p.producer.SendMessage(msg)
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetAttributes(
        attribute.Int("messaging.kafka.partition", int(partition)),
        attribute.Int64("messaging.kafka.offset", offset),
    )
    span.SetStatus(codes.Ok, "")
    
    return nil
}

// Close å…³é—­ Producer
func (p *TracedKafkaProducer) Close() error {
    return p.producer.Close()
}

// kafkaHeaderCarrier Kafka Header Carrier
type kafkaHeaderCarrier struct {
    headers *[]sarama.RecordHeader
}

func (c *kafkaHeaderCarrier) Get(key string) string {
    for _, h := range *c.headers {
        if string(h.Key) == key {
            return string(h.Value)
        }
    }
    return ""
}

func (c *kafkaHeaderCarrier) Set(key, value string) {
    *c.headers = append(*c.headers, sarama.RecordHeader{
        Key:   []byte(key),
        Value: []byte(value),
    })
}

func (c *kafkaHeaderCarrier) Keys() []string {
    keys := make([]string, 0, len(*c.headers))
    for _, h := range *c.headers {
        keys = append(keys, string(h.Key))
    }
    return keys
}
```

**Kafka Consumer è¿½è¸ªï¼š**

```go
package kafka

import (
    "context"
    
    "github.com/IBM/sarama"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/trace"
)

// TracedKafkaConsumer å¸¦è¿½è¸ªçš„ Kafka Consumer
type TracedKafkaConsumer struct {
    consumer   sarama.ConsumerGroup
    tracer     trace.Tracer
    propagator propagation.TextMapPropagator
}

// NewTracedKafkaConsumer åˆ›å»ºå¸¦è¿½è¸ªçš„ Kafka Consumer
func NewTracedKafkaConsumer(brokers []string, groupID string) (*TracedKafkaConsumer, error) {
    config := sarama.NewConfig()
    config.Consumer.Group.Rebalance.Strategy = sarama.NewBalanceStrategyRoundRobin()
    config.Consumer.Offsets.Initial = sarama.OffsetNewest
    
    consumer, err := sarama.NewConsumerGroup(brokers, groupID, config)
    if err != nil {
        return nil, err
    }
    
    return &TracedKafkaConsumer{
        consumer:   consumer,
        tracer:     otel.Tracer("kafka-consumer"),
        propagator: otel.GetTextMapPropagator(),
    }, nil
}

// Consume æ¶ˆè´¹æ¶ˆæ¯
func (c *TracedKafkaConsumer) Consume(ctx context.Context, topics []string, handler func(context.Context, *sarama.ConsumerMessage) error) error {
    consumerHandler := &tracedConsumerGroupHandler{
        tracer:     c.tracer,
        propagator: c.propagator,
        handler:    handler,
    }
    
    for {
        if err := c.consumer.Consume(ctx, topics, consumerHandler); err != nil {
            return err
        }
        
        if ctx.Err() != nil {
            return ctx.Err()
        }
    }
}

// Close å…³é—­ Consumer
func (c *TracedKafkaConsumer) Close() error {
    return c.consumer.Close()
}

// tracedConsumerGroupHandler Consumer Group Handler
type tracedConsumerGroupHandler struct {
    tracer     trace.Tracer
    propagator propagation.TextMapPropagator
    handler    func(context.Context, *sarama.ConsumerMessage) error
}

func (h *tracedConsumerGroupHandler) Setup(sarama.ConsumerGroupSession) error {
    return nil
}

func (h *tracedConsumerGroupHandler) Cleanup(sarama.ConsumerGroupSession) error {
    return nil
}

func (h *tracedConsumerGroupHandler) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
    for message := range claim.Messages() {
        // æå– Trace Context
        carrier := &kafkaMessageCarrier{message: message}
        ctx := h.propagator.Extract(context.Background(), carrier)
        
        ctx, span := h.tracer.Start(ctx, "kafka.consume",
            trace.WithSpanKind(trace.SpanKindConsumer),
            trace.WithAttributes(
                attribute.String("messaging.system", "kafka"),
                attribute.String("messaging.destination", message.Topic),
                attribute.Int("messaging.kafka.partition", int(message.Partition)),
                attribute.Int64("messaging.kafka.offset", message.Offset),
                attribute.Int("messaging.message.payload_size_bytes", len(message.Value)),
            ),
        )
        
        // è°ƒç”¨å¤„ç†å™¨
        err := h.handler(ctx, message)
        
        if err != nil {
            span.RecordError(err)
            span.SetStatus(codes.Error, err.Error())
        } else {
            span.SetStatus(codes.Ok, "")
            session.MarkMessage(message, "")
        }
        
        span.End()
    }
    
    return nil
}

// kafkaMessageCarrier Kafka Message Carrier
type kafkaMessageCarrier struct {
    message *sarama.ConsumerMessage
}

func (c *kafkaMessageCarrier) Get(key string) string {
    for _, h := range c.message.Headers {
        if string(h.Key) == key {
            return string(h.Value)
        }
    }
    return ""
}

func (c *kafkaMessageCarrier) Set(key, value string) {
    // Consumer ä¸éœ€è¦å®ç°
}

func (c *kafkaMessageCarrier) Keys() []string {
    keys := make([]string, 0, len(c.message.Headers))
    for _, h := range c.message.Headers {
        keys = append(keys, string(h.Key))
    }
    return keys
}
```

### NATS è¿½è¸ª

**NATS Publish/Subscribe è¿½è¸ªï¼š**

```go
package nats

import (
    "context"
    "encoding/json"
    
    "github.com/nats-io/nats.go"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/trace"
)

// TracedNATSClient å¸¦è¿½è¸ªçš„ NATS Client
type TracedNATSClient struct {
    conn       *nats.Conn
    tracer     trace.Tracer
    propagator propagation.TextMapPropagator
}

// NewTracedNATSClient åˆ›å»ºå¸¦è¿½è¸ªçš„ NATS Client
func NewTracedNATSClient(url string) (*TracedNATSClient, error) {
    conn, err := nats.Connect(url)
    if err != nil {
        return nil, err
    }
    
    return &TracedNATSClient{
        conn:       conn,
        tracer:     otel.Tracer("nats-client"),
        propagator: otel.GetTextMapPropagator(),
    }, nil
}

// Publish å‘å¸ƒæ¶ˆæ¯
func (c *TracedNATSClient) Publish(ctx context.Context, subject string, data []byte) error {
    ctx, span := c.tracer.Start(ctx, "nats.publish",
        trace.WithSpanKind(trace.SpanKindProducer),
        trace.WithAttributes(
            attribute.String("messaging.system", "nats"),
            attribute.String("messaging.destination", subject),
            attribute.Int("messaging.message.payload_size_bytes", len(data)),
        ),
    )
    defer span.End()
    
    // åˆ›å»ºæ¶ˆæ¯ Envelope
    envelope := &MessageEnvelope{
        Data:    data,
        Headers: make(map[string]string),
    }
    
    // æ³¨å…¥ Trace Context
    carrier := propagation.MapCarrier(envelope.Headers)
    c.propagator.Inject(ctx, carrier)
    
    // åºåˆ—åŒ– Envelope
    envelopeData, err := json.Marshal(envelope)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    // å‘å¸ƒæ¶ˆæ¯
    if err := c.conn.Publish(subject, envelopeData); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// Subscribe è®¢é˜…æ¶ˆæ¯
func (c *TracedNATSClient) Subscribe(subject string, handler func(context.Context, []byte) error) (*nats.Subscription, error) {
    return c.conn.Subscribe(subject, func(msg *nats.Msg) {
        // ååºåˆ—åŒ– Envelope
        var envelope MessageEnvelope
        if err := json.Unmarshal(msg.Data, &envelope); err != nil {
            return
        }
        
        // æå– Trace Context
        carrier := propagation.MapCarrier(envelope.Headers)
        ctx := c.propagator.Extract(context.Background(), carrier)
        
        ctx, span := c.tracer.Start(ctx, "nats.consume",
            trace.WithSpanKind(trace.SpanKindConsumer),
            trace.WithAttributes(
                attribute.String("messaging.system", "nats"),
                attribute.String("messaging.destination", subject),
                attribute.Int("messaging.message.payload_size_bytes", len(envelope.Data)),
            ),
        )
        defer span.End()
        
        // è°ƒç”¨å¤„ç†å™¨
        if err := handler(ctx, envelope.Data); err != nil {
            span.RecordError(err)
            span.SetStatus(codes.Error, err.Error())
        } else {
            span.SetStatus(codes.Ok, "")
        }
    })
}

// Close å…³é—­è¿æ¥
func (c *TracedNATSClient) Close() {
    c.conn.Close()
}

// MessageEnvelope æ¶ˆæ¯ä¿¡å°
type MessageEnvelope struct {
    Data    []byte            `json:"data"`
    Headers map[string]string `json:"headers"`
}
```

### RabbitMQ è¿½è¸ª

**RabbitMQ Producer è¿½è¸ªï¼š**

```go
package rabbitmq

import (
    "context"
    "encoding/json"
    
    amqp "github.com/rabbitmq/amqp091-go"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/trace"
)

// TracedRabbitMQProducer å¸¦è¿½è¸ªçš„ RabbitMQ Producer
type TracedRabbitMQProducer struct {
    conn       *amqp.Connection
    channel    *amqp.Channel
    tracer     trace.Tracer
    propagator propagation.TextMapPropagator
}

// NewTracedRabbitMQProducer åˆ›å»ºå¸¦è¿½è¸ªçš„ RabbitMQ Producer
func NewTracedRabbitMQProducer(url string) (*TracedRabbitMQProducer, error) {
    conn, err := amqp.Dial(url)
    if err != nil {
        return nil, err
    }
    
    channel, err := conn.Channel()
    if err != nil {
        conn.Close()
        return nil, err
    }
    
    return &TracedRabbitMQProducer{
        conn:       conn,
        channel:    channel,
        tracer:     otel.Tracer("rabbitmq-producer"),
        propagator: otel.GetTextMapPropagator(),
    }, nil
}

// Publish å‘å¸ƒæ¶ˆæ¯
func (p *TracedRabbitMQProducer) Publish(ctx context.Context, exchange, routingKey string, body []byte) error {
    ctx, span := p.tracer.Start(ctx, "rabbitmq.publish",
        trace.WithSpanKind(trace.SpanKindProducer),
        trace.WithAttributes(
            attribute.String("messaging.system", "rabbitmq"),
            attribute.String("messaging.destination", exchange),
            attribute.String("messaging.rabbitmq.routing_key", routingKey),
            attribute.Int("messaging.message.payload_size_bytes", len(body)),
        ),
    )
    defer span.End()
    
    // æ³¨å…¥ Trace Context
    headers := make(amqp.Table)
    carrier := &amqpHeaderCarrier{headers: headers}
    p.propagator.Inject(ctx, carrier)
    
    // å‘å¸ƒæ¶ˆæ¯
    err := p.channel.PublishWithContext(
        ctx,
        exchange,
        routingKey,
        false,
        false,
        amqp.Publishing{
            ContentType: "application/json",
            Body:        body,
            Headers:     headers,
        },
    )
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// Close å…³é—­è¿æ¥
func (p *TracedRabbitMQProducer) Close() error {
    if err := p.channel.Close(); err != nil {
        return err
    }
    return p.conn.Close()
}

// amqpHeaderCarrier AMQP Header Carrier
type amqpHeaderCarrier struct {
    headers amqp.Table
}

func (c *amqpHeaderCarrier) Get(key string) string {
    if value, ok := c.headers[key]; ok {
        if str, ok := value.(string); ok {
            return str
        }
    }
    return ""
}

func (c *amqpHeaderCarrier) Set(key, value string) {
    c.headers[key] = value
}

func (c *amqpHeaderCarrier) Keys() []string {
    keys := make([]string, 0, len(c.headers))
    for k := range c.headers {
        keys = append(keys, k)
    }
    return keys
}
```

---

## æœåŠ¡ç½‘æ ¼é›†æˆ

### Istio é›†æˆ

**Istio + OTLP é…ç½®ï¼š**

```yaml
# istio-telemetry.yaml
apiVersion: telemetry.istio.io/v1alpha1
kind: Telemetry
metadata:
  name: otlp-telemetry
  namespace: default
spec:
  tracing:
  - providers:
    - name: otlp-exporter
    randomSamplingPercentage: 10.0
    customTags:
      environment:
        literal:
          value: "production"
      service.version:
        environment:
          name: SERVICE_VERSION
  metrics:
  - providers:
    - name: prometheus
---
apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
metadata:
  name: otlp-config
spec:
  meshConfig:
    extensionProviders:
    - name: otlp-exporter
      opentelemetry:
        service: otel-collector.observability.svc.cluster.local
        port: 4317
    - name: prometheus
      prometheus: {}
    defaultProviders:
      tracing:
      - "otlp-exporter"
      metrics:
      - "prometheus"
```

**Go åº”ç”¨é…ç½®ï¼š**

```go
package istio

import (
    "context"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// InitIstioTracing åˆå§‹åŒ– Istio è¿½è¸ª
func InitIstioTracing() {
    // Istio ä¼šè‡ªåŠ¨æ³¨å…¥ Envoy Sidecar
    // Envoy ä¼šæ‹¦æˆªæ‰€æœ‰æµé‡å¹¶è‡ªåŠ¨ä¼ æ’­ Trace Context
    
    // åº”ç”¨åªéœ€è¦æ­£å¸¸ä½¿ç”¨ OTLP SDK
    tracer := otel.Tracer("my-service")
    
    // Istio ä¼šè‡ªåŠ¨å…³è” Envoy ç”Ÿæˆçš„ Span
}

// HandleRequest å¤„ç†è¯·æ±‚
func HandleRequest(ctx context.Context) {
    tracer := otel.Tracer("my-service")
    
    // åˆ›å»º Spanï¼ˆä¼šè‡ªåŠ¨ç»§æ‰¿ Istio çš„ Spanï¼‰
    ctx, span := tracer.Start(ctx, "handle-request")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("service.version", "1.0.0"),
        attribute.String("deployment.environment", "production"),
    )
    
    // ä¸šåŠ¡é€»è¾‘
}
```

### Linkerd é›†æˆ

**Linkerd + OTLP é…ç½®ï¼š**

```yaml
# linkerd-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: linkerd-config
  namespace: linkerd
data:
  tracing.yaml: |
    tracing:
      enabled: true
      collector:
        endpoint: otel-collector.observability.svc.cluster.local:4317
      samplingRate: 0.1
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
  annotations:
    config.linkerd.io/trace-collector: otel-collector.observability.svc.cluster.local:4317
spec:
  template:
    metadata:
      annotations:
        config.linkerd.io/trace-collector: otel-collector.observability.svc.cluster.local:4317
        config.linkerd.io/trace-collector-svc-account: default
    spec:
      containers:
      - name: app
        image: my-app:latest
```

---

## åˆ†å¸ƒå¼äº‹åŠ¡è¿½è¸ª

### Saga æ¨¡å¼

**Saga ç¼–æ’å™¨è¿½è¸ªï¼š**

```go
package saga

import (
    "context"
    "fmt"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// SagaOrchestrator Saga ç¼–æ’å™¨
type SagaOrchestrator struct {
    tracer trace.Tracer
    steps  []SagaStep
}

// SagaStep Saga æ­¥éª¤
type SagaStep struct {
    Name        string
    Action      func(context.Context) error
    Compensate  func(context.Context) error
}

// NewSagaOrchestrator åˆ›å»º Saga ç¼–æ’å™¨
func NewSagaOrchestrator() *SagaOrchestrator {
    return &SagaOrchestrator{
        tracer: otel.Tracer("saga-orchestrator"),
        steps:  make([]SagaStep, 0),
    }
}

// AddStep æ·»åŠ æ­¥éª¤
func (s *SagaOrchestrator) AddStep(step SagaStep) {
    s.steps = append(s.steps, step)
}

// Execute æ‰§è¡Œ Saga
func (s *SagaOrchestrator) Execute(ctx context.Context) error {
    ctx, span := s.tracer.Start(ctx, "saga.execute",
        trace.WithAttributes(
            attribute.Int("saga.steps", len(s.steps)),
        ),
    )
    defer span.End()
    
    executedSteps := make([]SagaStep, 0)
    
    // æ‰§è¡Œæ‰€æœ‰æ­¥éª¤
    for i, step := range s.steps {
        ctx, stepSpan := s.tracer.Start(ctx, fmt.Sprintf("saga.step.%s", step.Name),
            trace.WithAttributes(
                attribute.String("saga.step.name", step.Name),
                attribute.Int("saga.step.index", i),
            ),
        )
        
        if err := step.Action(ctx); err != nil {
            stepSpan.RecordError(err)
            stepSpan.SetStatus(codes.Error, err.Error())
            stepSpan.End()
            
            // è¡¥å¿å·²æ‰§è¡Œçš„æ­¥éª¤
            span.AddEvent("saga.compensating",
                trace.WithAttributes(
                    attribute.String("failed_step", step.Name),
                ),
            )
            
            if compErr := s.compensate(ctx, executedSteps); compErr != nil {
                span.RecordError(compErr)
                span.SetStatus(codes.Error, fmt.Sprintf("compensation failed: %v", compErr))
                return fmt.Errorf("action failed: %w, compensation failed: %v", err, compErr)
            }
            
            span.SetStatus(codes.Error, fmt.Sprintf("action failed, compensated: %v", err))
            return err
        }
        
        stepSpan.SetStatus(codes.Ok, "")
        stepSpan.End()
        
        executedSteps = append(executedSteps, step)
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// compensate è¡¥å¿
func (s *SagaOrchestrator) compensate(ctx context.Context, steps []SagaStep) error {
    ctx, span := s.tracer.Start(ctx, "saga.compensate",
        trace.WithAttributes(
            attribute.Int("saga.compensate.steps", len(steps)),
        ),
    )
    defer span.End()
    
    // é€†åºæ‰§è¡Œè¡¥å¿
    for i := len(steps) - 1; i >= 0; i-- {
        step := steps[i]
        
        ctx, compSpan := s.tracer.Start(ctx, fmt.Sprintf("saga.compensate.%s", step.Name),
            trace.WithAttributes(
                attribute.String("saga.step.name", step.Name),
            ),
        )
        
        if err := step.Compensate(ctx); err != nil {
            compSpan.RecordError(err)
            compSpan.SetStatus(codes.Error, err.Error())
            compSpan.End()
            return err
        }
        
        compSpan.SetStatus(codes.Ok, "")
        compSpan.End()
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}
```

**ä½¿ç”¨ç¤ºä¾‹ï¼š**

```go
// è®¢å• Saga
saga := NewSagaOrchestrator()

// 1. åˆ›å»ºè®¢å•
saga.AddStep(SagaStep{
    Name: "create-order",
    Action: func(ctx context.Context) error {
        return orderService.CreateOrder(ctx, order)
    },
    Compensate: func(ctx context.Context) error {
        return orderService.CancelOrder(ctx, order.ID)
    },
})

// 2. æ‰£å‡åº“å­˜
saga.AddStep(SagaStep{
    Name: "reserve-inventory",
    Action: func(ctx context.Context) error {
        return inventoryService.Reserve(ctx, order.Items)
    },
    Compensate: func(ctx context.Context) error {
        return inventoryService.Release(ctx, order.Items)
    },
})

// 3. å¤„ç†æ”¯ä»˜
saga.AddStep(SagaStep{
    Name: "process-payment",
    Action: func(ctx context.Context) error {
        return paymentService.Charge(ctx, order.TotalAmount)
    },
    Compensate: func(ctx context.Context) error {
        return paymentService.Refund(ctx, order.TotalAmount)
    },
})

// æ‰§è¡Œ Saga
if err := saga.Execute(ctx); err != nil {
    log.Fatal(err)
}
```

### ä¸¤é˜¶æ®µæäº¤

**2PC åè°ƒå™¨è¿½è¸ªï¼š**

```go
package twopc

import (
    "context"
    "sync"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// TwoPCCoordinator 2PC åè°ƒå™¨
type TwoPCCoordinator struct {
    tracer       trace.Tracer
    participants []Participant
}

// Participant å‚ä¸è€…
type Participant interface {
    Prepare(context.Context) error
    Commit(context.Context) error
    Rollback(context.Context) error
}

// NewTwoPCCoordinator åˆ›å»º 2PC åè°ƒå™¨
func NewTwoPCCoordinator() *TwoPCCoordinator {
    return &TwoPCCoordinator{
        tracer:       otel.Tracer("2pc-coordinator"),
        participants: make([]Participant, 0),
    }
}

// AddParticipant æ·»åŠ å‚ä¸è€…
func (c *TwoPCCoordinator) AddParticipant(p Participant) {
    c.participants = append(c.participants, p)
}

// Execute æ‰§è¡Œ 2PC
func (c *TwoPCCoordinator) Execute(ctx context.Context) error {
    ctx, span := c.tracer.Start(ctx, "2pc.execute",
        trace.WithAttributes(
            attribute.Int("2pc.participants", len(c.participants)),
        ),
    )
    defer span.End()
    
    // Phase 1: Prepare
    if err := c.prepare(ctx); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        
        // Rollback
        c.rollback(ctx)
        return err
    }
    
    // Phase 2: Commit
    if err := c.commit(ctx); err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// prepare Prepare é˜¶æ®µ
func (c *TwoPCCoordinator) prepare(ctx context.Context) error {
    ctx, span := c.tracer.Start(ctx, "2pc.prepare")
    defer span.End()
    
    var wg sync.WaitGroup
    errCh := make(chan error, len(c.participants))
    
    for i, p := range c.participants {
        wg.Add(1)
        go func(index int, participant Participant) {
            defer wg.Done()
            
            ctx, pSpan := c.tracer.Start(ctx, "2pc.prepare.participant",
                trace.WithAttributes(
                    attribute.Int("participant.index", index),
                ),
            )
            defer pSpan.End()
            
            if err := participant.Prepare(ctx); err != nil {
                pSpan.RecordError(err)
                pSpan.SetStatus(codes.Error, err.Error())
                errCh <- err
                return
            }
            
            pSpan.SetStatus(codes.Ok, "")
        }(i, p)
    }
    
    wg.Wait()
    close(errCh)
    
    for err := range errCh {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// commit Commit é˜¶æ®µ
func (c *TwoPCCoordinator) commit(ctx context.Context) error {
    ctx, span := c.tracer.Start(ctx, "2pc.commit")
    defer span.End()
    
    var wg sync.WaitGroup
    errCh := make(chan error, len(c.participants))
    
    for i, p := range c.participants {
        wg.Add(1)
        go func(index int, participant Participant) {
            defer wg.Done()
            
            ctx, pSpan := c.tracer.Start(ctx, "2pc.commit.participant",
                trace.WithAttributes(
                    attribute.Int("participant.index", index),
                ),
            )
            defer pSpan.End()
            
            if err := participant.Commit(ctx); err != nil {
                pSpan.RecordError(err)
                pSpan.SetStatus(codes.Error, err.Error())
                errCh <- err
                return
            }
            
            pSpan.SetStatus(codes.Ok, "")
        }(i, p)
    }
    
    wg.Wait()
    close(errCh)
    
    for err := range errCh {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// rollback Rollback é˜¶æ®µ
func (c *TwoPCCoordinator) rollback(ctx context.Context) {
    ctx, span := c.tracer.Start(ctx, "2pc.rollback")
    defer span.End()
    
    var wg sync.WaitGroup
    
    for i, p := range c.participants {
        wg.Add(1)
        go func(index int, participant Participant) {
            defer wg.Done()
            
            ctx, pSpan := c.tracer.Start(ctx, "2pc.rollback.participant",
                trace.WithAttributes(
                    attribute.Int("participant.index", index),
                ),
            )
            defer pSpan.End()
            
            if err := participant.Rollback(ctx); err != nil {
                pSpan.RecordError(err)
                pSpan.SetStatus(codes.Error, err.Error())
                return
            }
            
            pSpan.SetStatus(codes.Ok, "")
        }(i, p)
    }
    
    wg.Wait()
}
```

---

## æœ€ä½³å®è·µ

### 1. Context ä¼ æ’­

âœ… **å§‹ç»ˆä¼ æ’­ Context**

```go
// âœ… Good
func processRequest(ctx context.Context) error {
    ctx, span := tracer.Start(ctx, "process")
    defer span.End()
    
    return callDownstream(ctx)
}

// âŒ Bad
func processRequest(ctx context.Context) error {
    ctx, span := tracer.Start(ctx, "process")
    defer span.End()
    
    return callDownstream(context.Background()) // ä¸¢å¤±äº†è¿½è¸ªä¸Šä¸‹æ–‡
}
```

### 2. Span å‘½å

âœ… **ä½¿ç”¨æœ‰æ„ä¹‰çš„åç§°**

```go
// âœ… Good
tracer.Start(ctx, "POST /api/users")
tracer.Start(ctx, "query-user-by-id")
tracer.Start(ctx, "kafka.produce.orders")

// âŒ Bad
tracer.Start(ctx, "function1")
tracer.Start(ctx, "process")
```

### 3. é”™è¯¯å¤„ç†

âœ… **è®°å½•é”™è¯¯å’ŒçŠ¶æ€**

```go
// âœ… Good
if err != nil {
    span.RecordError(err)
    span.SetStatus(codes.Error, err.Error())
    return err
}
span.SetStatus(codes.Ok, "")

// âŒ Bad
if err != nil {
    return err // æ²¡æœ‰è®°å½•é”™è¯¯
}
```

### 4. å±æ€§è®¾ç½®

âœ… **æ·»åŠ æœ‰ç”¨çš„å±æ€§**

```go
// âœ… Good
span.SetAttributes(
    attribute.String("user.id", userID),
    attribute.String("http.method", "GET"),
    attribute.Int("http.status_code", 200),
    attribute.Int64("db.rows_affected", rowsAffected),
)

// âŒ Bad
span.SetAttributes(
    attribute.String("data", "some data"), // å¤ªæ¨¡ç³Š
)
```

### 5. Metric å‘½å

âœ… **éµå¾ªå‘½åçº¦å®š**

```go
// âœ… Good
"http.server.requests"          // è®¡æ•°å™¨
"http.server.duration"          // ç›´æ–¹å›¾
"http.server.active_requests"   // UpDownCounter

// âŒ Bad
"requests"          // å¤ªæ¨¡ç³Š
"httpDuration"      // ä¸ç¬¦åˆçº¦å®š
"activeReq"         // ç¼©å†™ä¸æ¸…æ™°
```

---

## å®Œæ•´ç¤ºä¾‹

### å¾®æœåŠ¡é€šä¿¡å®Œæ•´ç¤ºä¾‹

```go
package main

import (
    "context"
    "log"
    "net/http"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/sdk/trace"
)

func main() {
    ctx := context.Background()
    
    // 1. åˆå§‹åŒ– OTLP
    tp, err := initTracing(ctx)
    if err != nil {
        log.Fatal(err)
    }
    defer tp.Shutdown(ctx)
    
    // 2. è®¾ç½®ä¼ æ’­å™¨
    otel.SetTextMapPropagator(
        propagation.NewCompositeTextMapPropagator(
            propagation.TraceContext{},
            propagation.Baggage{},
        ),
    )
    
    // 3. åˆ›å»º HTTP Client
    client, err := NewTracedHTTPClient(10 * time.Second)
    if err != nil {
        log.Fatal(err)
    }
    
    // 4. åˆ›å»ºæœåŠ¡
    userService := NewUserService(client)
    
    // 5. åˆ›å»º HTTP Server
    mux := http.NewServeMux()
    
    mux.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
        ctx := r.Context()
        
        // å¤„ç†è¯·æ±‚
        user, err := userService.GetUser(ctx, r.URL.Query().Get("id"))
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        
        json.NewEncoder(w).Encode(user)
    })
    
    server, err := NewTracedHTTPServer(":8080", mux)
    if err != nil {
        log.Fatal(err)
    }
    
    log.Println("Server started on :8080")
    if err := server.Start(); err != nil {
        log.Fatal(err)
    }
}

func initTracing(ctx context.Context) (*trace.TracerProvider, error) {
    exporter, err := otlptracegrpc.New(ctx,
        otlptracegrpc.WithEndpoint("localhost:4317"),
        otlptracegrpc.WithInsecure(),
    )
    if err != nil {
        return nil, err
    }
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
    )
    
    otel.SetTracerProvider(tp)
    return tp, nil
}
```

---

## æ€»ç»“

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº† Go å¾®æœåŠ¡é—´é€šä¿¡çš„åˆ†å¸ƒå¼è¿½è¸ªå®ç°ï¼Œæ¶µç›–ï¼š

âœ… **åˆ†å¸ƒå¼è¿½è¸ªåŸºç¡€** - W3C Trace Contextã€Baggageã€Span Context  
âœ… **HTTP é€šä¿¡è¿½è¸ª** - Clientã€Serverã€RESTful API  
âœ… **gRPC é€šä¿¡è¿½è¸ª** - Clientã€Serverã€åŒå‘æµ  
âœ… **æ¶ˆæ¯é˜Ÿåˆ—è¿½è¸ª** - Kafkaã€NATSã€RabbitMQ  
âœ… **æœåŠ¡ç½‘æ ¼é›†æˆ** - Istioã€Linkerd  
âœ… **åˆ†å¸ƒå¼äº‹åŠ¡è¿½è¸ª** - Sagaã€2PC  
âœ… **æœ€ä½³å®è·µ** - Contextã€Spanã€Errorã€Metric  

### å…³é”®è¦ç‚¹

1. **Context ä¼ æ’­æ˜¯æ ¸å¿ƒ** - ç¡®ä¿æ‰€æœ‰æœåŠ¡é—´è°ƒç”¨éƒ½ä¼ æ’­ Context
2. **ä½¿ç”¨æ ‡å‡†åè®®** - W3C Trace Context ä¿è¯äº’æ“ä½œæ€§
3. **å®Œæ•´çš„é”™è¯¯å¤„ç†** - è®°å½•é”™è¯¯å’Œ Span çŠ¶æ€
4. **æœ‰æ„ä¹‰çš„å‘½å** - Span å’Œ Metric åç§°è¦æ¸…æ™°
5. **æœåŠ¡ç½‘æ ¼å¢å¼º** - ç»“åˆ Istio/Linkerd è·å¾—æ›´å¥½çš„å¯è§‚æµ‹æ€§

### ç›¸å…³æ–‡æ¡£

- [31_Goé«˜çº§å¹¶å‘æ¨¡å¼ä¸OTLPå®Œæ•´é›†æˆ](./31_Goé«˜çº§å¹¶å‘æ¨¡å¼ä¸OTLPå®Œæ•´é›†æˆ.md)
- [32_Goå‡½æ•°å¼ç¼–ç¨‹ä¸OTLPé›†æˆ](./32_Goå‡½æ•°å¼ç¼–ç¨‹ä¸OTLPé›†æˆ.md)
- [33_Goé«˜çº§é”™è¯¯å¤„ç†æ¨¡å¼ä¸Contextä¼ æ’­](./33_Goé«˜çº§é”™è¯¯å¤„ç†æ¨¡å¼ä¸Contextä¼ æ’­.md)
- [09_Goä¸»æµæ¡†æ¶æ·±åº¦é›†æˆæŒ‡å—](./09_Goä¸»æµæ¡†æ¶æ·±åº¦é›†æˆæŒ‡å—.md)

---

**æœ€åæ›´æ–°ï¼š** 2025-10-09  
**ç‰ˆæœ¬ï¼š** v1.0.0  
**ä½œè€…ï¼š** OTLP Go Integration Team
