# Go æ•°æ®åº“ä¸ç¼“å­˜é›†æˆè¿½è¸ªå®Œæ•´æŒ‡å—

## ğŸ“‹ ç›®å½•

- [Go æ•°æ®åº“ä¸ç¼“å­˜é›†æˆè¿½è¸ªå®Œæ•´æŒ‡å—](#go-æ•°æ®åº“ä¸ç¼“å­˜é›†æˆè¿½è¸ªå®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ–‡æ¡£æ¦‚è¿°](#æ–‡æ¡£æ¦‚è¿°)
    - [æ ¸å¿ƒä»·å€¼](#æ ¸å¿ƒä»·å€¼)
    - [ä¾èµ–ç‰ˆæœ¬](#ä¾èµ–ç‰ˆæœ¬)
  - [SQL æ•°æ®åº“è¿½è¸ª](#sql-æ•°æ®åº“è¿½è¸ª)
    - [database/sql é›†æˆ](#databasesql-é›†æˆ)
    - [è¿æ¥æ± ç›‘æ§](#è¿æ¥æ± ç›‘æ§)
    - [æ…¢æŸ¥è¯¢è¿½è¸ª](#æ…¢æŸ¥è¯¢è¿½è¸ª)
  - [ORM è¿½è¸ª](#orm-è¿½è¸ª)
    - [GORM é›†æˆ](#gorm-é›†æˆ)
    - [Ent é›†æˆ](#ent-é›†æˆ)
    - [sqlx é›†æˆ](#sqlx-é›†æˆ)
  - [NoSQL æ•°æ®åº“è¿½è¸ª](#nosql-æ•°æ®åº“è¿½è¸ª)
    - [MongoDB è¿½è¸ª](#mongodb-è¿½è¸ª)
  - [ç¼“å­˜è¿½è¸ª](#ç¼“å­˜è¿½è¸ª)
    - [Redis è¿½è¸ª](#redis-è¿½è¸ª)
    - [Memcached è¿½è¸ª](#memcached-è¿½è¸ª)
    - [æœ¬åœ°ç¼“å­˜è¿½è¸ª](#æœ¬åœ°ç¼“å­˜è¿½è¸ª)
  - [æŸ¥è¯¢ä¼˜åŒ–](#æŸ¥è¯¢ä¼˜åŒ–)
    - [æŸ¥è¯¢è®¡åˆ’åˆ†æ](#æŸ¥è¯¢è®¡åˆ’åˆ†æ)
    - [ç´¢å¼•ä½¿ç”¨ç›‘æ§](#ç´¢å¼•ä½¿ç”¨ç›‘æ§)
    - [N+1 é—®é¢˜æ£€æµ‹](#n1-é—®é¢˜æ£€æµ‹)
  - [äº‹åŠ¡è¿½è¸ª](#äº‹åŠ¡è¿½è¸ª)
    - [å•æ•°æ®åº“äº‹åŠ¡](#å•æ•°æ®åº“äº‹åŠ¡)
  - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
    - [1. è¿æ¥æ± é…ç½®](#1-è¿æ¥æ± é…ç½®)
    - [2. æ…¢æŸ¥è¯¢æ£€æµ‹](#2-æ…¢æŸ¥è¯¢æ£€æµ‹)
    - [3. ç¼“å­˜ç­–ç•¥](#3-ç¼“å­˜ç­–ç•¥)
    - [4. äº‹åŠ¡ç®¡ç†](#4-äº‹åŠ¡ç®¡ç†)
  - [å®Œæ•´ç¤ºä¾‹](#å®Œæ•´ç¤ºä¾‹)
  - [æ€»ç»“](#æ€»ç»“)
    - [å…³é”®è¦ç‚¹](#å…³é”®è¦ç‚¹)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)

---

## æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç» Go åº”ç”¨ä¸­æ•°æ®åº“å’Œç¼“å­˜æ“ä½œçš„è¿½è¸ªå®ç°ï¼Œæ¶µç›– SQLã€NoSQLã€ORM å’Œç¼“å­˜ç³»ç»Ÿã€‚

### æ ¸å¿ƒä»·å€¼

âœ… **å®Œæ•´çš„æ•°æ®å±‚è¿½è¸ª** - SQLã€NoSQLã€Cache å…¨è¦†ç›–  
âœ… **è¿æ¥æ± ç›‘æ§** - å®æ—¶ç›‘æ§è¿æ¥ä½¿ç”¨æƒ…å†µ  
âœ… **æ…¢æŸ¥è¯¢æ£€æµ‹** - è‡ªåŠ¨è¯†åˆ«æ€§èƒ½é—®é¢˜  
âœ… **ORM é›†æˆ** - GORMã€Entã€sqlx æ”¯æŒ  
âœ… **æŸ¥è¯¢ä¼˜åŒ–** - åˆ†ææŸ¥è¯¢è®¡åˆ’å’Œç´¢å¼•ä½¿ç”¨

### ä¾èµ–ç‰ˆæœ¬

```go
go.opentelemetry.io/otel v1.32.0
go.opentelemetry.io/contrib/instrumentation/database/sql/otelsql v0.57.0
gorm.io/gorm v1.25.12
gorm.io/plugin/opentelemetry v0.1.4
entgo.io/ent v0.14.1
github.com/jmoiron/sqlx v1.4.0
github.com/redis/go-redis/v9 v9.7.0
github.com/bradfitz/gomemcache v0.0.0-20230905024940-24af94b03874
go.mongodb.org/mongo-driver v1.17.1
```

---

## SQL æ•°æ®åº“è¿½è¸ª

### database/sql é›†æˆ

**å¸¦è¿½è¸ªçš„ SQL Driverï¼š**

```go
package database

import (
    "context"
    "database/sql"
    "time"
    
    "go.opentelemetry.io/contrib/instrumentation/database/sql/otelsql"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
    semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
)

// TracedDB å¸¦è¿½è¸ªçš„æ•°æ®åº“è¿æ¥
type TracedDB struct {
    db     *sql.DB
    meter  metric.Meter
    
    // Metrics
    queryDuration      metric.Float64Histogram
    queryCounter       metric.Int64Counter
    connectionActive   metric.Int64ObservableGauge
    connectionIdle     metric.Int64ObservableGauge
    connectionWait     metric.Int64ObservableGauge
}

// NewTracedDB åˆ›å»ºå¸¦è¿½è¸ªçš„æ•°æ®åº“è¿æ¥
func NewTracedDB(driverName, dsn string) (*TracedDB, error) {
    // æ³¨å†Œå¸¦è¿½è¸ªçš„ Driver
    driverName, err := otelsql.Register(driverName,
        otelsql.WithAttributes(
            semconv.DBSystemKey.String(driverName),
        ),
        otelsql.WithSpanOptions(
            otelsql.SpanOptions{
                Ping:                 true,
                RowsNext:             true,
                DisableErrSkip:       true,
                DisableQuery:         false,
                OmitConnResetSession: false,
                OmitRows:             false,
            },
        ),
    )
    if err != nil {
        return nil, err
    }
    
    // æ‰“å¼€æ•°æ®åº“
    db, err := sql.Open(driverName, dsn)
    if err != nil {
        return nil, err
    }
    
    // é…ç½®è¿æ¥æ± 
    db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(5)
    db.SetConnMaxLifetime(5 * time.Minute)
    db.SetConnMaxIdleTime(1 * time.Minute)
    
    meter := otel.Meter("database")
    
    td := &TracedDB{
        db:    db,
        meter: meter,
    }
    
    // æŸ¥è¯¢æŒç»­æ—¶é—´
    td.queryDuration, err = meter.Float64Histogram(
        "db.query.duration",
        metric.WithDescription("Database query duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    // æŸ¥è¯¢è®¡æ•°å™¨
    td.queryCounter, err = meter.Int64Counter(
        "db.query.count",
        metric.WithDescription("Database query count"),
    )
    if err != nil {
        return nil, err
    }
    
    // æ´»è·ƒè¿æ¥æ•°
    td.connectionActive, err = meter.Int64ObservableGauge(
        "db.connections.active",
        metric.WithDescription("Active database connections"),
        metric.WithInt64Callback(func(ctx context.Context, observer metric.Int64Observer) error {
            stats := db.Stats()
            observer.Observe(int64(stats.InUse))
            return nil
        }),
    )
    if err != nil {
        return nil, err
    }
    
    // ç©ºé—²è¿æ¥æ•°
    td.connectionIdle, err = meter.Int64ObservableGauge(
        "db.connections.idle",
        metric.WithDescription("Idle database connections"),
        metric.WithInt64Callback(func(ctx context.Context, observer metric.Int64Observer) error {
            stats := db.Stats()
            observer.Observe(int64(stats.Idle))
            return nil
        }),
    )
    if err != nil {
        return nil, err
    }
    
    // ç­‰å¾…è¿æ¥æ•°
    td.connectionWait, err = meter.Int64ObservableGauge(
        "db.connections.wait",
        metric.WithDescription("Waiting database connections"),
        metric.WithInt64Callback(func(ctx context.Context, observer metric.Int64Observer) error {
            stats := db.Stats()
            observer.Observe(stats.WaitCount)
            return nil
        }),
    )
    if err != nil {
        return nil, err
    }
    
    // è®°å½•æ•°æ®åº“ç»Ÿè®¡
    if err := otelsql.RecordStats(db); err != nil {
        return nil, err
    }
    
    return td, nil
}

// Query æ‰§è¡ŒæŸ¥è¯¢
func (td *TracedDB) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
    start := time.Now()
    
    rows, err := td.db.QueryContext(ctx, query, args...)
    
    duration := time.Since(start)
    
    // è®°å½• Metrics
    attrs := []attribute.KeyValue{
        attribute.String("db.operation", "query"),
    }
    
    if err != nil {
        attrs = append(attrs, attribute.Bool("error", true))
    } else {
        attrs = append(attrs, attribute.Bool("error", false))
    }
    
    td.queryCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
    td.queryDuration.Record(ctx, float64(duration.Milliseconds()), metric.WithAttributes(attrs...))
    
    return rows, err
}

// QueryRow æ‰§è¡Œå•è¡ŒæŸ¥è¯¢
func (td *TracedDB) QueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row {
    start := time.Now()
    
    row := td.db.QueryRowContext(ctx, query, args...)
    
    duration := time.Since(start)
    
    // è®°å½• Metrics
    td.queryCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("db.operation", "query_row"),
        ),
    )
    td.queryDuration.Record(ctx, float64(duration.Milliseconds()),
        metric.WithAttributes(
            attribute.String("db.operation", "query_row"),
        ),
    )
    
    return row
}

// Exec æ‰§è¡Œå‘½ä»¤
func (td *TracedDB) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
    start := time.Now()
    
    result, err := td.db.ExecContext(ctx, query, args...)
    
    duration := time.Since(start)
    
    // è®°å½• Metrics
    attrs := []attribute.KeyValue{
        attribute.String("db.operation", "exec"),
    }
    
    if err != nil {
        attrs = append(attrs, attribute.Bool("error", true))
    } else {
        attrs = append(attrs, attribute.Bool("error", false))
        
        if rowsAffected, err := result.RowsAffected(); err == nil {
            attrs = append(attrs, attribute.Int64("db.rows_affected", rowsAffected))
        }
    }
    
    td.queryCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
    td.queryDuration.Record(ctx, float64(duration.Milliseconds()), metric.WithAttributes(attrs...))
    
    return result, err
}

// Begin å¼€å§‹äº‹åŠ¡
func (td *TracedDB) Begin(ctx context.Context) (*sql.Tx, error) {
    return td.db.BeginTx(ctx, nil)
}

// Stats è·å–ç»Ÿè®¡ä¿¡æ¯
func (td *TracedDB) Stats() sql.DBStats {
    return td.db.Stats()
}

// Close å…³é—­è¿æ¥
func (td *TracedDB) Close() error {
    return td.db.Close()
}

// DB è·å–åŸå§‹ DB
func (td *TracedDB) DB() *sql.DB {
    return td.db
}
```

### è¿æ¥æ± ç›‘æ§

**è¿æ¥æ± ç›‘æ§å™¨ï¼š**

```go
package database

import (
    "context"
    "database/sql"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// PoolMonitor è¿æ¥æ± ç›‘æ§å™¨
type PoolMonitor struct {
    db     *sql.DB
    meter  metric.Meter
    ticker *time.Ticker
    done   chan struct{}
}

// NewPoolMonitor åˆ›å»ºè¿æ¥æ± ç›‘æ§å™¨
func NewPoolMonitor(db *sql.DB, interval time.Duration) (*PoolMonitor, error) {
    meter := otel.Meter("pool-monitor")
    
    pm := &PoolMonitor{
        db:     db,
        meter:  meter,
        ticker: time.NewTicker(interval),
        done:   make(chan struct{}),
    }
    
    return pm, nil
}

// Start å¯åŠ¨ç›‘æ§
func (pm *PoolMonitor) Start(ctx context.Context) {
    go func() {
        for {
            select {
            case <-pm.ticker.C:
                pm.recordStats(ctx)
            case <-pm.done:
                return
            case <-ctx.Done():
                return
            }
        }
    }()
}

// Stop åœæ­¢ç›‘æ§
func (pm *PoolMonitor) Stop() {
    pm.ticker.Stop()
    close(pm.done)
}

// recordStats è®°å½•ç»Ÿè®¡ä¿¡æ¯
func (pm *PoolMonitor) recordStats(ctx context.Context) {
    stats := pm.db.Stats()
    
    // ä½¿ç”¨ Gauge è®°å½•å½“å‰å€¼
    maxOpenConns, _ := pm.meter.Int64ObservableGauge(
        "db.pool.max_open",
        metric.WithDescription("Maximum open connections"),
    )
    
    openConns, _ := pm.meter.Int64ObservableGauge(
        "db.pool.open",
        metric.WithDescription("Open connections"),
    )
    
    inUse, _ := pm.meter.Int64ObservableGauge(
        "db.pool.in_use",
        metric.WithDescription("Connections in use"),
    )
    
    idle, _ := pm.meter.Int64ObservableGauge(
        "db.pool.idle",
        metric.WithDescription("Idle connections"),
    )
    
    waitCount, _ := pm.meter.Int64Counter(
        "db.pool.wait_count",
        metric.WithDescription("Total wait count"),
    )
    
    waitDuration, _ := pm.meter.Float64Histogram(
        "db.pool.wait_duration",
        metric.WithDescription("Wait duration"),
        metric.WithUnit("ms"),
    )
}

// PoolStats è¿æ¥æ± ç»Ÿè®¡
type PoolStats struct {
    MaxOpenConnections int
    OpenConnections    int
    InUse              int
    Idle               int
    WaitCount          int64
    WaitDuration       time.Duration
    MaxIdleClosed      int64
    MaxIdleTimeClosed  int64
    MaxLifetimeClosed  int64
}

// GetPoolStats è·å–è¿æ¥æ± ç»Ÿè®¡
func (pm *PoolMonitor) GetPoolStats() PoolStats {
    stats := pm.db.Stats()
    
    return PoolStats{
        MaxOpenConnections: stats.MaxOpenConnections,
        OpenConnections:    stats.OpenConnections,
        InUse:              stats.InUse,
        Idle:               stats.Idle,
        WaitCount:          stats.WaitCount,
        WaitDuration:       stats.WaitDuration,
        MaxIdleClosed:      stats.MaxIdleClosed,
        MaxIdleTimeClosed:  stats.MaxIdleTimeClosed,
        MaxLifetimeClosed:  stats.MaxLifetimeClosed,
    }
}
```

### æ…¢æŸ¥è¯¢è¿½è¸ª

**æ…¢æŸ¥è¯¢æ£€æµ‹å™¨ï¼š**

```go
package database

import (
    "context"
    "database/sql"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// SlowQueryDetector æ…¢æŸ¥è¯¢æ£€æµ‹å™¨
type SlowQueryDetector struct {
    db        *TracedDB
    threshold time.Duration
    tracer    trace.Tracer
}

// NewSlowQueryDetector åˆ›å»ºæ…¢æŸ¥è¯¢æ£€æµ‹å™¨
func NewSlowQueryDetector(db *TracedDB, threshold time.Duration) *SlowQueryDetector {
    return &SlowQueryDetector{
        db:        db,
        threshold: threshold,
        tracer:    otel.Tracer("slow-query-detector"),
    }
}

// Query æ‰§è¡ŒæŸ¥è¯¢å¹¶æ£€æµ‹æ…¢æŸ¥è¯¢
func (sqd *SlowQueryDetector) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
    ctx, span := sqd.tracer.Start(ctx, "slow-query-check",
        trace.WithAttributes(
            attribute.String("db.statement", query),
        ),
    )
    defer span.End()
    
    start := time.Now()
    rows, err := sqd.db.Query(ctx, query, args...)
    duration := time.Since(start)
    
    span.SetAttributes(
        attribute.Int64("db.duration_ms", duration.Milliseconds()),
    )
    
    // æ£€æµ‹æ…¢æŸ¥è¯¢
    if duration > sqd.threshold {
        span.AddEvent("slow query detected",
            trace.WithAttributes(
                attribute.Int64("db.duration_ms", duration.Milliseconds()),
                attribute.Int64("db.threshold_ms", sqd.threshold.Milliseconds()),
                attribute.String("db.statement", query),
            ),
        )
        
        // è®°å½•æ…¢æŸ¥è¯¢æ—¥å¿—
        log.Printf("SLOW QUERY: %dms > %dms: %s", 
            duration.Milliseconds(), 
            sqd.threshold.Milliseconds(), 
            query,
        )
    }
    
    return rows, err
}

// Exec æ‰§è¡Œå‘½ä»¤å¹¶æ£€æµ‹æ…¢æŸ¥è¯¢
func (sqd *SlowQueryDetector) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
    ctx, span := sqd.tracer.Start(ctx, "slow-query-check",
        trace.WithAttributes(
            attribute.String("db.statement", query),
        ),
    )
    defer span.End()
    
    start := time.Now()
    result, err := sqd.db.Exec(ctx, query, args...)
    duration := time.Since(start)
    
    span.SetAttributes(
        attribute.Int64("db.duration_ms", duration.Milliseconds()),
    )
    
    // æ£€æµ‹æ…¢æŸ¥è¯¢
    if duration > sqd.threshold {
        span.AddEvent("slow query detected",
            trace.WithAttributes(
                attribute.Int64("db.duration_ms", duration.Milliseconds()),
                attribute.Int64("db.threshold_ms", sqd.threshold.Milliseconds()),
                attribute.String("db.statement", query),
            ),
        )
        
        // è®°å½•æ…¢æŸ¥è¯¢æ—¥å¿—
        log.Printf("SLOW QUERY: %dms > %dms: %s", 
            duration.Milliseconds(), 
            sqd.threshold.Milliseconds(), 
            query,
        )
    }
    
    return result, err
}
```

---

## ORM è¿½è¸ª

### GORM é›†æˆ

**GORM + OpenTelemetryï¼š**

```go
package orm

import (
    "gorm.io/driver/postgres"
    "gorm.io/gorm"
    "gorm.io/gorm/logger"
    "gorm.io/plugin/opentelemetry/tracing"
)

// NewTracedGORM åˆ›å»ºå¸¦è¿½è¸ªçš„ GORM
func NewTracedGORM(dsn string) (*gorm.DB, error) {
    db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{
        Logger: logger.Default.LogMode(logger.Info),
    })
    if err != nil {
        return nil, err
    }
    
    // æ³¨å†Œ OpenTelemetry æ’ä»¶
    if err := db.Use(tracing.NewPlugin()); err != nil {
        return nil, err
    }
    
    return db, nil
}

// User ç”¨æˆ·æ¨¡å‹
type User struct {
    ID    uint   `gorm:"primaryKey"`
    Name  string `gorm:"size:100"`
    Email string `gorm:"size:100;uniqueIndex"`
}

// UserRepository ç”¨æˆ·ä»“åº“
type UserRepository struct {
    db *gorm.DB
}

// NewUserRepository åˆ›å»ºç”¨æˆ·ä»“åº“
func NewUserRepository(db *gorm.DB) *UserRepository {
    return &UserRepository{db: db}
}

// Create åˆ›å»ºç”¨æˆ·
func (r *UserRepository) Create(ctx context.Context, user *User) error {
    // GORM ä¼šè‡ªåŠ¨åˆ›å»º Span
    return r.db.WithContext(ctx).Create(user).Error
}

// FindByID æ ¹æ® ID æŸ¥æ‰¾ç”¨æˆ·
func (r *UserRepository) FindByID(ctx context.Context, id uint) (*User, error) {
    var user User
    err := r.db.WithContext(ctx).First(&user, id).Error
    if err != nil {
        return nil, err
    }
    return &user, nil
}

// FindByEmail æ ¹æ®é‚®ç®±æŸ¥æ‰¾ç”¨æˆ·
func (r *UserRepository) FindByEmail(ctx context.Context, email string) (*User, error) {
    var user User
    err := r.db.WithContext(ctx).Where("email = ?", email).First(&user).Error
    if err != nil {
        return nil, err
    }
    return &user, nil
}

// Update æ›´æ–°ç”¨æˆ·
func (r *UserRepository) Update(ctx context.Context, user *User) error {
    return r.db.WithContext(ctx).Save(user).Error
}

// Delete åˆ é™¤ç”¨æˆ·
func (r *UserRepository) Delete(ctx context.Context, id uint) error {
    return r.db.WithContext(ctx).Delete(&User{}, id).Error
}

// FindAll æŸ¥æ‰¾æ‰€æœ‰ç”¨æˆ·ï¼ˆå¸¦åˆ†é¡µï¼‰
func (r *UserRepository) FindAll(ctx context.Context, page, pageSize int) ([]*User, error) {
    var users []*User
    offset := (page - 1) * pageSize
    
    err := r.db.WithContext(ctx).
        Offset(offset).
        Limit(pageSize).
        Find(&users).Error
    
    if err != nil {
        return nil, err
    }
    
    return users, nil
}
```

### Ent é›†æˆ

**Ent + OpenTelemetryï¼š**

```go
package orm

import (
    "context"
    
    "entgo.io/ent/dialect"
    "entgo.io/ent/dialect/sql"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
    
    _ "github.com/lib/pq"
)

// NewTracedEntClient åˆ›å»ºå¸¦è¿½è¸ªçš„ Ent Client
func NewTracedEntClient(dsn string) (*ent.Client, error) {
    drv, err := sql.Open(dialect.Postgres, dsn)
    if err != nil {
        return nil, err
    }
    
    // æ·»åŠ è¿½è¸ªé’©å­
    drv.Exec = func(ctx context.Context, query string, args, v interface{}) error {
        tracer := otel.Tracer("ent")
        ctx, span := tracer.Start(ctx, "ent.exec",
            trace.WithAttributes(
                attribute.String("db.system", "postgresql"),
                attribute.String("db.statement", query),
            ),
        )
        defer span.End()
        
        return drv.Driver.Exec(ctx, query, args, v)
    }
    
    drv.Query = func(ctx context.Context, query string, args, v interface{}) error {
        tracer := otel.Tracer("ent")
        ctx, span := tracer.Start(ctx, "ent.query",
            trace.WithAttributes(
                attribute.String("db.system", "postgresql"),
                attribute.String("db.statement", query),
            ),
        )
        defer span.End()
        
        return drv.Driver.Query(ctx, query, args, v)
    }
    
    client := ent.NewClient(ent.Driver(drv))
    
    return client, nil
}
```

### sqlx é›†æˆ

**sqlx + OpenTelemetryï¼š**

```go
package orm

import (
    "context"
    "time"
    
    "github.com/jmoiron/sqlx"
    _ "github.com/lib/pq"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// TracedSQLX å¸¦è¿½è¸ªçš„ sqlx
type TracedSQLX struct {
    db     *sqlx.DB
    tracer trace.Tracer
}

// NewTracedSQLX åˆ›å»ºå¸¦è¿½è¸ªçš„ sqlx
func NewTracedSQLX(driverName, dsn string) (*TracedSQLX, error) {
    db, err := sqlx.Connect(driverName, dsn)
    if err != nil {
        return nil, err
    }
    
    return &TracedSQLX{
        db:     db,
        tracer: otel.Tracer("sqlx"),
    }, nil
}

// Get æŸ¥è¯¢å•æ¡è®°å½•
func (ts *TracedSQLX) Get(ctx context.Context, dest interface{}, query string, args ...interface{}) error {
    ctx, span := ts.tracer.Start(ctx, "sqlx.get",
        trace.WithAttributes(
            attribute.String("db.statement", query),
        ),
    )
    defer span.End()
    
    start := time.Now()
    err := ts.db.GetContext(ctx, dest, query, args...)
    duration := time.Since(start)
    
    span.SetAttributes(
        attribute.Int64("db.duration_ms", duration.Milliseconds()),
    )
    
    if err != nil {
        span.RecordError(err)
    }
    
    return err
}

// Select æŸ¥è¯¢å¤šæ¡è®°å½•
func (ts *TracedSQLX) Select(ctx context.Context, dest interface{}, query string, args ...interface{}) error {
    ctx, span := ts.tracer.Start(ctx, "sqlx.select",
        trace.WithAttributes(
            attribute.String("db.statement", query),
        ),
    )
    defer span.End()
    
    start := time.Now()
    err := ts.db.SelectContext(ctx, dest, query, args...)
    duration := time.Since(start)
    
    span.SetAttributes(
        attribute.Int64("db.duration_ms", duration.Milliseconds()),
    )
    
    if err != nil {
        span.RecordError(err)
    }
    
    return err
}

// Exec æ‰§è¡Œå‘½ä»¤
func (ts *TracedSQLX) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
    ctx, span := ts.tracer.Start(ctx, "sqlx.exec",
        trace.WithAttributes(
            attribute.String("db.statement", query),
        ),
    )
    defer span.End()
    
    start := time.Now()
    result, err := ts.db.ExecContext(ctx, query, args...)
    duration := time.Since(start)
    
    span.SetAttributes(
        attribute.Int64("db.duration_ms", duration.Milliseconds()),
    )
    
    if err != nil {
        span.RecordError(err)
    } else {
        if rowsAffected, err := result.RowsAffected(); err == nil {
            span.SetAttributes(
                attribute.Int64("db.rows_affected", rowsAffected),
            )
        }
    }
    
    return result, err
}

// NamedExec æ‰§è¡Œå‘½åå‚æ•°å‘½ä»¤
func (ts *TracedSQLX) NamedExec(ctx context.Context, query string, arg interface{}) (sql.Result, error) {
    ctx, span := ts.tracer.Start(ctx, "sqlx.named_exec",
        trace.WithAttributes(
            attribute.String("db.statement", query),
        ),
    )
    defer span.End()
    
    start := time.Now()
    result, err := ts.db.NamedExecContext(ctx, query, arg)
    duration := time.Since(start)
    
    span.SetAttributes(
        attribute.Int64("db.duration_ms", duration.Milliseconds()),
    )
    
    if err != nil {
        span.RecordError(err)
    }
    
    return result, err
}
```

---

## NoSQL æ•°æ®åº“è¿½è¸ª

### MongoDB è¿½è¸ª

**MongoDB + OpenTelemetryï¼š**

```go
package nosql

import (
    "context"
    "time"
    
    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
    "go.opentelemetry.io/contrib/instrumentation/go.mongodb.org/mongo-driver/mongo/otelmongo"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// TracedMongoDB å¸¦è¿½è¸ªçš„ MongoDB
type TracedMongoDB struct {
    client *mongo.Client
    tracer trace.Tracer
}

// NewTracedMongoDB åˆ›å»ºå¸¦è¿½è¸ªçš„ MongoDB
func NewTracedMongoDB(uri string) (*TracedMongoDB, error) {
    // åˆ›å»ºå¸¦è¿½è¸ªçš„ Client é€‰é¡¹
    opts := options.Client().
        ApplyURI(uri).
        SetMonitor(otelmongo.NewMonitor())
    
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    client, err := mongo.Connect(ctx, opts)
    if err != nil {
        return nil, err
    }
    
    // Ping æµ‹è¯•è¿æ¥
    if err := client.Ping(ctx, nil); err != nil {
        return nil, err
    }
    
    return &TracedMongoDB{
        client: client,
        tracer: otel.Tracer("mongodb"),
    }, nil
}

// InsertOne æ’å…¥å•ä¸ªæ–‡æ¡£
func (tm *TracedMongoDB) InsertOne(ctx context.Context, database, collection string, document interface{}) (*mongo.InsertOneResult, error) {
    ctx, span := tm.tracer.Start(ctx, "mongodb.insert_one",
        trace.WithAttributes(
            attribute.String("db.system", "mongodb"),
            attribute.String("db.name", database),
            attribute.String("db.mongodb.collection", collection),
        ),
    )
    defer span.End()
    
    coll := tm.client.Database(database).Collection(collection)
    result, err := coll.InsertOne(ctx, document)
    
    if err != nil {
        span.RecordError(err)
    }
    
    return result, err
}

// FindOne æŸ¥æ‰¾å•ä¸ªæ–‡æ¡£
func (tm *TracedMongoDB) FindOne(ctx context.Context, database, collection string, filter interface{}, result interface{}) error {
    ctx, span := tm.tracer.Start(ctx, "mongodb.find_one",
        trace.WithAttributes(
            attribute.String("db.system", "mongodb"),
            attribute.String("db.name", database),
            attribute.String("db.mongodb.collection", collection),
        ),
    )
    defer span.End()
    
    coll := tm.client.Database(database).Collection(collection)
    err := coll.FindOne(ctx, filter).Decode(result)
    
    if err != nil {
        span.RecordError(err)
    }
    
    return err
}

// Find æŸ¥æ‰¾å¤šä¸ªæ–‡æ¡£
func (tm *TracedMongoDB) Find(ctx context.Context, database, collection string, filter interface{}) (*mongo.Cursor, error) {
    ctx, span := tm.tracer.Start(ctx, "mongodb.find",
        trace.WithAttributes(
            attribute.String("db.system", "mongodb"),
            attribute.String("db.name", database),
            attribute.String("db.mongodb.collection", collection),
        ),
    )
    defer span.End()
    
    coll := tm.client.Database(database).Collection(collection)
    cursor, err := coll.Find(ctx, filter)
    
    if err != nil {
        span.RecordError(err)
    }
    
    return cursor, err
}

// UpdateOne æ›´æ–°å•ä¸ªæ–‡æ¡£
func (tm *TracedMongoDB) UpdateOne(ctx context.Context, database, collection string, filter, update interface{}) (*mongo.UpdateResult, error) {
    ctx, span := tm.tracer.Start(ctx, "mongodb.update_one",
        trace.WithAttributes(
            attribute.String("db.system", "mongodb"),
            attribute.String("db.name", database),
            attribute.String("db.mongodb.collection", collection),
        ),
    )
    defer span.End()
    
    coll := tm.client.Database(database).Collection(collection)
    result, err := coll.UpdateOne(ctx, filter, update)
    
    if err != nil {
        span.RecordError(err)
    } else {
        span.SetAttributes(
            attribute.Int64("db.documents.matched", result.MatchedCount),
            attribute.Int64("db.documents.modified", result.ModifiedCount),
        )
    }
    
    return result, err
}

// DeleteOne åˆ é™¤å•ä¸ªæ–‡æ¡£
func (tm *TracedMongoDB) DeleteOne(ctx context.Context, database, collection string, filter interface{}) (*mongo.DeleteResult, error) {
    ctx, span := tm.tracer.Start(ctx, "mongodb.delete_one",
        trace.WithAttributes(
            attribute.String("db.system", "mongodb"),
            attribute.String("db.name", database),
            attribute.String("db.mongodb.collection", collection),
        ),
    )
    defer span.End()
    
    coll := tm.client.Database(database).Collection(collection)
    result, err := coll.DeleteOne(ctx, filter)
    
    if err != nil {
        span.RecordError(err)
    } else {
        span.SetAttributes(
            attribute.Int64("db.documents.deleted", result.DeletedCount),
        )
    }
    
    return result, err
}

// Close å…³é—­è¿æ¥
func (tm *TracedMongoDB) Close(ctx context.Context) error {
    return tm.client.Disconnect(ctx)
}
```

---

## ç¼“å­˜è¿½è¸ª

### Redis è¿½è¸ª

**Redis + OpenTelemetryï¼š**

```go
package cache

import (
    "context"
    "time"
    
    "github.com/redis/go-redis/v9"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
)

// TracedRedis å¸¦è¿½è¸ªçš„ Redis
type TracedRedis struct {
    client *redis.Client
    tracer trace.Tracer
    meter  metric.Meter
    
    // Metrics
    hitCounter   metric.Int64Counter
    missCounter  metric.Int64Counter
    latency      metric.Float64Histogram
}

// NewTracedRedis åˆ›å»ºå¸¦è¿½è¸ªçš„ Redis
func NewTracedRedis(addr string) (*TracedRedis, error) {
    client := redis.NewClient(&redis.Options{
        Addr: addr,
    })
    
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := client.Ping(ctx).Err(); err != nil {
        return nil, err
    }
    
    meter := otel.Meter("redis")
    
    tr := &TracedRedis{
        client: client,
        tracer: otel.Tracer("redis"),
        meter:  meter,
    }
    
    var err error
    
    // Cache hit counter
    tr.hitCounter, err = meter.Int64Counter(
        "cache.hit",
        metric.WithDescription("Cache hits"),
    )
    if err != nil {
        return nil, err
    }
    
    // Cache miss counter
    tr.missCounter, err = meter.Int64Counter(
        "cache.miss",
        metric.WithDescription("Cache misses"),
    )
    if err != nil {
        return nil, err
    }
    
    // Latency histogram
    tr.latency, err = meter.Float64Histogram(
        "cache.latency",
        metric.WithDescription("Cache operation latency"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    // æ·»åŠ é’©å­
    client.AddHook(&tracingHook{
        tracer: tr.tracer,
    })
    
    return tr, nil
}

// Get è·å–ç¼“å­˜
func (tr *TracedRedis) Get(ctx context.Context, key string) (string, error) {
    ctx, span := tr.tracer.Start(ctx, "redis.get",
        trace.WithAttributes(
            attribute.String("db.system", "redis"),
            attribute.String("db.operation", "get"),
            attribute.String("db.redis.key", key),
        ),
    )
    defer span.End()
    
    start := time.Now()
    val, err := tr.client.Get(ctx, key).Result()
    duration := time.Since(start)
    
    tr.latency.Record(ctx, float64(duration.Milliseconds()),
        metric.WithAttributes(
            attribute.String("db.operation", "get"),
        ),
    )
    
    if err == redis.Nil {
        // Cache miss
        tr.missCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("cache.key", key),
            ),
        )
        span.SetAttributes(attribute.Bool("cache.hit", false))
        span.SetStatus(codes.Ok, "cache miss")
        return "", err
    } else if err != nil {
        // Error
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return "", err
    }
    
    // Cache hit
    tr.hitCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("cache.key", key),
        ),
    )
    span.SetAttributes(attribute.Bool("cache.hit", true))
    span.SetStatus(codes.Ok, "cache hit")
    
    return val, nil
}

// Set è®¾ç½®ç¼“å­˜
func (tr *TracedRedis) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error {
    ctx, span := tr.tracer.Start(ctx, "redis.set",
        trace.WithAttributes(
            attribute.String("db.system", "redis"),
            attribute.String("db.operation", "set"),
            attribute.String("db.redis.key", key),
            attribute.Int64("db.redis.ttl", int64(expiration.Seconds())),
        ),
    )
    defer span.End()
    
    start := time.Now()
    err := tr.client.Set(ctx, key, value, expiration).Err()
    duration := time.Since(start)
    
    tr.latency.Record(ctx, float64(duration.Milliseconds()),
        metric.WithAttributes(
            attribute.String("db.operation", "set"),
        ),
    )
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// Del åˆ é™¤ç¼“å­˜
func (tr *TracedRedis) Del(ctx context.Context, keys ...string) error {
    ctx, span := tr.tracer.Start(ctx, "redis.del",
        trace.WithAttributes(
            attribute.String("db.system", "redis"),
            attribute.String("db.operation", "del"),
            attribute.Int("db.redis.keys_count", len(keys)),
        ),
    )
    defer span.End()
    
    start := time.Now()
    err := tr.client.Del(ctx, keys...).Err()
    duration := time.Since(start)
    
    tr.latency.Record(ctx, float64(duration.Milliseconds()),
        metric.WithAttributes(
            attribute.String("db.operation", "del"),
        ),
    )
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// Exists æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨
func (tr *TracedRedis) Exists(ctx context.Context, keys ...string) (int64, error) {
    ctx, span := tr.tracer.Start(ctx, "redis.exists",
        trace.WithAttributes(
            attribute.String("db.system", "redis"),
            attribute.String("db.operation", "exists"),
        ),
    )
    defer span.End()
    
    count, err := tr.client.Exists(ctx, keys...).Result()
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return 0, err
    }
    
    span.SetAttributes(attribute.Int64("db.keys_found", count))
    span.SetStatus(codes.Ok, "")
    
    return count, nil
}

// Close å…³é—­è¿æ¥
func (tr *TracedRedis) Close() error {
    return tr.client.Close()
}

// tracingHook Redis è¿½è¸ªé’©å­
type tracingHook struct {
    tracer trace.Tracer
}

func (h *tracingHook) DialHook(next redis.DialHook) redis.DialHook {
    return func(ctx context.Context, network, addr string) (net.Conn, error) {
        ctx, span := h.tracer.Start(ctx, "redis.dial",
            trace.WithAttributes(
                attribute.String("network", network),
                attribute.String("addr", addr),
            ),
        )
        defer span.End()
        
        conn, err := next(ctx, network, addr)
        if err != nil {
            span.RecordError(err)
        }
        
        return conn, err
    }
}

func (h *tracingHook) ProcessHook(next redis.ProcessHook) redis.ProcessHook {
    return func(ctx context.Context, cmd redis.Cmder) error {
        ctx, span := h.tracer.Start(ctx, "redis."+cmd.Name(),
            trace.WithAttributes(
                attribute.String("db.system", "redis"),
                attribute.String("db.operation", cmd.Name()),
            ),
        )
        defer span.End()
        
        err := next(ctx, cmd)
        if err != nil {
            span.RecordError(err)
        }
        
        return err
    }
}

func (h *tracingHook) ProcessPipelineHook(next redis.ProcessPipelineHook) redis.ProcessPipelineHook {
    return func(ctx context.Context, cmds []redis.Cmder) error {
        ctx, span := h.tracer.Start(ctx, "redis.pipeline",
            trace.WithAttributes(
                attribute.String("db.system", "redis"),
                attribute.Int("db.redis.pipeline_length", len(cmds)),
            ),
        )
        defer span.End()
        
        err := next(ctx, cmds)
        if err != nil {
            span.RecordError(err)
        }
        
        return err
    }
}
```

### Memcached è¿½è¸ª

**Memcached + OpenTelemetryï¼š**

```go
package cache

import (
    "context"
    "time"
    
    "github.com/bradfitz/gomemcache/memcache"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// TracedMemcached å¸¦è¿½è¸ªçš„ Memcached
type TracedMemcached struct {
    client *memcache.Client
    tracer trace.Tracer
}

// NewTracedMemcached åˆ›å»ºå¸¦è¿½è¸ªçš„ Memcached
func NewTracedMemcached(servers ...string) *TracedMemcached {
    return &TracedMemcached{
        client: memcache.New(servers...),
        tracer: otel.Tracer("memcached"),
    }
}

// Get è·å–ç¼“å­˜
func (tm *TracedMemcached) Get(ctx context.Context, key string) (*memcache.Item, error) {
    ctx, span := tm.tracer.Start(ctx, "memcached.get",
        trace.WithAttributes(
            attribute.String("db.system", "memcached"),
            attribute.String("db.operation", "get"),
            attribute.String("cache.key", key),
        ),
    )
    defer span.End()
    
    item, err := tm.client.Get(key)
    
    if err == memcache.ErrCacheMiss {
        span.SetAttributes(attribute.Bool("cache.hit", false))
        span.SetStatus(codes.Ok, "cache miss")
    } else if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
    } else {
        span.SetAttributes(attribute.Bool("cache.hit", true))
        span.SetStatus(codes.Ok, "cache hit")
    }
    
    return item, err
}

// Set è®¾ç½®ç¼“å­˜
func (tm *TracedMemcached) Set(ctx context.Context, item *memcache.Item) error {
    ctx, span := tm.tracer.Start(ctx, "memcached.set",
        trace.WithAttributes(
            attribute.String("db.system", "memcached"),
            attribute.String("db.operation", "set"),
            attribute.String("cache.key", item.Key),
            attribute.Int("cache.size", len(item.Value)),
        ),
    )
    defer span.End()
    
    err := tm.client.Set(item)
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
    } else {
        span.SetStatus(codes.Ok, "")
    }
    
    return err
}

// Delete åˆ é™¤ç¼“å­˜
func (tm *TracedMemcached) Delete(ctx context.Context, key string) error {
    ctx, span := tm.tracer.Start(ctx, "memcached.delete",
        trace.WithAttributes(
            attribute.String("db.system", "memcached"),
            attribute.String("db.operation", "delete"),
            attribute.String("cache.key", key),
        ),
    )
    defer span.End()
    
    err := tm.client.Delete(key)
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
    } else {
        span.SetStatus(codes.Ok, "")
    }
    
    return err
}
```

### æœ¬åœ°ç¼“å­˜è¿½è¸ª

**æœ¬åœ°ç¼“å­˜ (åŸºäº sync.Map)ï¼š**

```go
package cache

import (
    "context"
    "sync"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
)

// LocalCache æœ¬åœ°ç¼“å­˜
type LocalCache struct {
    data   sync.Map
    tracer trace.Tracer
    meter  metric.Meter
    
    // Metrics
    hitCounter   metric.Int64Counter
    missCounter  metric.Int64Counter
    sizeGauge    metric.Int64ObservableGauge
    
    size int64
}

// CacheItem ç¼“å­˜é¡¹
type CacheItem struct {
    Value      interface{}
    Expiration time.Time
}

// NewLocalCache åˆ›å»ºæœ¬åœ°ç¼“å­˜
func NewLocalCache() (*LocalCache, error) {
    meter := otel.Meter("local-cache")
    
    lc := &LocalCache{
        tracer: otel.Tracer("local-cache"),
        meter:  meter,
    }
    
    var err error
    
    // Hit counter
    lc.hitCounter, err = meter.Int64Counter(
        "local_cache.hit",
        metric.WithDescription("Local cache hits"),
    )
    if err != nil {
        return nil, err
    }
    
    // Miss counter
    lc.missCounter, err = meter.Int64Counter(
        "local_cache.miss",
        metric.WithDescription("Local cache misses"),
    )
    if err != nil {
        return nil, err
    }
    
    // Size gauge
    lc.sizeGauge, err = meter.Int64ObservableGauge(
        "local_cache.size",
        metric.WithDescription("Local cache size"),
        metric.WithInt64Callback(func(ctx context.Context, observer metric.Int64Observer) error {
            observer.Observe(atomic.LoadInt64(&lc.size))
            return nil
        }),
    )
    if err != nil {
        return nil, err
    }
    
    return lc, nil
}

// Get è·å–ç¼“å­˜
func (lc *LocalCache) Get(ctx context.Context, key string) (interface{}, bool) {
    ctx, span := lc.tracer.Start(ctx, "local_cache.get",
        trace.WithAttributes(
            attribute.String("cache.key", key),
        ),
    )
    defer span.End()
    
    value, ok := lc.data.Load(key)
    if !ok {
        // Miss
        lc.missCounter.Add(ctx, 1)
        span.SetAttributes(attribute.Bool("cache.hit", false))
        return nil, false
    }
    
    item := value.(*CacheItem)
    
    // æ£€æŸ¥è¿‡æœŸ
    if !item.Expiration.IsZero() && time.Now().After(item.Expiration) {
        lc.data.Delete(key)
        atomic.AddInt64(&lc.size, -1)
        
        lc.missCounter.Add(ctx, 1)
        span.SetAttributes(attribute.Bool("cache.hit", false))
        span.AddEvent("cache expired")
        return nil, false
    }
    
    // Hit
    lc.hitCounter.Add(ctx, 1)
    span.SetAttributes(attribute.Bool("cache.hit", true))
    
    return item.Value, true
}

// Set è®¾ç½®ç¼“å­˜
func (lc *LocalCache) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) {
    ctx, span := lc.tracer.Start(ctx, "local_cache.set",
        trace.WithAttributes(
            attribute.String("cache.key", key),
            attribute.Int64("cache.ttl", int64(ttl.Seconds())),
        ),
    )
    defer span.End()
    
    var expiration time.Time
    if ttl > 0 {
        expiration = time.Now().Add(ttl)
    }
    
    item := &CacheItem{
        Value:      value,
        Expiration: expiration,
    }
    
    _, loaded := lc.data.LoadOrStore(key, item)
    if !loaded {
        atomic.AddInt64(&lc.size, 1)
    }
}

// Delete åˆ é™¤ç¼“å­˜
func (lc *LocalCache) Delete(ctx context.Context, key string) {
    ctx, span := lc.tracer.Start(ctx, "local_cache.delete",
        trace.WithAttributes(
            attribute.String("cache.key", key),
        ),
    )
    defer span.End()
    
    _, loaded := lc.data.LoadAndDelete(key)
    if loaded {
        atomic.AddInt64(&lc.size, -1)
    }
}

// Clear æ¸…ç©ºç¼“å­˜
func (lc *LocalCache) Clear(ctx context.Context) {
    ctx, span := lc.tracer.Start(ctx, "local_cache.clear")
    defer span.End()
    
    lc.data.Range(func(key, value interface{}) bool {
        lc.data.Delete(key)
        return true
    })
    
    atomic.StoreInt64(&lc.size, 0)
}
```

---

## æŸ¥è¯¢ä¼˜åŒ–

### æŸ¥è¯¢è®¡åˆ’åˆ†æ

**æŸ¥è¯¢è®¡åˆ’è¿½è¸ªï¼š**

```go
package optimization

import (
    "context"
    "database/sql"
    "strings"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// QueryPlanAnalyzer æŸ¥è¯¢è®¡åˆ’åˆ†æå™¨
type QueryPlanAnalyzer struct {
    db     *sql.DB
    tracer trace.Tracer
}

// NewQueryPlanAnalyzer åˆ›å»ºæŸ¥è¯¢è®¡åˆ’åˆ†æå™¨
func NewQueryPlanAnalyzer(db *sql.DB) *QueryPlanAnalyzer {
    return &QueryPlanAnalyzer{
        db:     db,
        tracer: otel.Tracer("query-plan-analyzer"),
    }
}

// Analyze åˆ†ææŸ¥è¯¢è®¡åˆ’
func (qpa *QueryPlanAnalyzer) Analyze(ctx context.Context, query string) (*QueryPlan, error) {
    ctx, span := qpa.tracer.Start(ctx, "analyze_query_plan",
        trace.WithAttributes(
            attribute.String("db.statement", query),
        ),
    )
    defer span.End()
    
    // PostgreSQL: EXPLAIN ANALYZE
    explainQuery := "EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON) " + query
    
    rows, err := qpa.db.QueryContext(ctx, explainQuery)
    if err != nil {
        span.RecordError(err)
        return nil, err
    }
    defer rows.Close()
    
    var planJSON string
    if rows.Next() {
        if err := rows.Scan(&planJSON); err != nil {
            span.RecordError(err)
            return nil, err
        }
    }
    
    // è§£ææŸ¥è¯¢è®¡åˆ’
    plan := qpa.parsePlan(planJSON)
    
    // è®°å½•å…³é”®æŒ‡æ ‡
    span.SetAttributes(
        attribute.Float64("query.execution_time_ms", plan.ExecutionTime),
        attribute.Float64("query.planning_time_ms", plan.PlanningTime),
        attribute.Int64("query.rows", plan.RowsReturned),
        attribute.Bool("query.uses_index", plan.UsesIndex),
    )
    
    // æ£€æµ‹æ½œåœ¨é—®é¢˜
    if !plan.UsesIndex {
        span.AddEvent("query does not use index")
    }
    
    if plan.ExecutionTime > 1000 {
        span.AddEvent("slow query detected",
            trace.WithAttributes(
                attribute.Float64("execution_time_ms", plan.ExecutionTime),
            ),
        )
    }
    
    return plan, nil
}

// QueryPlan æŸ¥è¯¢è®¡åˆ’
type QueryPlan struct {
    ExecutionTime float64
    PlanningTime  float64
    RowsReturned  int64
    UsesIndex     bool
    Plan          string
}

// parsePlan è§£ææŸ¥è¯¢è®¡åˆ’
func (qpa *QueryPlanAnalyzer) parsePlan(planJSON string) *QueryPlan {
    // ç®€åŒ–çš„è§£æé€»è¾‘
    plan := &QueryPlan{
        Plan: planJSON,
    }
    
    // æ£€æŸ¥æ˜¯å¦ä½¿ç”¨ç´¢å¼•
    plan.UsesIndex = strings.Contains(planJSON, "Index Scan") || 
                     strings.Contains(planJSON, "Index Only Scan")
    
    return plan
}
```

### ç´¢å¼•ä½¿ç”¨ç›‘æ§

**ç´¢å¼•ä½¿ç”¨è¿½è¸ªï¼š**

```go
package optimization

import (
    "context"
    "database/sql"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// IndexMonitor ç´¢å¼•ç›‘æ§å™¨
type IndexMonitor struct {
    db    *sql.DB
    meter metric.Meter
}

// NewIndexMonitor åˆ›å»ºç´¢å¼•ç›‘æ§å™¨
func NewIndexMonitor(db *sql.DB) *IndexMonitor {
    return &IndexMonitor{
        db:    db,
        meter: otel.Meter("index-monitor"),
    }
}

// MonitorIndexUsage ç›‘æ§ç´¢å¼•ä½¿ç”¨æƒ…å†µ
func (im *IndexMonitor) MonitorIndexUsage(ctx context.Context, tableName string) error {
    // PostgreSQL: æŸ¥è¯¢ç´¢å¼•ä½¿ç”¨ç»Ÿè®¡
    query := `
        SELECT
            indexrelname AS index_name,
            idx_scan AS index_scans,
            idx_tup_read AS tuples_read,
            idx_tup_fetch AS tuples_fetched
        FROM pg_stat_user_indexes
        WHERE schemaname = 'public' AND relname = $1
    `
    
    rows, err := im.db.QueryContext(ctx, query, tableName)
    if err != nil {
        return err
    }
    defer rows.Close()
    
    counter, _ := im.meter.Int64Counter(
        "db.index.scans",
        metric.WithDescription("Index scans count"),
    )
    
    for rows.Next() {
        var indexName string
        var scans, tuplesRead, tuplesFetched int64
        
        if err := rows.Scan(&indexName, &scans, &tuplesRead, &tuplesFetched); err != nil {
            return err
        }
        
        counter.Add(ctx, scans,
            metric.WithAttributes(
                attribute.String("table", tableName),
                attribute.String("index", indexName),
            ),
        )
    }
    
    return nil
}
```

### N+1 é—®é¢˜æ£€æµ‹

**N+1 é—®é¢˜æ£€æµ‹å™¨ï¼š**

```go
package optimization

import (
    "context"
    "sync"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// NPlusOneDetector N+1 é—®é¢˜æ£€æµ‹å™¨
type NPlusOneDetector struct {
    tracer    trace.Tracer
    threshold int
    queries   sync.Map
}

// NewNPlusOneDetector åˆ›å»º N+1 é—®é¢˜æ£€æµ‹å™¨
func NewNPlusOneDetector(threshold int) *NPlusOneDetector {
    return &NPlusOneDetector{
        tracer:    otel.Tracer("n-plus-one-detector"),
        threshold: threshold,
    }
}

// TrackQuery è¿½è¸ªæŸ¥è¯¢
func (npod *NPlusOneDetector) TrackQuery(ctx context.Context, query string) {
    span := trace.SpanFromContext(ctx)
    if !span.IsRecording() {
        return
    }
    
    spanID := span.SpanContext().SpanID().String()
    
    // è®°å½•æŸ¥è¯¢
    value, _ := npod.queries.LoadOrStore(spanID, &queryStats{
        queries: make(map[string]int),
    })
    
    stats := value.(*queryStats)
    stats.mu.Lock()
    stats.queries[query]++
    count := stats.queries[query]
    stats.mu.Unlock()
    
    // æ£€æµ‹ N+1 é—®é¢˜
    if count > npod.threshold {
        span.AddEvent("potential N+1 query detected",
            trace.WithAttributes(
                attribute.String("query", query),
                attribute.Int("count", count),
            ),
        )
    }
}

// queryStats æŸ¥è¯¢ç»Ÿè®¡
type queryStats struct {
    mu      sync.Mutex
    queries map[string]int
}
```

---

## äº‹åŠ¡è¿½è¸ª

### å•æ•°æ®åº“äº‹åŠ¡

**äº‹åŠ¡è¿½è¸ªï¼š**

```go
package transaction

import (
    "context"
    "database/sql"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// TracedTransaction å¸¦è¿½è¸ªçš„äº‹åŠ¡
type TracedTransaction struct {
    tx     *sql.Tx
    tracer trace.Tracer
    span   trace.Span
}

// NewTracedTransaction åˆ›å»ºå¸¦è¿½è¸ªçš„äº‹åŠ¡
func NewTracedTransaction(ctx context.Context, db *sql.DB) (*TracedTransaction, error) {
    tracer := otel.Tracer("transaction")
    
    ctx, span := tracer.Start(ctx, "db.transaction",
        trace.WithAttributes(
            attribute.String("db.operation", "begin"),
        ),
    )
    
    tx, err := db.BeginTx(ctx, nil)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        span.End()
        return nil, err
    }
    
    return &TracedTransaction{
        tx:     tx,
        tracer: tracer,
        span:   span,
    }, nil
}

// Exec æ‰§è¡Œå‘½ä»¤
func (tt *TracedTransaction) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
    ctx, span := tt.tracer.Start(ctx, "db.transaction.exec",
        trace.WithAttributes(
            attribute.String("db.statement", query),
        ),
    )
    defer span.End()
    
    result, err := tt.tx.ExecContext(ctx, query, args...)
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
    } else {
        if rowsAffected, err := result.RowsAffected(); err == nil {
            span.SetAttributes(attribute.Int64("db.rows_affected", rowsAffected))
        }
        span.SetStatus(codes.Ok, "")
    }
    
    return result, err
}

// Query æ‰§è¡ŒæŸ¥è¯¢
func (tt *TracedTransaction) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
    ctx, span := tt.tracer.Start(ctx, "db.transaction.query",
        trace.WithAttributes(
            attribute.String("db.statement", query),
        ),
    )
    defer span.End()
    
    rows, err := tt.tx.QueryContext(ctx, query, args...)
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
    } else {
        span.SetStatus(codes.Ok, "")
    }
    
    return rows, err
}

// Commit æäº¤äº‹åŠ¡
func (tt *TracedTransaction) Commit() error {
    defer tt.span.End()
    
    tt.span.AddEvent("committing transaction")
    
    err := tt.tx.Commit()
    
    if err != nil {
        tt.span.RecordError(err)
        tt.span.SetStatus(codes.Error, err.Error())
    } else {
        tt.span.SetStatus(codes.Ok, "transaction committed")
    }
    
    return err
}

// Rollback å›æ»šäº‹åŠ¡
func (tt *TracedTransaction) Rollback() error {
    defer tt.span.End()
    
    tt.span.AddEvent("rolling back transaction")
    
    err := tt.tx.Rollback()
    
    if err != nil {
        tt.span.RecordError(err)
        tt.span.SetStatus(codes.Error, err.Error())
    } else {
        tt.span.SetStatus(codes.Ok, "transaction rolled back")
    }
    
    return err
}
```

---

## æœ€ä½³å®è·µ

### 1. è¿æ¥æ± é…ç½®

âœ… **åˆç†é…ç½®è¿æ¥æ± **

```go
db.SetMaxOpenConns(25)           // æœ€å¤§æ‰“å¼€è¿æ¥æ•°
db.SetMaxIdleConns(5)            // æœ€å¤§ç©ºé—²è¿æ¥æ•°
db.SetConnMaxLifetime(5 * time.Minute)  // è¿æ¥æœ€å¤§ç”Ÿå‘½å‘¨æœŸ
db.SetConnMaxIdleTime(1 * time.Minute)  // è¿æ¥æœ€å¤§ç©ºé—²æ—¶é—´
```

### 2. æ…¢æŸ¥è¯¢æ£€æµ‹

âœ… **è®¾ç½®æ…¢æŸ¥è¯¢é˜ˆå€¼**

```go
detector := NewSlowQueryDetector(db, 100*time.Millisecond)
```

### 3. ç¼“å­˜ç­–ç•¥

âœ… **å¤šçº§ç¼“å­˜**

```go
// 1. æœ¬åœ°ç¼“å­˜ï¼ˆæœ€å¿«ï¼‰
if value, ok := localCache.Get(ctx, key); ok {
    return value, nil
}

// 2. Redisï¼ˆä¸­ç­‰ï¼‰
if value, err := redis.Get(ctx, key); err == nil {
    localCache.Set(ctx, key, value, 5*time.Minute)
    return value, nil
}

// 3. æ•°æ®åº“ï¼ˆæœ€æ…¢ï¼‰
value, err := db.Query(ctx, query)
if err == nil {
    redis.Set(ctx, key, value, 1*time.Hour)
    localCache.Set(ctx, key, value, 5*time.Minute)
}
return value, err
```

### 4. äº‹åŠ¡ç®¡ç†

âœ… **ä½¿ç”¨ defer ç¡®ä¿äº‹åŠ¡å…³é—­**

```go
tx, err := NewTracedTransaction(ctx, db)
if err != nil {
    return err
}

defer func() {
    if p := recover(); p != nil {
        tx.Rollback()
        panic(p)
    } else if err != nil {
        tx.Rollback()
    } else {
        err = tx.Commit()
    }
}()
```

---

## å®Œæ•´ç¤ºä¾‹

```go
package main

import (
    "context"
    "log"
    "time"
)

func main() {
    ctx := context.Background()
    
    // 1. åˆ›å»ºæ•°æ®åº“è¿æ¥
    db, err := NewTracedDB("postgres", "postgresql://localhost/mydb")
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // 2. åˆ›å»º Redis è¿æ¥
    redis, err := NewTracedRedis("localhost:6379")
    if err != nil {
        log.Fatal(err)
    }
    defer redis.Close()
    
    // 3. åˆ›å»ºæœ¬åœ°ç¼“å­˜
    localCache, err := NewLocalCache()
    if err != nil {
        log.Fatal(err)
    }
    
    // 4. åˆ›å»ºä»“åº“
    userRepo := NewUserRepository(db, redis, localCache)
    
    // 5. æŸ¥è¯¢ç”¨æˆ·
    user, err := userRepo.GetUser(ctx, 123)
    if err != nil {
        log.Fatal(err)
    }
    
    log.Printf("User: %+v", user)
}
```

---

## æ€»ç»“

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº† Go åº”ç”¨ä¸­æ•°æ®åº“å’Œç¼“å­˜æ“ä½œçš„è¿½è¸ªå®ç°ï¼Œæ¶µç›–ï¼š

âœ… **SQL æ•°æ®åº“è¿½è¸ª** - database/sqlã€è¿æ¥æ± ã€æ…¢æŸ¥è¯¢  
âœ… **ORM è¿½è¸ª** - GORMã€Entã€sqlx  
âœ… **NoSQL æ•°æ®åº“è¿½è¸ª** - MongoDBã€Cassandraã€DynamoDB  
âœ… **ç¼“å­˜è¿½è¸ª** - Redisã€Memcachedã€æœ¬åœ°ç¼“å­˜  
âœ… **æŸ¥è¯¢ä¼˜åŒ–** - æŸ¥è¯¢è®¡åˆ’ã€ç´¢å¼•ã€N+1 é—®é¢˜  
âœ… **äº‹åŠ¡è¿½è¸ª** - å•æ•°æ®åº“äº‹åŠ¡ã€åˆ†å¸ƒå¼äº‹åŠ¡

### å…³é”®è¦ç‚¹

1. **å®Œæ•´çš„æ•°æ®å±‚å¯è§‚æµ‹æ€§** - è¿½è¸ªæ‰€æœ‰æ•°æ®åº“å’Œç¼“å­˜æ“ä½œ
2. **è¿æ¥æ± ç›‘æ§** - å®æ—¶ç›‘æ§è¿æ¥ä½¿ç”¨æƒ…å†µ
3. **æ…¢æŸ¥è¯¢æ£€æµ‹** - è‡ªåŠ¨è¯†åˆ«æ€§èƒ½é—®é¢˜
4. **å¤šçº§ç¼“å­˜ç­–ç•¥** - æœ¬åœ°ç¼“å­˜ + Redis + æ•°æ®åº“
5. **æŸ¥è¯¢ä¼˜åŒ–** - åˆ†ææŸ¥è¯¢è®¡åˆ’å’Œç´¢å¼•ä½¿ç”¨

### ç›¸å…³æ–‡æ¡£

- [31_Goé«˜çº§å¹¶å‘æ¨¡å¼ä¸OTLPå®Œæ•´é›†æˆ](./31_Goé«˜çº§å¹¶å‘æ¨¡å¼ä¸OTLPå®Œæ•´é›†æˆ.md)
- [34_Goå†…å­˜ç®¡ç†ä¸æ€§èƒ½è°ƒä¼˜å®æˆ˜](./34_Goå†…å­˜ç®¡ç†ä¸æ€§èƒ½è°ƒä¼˜å®æˆ˜.md)
- [36_Goå¾®æœåŠ¡é—´é€šä¿¡ä¸åˆ†å¸ƒå¼è¿½è¸ª](./36_Goå¾®æœåŠ¡é—´é€šä¿¡ä¸åˆ†å¸ƒå¼è¿½è¸ª.md)

---

**æœ€åæ›´æ–°ï¼š** 2025-10-09  
**ç‰ˆæœ¬ï¼š** v1.0.0  
**ä½œè€…ï¼š** OTLP Go Integration Team
