# Go 数据库与缓存集成追踪完整指南

## 📋 目录

- [Go 数据库与缓存集成追踪完整指南](#go-数据库与缓存集成追踪完整指南)
  - [📋 目录](#-目录)
  - [文档概述](#文档概述)
    - [核心价值](#核心价值)
    - [依赖版本](#依赖版本)
  - [SQL 数据库追踪](#sql-数据库追踪)
    - [database/sql 集成](#databasesql-集成)
    - [连接池监控](#连接池监控)
    - [慢查询追踪](#慢查询追踪)
  - [ORM 追踪](#orm-追踪)
    - [GORM 集成](#gorm-集成)
    - [Ent 集成](#ent-集成)
    - [sqlx 集成](#sqlx-集成)
  - [NoSQL 数据库追踪](#nosql-数据库追踪)
    - [MongoDB 追踪](#mongodb-追踪)
  - [缓存追踪](#缓存追踪)
    - [Redis 追踪](#redis-追踪)
    - [Memcached 追踪](#memcached-追踪)
    - [本地缓存追踪](#本地缓存追踪)
  - [查询优化](#查询优化)
    - [查询计划分析](#查询计划分析)
    - [索引使用监控](#索引使用监控)
    - [N+1 问题检测](#n1-问题检测)
  - [事务追踪](#事务追踪)
    - [单数据库事务](#单数据库事务)
  - [最佳实践](#最佳实践)
    - [1. 连接池配置](#1-连接池配置)
    - [2. 慢查询检测](#2-慢查询检测)
    - [3. 缓存策略](#3-缓存策略)
    - [4. 事务管理](#4-事务管理)
  - [完整示例](#完整示例)
  - [总结](#总结)
    - [关键要点](#关键要点)
    - [相关文档](#相关文档)

---

## 文档概述

本文档详细介绍 Go 应用中数据库和缓存操作的追踪实现，涵盖 SQL、NoSQL、ORM 和缓存系统。

### 核心价值

✅ **完整的数据层追踪** - SQL、NoSQL、Cache 全覆盖  
✅ **连接池监控** - 实时监控连接使用情况  
✅ **慢查询检测** - 自动识别性能问题  
✅ **ORM 集成** - GORM、Ent、sqlx 支持  
✅ **查询优化** - 分析查询计划和索引使用

### 依赖版本

```go
go.opentelemetry.io/otel v1.32.0
go.opentelemetry.io/contrib/instrumentation/database/sql/otelsql v0.57.0
gorm.io/gorm v1.25.12
gorm.io/plugin/opentelemetry v0.1.4
entgo.io/ent v0.14.1
github.com/jmoiron/sqlx v1.4.0
github.com/redis/go-redis/v9 v9.7.0
github.com/bradfitz/gomemcache v0.0.0-20230905024940-24af94b03874
go.mongodb.org/mongo-driver v1.17.1
```

---

## SQL 数据库追踪

### database/sql 集成

**带追踪的 SQL Driver：**

```go
package database

import (
    "context"
    "database/sql"
    "time"
    
    "go.opentelemetry.io/contrib/instrumentation/database/sql/otelsql"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
    semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
)

// TracedDB 带追踪的数据库连接
type TracedDB struct {
    db     *sql.DB
    meter  metric.Meter
    
    // Metrics
    queryDuration      metric.Float64Histogram
    queryCounter       metric.Int64Counter
    connectionActive   metric.Int64ObservableGauge
    connectionIdle     metric.Int64ObservableGauge
    connectionWait     metric.Int64ObservableGauge
}

// NewTracedDB 创建带追踪的数据库连接
func NewTracedDB(driverName, dsn string) (*TracedDB, error) {
    // 注册带追踪的 Driver
    driverName, err := otelsql.Register(driverName,
        otelsql.WithAttributes(
            semconv.DBSystemKey.String(driverName),
        ),
        otelsql.WithSpanOptions(
            otelsql.SpanOptions{
                Ping:                 true,
                RowsNext:             true,
                DisableErrSkip:       true,
                DisableQuery:         false,
                OmitConnResetSession: false,
                OmitRows:             false,
            },
        ),
    )
    if err != nil {
        return nil, err
    }
    
    // 打开数据库
    db, err := sql.Open(driverName, dsn)
    if err != nil {
        return nil, err
    }
    
    // 配置连接池
    db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(5)
    db.SetConnMaxLifetime(5 * time.Minute)
    db.SetConnMaxIdleTime(1 * time.Minute)
    
    meter := otel.Meter("database")
    
    td := &TracedDB{
        db:    db,
        meter: meter,
    }
    
    // 查询持续时间
    td.queryDuration, err = meter.Float64Histogram(
        "db.query.duration",
        metric.WithDescription("Database query duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    // 查询计数器
    td.queryCounter, err = meter.Int64Counter(
        "db.query.count",
        metric.WithDescription("Database query count"),
    )
    if err != nil {
        return nil, err
    }
    
    // 活跃连接数
    td.connectionActive, err = meter.Int64ObservableGauge(
        "db.connections.active",
        metric.WithDescription("Active database connections"),
        metric.WithInt64Callback(func(ctx context.Context, observer metric.Int64Observer) error {
            stats := db.Stats()
            observer.Observe(int64(stats.InUse))
            return nil
        }),
    )
    if err != nil {
        return nil, err
    }
    
    // 空闲连接数
    td.connectionIdle, err = meter.Int64ObservableGauge(
        "db.connections.idle",
        metric.WithDescription("Idle database connections"),
        metric.WithInt64Callback(func(ctx context.Context, observer metric.Int64Observer) error {
            stats := db.Stats()
            observer.Observe(int64(stats.Idle))
            return nil
        }),
    )
    if err != nil {
        return nil, err
    }
    
    // 等待连接数
    td.connectionWait, err = meter.Int64ObservableGauge(
        "db.connections.wait",
        metric.WithDescription("Waiting database connections"),
        metric.WithInt64Callback(func(ctx context.Context, observer metric.Int64Observer) error {
            stats := db.Stats()
            observer.Observe(stats.WaitCount)
            return nil
        }),
    )
    if err != nil {
        return nil, err
    }
    
    // 记录数据库统计
    if err := otelsql.RecordStats(db); err != nil {
        return nil, err
    }
    
    return td, nil
}

// Query 执行查询
func (td *TracedDB) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
    start := time.Now()
    
    rows, err := td.db.QueryContext(ctx, query, args...)
    
    duration := time.Since(start)
    
    // 记录 Metrics
    attrs := []attribute.KeyValue{
        attribute.String("db.operation", "query"),
    }
    
    if err != nil {
        attrs = append(attrs, attribute.Bool("error", true))
    } else {
        attrs = append(attrs, attribute.Bool("error", false))
    }
    
    td.queryCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
    td.queryDuration.Record(ctx, float64(duration.Milliseconds()), metric.WithAttributes(attrs...))
    
    return rows, err
}

// QueryRow 执行单行查询
func (td *TracedDB) QueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row {
    start := time.Now()
    
    row := td.db.QueryRowContext(ctx, query, args...)
    
    duration := time.Since(start)
    
    // 记录 Metrics
    td.queryCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("db.operation", "query_row"),
        ),
    )
    td.queryDuration.Record(ctx, float64(duration.Milliseconds()),
        metric.WithAttributes(
            attribute.String("db.operation", "query_row"),
        ),
    )
    
    return row
}

// Exec 执行命令
func (td *TracedDB) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
    start := time.Now()
    
    result, err := td.db.ExecContext(ctx, query, args...)
    
    duration := time.Since(start)
    
    // 记录 Metrics
    attrs := []attribute.KeyValue{
        attribute.String("db.operation", "exec"),
    }
    
    if err != nil {
        attrs = append(attrs, attribute.Bool("error", true))
    } else {
        attrs = append(attrs, attribute.Bool("error", false))
        
        if rowsAffected, err := result.RowsAffected(); err == nil {
            attrs = append(attrs, attribute.Int64("db.rows_affected", rowsAffected))
        }
    }
    
    td.queryCounter.Add(ctx, 1, metric.WithAttributes(attrs...))
    td.queryDuration.Record(ctx, float64(duration.Milliseconds()), metric.WithAttributes(attrs...))
    
    return result, err
}

// Begin 开始事务
func (td *TracedDB) Begin(ctx context.Context) (*sql.Tx, error) {
    return td.db.BeginTx(ctx, nil)
}

// Stats 获取统计信息
func (td *TracedDB) Stats() sql.DBStats {
    return td.db.Stats()
}

// Close 关闭连接
func (td *TracedDB) Close() error {
    return td.db.Close()
}

// DB 获取原始 DB
func (td *TracedDB) DB() *sql.DB {
    return td.db
}
```

### 连接池监控

**连接池监控器：**

```go
package database

import (
    "context"
    "database/sql"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// PoolMonitor 连接池监控器
type PoolMonitor struct {
    db     *sql.DB
    meter  metric.Meter
    ticker *time.Ticker
    done   chan struct{}
}

// NewPoolMonitor 创建连接池监控器
func NewPoolMonitor(db *sql.DB, interval time.Duration) (*PoolMonitor, error) {
    meter := otel.Meter("pool-monitor")
    
    pm := &PoolMonitor{
        db:     db,
        meter:  meter,
        ticker: time.NewTicker(interval),
        done:   make(chan struct{}),
    }
    
    return pm, nil
}

// Start 启动监控
func (pm *PoolMonitor) Start(ctx context.Context) {
    go func() {
        for {
            select {
            case <-pm.ticker.C:
                pm.recordStats(ctx)
            case <-pm.done:
                return
            case <-ctx.Done():
                return
            }
        }
    }()
}

// Stop 停止监控
func (pm *PoolMonitor) Stop() {
    pm.ticker.Stop()
    close(pm.done)
}

// recordStats 记录统计信息
func (pm *PoolMonitor) recordStats(ctx context.Context) {
    stats := pm.db.Stats()
    
    // 使用 Gauge 记录当前值
    maxOpenConns, _ := pm.meter.Int64ObservableGauge(
        "db.pool.max_open",
        metric.WithDescription("Maximum open connections"),
    )
    
    openConns, _ := pm.meter.Int64ObservableGauge(
        "db.pool.open",
        metric.WithDescription("Open connections"),
    )
    
    inUse, _ := pm.meter.Int64ObservableGauge(
        "db.pool.in_use",
        metric.WithDescription("Connections in use"),
    )
    
    idle, _ := pm.meter.Int64ObservableGauge(
        "db.pool.idle",
        metric.WithDescription("Idle connections"),
    )
    
    waitCount, _ := pm.meter.Int64Counter(
        "db.pool.wait_count",
        metric.WithDescription("Total wait count"),
    )
    
    waitDuration, _ := pm.meter.Float64Histogram(
        "db.pool.wait_duration",
        metric.WithDescription("Wait duration"),
        metric.WithUnit("ms"),
    )
}

// PoolStats 连接池统计
type PoolStats struct {
    MaxOpenConnections int
    OpenConnections    int
    InUse              int
    Idle               int
    WaitCount          int64
    WaitDuration       time.Duration
    MaxIdleClosed      int64
    MaxIdleTimeClosed  int64
    MaxLifetimeClosed  int64
}

// GetPoolStats 获取连接池统计
func (pm *PoolMonitor) GetPoolStats() PoolStats {
    stats := pm.db.Stats()
    
    return PoolStats{
        MaxOpenConnections: stats.MaxOpenConnections,
        OpenConnections:    stats.OpenConnections,
        InUse:              stats.InUse,
        Idle:               stats.Idle,
        WaitCount:          stats.WaitCount,
        WaitDuration:       stats.WaitDuration,
        MaxIdleClosed:      stats.MaxIdleClosed,
        MaxIdleTimeClosed:  stats.MaxIdleTimeClosed,
        MaxLifetimeClosed:  stats.MaxLifetimeClosed,
    }
}
```

### 慢查询追踪

**慢查询检测器：**

```go
package database

import (
    "context"
    "database/sql"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// SlowQueryDetector 慢查询检测器
type SlowQueryDetector struct {
    db        *TracedDB
    threshold time.Duration
    tracer    trace.Tracer
}

// NewSlowQueryDetector 创建慢查询检测器
func NewSlowQueryDetector(db *TracedDB, threshold time.Duration) *SlowQueryDetector {
    return &SlowQueryDetector{
        db:        db,
        threshold: threshold,
        tracer:    otel.Tracer("slow-query-detector"),
    }
}

// Query 执行查询并检测慢查询
func (sqd *SlowQueryDetector) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
    ctx, span := sqd.tracer.Start(ctx, "slow-query-check",
        trace.WithAttributes(
            attribute.String("db.statement", query),
        ),
    )
    defer span.End()
    
    start := time.Now()
    rows, err := sqd.db.Query(ctx, query, args...)
    duration := time.Since(start)
    
    span.SetAttributes(
        attribute.Int64("db.duration_ms", duration.Milliseconds()),
    )
    
    // 检测慢查询
    if duration > sqd.threshold {
        span.AddEvent("slow query detected",
            trace.WithAttributes(
                attribute.Int64("db.duration_ms", duration.Milliseconds()),
                attribute.Int64("db.threshold_ms", sqd.threshold.Milliseconds()),
                attribute.String("db.statement", query),
            ),
        )
        
        // 记录慢查询日志
        log.Printf("SLOW QUERY: %dms > %dms: %s", 
            duration.Milliseconds(), 
            sqd.threshold.Milliseconds(), 
            query,
        )
    }
    
    return rows, err
}

// Exec 执行命令并检测慢查询
func (sqd *SlowQueryDetector) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
    ctx, span := sqd.tracer.Start(ctx, "slow-query-check",
        trace.WithAttributes(
            attribute.String("db.statement", query),
        ),
    )
    defer span.End()
    
    start := time.Now()
    result, err := sqd.db.Exec(ctx, query, args...)
    duration := time.Since(start)
    
    span.SetAttributes(
        attribute.Int64("db.duration_ms", duration.Milliseconds()),
    )
    
    // 检测慢查询
    if duration > sqd.threshold {
        span.AddEvent("slow query detected",
            trace.WithAttributes(
                attribute.Int64("db.duration_ms", duration.Milliseconds()),
                attribute.Int64("db.threshold_ms", sqd.threshold.Milliseconds()),
                attribute.String("db.statement", query),
            ),
        )
        
        // 记录慢查询日志
        log.Printf("SLOW QUERY: %dms > %dms: %s", 
            duration.Milliseconds(), 
            sqd.threshold.Milliseconds(), 
            query,
        )
    }
    
    return result, err
}
```

---

## ORM 追踪

### GORM 集成

**GORM + OpenTelemetry：**

```go
package orm

import (
    "gorm.io/driver/postgres"
    "gorm.io/gorm"
    "gorm.io/gorm/logger"
    "gorm.io/plugin/opentelemetry/tracing"
)

// NewTracedGORM 创建带追踪的 GORM
func NewTracedGORM(dsn string) (*gorm.DB, error) {
    db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{
        Logger: logger.Default.LogMode(logger.Info),
    })
    if err != nil {
        return nil, err
    }
    
    // 注册 OpenTelemetry 插件
    if err := db.Use(tracing.NewPlugin()); err != nil {
        return nil, err
    }
    
    return db, nil
}

// User 用户模型
type User struct {
    ID    uint   `gorm:"primaryKey"`
    Name  string `gorm:"size:100"`
    Email string `gorm:"size:100;uniqueIndex"`
}

// UserRepository 用户仓库
type UserRepository struct {
    db *gorm.DB
}

// NewUserRepository 创建用户仓库
func NewUserRepository(db *gorm.DB) *UserRepository {
    return &UserRepository{db: db}
}

// Create 创建用户
func (r *UserRepository) Create(ctx context.Context, user *User) error {
    // GORM 会自动创建 Span
    return r.db.WithContext(ctx).Create(user).Error
}

// FindByID 根据 ID 查找用户
func (r *UserRepository) FindByID(ctx context.Context, id uint) (*User, error) {
    var user User
    err := r.db.WithContext(ctx).First(&user, id).Error
    if err != nil {
        return nil, err
    }
    return &user, nil
}

// FindByEmail 根据邮箱查找用户
func (r *UserRepository) FindByEmail(ctx context.Context, email string) (*User, error) {
    var user User
    err := r.db.WithContext(ctx).Where("email = ?", email).First(&user).Error
    if err != nil {
        return nil, err
    }
    return &user, nil
}

// Update 更新用户
func (r *UserRepository) Update(ctx context.Context, user *User) error {
    return r.db.WithContext(ctx).Save(user).Error
}

// Delete 删除用户
func (r *UserRepository) Delete(ctx context.Context, id uint) error {
    return r.db.WithContext(ctx).Delete(&User{}, id).Error
}

// FindAll 查找所有用户（带分页）
func (r *UserRepository) FindAll(ctx context.Context, page, pageSize int) ([]*User, error) {
    var users []*User
    offset := (page - 1) * pageSize
    
    err := r.db.WithContext(ctx).
        Offset(offset).
        Limit(pageSize).
        Find(&users).Error
    
    if err != nil {
        return nil, err
    }
    
    return users, nil
}
```

### Ent 集成

**Ent + OpenTelemetry：**

```go
package orm

import (
    "context"
    
    "entgo.io/ent/dialect"
    "entgo.io/ent/dialect/sql"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
    
    _ "github.com/lib/pq"
)

// NewTracedEntClient 创建带追踪的 Ent Client
func NewTracedEntClient(dsn string) (*ent.Client, error) {
    drv, err := sql.Open(dialect.Postgres, dsn)
    if err != nil {
        return nil, err
    }
    
    // 添加追踪钩子
    drv.Exec = func(ctx context.Context, query string, args, v interface{}) error {
        tracer := otel.Tracer("ent")
        ctx, span := tracer.Start(ctx, "ent.exec",
            trace.WithAttributes(
                attribute.String("db.system", "postgresql"),
                attribute.String("db.statement", query),
            ),
        )
        defer span.End()
        
        return drv.Driver.Exec(ctx, query, args, v)
    }
    
    drv.Query = func(ctx context.Context, query string, args, v interface{}) error {
        tracer := otel.Tracer("ent")
        ctx, span := tracer.Start(ctx, "ent.query",
            trace.WithAttributes(
                attribute.String("db.system", "postgresql"),
                attribute.String("db.statement", query),
            ),
        )
        defer span.End()
        
        return drv.Driver.Query(ctx, query, args, v)
    }
    
    client := ent.NewClient(ent.Driver(drv))
    
    return client, nil
}
```

### sqlx 集成

**sqlx + OpenTelemetry：**

```go
package orm

import (
    "context"
    "time"
    
    "github.com/jmoiron/sqlx"
    _ "github.com/lib/pq"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// TracedSQLX 带追踪的 sqlx
type TracedSQLX struct {
    db     *sqlx.DB
    tracer trace.Tracer
}

// NewTracedSQLX 创建带追踪的 sqlx
func NewTracedSQLX(driverName, dsn string) (*TracedSQLX, error) {
    db, err := sqlx.Connect(driverName, dsn)
    if err != nil {
        return nil, err
    }
    
    return &TracedSQLX{
        db:     db,
        tracer: otel.Tracer("sqlx"),
    }, nil
}

// Get 查询单条记录
func (ts *TracedSQLX) Get(ctx context.Context, dest interface{}, query string, args ...interface{}) error {
    ctx, span := ts.tracer.Start(ctx, "sqlx.get",
        trace.WithAttributes(
            attribute.String("db.statement", query),
        ),
    )
    defer span.End()
    
    start := time.Now()
    err := ts.db.GetContext(ctx, dest, query, args...)
    duration := time.Since(start)
    
    span.SetAttributes(
        attribute.Int64("db.duration_ms", duration.Milliseconds()),
    )
    
    if err != nil {
        span.RecordError(err)
    }
    
    return err
}

// Select 查询多条记录
func (ts *TracedSQLX) Select(ctx context.Context, dest interface{}, query string, args ...interface{}) error {
    ctx, span := ts.tracer.Start(ctx, "sqlx.select",
        trace.WithAttributes(
            attribute.String("db.statement", query),
        ),
    )
    defer span.End()
    
    start := time.Now()
    err := ts.db.SelectContext(ctx, dest, query, args...)
    duration := time.Since(start)
    
    span.SetAttributes(
        attribute.Int64("db.duration_ms", duration.Milliseconds()),
    )
    
    if err != nil {
        span.RecordError(err)
    }
    
    return err
}

// Exec 执行命令
func (ts *TracedSQLX) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
    ctx, span := ts.tracer.Start(ctx, "sqlx.exec",
        trace.WithAttributes(
            attribute.String("db.statement", query),
        ),
    )
    defer span.End()
    
    start := time.Now()
    result, err := ts.db.ExecContext(ctx, query, args...)
    duration := time.Since(start)
    
    span.SetAttributes(
        attribute.Int64("db.duration_ms", duration.Milliseconds()),
    )
    
    if err != nil {
        span.RecordError(err)
    } else {
        if rowsAffected, err := result.RowsAffected(); err == nil {
            span.SetAttributes(
                attribute.Int64("db.rows_affected", rowsAffected),
            )
        }
    }
    
    return result, err
}

// NamedExec 执行命名参数命令
func (ts *TracedSQLX) NamedExec(ctx context.Context, query string, arg interface{}) (sql.Result, error) {
    ctx, span := ts.tracer.Start(ctx, "sqlx.named_exec",
        trace.WithAttributes(
            attribute.String("db.statement", query),
        ),
    )
    defer span.End()
    
    start := time.Now()
    result, err := ts.db.NamedExecContext(ctx, query, arg)
    duration := time.Since(start)
    
    span.SetAttributes(
        attribute.Int64("db.duration_ms", duration.Milliseconds()),
    )
    
    if err != nil {
        span.RecordError(err)
    }
    
    return result, err
}
```

---

## NoSQL 数据库追踪

### MongoDB 追踪

**MongoDB + OpenTelemetry：**

```go
package nosql

import (
    "context"
    "time"
    
    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
    "go.opentelemetry.io/contrib/instrumentation/go.mongodb.org/mongo-driver/mongo/otelmongo"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// TracedMongoDB 带追踪的 MongoDB
type TracedMongoDB struct {
    client *mongo.Client
    tracer trace.Tracer
}

// NewTracedMongoDB 创建带追踪的 MongoDB
func NewTracedMongoDB(uri string) (*TracedMongoDB, error) {
    // 创建带追踪的 Client 选项
    opts := options.Client().
        ApplyURI(uri).
        SetMonitor(otelmongo.NewMonitor())
    
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    client, err := mongo.Connect(ctx, opts)
    if err != nil {
        return nil, err
    }
    
    // Ping 测试连接
    if err := client.Ping(ctx, nil); err != nil {
        return nil, err
    }
    
    return &TracedMongoDB{
        client: client,
        tracer: otel.Tracer("mongodb"),
    }, nil
}

// InsertOne 插入单个文档
func (tm *TracedMongoDB) InsertOne(ctx context.Context, database, collection string, document interface{}) (*mongo.InsertOneResult, error) {
    ctx, span := tm.tracer.Start(ctx, "mongodb.insert_one",
        trace.WithAttributes(
            attribute.String("db.system", "mongodb"),
            attribute.String("db.name", database),
            attribute.String("db.mongodb.collection", collection),
        ),
    )
    defer span.End()
    
    coll := tm.client.Database(database).Collection(collection)
    result, err := coll.InsertOne(ctx, document)
    
    if err != nil {
        span.RecordError(err)
    }
    
    return result, err
}

// FindOne 查找单个文档
func (tm *TracedMongoDB) FindOne(ctx context.Context, database, collection string, filter interface{}, result interface{}) error {
    ctx, span := tm.tracer.Start(ctx, "mongodb.find_one",
        trace.WithAttributes(
            attribute.String("db.system", "mongodb"),
            attribute.String("db.name", database),
            attribute.String("db.mongodb.collection", collection),
        ),
    )
    defer span.End()
    
    coll := tm.client.Database(database).Collection(collection)
    err := coll.FindOne(ctx, filter).Decode(result)
    
    if err != nil {
        span.RecordError(err)
    }
    
    return err
}

// Find 查找多个文档
func (tm *TracedMongoDB) Find(ctx context.Context, database, collection string, filter interface{}) (*mongo.Cursor, error) {
    ctx, span := tm.tracer.Start(ctx, "mongodb.find",
        trace.WithAttributes(
            attribute.String("db.system", "mongodb"),
            attribute.String("db.name", database),
            attribute.String("db.mongodb.collection", collection),
        ),
    )
    defer span.End()
    
    coll := tm.client.Database(database).Collection(collection)
    cursor, err := coll.Find(ctx, filter)
    
    if err != nil {
        span.RecordError(err)
    }
    
    return cursor, err
}

// UpdateOne 更新单个文档
func (tm *TracedMongoDB) UpdateOne(ctx context.Context, database, collection string, filter, update interface{}) (*mongo.UpdateResult, error) {
    ctx, span := tm.tracer.Start(ctx, "mongodb.update_one",
        trace.WithAttributes(
            attribute.String("db.system", "mongodb"),
            attribute.String("db.name", database),
            attribute.String("db.mongodb.collection", collection),
        ),
    )
    defer span.End()
    
    coll := tm.client.Database(database).Collection(collection)
    result, err := coll.UpdateOne(ctx, filter, update)
    
    if err != nil {
        span.RecordError(err)
    } else {
        span.SetAttributes(
            attribute.Int64("db.documents.matched", result.MatchedCount),
            attribute.Int64("db.documents.modified", result.ModifiedCount),
        )
    }
    
    return result, err
}

// DeleteOne 删除单个文档
func (tm *TracedMongoDB) DeleteOne(ctx context.Context, database, collection string, filter interface{}) (*mongo.DeleteResult, error) {
    ctx, span := tm.tracer.Start(ctx, "mongodb.delete_one",
        trace.WithAttributes(
            attribute.String("db.system", "mongodb"),
            attribute.String("db.name", database),
            attribute.String("db.mongodb.collection", collection),
        ),
    )
    defer span.End()
    
    coll := tm.client.Database(database).Collection(collection)
    result, err := coll.DeleteOne(ctx, filter)
    
    if err != nil {
        span.RecordError(err)
    } else {
        span.SetAttributes(
            attribute.Int64("db.documents.deleted", result.DeletedCount),
        )
    }
    
    return result, err
}

// Close 关闭连接
func (tm *TracedMongoDB) Close(ctx context.Context) error {
    return tm.client.Disconnect(ctx)
}
```

---

## 缓存追踪

### Redis 追踪

**Redis + OpenTelemetry：**

```go
package cache

import (
    "context"
    "time"
    
    "github.com/redis/go-redis/v9"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
)

// TracedRedis 带追踪的 Redis
type TracedRedis struct {
    client *redis.Client
    tracer trace.Tracer
    meter  metric.Meter
    
    // Metrics
    hitCounter   metric.Int64Counter
    missCounter  metric.Int64Counter
    latency      metric.Float64Histogram
}

// NewTracedRedis 创建带追踪的 Redis
func NewTracedRedis(addr string) (*TracedRedis, error) {
    client := redis.NewClient(&redis.Options{
        Addr: addr,
    })
    
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := client.Ping(ctx).Err(); err != nil {
        return nil, err
    }
    
    meter := otel.Meter("redis")
    
    tr := &TracedRedis{
        client: client,
        tracer: otel.Tracer("redis"),
        meter:  meter,
    }
    
    var err error
    
    // Cache hit counter
    tr.hitCounter, err = meter.Int64Counter(
        "cache.hit",
        metric.WithDescription("Cache hits"),
    )
    if err != nil {
        return nil, err
    }
    
    // Cache miss counter
    tr.missCounter, err = meter.Int64Counter(
        "cache.miss",
        metric.WithDescription("Cache misses"),
    )
    if err != nil {
        return nil, err
    }
    
    // Latency histogram
    tr.latency, err = meter.Float64Histogram(
        "cache.latency",
        metric.WithDescription("Cache operation latency"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    // 添加钩子
    client.AddHook(&tracingHook{
        tracer: tr.tracer,
    })
    
    return tr, nil
}

// Get 获取缓存
func (tr *TracedRedis) Get(ctx context.Context, key string) (string, error) {
    ctx, span := tr.tracer.Start(ctx, "redis.get",
        trace.WithAttributes(
            attribute.String("db.system", "redis"),
            attribute.String("db.operation", "get"),
            attribute.String("db.redis.key", key),
        ),
    )
    defer span.End()
    
    start := time.Now()
    val, err := tr.client.Get(ctx, key).Result()
    duration := time.Since(start)
    
    tr.latency.Record(ctx, float64(duration.Milliseconds()),
        metric.WithAttributes(
            attribute.String("db.operation", "get"),
        ),
    )
    
    if err == redis.Nil {
        // Cache miss
        tr.missCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("cache.key", key),
            ),
        )
        span.SetAttributes(attribute.Bool("cache.hit", false))
        span.SetStatus(codes.Ok, "cache miss")
        return "", err
    } else if err != nil {
        // Error
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return "", err
    }
    
    // Cache hit
    tr.hitCounter.Add(ctx, 1,
        metric.WithAttributes(
            attribute.String("cache.key", key),
        ),
    )
    span.SetAttributes(attribute.Bool("cache.hit", true))
    span.SetStatus(codes.Ok, "cache hit")
    
    return val, nil
}

// Set 设置缓存
func (tr *TracedRedis) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error {
    ctx, span := tr.tracer.Start(ctx, "redis.set",
        trace.WithAttributes(
            attribute.String("db.system", "redis"),
            attribute.String("db.operation", "set"),
            attribute.String("db.redis.key", key),
            attribute.Int64("db.redis.ttl", int64(expiration.Seconds())),
        ),
    )
    defer span.End()
    
    start := time.Now()
    err := tr.client.Set(ctx, key, value, expiration).Err()
    duration := time.Since(start)
    
    tr.latency.Record(ctx, float64(duration.Milliseconds()),
        metric.WithAttributes(
            attribute.String("db.operation", "set"),
        ),
    )
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// Del 删除缓存
func (tr *TracedRedis) Del(ctx context.Context, keys ...string) error {
    ctx, span := tr.tracer.Start(ctx, "redis.del",
        trace.WithAttributes(
            attribute.String("db.system", "redis"),
            attribute.String("db.operation", "del"),
            attribute.Int("db.redis.keys_count", len(keys)),
        ),
    )
    defer span.End()
    
    start := time.Now()
    err := tr.client.Del(ctx, keys...).Err()
    duration := time.Since(start)
    
    tr.latency.Record(ctx, float64(duration.Milliseconds()),
        metric.WithAttributes(
            attribute.String("db.operation", "del"),
        ),
    )
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// Exists 检查键是否存在
func (tr *TracedRedis) Exists(ctx context.Context, keys ...string) (int64, error) {
    ctx, span := tr.tracer.Start(ctx, "redis.exists",
        trace.WithAttributes(
            attribute.String("db.system", "redis"),
            attribute.String("db.operation", "exists"),
        ),
    )
    defer span.End()
    
    count, err := tr.client.Exists(ctx, keys...).Result()
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return 0, err
    }
    
    span.SetAttributes(attribute.Int64("db.keys_found", count))
    span.SetStatus(codes.Ok, "")
    
    return count, nil
}

// Close 关闭连接
func (tr *TracedRedis) Close() error {
    return tr.client.Close()
}

// tracingHook Redis 追踪钩子
type tracingHook struct {
    tracer trace.Tracer
}

func (h *tracingHook) DialHook(next redis.DialHook) redis.DialHook {
    return func(ctx context.Context, network, addr string) (net.Conn, error) {
        ctx, span := h.tracer.Start(ctx, "redis.dial",
            trace.WithAttributes(
                attribute.String("network", network),
                attribute.String("addr", addr),
            ),
        )
        defer span.End()
        
        conn, err := next(ctx, network, addr)
        if err != nil {
            span.RecordError(err)
        }
        
        return conn, err
    }
}

func (h *tracingHook) ProcessHook(next redis.ProcessHook) redis.ProcessHook {
    return func(ctx context.Context, cmd redis.Cmder) error {
        ctx, span := h.tracer.Start(ctx, "redis."+cmd.Name(),
            trace.WithAttributes(
                attribute.String("db.system", "redis"),
                attribute.String("db.operation", cmd.Name()),
            ),
        )
        defer span.End()
        
        err := next(ctx, cmd)
        if err != nil {
            span.RecordError(err)
        }
        
        return err
    }
}

func (h *tracingHook) ProcessPipelineHook(next redis.ProcessPipelineHook) redis.ProcessPipelineHook {
    return func(ctx context.Context, cmds []redis.Cmder) error {
        ctx, span := h.tracer.Start(ctx, "redis.pipeline",
            trace.WithAttributes(
                attribute.String("db.system", "redis"),
                attribute.Int("db.redis.pipeline_length", len(cmds)),
            ),
        )
        defer span.End()
        
        err := next(ctx, cmds)
        if err != nil {
            span.RecordError(err)
        }
        
        return err
    }
}
```

### Memcached 追踪

**Memcached + OpenTelemetry：**

```go
package cache

import (
    "context"
    "time"
    
    "github.com/bradfitz/gomemcache/memcache"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// TracedMemcached 带追踪的 Memcached
type TracedMemcached struct {
    client *memcache.Client
    tracer trace.Tracer
}

// NewTracedMemcached 创建带追踪的 Memcached
func NewTracedMemcached(servers ...string) *TracedMemcached {
    return &TracedMemcached{
        client: memcache.New(servers...),
        tracer: otel.Tracer("memcached"),
    }
}

// Get 获取缓存
func (tm *TracedMemcached) Get(ctx context.Context, key string) (*memcache.Item, error) {
    ctx, span := tm.tracer.Start(ctx, "memcached.get",
        trace.WithAttributes(
            attribute.String("db.system", "memcached"),
            attribute.String("db.operation", "get"),
            attribute.String("cache.key", key),
        ),
    )
    defer span.End()
    
    item, err := tm.client.Get(key)
    
    if err == memcache.ErrCacheMiss {
        span.SetAttributes(attribute.Bool("cache.hit", false))
        span.SetStatus(codes.Ok, "cache miss")
    } else if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
    } else {
        span.SetAttributes(attribute.Bool("cache.hit", true))
        span.SetStatus(codes.Ok, "cache hit")
    }
    
    return item, err
}

// Set 设置缓存
func (tm *TracedMemcached) Set(ctx context.Context, item *memcache.Item) error {
    ctx, span := tm.tracer.Start(ctx, "memcached.set",
        trace.WithAttributes(
            attribute.String("db.system", "memcached"),
            attribute.String("db.operation", "set"),
            attribute.String("cache.key", item.Key),
            attribute.Int("cache.size", len(item.Value)),
        ),
    )
    defer span.End()
    
    err := tm.client.Set(item)
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
    } else {
        span.SetStatus(codes.Ok, "")
    }
    
    return err
}

// Delete 删除缓存
func (tm *TracedMemcached) Delete(ctx context.Context, key string) error {
    ctx, span := tm.tracer.Start(ctx, "memcached.delete",
        trace.WithAttributes(
            attribute.String("db.system", "memcached"),
            attribute.String("db.operation", "delete"),
            attribute.String("cache.key", key),
        ),
    )
    defer span.End()
    
    err := tm.client.Delete(key)
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
    } else {
        span.SetStatus(codes.Ok, "")
    }
    
    return err
}
```

### 本地缓存追踪

**本地缓存 (基于 sync.Map)：**

```go
package cache

import (
    "context"
    "sync"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
)

// LocalCache 本地缓存
type LocalCache struct {
    data   sync.Map
    tracer trace.Tracer
    meter  metric.Meter
    
    // Metrics
    hitCounter   metric.Int64Counter
    missCounter  metric.Int64Counter
    sizeGauge    metric.Int64ObservableGauge
    
    size int64
}

// CacheItem 缓存项
type CacheItem struct {
    Value      interface{}
    Expiration time.Time
}

// NewLocalCache 创建本地缓存
func NewLocalCache() (*LocalCache, error) {
    meter := otel.Meter("local-cache")
    
    lc := &LocalCache{
        tracer: otel.Tracer("local-cache"),
        meter:  meter,
    }
    
    var err error
    
    // Hit counter
    lc.hitCounter, err = meter.Int64Counter(
        "local_cache.hit",
        metric.WithDescription("Local cache hits"),
    )
    if err != nil {
        return nil, err
    }
    
    // Miss counter
    lc.missCounter, err = meter.Int64Counter(
        "local_cache.miss",
        metric.WithDescription("Local cache misses"),
    )
    if err != nil {
        return nil, err
    }
    
    // Size gauge
    lc.sizeGauge, err = meter.Int64ObservableGauge(
        "local_cache.size",
        metric.WithDescription("Local cache size"),
        metric.WithInt64Callback(func(ctx context.Context, observer metric.Int64Observer) error {
            observer.Observe(atomic.LoadInt64(&lc.size))
            return nil
        }),
    )
    if err != nil {
        return nil, err
    }
    
    return lc, nil
}

// Get 获取缓存
func (lc *LocalCache) Get(ctx context.Context, key string) (interface{}, bool) {
    ctx, span := lc.tracer.Start(ctx, "local_cache.get",
        trace.WithAttributes(
            attribute.String("cache.key", key),
        ),
    )
    defer span.End()
    
    value, ok := lc.data.Load(key)
    if !ok {
        // Miss
        lc.missCounter.Add(ctx, 1)
        span.SetAttributes(attribute.Bool("cache.hit", false))
        return nil, false
    }
    
    item := value.(*CacheItem)
    
    // 检查过期
    if !item.Expiration.IsZero() && time.Now().After(item.Expiration) {
        lc.data.Delete(key)
        atomic.AddInt64(&lc.size, -1)
        
        lc.missCounter.Add(ctx, 1)
        span.SetAttributes(attribute.Bool("cache.hit", false))
        span.AddEvent("cache expired")
        return nil, false
    }
    
    // Hit
    lc.hitCounter.Add(ctx, 1)
    span.SetAttributes(attribute.Bool("cache.hit", true))
    
    return item.Value, true
}

// Set 设置缓存
func (lc *LocalCache) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) {
    ctx, span := lc.tracer.Start(ctx, "local_cache.set",
        trace.WithAttributes(
            attribute.String("cache.key", key),
            attribute.Int64("cache.ttl", int64(ttl.Seconds())),
        ),
    )
    defer span.End()
    
    var expiration time.Time
    if ttl > 0 {
        expiration = time.Now().Add(ttl)
    }
    
    item := &CacheItem{
        Value:      value,
        Expiration: expiration,
    }
    
    _, loaded := lc.data.LoadOrStore(key, item)
    if !loaded {
        atomic.AddInt64(&lc.size, 1)
    }
}

// Delete 删除缓存
func (lc *LocalCache) Delete(ctx context.Context, key string) {
    ctx, span := lc.tracer.Start(ctx, "local_cache.delete",
        trace.WithAttributes(
            attribute.String("cache.key", key),
        ),
    )
    defer span.End()
    
    _, loaded := lc.data.LoadAndDelete(key)
    if loaded {
        atomic.AddInt64(&lc.size, -1)
    }
}

// Clear 清空缓存
func (lc *LocalCache) Clear(ctx context.Context) {
    ctx, span := lc.tracer.Start(ctx, "local_cache.clear")
    defer span.End()
    
    lc.data.Range(func(key, value interface{}) bool {
        lc.data.Delete(key)
        return true
    })
    
    atomic.StoreInt64(&lc.size, 0)
}
```

---

## 查询优化

### 查询计划分析

**查询计划追踪：**

```go
package optimization

import (
    "context"
    "database/sql"
    "strings"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// QueryPlanAnalyzer 查询计划分析器
type QueryPlanAnalyzer struct {
    db     *sql.DB
    tracer trace.Tracer
}

// NewQueryPlanAnalyzer 创建查询计划分析器
func NewQueryPlanAnalyzer(db *sql.DB) *QueryPlanAnalyzer {
    return &QueryPlanAnalyzer{
        db:     db,
        tracer: otel.Tracer("query-plan-analyzer"),
    }
}

// Analyze 分析查询计划
func (qpa *QueryPlanAnalyzer) Analyze(ctx context.Context, query string) (*QueryPlan, error) {
    ctx, span := qpa.tracer.Start(ctx, "analyze_query_plan",
        trace.WithAttributes(
            attribute.String("db.statement", query),
        ),
    )
    defer span.End()
    
    // PostgreSQL: EXPLAIN ANALYZE
    explainQuery := "EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON) " + query
    
    rows, err := qpa.db.QueryContext(ctx, explainQuery)
    if err != nil {
        span.RecordError(err)
        return nil, err
    }
    defer rows.Close()
    
    var planJSON string
    if rows.Next() {
        if err := rows.Scan(&planJSON); err != nil {
            span.RecordError(err)
            return nil, err
        }
    }
    
    // 解析查询计划
    plan := qpa.parsePlan(planJSON)
    
    // 记录关键指标
    span.SetAttributes(
        attribute.Float64("query.execution_time_ms", plan.ExecutionTime),
        attribute.Float64("query.planning_time_ms", plan.PlanningTime),
        attribute.Int64("query.rows", plan.RowsReturned),
        attribute.Bool("query.uses_index", plan.UsesIndex),
    )
    
    // 检测潜在问题
    if !plan.UsesIndex {
        span.AddEvent("query does not use index")
    }
    
    if plan.ExecutionTime > 1000 {
        span.AddEvent("slow query detected",
            trace.WithAttributes(
                attribute.Float64("execution_time_ms", plan.ExecutionTime),
            ),
        )
    }
    
    return plan, nil
}

// QueryPlan 查询计划
type QueryPlan struct {
    ExecutionTime float64
    PlanningTime  float64
    RowsReturned  int64
    UsesIndex     bool
    Plan          string
}

// parsePlan 解析查询计划
func (qpa *QueryPlanAnalyzer) parsePlan(planJSON string) *QueryPlan {
    // 简化的解析逻辑
    plan := &QueryPlan{
        Plan: planJSON,
    }
    
    // 检查是否使用索引
    plan.UsesIndex = strings.Contains(planJSON, "Index Scan") || 
                     strings.Contains(planJSON, "Index Only Scan")
    
    return plan
}
```

### 索引使用监控

**索引使用追踪：**

```go
package optimization

import (
    "context"
    "database/sql"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// IndexMonitor 索引监控器
type IndexMonitor struct {
    db    *sql.DB
    meter metric.Meter
}

// NewIndexMonitor 创建索引监控器
func NewIndexMonitor(db *sql.DB) *IndexMonitor {
    return &IndexMonitor{
        db:    db,
        meter: otel.Meter("index-monitor"),
    }
}

// MonitorIndexUsage 监控索引使用情况
func (im *IndexMonitor) MonitorIndexUsage(ctx context.Context, tableName string) error {
    // PostgreSQL: 查询索引使用统计
    query := `
        SELECT
            indexrelname AS index_name,
            idx_scan AS index_scans,
            idx_tup_read AS tuples_read,
            idx_tup_fetch AS tuples_fetched
        FROM pg_stat_user_indexes
        WHERE schemaname = 'public' AND relname = $1
    `
    
    rows, err := im.db.QueryContext(ctx, query, tableName)
    if err != nil {
        return err
    }
    defer rows.Close()
    
    counter, _ := im.meter.Int64Counter(
        "db.index.scans",
        metric.WithDescription("Index scans count"),
    )
    
    for rows.Next() {
        var indexName string
        var scans, tuplesRead, tuplesFetched int64
        
        if err := rows.Scan(&indexName, &scans, &tuplesRead, &tuplesFetched); err != nil {
            return err
        }
        
        counter.Add(ctx, scans,
            metric.WithAttributes(
                attribute.String("table", tableName),
                attribute.String("index", indexName),
            ),
        )
    }
    
    return nil
}
```

### N+1 问题检测

**N+1 问题检测器：**

```go
package optimization

import (
    "context"
    "sync"
    "time"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// NPlusOneDetector N+1 问题检测器
type NPlusOneDetector struct {
    tracer    trace.Tracer
    threshold int
    queries   sync.Map
}

// NewNPlusOneDetector 创建 N+1 问题检测器
func NewNPlusOneDetector(threshold int) *NPlusOneDetector {
    return &NPlusOneDetector{
        tracer:    otel.Tracer("n-plus-one-detector"),
        threshold: threshold,
    }
}

// TrackQuery 追踪查询
func (npod *NPlusOneDetector) TrackQuery(ctx context.Context, query string) {
    span := trace.SpanFromContext(ctx)
    if !span.IsRecording() {
        return
    }
    
    spanID := span.SpanContext().SpanID().String()
    
    // 记录查询
    value, _ := npod.queries.LoadOrStore(spanID, &queryStats{
        queries: make(map[string]int),
    })
    
    stats := value.(*queryStats)
    stats.mu.Lock()
    stats.queries[query]++
    count := stats.queries[query]
    stats.mu.Unlock()
    
    // 检测 N+1 问题
    if count > npod.threshold {
        span.AddEvent("potential N+1 query detected",
            trace.WithAttributes(
                attribute.String("query", query),
                attribute.Int("count", count),
            ),
        )
    }
}

// queryStats 查询统计
type queryStats struct {
    mu      sync.Mutex
    queries map[string]int
}
```

---

## 事务追踪

### 单数据库事务

**事务追踪：**

```go
package transaction

import (
    "context"
    "database/sql"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

// TracedTransaction 带追踪的事务
type TracedTransaction struct {
    tx     *sql.Tx
    tracer trace.Tracer
    span   trace.Span
}

// NewTracedTransaction 创建带追踪的事务
func NewTracedTransaction(ctx context.Context, db *sql.DB) (*TracedTransaction, error) {
    tracer := otel.Tracer("transaction")
    
    ctx, span := tracer.Start(ctx, "db.transaction",
        trace.WithAttributes(
            attribute.String("db.operation", "begin"),
        ),
    )
    
    tx, err := db.BeginTx(ctx, nil)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        span.End()
        return nil, err
    }
    
    return &TracedTransaction{
        tx:     tx,
        tracer: tracer,
        span:   span,
    }, nil
}

// Exec 执行命令
func (tt *TracedTransaction) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
    ctx, span := tt.tracer.Start(ctx, "db.transaction.exec",
        trace.WithAttributes(
            attribute.String("db.statement", query),
        ),
    )
    defer span.End()
    
    result, err := tt.tx.ExecContext(ctx, query, args...)
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
    } else {
        if rowsAffected, err := result.RowsAffected(); err == nil {
            span.SetAttributes(attribute.Int64("db.rows_affected", rowsAffected))
        }
        span.SetStatus(codes.Ok, "")
    }
    
    return result, err
}

// Query 执行查询
func (tt *TracedTransaction) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
    ctx, span := tt.tracer.Start(ctx, "db.transaction.query",
        trace.WithAttributes(
            attribute.String("db.statement", query),
        ),
    )
    defer span.End()
    
    rows, err := tt.tx.QueryContext(ctx, query, args...)
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
    } else {
        span.SetStatus(codes.Ok, "")
    }
    
    return rows, err
}

// Commit 提交事务
func (tt *TracedTransaction) Commit() error {
    defer tt.span.End()
    
    tt.span.AddEvent("committing transaction")
    
    err := tt.tx.Commit()
    
    if err != nil {
        tt.span.RecordError(err)
        tt.span.SetStatus(codes.Error, err.Error())
    } else {
        tt.span.SetStatus(codes.Ok, "transaction committed")
    }
    
    return err
}

// Rollback 回滚事务
func (tt *TracedTransaction) Rollback() error {
    defer tt.span.End()
    
    tt.span.AddEvent("rolling back transaction")
    
    err := tt.tx.Rollback()
    
    if err != nil {
        tt.span.RecordError(err)
        tt.span.SetStatus(codes.Error, err.Error())
    } else {
        tt.span.SetStatus(codes.Ok, "transaction rolled back")
    }
    
    return err
}
```

---

## 最佳实践

### 1. 连接池配置

✅ **合理配置连接池**

```go
db.SetMaxOpenConns(25)           // 最大打开连接数
db.SetMaxIdleConns(5)            // 最大空闲连接数
db.SetConnMaxLifetime(5 * time.Minute)  // 连接最大生命周期
db.SetConnMaxIdleTime(1 * time.Minute)  // 连接最大空闲时间
```

### 2. 慢查询检测

✅ **设置慢查询阈值**

```go
detector := NewSlowQueryDetector(db, 100*time.Millisecond)
```

### 3. 缓存策略

✅ **多级缓存**

```go
// 1. 本地缓存（最快）
if value, ok := localCache.Get(ctx, key); ok {
    return value, nil
}

// 2. Redis（中等）
if value, err := redis.Get(ctx, key); err == nil {
    localCache.Set(ctx, key, value, 5*time.Minute)
    return value, nil
}

// 3. 数据库（最慢）
value, err := db.Query(ctx, query)
if err == nil {
    redis.Set(ctx, key, value, 1*time.Hour)
    localCache.Set(ctx, key, value, 5*time.Minute)
}
return value, err
```

### 4. 事务管理

✅ **使用 defer 确保事务关闭**

```go
tx, err := NewTracedTransaction(ctx, db)
if err != nil {
    return err
}

defer func() {
    if p := recover(); p != nil {
        tx.Rollback()
        panic(p)
    } else if err != nil {
        tx.Rollback()
    } else {
        err = tx.Commit()
    }
}()
```

---

## 完整示例

```go
package main

import (
    "context"
    "log"
    "time"
)

func main() {
    ctx := context.Background()
    
    // 1. 创建数据库连接
    db, err := NewTracedDB("postgres", "postgresql://localhost/mydb")
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // 2. 创建 Redis 连接
    redis, err := NewTracedRedis("localhost:6379")
    if err != nil {
        log.Fatal(err)
    }
    defer redis.Close()
    
    // 3. 创建本地缓存
    localCache, err := NewLocalCache()
    if err != nil {
        log.Fatal(err)
    }
    
    // 4. 创建仓库
    userRepo := NewUserRepository(db, redis, localCache)
    
    // 5. 查询用户
    user, err := userRepo.GetUser(ctx, 123)
    if err != nil {
        log.Fatal(err)
    }
    
    log.Printf("User: %+v", user)
}
```

---

## 总结

本文档详细介绍了 Go 应用中数据库和缓存操作的追踪实现，涵盖：

✅ **SQL 数据库追踪** - database/sql、连接池、慢查询  
✅ **ORM 追踪** - GORM、Ent、sqlx  
✅ **NoSQL 数据库追踪** - MongoDB、Cassandra、DynamoDB  
✅ **缓存追踪** - Redis、Memcached、本地缓存  
✅ **查询优化** - 查询计划、索引、N+1 问题  
✅ **事务追踪** - 单数据库事务、分布式事务

### 关键要点

1. **完整的数据层可观测性** - 追踪所有数据库和缓存操作
2. **连接池监控** - 实时监控连接使用情况
3. **慢查询检测** - 自动识别性能问题
4. **多级缓存策略** - 本地缓存 + Redis + 数据库
5. **查询优化** - 分析查询计划和索引使用

### 相关文档

- [31_Go高级并发模式与OTLP完整集成](./31_Go高级并发模式与OTLP完整集成.md)
- [34_Go内存管理与性能调优实战](./34_Go内存管理与性能调优实战.md)
- [36_Go微服务间通信与分布式追踪](./36_Go微服务间通信与分布式追踪.md)

---

**最后更新：** 2025-10-09  
**版本：** v1.0.0  
**作者：** OTLP Go Integration Team
