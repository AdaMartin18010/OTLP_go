# 47. Go + OTLP å¿«é€Ÿå‚è€ƒå¡ç‰‡

## ğŸ“š å¿«é€Ÿå¯¼èˆª

### åˆå§‹åŒ– (3 æ­¥)

```go
// 1. åˆ›å»º OTLP Exporter
exporter, _ := otlptracegrpc.New(ctx,
    otlptracegrpc.WithEndpoint("localhost:4317"),
    otlptracegrpc.WithInsecure(),
)

// 2. åˆ›å»º TracerProvider
tp := sdktrace.NewTracerProvider(
    sdktrace.WithBatcher(exporter),
    sdktrace.WithResource(resource.NewWithAttributes(
        semconv.SchemaURL,
        semconv.ServiceName("my-service"),
    )),
)
otel.SetTracerProvider(tp)

// 3. è·å– Tracer
tracer := otel.Tracer("my-service")
```

---

## Trace æ ¸å¿ƒ API

### åˆ›å»º Span

```go
// åŸºç¡€ Span
ctx, span := tracer.Start(ctx, "operation-name")
defer span.End()

// å¸¦å±æ€§çš„ Span
ctx, span := tracer.Start(ctx, "operation-name",
    trace.WithSpanKind(trace.SpanKindServer),
    trace.WithAttributes(
        attribute.String("user.id", userID),
        attribute.Int64("order.amount", amount),
    ),
)
defer span.End()
```

### Span æ“ä½œ

```go
// è®¾ç½®å±æ€§
span.SetAttributes(
    attribute.String("key", "value"),
    attribute.Int("count", 42),
    attribute.Bool("success", true),
)

// æ·»åŠ  Event
span.AddEvent("cache miss")
span.AddEvent("validation started", trace.WithAttributes(
    attribute.String("validator", "email"),
))

// è®°å½•é”™è¯¯
if err != nil {
    span.RecordError(err)
    span.SetStatus(codes.Error, "operation failed")
}

// æˆåŠŸçŠ¶æ€
span.SetStatus(codes.Ok, "")
```

---

## Metrics æ ¸å¿ƒ API

### åˆå§‹åŒ– Meter

```go
meter := otel.Meter("my-service")
```

### Counter (åªå¢)

```go
counter, _ := meter.Int64Counter(
    "http.server.requests",
    metric.WithDescription("HTTP server requests"),
)

counter.Add(ctx, 1,
    metric.WithAttributes(
        attribute.String("method", "GET"),
        attribute.String("status", "200"),
    ),
)
```

### Histogram (åˆ†å¸ƒ)

```go
histogram, _ := meter.Float64Histogram(
    "http.server.duration",
    metric.WithDescription("HTTP request duration"),
    metric.WithUnit("ms"),
)

start := time.Now()
// ... do work
duration := time.Since(start)

histogram.Record(ctx, float64(duration.Milliseconds()),
    metric.WithAttributes(
        attribute.String("endpoint", "/api/orders"),
    ),
)
```

### Gauge (å¯å¢å¯å‡)

```go
gauge, _ := meter.Int64ObservableGauge(
    "system.memory.usage",
    metric.WithDescription("Current memory usage"),
    metric.WithInt64Callback(func(ctx context.Context, observer metric.Int64Observer) error {
        var m runtime.MemStats
        runtime.ReadMemStats(&m)
        observer.Observe(int64(m.Alloc))
        return nil
    }),
)
```

---

## Context ä¼ æ’­

### HTTP Client

```go
import "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"

client := &http.Client{
    Transport: otelhttp.NewTransport(http.DefaultTransport),
}

req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
resp, err := client.Do(req)
```

### gRPC Client

```go
import "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"

conn, err := grpc.Dial(target,
    grpc.WithStatsHandler(otelgrpc.NewClientHandler()),
)
```

### gRPC Server

```go
server := grpc.NewServer(
    grpc.StatsHandler(otelgrpc.NewServerHandler()),
)
```

---

## æ¡†æ¶é›†æˆ

### Gin

```go
import "go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"

router := gin.New()
router.Use(otelgin.Middleware("my-service"))

router.GET("/api/orders", func(c *gin.Context) {
    ctx := c.Request.Context()
    
    ctx, span := tracer.Start(ctx, "get_orders")
    defer span.End()
    
    // ... business logic
})
```

### Echo

```go
import "go.opentelemetry.io/contrib/instrumentation/github.com/labstack/echo/otelecho"

e := echo.New()
e.Use(otelecho.Middleware("my-service"))
```

### GORM

```go
import "gorm.io/plugin/opentelemetry/tracing"

db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
db.Use(tracing.NewPlugin())

// ä½¿ç”¨æ—¶ä¼ å…¥ Context
db.WithContext(ctx).Where("id = ?", id).First(&user)
```

---

## é«˜çº§æ¨¡å¼

### Worker Pool

```go
pool, _ := NewWorkerPool[Task, Result](ctx, workerCount, 
    func(ctx context.Context, task Task) (Result, error) {
        ctx, span := tracer.Start(ctx, "worker.process")
        defer span.End()
        
        return processTask(ctx, task)
    },
)

future := pool.Submit(ctx, task)
result, err := future.Get(ctx)
```

### Retry with Backoff

```go
func WithRetry[T any](ctx context.Context, operation func(context.Context) (T, error)) (T, error) {
    var result T
    var err error
    
    backoff := []time.Duration{100*time.Millisecond, 500*time.Millisecond, 1*time.Second}
    
    for i := 0; i <= len(backoff); i++ {
        ctx, span := tracer.Start(ctx, "retry_attempt",
            trace.WithAttributes(attribute.Int("attempt", i+1)),
        )
        
        result, err = operation(ctx)
        span.End()
        
        if err == nil {
            return result, nil
        }
        
        if i < len(backoff) {
            time.Sleep(backoff[i])
        }
    }
    
    return result, err
}
```

### Circuit Breaker

```go
type CircuitBreaker struct {
    state      State
    failures   int64
    threshold  int64
    tracer     trace.Tracer
    stateGauge metric.Int64ObservableGauge
}

func (cb *CircuitBreaker) Execute(ctx context.Context, fn func() error) error {
    ctx, span := cb.tracer.Start(ctx, "circuit_breaker.execute",
        trace.WithAttributes(
            attribute.String("circuit.state", string(cb.state)),
        ),
    )
    defer span.End()
    
    if cb.state == StateOpen {
        return ErrCircuitOpen
    }
    
    err := fn()
    if err != nil {
        cb.recordFailure()
    } else {
        cb.recordSuccess()
    }
    
    return err
}
```

---

## é‡‡æ ·ç­–ç•¥

### åŸºäºæ¯”ä¾‹

```go
// é‡‡æ · 10% çš„è¯·æ±‚
sampler := sdktrace.TraceIDRatioBased(0.1)
```

### çˆ¶èŠ‚ç‚¹é‡‡æ ·

```go
// è·Ÿéšçˆ¶ Span çš„é‡‡æ ·å†³ç­–
sampler := sdktrace.ParentBased(
    sdktrace.TraceIDRatioBased(0.1),
)
```

### è‡ªé€‚åº”é‡‡æ ·

```go
type AdaptiveSampler struct {
    baseRate    float64
    errorRate   float64
    latencyP99  time.Duration
}

func (s *AdaptiveSampler) ShouldSample(parameters sdktrace.SamplingParameters) sdktrace.SamplingResult {
    rate := s.baseRate
    
    // é”™è¯¯è¯·æ±‚ 100% é‡‡æ ·
    if hasError(parameters.Attributes) {
        rate = 1.0
    }
    
    // æ…¢è¯·æ±‚æé«˜é‡‡æ ·ç‡
    if isSlow(parameters) {
        rate = 0.5
    }
    
    if rand.Float64() < rate {
        return sdktrace.SamplingResult{Decision: sdktrace.RecordAndSample}
    }
    
    return sdktrace.SamplingResult{Decision: sdktrace.Drop}
}
```

---

## é”™è¯¯å¤„ç†

### è‡ªå®šä¹‰é”™è¯¯ç±»å‹

```go
type TracedError struct {
    Err       error
    TraceID   string
    SpanID    string
    Code      string
    Timestamp time.Time
}

func NewTracedError(ctx context.Context, err error, code string) *TracedError {
    span := trace.SpanFromContext(ctx)
    spanCtx := span.SpanContext()
    
    return &TracedError{
        Err:       err,
        TraceID:   spanCtx.TraceID().String(),
        SpanID:    spanCtx.SpanID().String(),
        Code:      code,
        Timestamp: time.Now(),
    }
}
```

### é”™è¯¯åŒ…è£…

```go
func WrapError(ctx context.Context, err error, operation string) error {
    span := trace.SpanFromContext(ctx)
    
    span.RecordError(err)
    span.SetStatus(codes.Error, operation+" failed")
    
    return fmt.Errorf("%s: %w", operation, err)
}
```

---

## æ€§èƒ½ä¼˜åŒ–

### å¯¹è±¡æ± 

```go
var spanPool = sync.Pool{
    New: func() interface{} {
        return &SpanData{
            Attributes: make(map[string]interface{}, 10),
        }
    },
}

span := spanPool.Get().(*SpanData)
defer spanPool.Put(span)
```

### æ‰¹é‡å¯¼å‡º

```go
exporter, _ := otlptracegrpc.New(ctx,
    otlptracegrpc.WithEndpoint("localhost:4317"),
)

tp := sdktrace.NewTracerProvider(
    sdktrace.WithBatcher(exporter,
        sdktrace.WithMaxExportBatchSize(512),
        sdktrace.WithBatchTimeout(5*time.Second),
        sdktrace.WithMaxQueueSize(2048),
    ),
)
```

### é›¶åˆ†é…æŠ€æœ¯

```go
// é¿å…ä¸å¿…è¦çš„å­—ç¬¦ä¸²è½¬æ¢
func Int64ToString(buf []byte, n int64) string {
    return string(strconv.AppendInt(buf[:0], n, 10))
}

// é‡ç”¨ slice
func ReuseSlice[T any](slice []T) []T {
    return slice[:0] // ä¿ç•™å®¹é‡ï¼Œæ¸…ç©ºé•¿åº¦
}
```

---

## éƒ¨ç½²é…ç½®

### Docker Compose

```yaml
version: '3.8'

services:
  app:
    build: .
    environment:
      - OTEL_EXPORTER_OTLP_ENDPOINT=http://otel-collector:4317
      - OTEL_SERVICE_NAME=my-service
      - OTEL_TRACES_SAMPLER=traceidratio
      - OTEL_TRACES_SAMPLER_ARG=0.1
    depends_on:
      - otel-collector

  otel-collector:
    image: otel/opentelemetry-collector:latest
    command: ["--config=/etc/otel-collector-config.yaml"]
    volumes:
      - ./otel-collector-config.yaml:/etc/otel-collector-config.yaml
    ports:
      - "4317:4317"
      - "4318:4318"
```

### Kubernetes

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-service
  template:
    metadata:
      labels:
        app: my-service
    spec:
      containers:
      - name: app
        image: my-service:latest
        env:
        - name: OTEL_EXPORTER_OTLP_ENDPOINT
          value: "http://otel-collector:4317"
        - name: OTEL_SERVICE_NAME
          value: "my-service"
        ports:
        - containerPort: 8080
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
```

---

## ç›‘æ§æŸ¥è¯¢

### Prometheus PromQL

```promql
# è¯·æ±‚é€Ÿç‡
rate(http_server_requests_total[5m])

# é”™è¯¯ç‡
rate(http_server_requests_total{status=~"5.."}[5m]) / 
rate(http_server_requests_total[5m])

# P95 å»¶è¿Ÿ
histogram_quantile(0.95, rate(http_server_duration_bucket[5m]))

# QPS by endpoint
sum(rate(http_server_requests_total[1m])) by (endpoint)
```

### Jaeger æŸ¥è¯¢

```bash
# æŒ‰æœåŠ¡æŸ¥æ‰¾
Service: my-service
Operation: GET /api/orders

# æŒ‰æ ‡ç­¾è¿‡æ»¤
Tags: http.status_code=500
Tags: error=true

# æŒ‰æŒç»­æ—¶é—´
Duration: > 1s
```

---

## å¸¸ç”¨å‘½ä»¤

```bash
# pprof CPU åˆ†æ
go tool pprof http://localhost:6060/debug/pprof/profile

# pprof å†…å­˜åˆ†æ
go tool pprof http://localhost:6060/debug/pprof/heap

# æŸ¥çœ‹ goroutines
curl http://localhost:6060/debug/pprof/goroutine?debug=2

# å‹åŠ›æµ‹è¯•
hey -z 60s -c 100 http://localhost:8080/api/orders

# Docker æ—¥å¿—
docker logs -f my-service | grep trace_id=xxx
```

---

## ç¯å¢ƒå˜é‡

```bash
# OTLP é…ç½®
export OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4317
export OTEL_EXPORTER_OTLP_PROTOCOL=grpc
export OTEL_EXPORTER_OTLP_INSECURE=true

# æœåŠ¡é…ç½®
export OTEL_SERVICE_NAME=my-service
export OTEL_SERVICE_VERSION=1.0.0
export OTEL_DEPLOYMENT_ENVIRONMENT=production

# é‡‡æ ·é…ç½®
export OTEL_TRACES_SAMPLER=traceidratio
export OTEL_TRACES_SAMPLER_ARG=0.1

# æ—¥å¿—é…ç½®
export OTEL_LOG_LEVEL=info
```

---

## å¿«é€Ÿæ£€æŸ¥æ¸…å•

### âœ… Trace é›†æˆ

- [ ] TracerProvider æ­£ç¡®åˆå§‹åŒ–
- [ ] Span æ­£ç¡®åˆ›å»ºå’Œç»“æŸ
- [ ] Context æ­£ç¡®ä¼ æ’­
- [ ] é”™è¯¯æ­£ç¡®è®°å½•
- [ ] å…³é”®å±æ€§å·²è®¾ç½®

### âœ… Metrics é›†æˆ

- [ ] Meter æ­£ç¡®åˆå§‹åŒ–
- [ ] Counter/Histogram/Gauge æ­£ç¡®ä½¿ç”¨
- [ ] æŒ‡æ ‡æœ‰åˆç†çš„æ ‡ç­¾
- [ ] æŒ‡æ ‡åç§°ç¬¦åˆè§„èŒƒ

### âœ… æ€§èƒ½ä¼˜åŒ–

- [ ] é‡‡æ ·ç‡åˆç†è®¾ç½®
- [ ] æ‰¹é‡å¯¼å‡ºå·²é…ç½®
- [ ] æ—  goroutine æ³„æ¼
- [ ] æ— å†…å­˜æ³„æ¼
- [ ] GC å‚æ•°åˆç†

### âœ… ç”Ÿäº§å°±ç»ª

- [ ] å¥åº·æ£€æŸ¥å·²å®ç°
- [ ] ä¼˜é›…å…³é—­å·²å®ç°
- [ ] ç›‘æ§å‘Šè­¦å·²é…ç½®
- [ ] æ—¥å¿—çº§åˆ«å¯è°ƒæ•´
- [ ] èµ„æºé™åˆ¶å·²è®¾ç½®

---

## ç›¸å…³æ–‡æ¡£

- [01_Go_1.25.1_å®Œæ•´é›†æˆæŒ‡å—](./01_Go_1.25.1_å®Œæ•´é›†æˆæŒ‡å—.md)
- [30_Goç¼–ç¨‹æ¨¡å¼é›†æˆå®Œæ•´ç´¢å¼•](./30_Goç¼–ç¨‹æ¨¡å¼é›†æˆå®Œæ•´ç´¢å¼•.md)
- [45_æ•…éšœæ’æŸ¥ä¸è°ƒè¯•æŒ‡å—](./45_æ•…éšœæ’æŸ¥ä¸è°ƒè¯•æŒ‡å—.md)

