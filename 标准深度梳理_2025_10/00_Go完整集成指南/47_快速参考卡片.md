# 47. Go + OTLP 快速参考卡片

## 📚 快速导航

### 初始化 (3 步)

```go
// 1. 创建 OTLP Exporter
exporter, _ := otlptracegrpc.New(ctx,
    otlptracegrpc.WithEndpoint("localhost:4317"),
    otlptracegrpc.WithInsecure(),
)

// 2. 创建 TracerProvider
tp := sdktrace.NewTracerProvider(
    sdktrace.WithBatcher(exporter),
    sdktrace.WithResource(resource.NewWithAttributes(
        semconv.SchemaURL,
        semconv.ServiceName("my-service"),
    )),
)
otel.SetTracerProvider(tp)

// 3. 获取 Tracer
tracer := otel.Tracer("my-service")
```

---

## Trace 核心 API

### 创建 Span

```go
// 基础 Span
ctx, span := tracer.Start(ctx, "operation-name")
defer span.End()

// 带属性的 Span
ctx, span := tracer.Start(ctx, "operation-name",
    trace.WithSpanKind(trace.SpanKindServer),
    trace.WithAttributes(
        attribute.String("user.id", userID),
        attribute.Int64("order.amount", amount),
    ),
)
defer span.End()
```

### Span 操作

```go
// 设置属性
span.SetAttributes(
    attribute.String("key", "value"),
    attribute.Int("count", 42),
    attribute.Bool("success", true),
)

// 添加 Event
span.AddEvent("cache miss")
span.AddEvent("validation started", trace.WithAttributes(
    attribute.String("validator", "email"),
))

// 记录错误
if err != nil {
    span.RecordError(err)
    span.SetStatus(codes.Error, "operation failed")
}

// 成功状态
span.SetStatus(codes.Ok, "")
```

---

## Metrics 核心 API

### 初始化 Meter

```go
meter := otel.Meter("my-service")
```

### Counter (只增)

```go
counter, _ := meter.Int64Counter(
    "http.server.requests",
    metric.WithDescription("HTTP server requests"),
)

counter.Add(ctx, 1,
    metric.WithAttributes(
        attribute.String("method", "GET"),
        attribute.String("status", "200"),
    ),
)
```

### Histogram (分布)

```go
histogram, _ := meter.Float64Histogram(
    "http.server.duration",
    metric.WithDescription("HTTP request duration"),
    metric.WithUnit("ms"),
)

start := time.Now()
// ... do work
duration := time.Since(start)

histogram.Record(ctx, float64(duration.Milliseconds()),
    metric.WithAttributes(
        attribute.String("endpoint", "/api/orders"),
    ),
)
```

### Gauge (可增可减)

```go
gauge, _ := meter.Int64ObservableGauge(
    "system.memory.usage",
    metric.WithDescription("Current memory usage"),
    metric.WithInt64Callback(func(ctx context.Context, observer metric.Int64Observer) error {
        var m runtime.MemStats
        runtime.ReadMemStats(&m)
        observer.Observe(int64(m.Alloc))
        return nil
    }),
)
```

---

## Context 传播

### HTTP Client

```go
import "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"

client := &http.Client{
    Transport: otelhttp.NewTransport(http.DefaultTransport),
}

req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
resp, err := client.Do(req)
```

### gRPC Client

```go
import "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"

conn, err := grpc.Dial(target,
    grpc.WithStatsHandler(otelgrpc.NewClientHandler()),
)
```

### gRPC Server

```go
server := grpc.NewServer(
    grpc.StatsHandler(otelgrpc.NewServerHandler()),
)
```

---

## 框架集成

### Gin

```go
import "go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"

router := gin.New()
router.Use(otelgin.Middleware("my-service"))

router.GET("/api/orders", func(c *gin.Context) {
    ctx := c.Request.Context()
    
    ctx, span := tracer.Start(ctx, "get_orders")
    defer span.End()
    
    // ... business logic
})
```

### Echo

```go
import "go.opentelemetry.io/contrib/instrumentation/github.com/labstack/echo/otelecho"

e := echo.New()
e.Use(otelecho.Middleware("my-service"))
```

### GORM

```go
import "gorm.io/plugin/opentelemetry/tracing"

db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
db.Use(tracing.NewPlugin())

// 使用时传入 Context
db.WithContext(ctx).Where("id = ?", id).First(&user)
```

---

## 高级模式

### Worker Pool

```go
pool, _ := NewWorkerPool[Task, Result](ctx, workerCount, 
    func(ctx context.Context, task Task) (Result, error) {
        ctx, span := tracer.Start(ctx, "worker.process")
        defer span.End()
        
        return processTask(ctx, task)
    },
)

future := pool.Submit(ctx, task)
result, err := future.Get(ctx)
```

### Retry with Backoff

```go
func WithRetry[T any](ctx context.Context, operation func(context.Context) (T, error)) (T, error) {
    var result T
    var err error
    
    backoff := []time.Duration{100*time.Millisecond, 500*time.Millisecond, 1*time.Second}
    
    for i := 0; i <= len(backoff); i++ {
        ctx, span := tracer.Start(ctx, "retry_attempt",
            trace.WithAttributes(attribute.Int("attempt", i+1)),
        )
        
        result, err = operation(ctx)
        span.End()
        
        if err == nil {
            return result, nil
        }
        
        if i < len(backoff) {
            time.Sleep(backoff[i])
        }
    }
    
    return result, err
}
```

### Circuit Breaker

```go
type CircuitBreaker struct {
    state      State
    failures   int64
    threshold  int64
    tracer     trace.Tracer
    stateGauge metric.Int64ObservableGauge
}

func (cb *CircuitBreaker) Execute(ctx context.Context, fn func() error) error {
    ctx, span := cb.tracer.Start(ctx, "circuit_breaker.execute",
        trace.WithAttributes(
            attribute.String("circuit.state", string(cb.state)),
        ),
    )
    defer span.End()
    
    if cb.state == StateOpen {
        return ErrCircuitOpen
    }
    
    err := fn()
    if err != nil {
        cb.recordFailure()
    } else {
        cb.recordSuccess()
    }
    
    return err
}
```

---

## 采样策略

### 基于比例

```go
// 采样 10% 的请求
sampler := sdktrace.TraceIDRatioBased(0.1)
```

### 父节点采样

```go
// 跟随父 Span 的采样决策
sampler := sdktrace.ParentBased(
    sdktrace.TraceIDRatioBased(0.1),
)
```

### 自适应采样

```go
type AdaptiveSampler struct {
    baseRate    float64
    errorRate   float64
    latencyP99  time.Duration
}

func (s *AdaptiveSampler) ShouldSample(parameters sdktrace.SamplingParameters) sdktrace.SamplingResult {
    rate := s.baseRate
    
    // 错误请求 100% 采样
    if hasError(parameters.Attributes) {
        rate = 1.0
    }
    
    // 慢请求提高采样率
    if isSlow(parameters) {
        rate = 0.5
    }
    
    if rand.Float64() < rate {
        return sdktrace.SamplingResult{Decision: sdktrace.RecordAndSample}
    }
    
    return sdktrace.SamplingResult{Decision: sdktrace.Drop}
}
```

---

## 错误处理

### 自定义错误类型

```go
type TracedError struct {
    Err       error
    TraceID   string
    SpanID    string
    Code      string
    Timestamp time.Time
}

func NewTracedError(ctx context.Context, err error, code string) *TracedError {
    span := trace.SpanFromContext(ctx)
    spanCtx := span.SpanContext()
    
    return &TracedError{
        Err:       err,
        TraceID:   spanCtx.TraceID().String(),
        SpanID:    spanCtx.SpanID().String(),
        Code:      code,
        Timestamp: time.Now(),
    }
}
```

### 错误包装

```go
func WrapError(ctx context.Context, err error, operation string) error {
    span := trace.SpanFromContext(ctx)
    
    span.RecordError(err)
    span.SetStatus(codes.Error, operation+" failed")
    
    return fmt.Errorf("%s: %w", operation, err)
}
```

---

## 性能优化

### 对象池

```go
var spanPool = sync.Pool{
    New: func() interface{} {
        return &SpanData{
            Attributes: make(map[string]interface{}, 10),
        }
    },
}

span := spanPool.Get().(*SpanData)
defer spanPool.Put(span)
```

### 批量导出

```go
exporter, _ := otlptracegrpc.New(ctx,
    otlptracegrpc.WithEndpoint("localhost:4317"),
)

tp := sdktrace.NewTracerProvider(
    sdktrace.WithBatcher(exporter,
        sdktrace.WithMaxExportBatchSize(512),
        sdktrace.WithBatchTimeout(5*time.Second),
        sdktrace.WithMaxQueueSize(2048),
    ),
)
```

### 零分配技术

```go
// 避免不必要的字符串转换
func Int64ToString(buf []byte, n int64) string {
    return string(strconv.AppendInt(buf[:0], n, 10))
}

// 重用 slice
func ReuseSlice[T any](slice []T) []T {
    return slice[:0] // 保留容量，清空长度
}
```

---

## 部署配置

### Docker Compose

```yaml
version: '3.8'

services:
  app:
    build: .
    environment:
      - OTEL_EXPORTER_OTLP_ENDPOINT=http://otel-collector:4317
      - OTEL_SERVICE_NAME=my-service
      - OTEL_TRACES_SAMPLER=traceidratio
      - OTEL_TRACES_SAMPLER_ARG=0.1
    depends_on:
      - otel-collector

  otel-collector:
    image: otel/opentelemetry-collector:latest
    command: ["--config=/etc/otel-collector-config.yaml"]
    volumes:
      - ./otel-collector-config.yaml:/etc/otel-collector-config.yaml
    ports:
      - "4317:4317"
      - "4318:4318"
```

### Kubernetes

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-service
  template:
    metadata:
      labels:
        app: my-service
    spec:
      containers:
      - name: app
        image: my-service:latest
        env:
        - name: OTEL_EXPORTER_OTLP_ENDPOINT
          value: "http://otel-collector:4317"
        - name: OTEL_SERVICE_NAME
          value: "my-service"
        ports:
        - containerPort: 8080
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
```

---

## 监控查询

### Prometheus PromQL

```promql
# 请求速率
rate(http_server_requests_total[5m])

# 错误率
rate(http_server_requests_total{status=~"5.."}[5m]) / 
rate(http_server_requests_total[5m])

# P95 延迟
histogram_quantile(0.95, rate(http_server_duration_bucket[5m]))

# QPS by endpoint
sum(rate(http_server_requests_total[1m])) by (endpoint)
```

### Jaeger 查询

```bash
# 按服务查找
Service: my-service
Operation: GET /api/orders

# 按标签过滤
Tags: http.status_code=500
Tags: error=true

# 按持续时间
Duration: > 1s
```

---

## 常用命令

```bash
# pprof CPU 分析
go tool pprof http://localhost:6060/debug/pprof/profile

# pprof 内存分析
go tool pprof http://localhost:6060/debug/pprof/heap

# 查看 goroutines
curl http://localhost:6060/debug/pprof/goroutine?debug=2

# 压力测试
hey -z 60s -c 100 http://localhost:8080/api/orders

# Docker 日志
docker logs -f my-service | grep trace_id=xxx
```

---

## 环境变量

```bash
# OTLP 配置
export OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4317
export OTEL_EXPORTER_OTLP_PROTOCOL=grpc
export OTEL_EXPORTER_OTLP_INSECURE=true

# 服务配置
export OTEL_SERVICE_NAME=my-service
export OTEL_SERVICE_VERSION=1.0.0
export OTEL_DEPLOYMENT_ENVIRONMENT=production

# 采样配置
export OTEL_TRACES_SAMPLER=traceidratio
export OTEL_TRACES_SAMPLER_ARG=0.1

# 日志配置
export OTEL_LOG_LEVEL=info
```

---

## 快速检查清单

### ✅ Trace 集成

- [ ] TracerProvider 正确初始化
- [ ] Span 正确创建和结束
- [ ] Context 正确传播
- [ ] 错误正确记录
- [ ] 关键属性已设置

### ✅ Metrics 集成

- [ ] Meter 正确初始化
- [ ] Counter/Histogram/Gauge 正确使用
- [ ] 指标有合理的标签
- [ ] 指标名称符合规范

### ✅ 性能优化

- [ ] 采样率合理设置
- [ ] 批量导出已配置
- [ ] 无 goroutine 泄漏
- [ ] 无内存泄漏
- [ ] GC 参数合理

### ✅ 生产就绪

- [ ] 健康检查已实现
- [ ] 优雅关闭已实现
- [ ] 监控告警已配置
- [ ] 日志级别可调整
- [ ] 资源限制已设置

---

## 相关文档

- [01_Go_1.25.1_完整集成指南](./01_Go_1.25.1_完整集成指南.md)
- [30_Go编程模式集成完整索引](./30_Go编程模式集成完整索引.md)
- [45_故障排查与调试指南](./45_故障排查与调试指南.md)

