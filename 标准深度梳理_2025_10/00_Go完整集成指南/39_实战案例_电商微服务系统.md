# 39. å®žæˆ˜æ¡ˆä¾‹ï¼šç”µå•†å¾®æœåŠ¡ç³»ç»Ÿå®Œæ•´ OTLP é›†æˆ

## ðŸ“š ç›®å½•

- [39. å®žæˆ˜æ¡ˆä¾‹ï¼šç”µå•†å¾®æœåŠ¡ç³»ç»Ÿå®Œæ•´ OTLP é›†æˆ](#39-å®žæˆ˜æ¡ˆä¾‹ç”µå•†å¾®æœåŠ¡ç³»ç»Ÿå®Œæ•´-otlp-é›†æˆ)
  - [ðŸ“š ç›®å½•](#-ç›®å½•)
  - [1. ç³»ç»Ÿæž¶æž„](#1-ç³»ç»Ÿæž¶æž„)
    - [1.1 æž¶æž„å›¾](#11-æž¶æž„å›¾)
    - [1.2 æŠ€æœ¯æ ˆ](#12-æŠ€æœ¯æ ˆ)
  - [2. æœåŠ¡æ‹†åˆ†](#2-æœåŠ¡æ‹†åˆ†)
    - [2.1 æœåŠ¡æ¸…å•](#21-æœåŠ¡æ¸…å•)
    - [2.2 ä¾èµ–å…³ç³»](#22-ä¾èµ–å…³ç³»)
  - [3. ç”¨æˆ·æœåŠ¡å®žçŽ°](#3-ç”¨æˆ·æœåŠ¡å®žçŽ°)
    - [3.1 æ•°æ®æ¨¡åž‹](#31-æ•°æ®æ¨¡åž‹)
    - [3.2 ç”¨æˆ·æœåŠ¡å®žçŽ°](#32-ç”¨æˆ·æœåŠ¡å®žçŽ°)
  - [4. å•†å“æœåŠ¡å®žçŽ°](#4-å•†å“æœåŠ¡å®žçŽ°)
    - [4.1 æ•°æ®æ¨¡åž‹](#41-æ•°æ®æ¨¡åž‹)
    - [4.2 å•†å“æœåŠ¡å®žçŽ°](#42-å•†å“æœåŠ¡å®žçŽ°)
  - [5. è®¢å•æœåŠ¡å®žçŽ°](#5-è®¢å•æœåŠ¡å®žçŽ°)
  - [æ€»ç»“](#æ€»ç»“)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)

---

## 1. ç³»ç»Ÿæž¶æž„

### 1.1 æž¶æž„å›¾

```text
                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                    â”‚   Client    â”‚
                                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                           â”‚
                                           â–¼
                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                    â”‚ API Gateway â”‚
                                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                           â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚                          â”‚                          â”‚
                â–¼                          â–¼                          â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚    User     â”‚          â”‚   Product   â”‚          â”‚    Order    â”‚
         â”‚   Service   â”‚          â”‚   Service   â”‚          â”‚   Service   â”‚
         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                â”‚                        â”‚                         â”‚
                â”‚                        â”‚                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
                â”‚                        â”‚                 â”‚               â”‚
                â–¼                        â–¼                 â–¼               â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  User DB    â”‚          â”‚ Product DB  â”‚  â”‚  Payment    â”‚ â”‚  Inventory  â”‚
         â”‚ (PostgreSQL)â”‚          â”‚ (PostgreSQL)â”‚  â”‚  Service    â”‚ â”‚  Service    â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                                           â”‚               â”‚
                                                           â–¼               â–¼
                                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                                    â”‚ Payment DB  â”‚ â”‚Inventory DB â”‚
                                                    â”‚ (PostgreSQL)â”‚ â”‚ (PostgreSQL)â”‚
                                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                    
                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                    â”‚     Redis (Cache/Queue)     â”‚
                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    
                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                    â”‚   OTLP Collector/Backend    â”‚
                                    â”‚  (Jaeger/Tempo/Prometheus)  â”‚
                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æŠ€æœ¯æ ˆ

- **è¯­è¨€**: Go 1.25.1
- **æ¡†æž¶**: Gin (API Gateway), gRPC (æœåŠ¡é—´é€šä¿¡)
- **æ•°æ®åº“**: PostgreSQL, Redis
- **æ¶ˆæ¯é˜Ÿåˆ—**: NATS
- **è¿½è¸ª**: OpenTelemetry + Jaeger/Tempo
- **æŒ‡æ ‡**: Prometheus + Grafana
- **å®¹å™¨**: Docker, Kubernetes

---

## 2. æœåŠ¡æ‹†åˆ†

### 2.1 æœåŠ¡æ¸…å•

| æœåŠ¡åç§° | èŒè´£ | ç«¯å£ | é€šä¿¡æ–¹å¼ |
|---------|------|------|----------|
| API Gateway | ç»Ÿä¸€å…¥å£ã€è·¯ç”±ã€è®¤è¯ | 8080 | HTTP |
| User Service | ç”¨æˆ·ç®¡ç†ã€è®¤è¯æŽˆæƒ | 9001 | gRPC |
| Product Service | å•†å“ç®¡ç†ã€æŸ¥è¯¢ | 9002 | gRPC |
| Order Service | è®¢å•ç®¡ç†ã€æµç¨‹ç¼–æŽ’ | 9003 | gRPC |
| Payment Service | æ”¯ä»˜å¤„ç† | 9004 | gRPC |
| Inventory Service | åº“å­˜ç®¡ç† | 9005 | gRPC |

### 2.2 ä¾èµ–å…³ç³»

```go
// go.mod
module ecommerce

go 1.25.1

require (
    // OpenTelemetry æ ¸å¿ƒ
    go.opentelemetry.io/otel v1.32.0
    go.opentelemetry.io/otel/sdk v1.32.0
    go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.32.0
    go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc v1.32.0
    
    // OpenTelemetry åº“æ’æ¡©
    go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.57.0
    go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin v0.57.0
    go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.57.0
    go.opentelemetry.io/contrib/instrumentation/database/sql/otelsql v0.57.0
    
    // Web æ¡†æž¶
    github.com/gin-gonic/gin v1.10.0
    google.golang.org/grpc v1.69.2
    google.golang.org/protobuf v1.36.0
    
    // æ•°æ®åº“
    gorm.io/gorm v1.25.12
    gorm.io/driver/postgres v1.5.11
    github.com/redis/go-redis/v9 v9.7.0
    
    // æ¶ˆæ¯é˜Ÿåˆ—
    github.com/nats-io/nats.go v1.38.0
    
    // å·¥å…·åº“
    github.com/google/uuid v1.6.0
    github.com/golang-jwt/jwt/v5 v5.2.1
    golang.org/x/sync v0.10.0
)
```

---

## 3. ç”¨æˆ·æœåŠ¡å®žçŽ°

### 3.1 æ•°æ®æ¨¡åž‹

```go
package user

import (
    "time"
    
    "github.com/google/uuid"
    "gorm.io/gorm"
)

// User ç”¨æˆ·æ¨¡åž‹
type User struct {
    ID           uuid.UUID      `gorm:"type:uuid;primary_key" json:"id"`
    Email        string         `gorm:"uniqueIndex;not null" json:"email"`
    Username     string         `gorm:"uniqueIndex;not null" json:"username"`
    PasswordHash string         `gorm:"not null" json:"-"`
    FullName     string         `json:"full_name"`
    Phone        string         `json:"phone"`
    Status       string         `gorm:"default:'active'" json:"status"` // active, suspended, deleted
    CreatedAt    time.Time      `json:"created_at"`
    UpdatedAt    time.Time      `json:"updated_at"`
    DeletedAt    gorm.DeletedAt `gorm:"index" json:"-"`
}

// BeforeCreate Hook
func (u *User) BeforeCreate(tx *gorm.DB) error {
    if u.ID == uuid.Nil {
        u.ID = uuid.New()
    }
    return nil
}
```

### 3.2 ç”¨æˆ·æœåŠ¡å®žçŽ°

```go
package user

import (
    "context"
    "errors"
    "time"
    
    "github.com/golang-jwt/jwt/v5"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
    "golang.org/x/crypto/bcrypt"
    "gorm.io/gorm"
)

// Service ç”¨æˆ·æœåŠ¡
type Service struct {
    db     *gorm.DB
    tracer trace.Tracer
    meter  metric.Meter
    
    // Metrics
    registerCounter  metric.Int64Counter
    loginCounter     metric.Int64Counter
    queryDuration    metric.Float64Histogram
}

// NewService åˆ›å»ºç”¨æˆ·æœåŠ¡
func NewService(db *gorm.DB) (*Service, error) {
    tracer := otel.Tracer("user-service")
    meter := otel.Meter("user-service")
    
    svc := &Service{
        db:     db,
        tracer: tracer,
        meter:  meter,
    }
    
    var err error
    
    // æ³¨å†Œè®¡æ•°å™¨
    svc.registerCounter, err = meter.Int64Counter(
        "user.register.count",
        metric.WithDescription("User registration count"),
    )
    if err != nil {
        return nil, err
    }
    
    // ç™»å½•è®¡æ•°å™¨
    svc.loginCounter, err = meter.Int64Counter(
        "user.login.count",
        metric.WithDescription("User login count"),
    )
    if err != nil {
        return nil, err
    }
    
    // æŸ¥è¯¢å»¶è¿Ÿ
    svc.queryDuration, err = meter.Float64Histogram(
        "user.query.duration",
        metric.WithDescription("User query duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    return svc, nil
}

// Register ç”¨æˆ·æ³¨å†Œ
func (s *Service) Register(ctx context.Context, req *RegisterRequest) (*User, error) {
    ctx, span := s.tracer.Start(ctx, "user.register",
        trace.WithAttributes(
            attribute.String("user.email", req.Email),
            attribute.String("user.username", req.Username),
        ),
    )
    defer span.End()
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        s.queryDuration.Record(ctx, float64(duration.Milliseconds()),
            metric.WithAttributes(attribute.String("operation", "register")),
        )
    }()
    
    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²å­˜åœ¨
    var existingUser User
    if err := s.db.WithContext(ctx).
        Where("email = ? OR username = ?", req.Email, req.Username).
        First(&existingUser).Error; err == nil {
        span.SetStatus(codes.Error, "user already exists")
        s.registerCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("status", "failed"),
                attribute.String("reason", "user_exists"),
            ),
        )
        return nil, errors.New("user already exists")
    }
    
    // å¯†ç å“ˆå¸Œ
    passwordHash, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "password hashing failed")
        return nil, err
    }
    
    // åˆ›å»ºç”¨æˆ·
    user := &User{
        Email:        req.Email,
        Username:     req.Username,
        PasswordHash: string(passwordHash),
        FullName:     req.FullName,
        Phone:        req.Phone,
        Status:       "active",
    }
    
    if err := s.db.WithContext(ctx).Create(user).Error; err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "database error")
        s.registerCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("status", "failed"),
                attribute.String("reason", "database_error"),
            ),
        )
        return nil, err
    }
    
    span.SetAttributes(attribute.String("user.id", user.ID.String()))
    span.SetStatus(codes.Ok, "")
    
    s.registerCounter.Add(ctx, 1,
        metric.WithAttributes(attribute.String("status", "success")),
    )
    
    return user, nil
}

// Login ç”¨æˆ·ç™»å½•
func (s *Service) Login(ctx context.Context, req *LoginRequest) (*LoginResponse, error) {
    ctx, span := s.tracer.Start(ctx, "user.login",
        trace.WithAttributes(
            attribute.String("user.email", req.Email),
        ),
    )
    defer span.End()
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        s.queryDuration.Record(ctx, float64(duration.Milliseconds()),
            metric.WithAttributes(attribute.String("operation", "login")),
        )
    }()
    
    // æŸ¥æ‰¾ç”¨æˆ·
    var user User
    if err := s.db.WithContext(ctx).
        Where("email = ? AND status = ?", req.Email, "active").
        First(&user).Error; err != nil {
        span.SetStatus(codes.Error, "user not found")
        s.loginCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("status", "failed"),
                attribute.String("reason", "user_not_found"),
            ),
        )
        return nil, errors.New("invalid credentials")
    }
    
    span.SetAttributes(attribute.String("user.id", user.ID.String()))
    
    // éªŒè¯å¯†ç 
    if err := bcrypt.CompareHashAndPassword(
        []byte(user.PasswordHash),
        []byte(req.Password),
    ); err != nil {
        span.SetStatus(codes.Error, "invalid password")
        s.loginCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("status", "failed"),
                attribute.String("reason", "invalid_password"),
            ),
        )
        return nil, errors.New("invalid credentials")
    }
    
    // ç”Ÿæˆ JWT Token
    token, err := s.generateToken(user.ID)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "token generation failed")
        return nil, err
    }
    
    span.SetStatus(codes.Ok, "")
    s.loginCounter.Add(ctx, 1,
        metric.WithAttributes(attribute.String("status", "success")),
    )
    
    return &LoginResponse{
        Token: token,
        User:  &user,
    }, nil
}

// GetByID æ ¹æ® ID èŽ·å–ç”¨æˆ·
func (s *Service) GetByID(ctx context.Context, userID string) (*User, error) {
    ctx, span := s.tracer.Start(ctx, "user.get_by_id",
        trace.WithAttributes(
            attribute.String("user.id", userID),
        ),
    )
    defer span.End()
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        s.queryDuration.Record(ctx, float64(duration.Milliseconds()),
            metric.WithAttributes(attribute.String("operation", "get_by_id")),
        )
    }()
    
    var user User
    if err := s.db.WithContext(ctx).
        Where("id = ? AND status = ?", userID, "active").
        First(&user).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            span.SetStatus(codes.Error, "user not found")
            return nil, errors.New("user not found")
        }
        span.RecordError(err)
        span.SetStatus(codes.Error, "database error")
        return nil, err
    }
    
    span.SetStatus(codes.Ok, "")
    return &user, nil
}

// generateToken ç”Ÿæˆ JWT Token
func (s *Service) generateToken(userID uuid.UUID) (string, error) {
    claims := jwt.MapClaims{
        "user_id": userID.String(),
        "exp":     time.Now().Add(24 * time.Hour).Unix(),
        "iat":     time.Now().Unix(),
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte("your-secret-key")) // åº”ä»ŽçŽ¯å¢ƒå˜é‡è¯»å–
}

// RegisterRequest æ³¨å†Œè¯·æ±‚
type RegisterRequest struct {
    Email    string `json:"email" binding:"required,email"`
    Username string `json:"username" binding:"required,min=3,max=50"`
    Password string `json:"password" binding:"required,min=8"`
    FullName string `json:"full_name" binding:"required"`
    Phone    string `json:"phone"`
}

// LoginRequest ç™»å½•è¯·æ±‚
type LoginRequest struct {
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required"`
}

// LoginResponse ç™»å½•å“åº”
type LoginResponse struct {
    Token string `json:"token"`
    User  *User  `json:"user"`
}
```

---

## 4. å•†å“æœåŠ¡å®žçŽ°

### 4.1 æ•°æ®æ¨¡åž‹

```go
package product

import (
    "time"
    
    "github.com/google/uuid"
    "gorm.io/gorm"
)

// Product å•†å“æ¨¡åž‹
type Product struct {
    ID          uuid.UUID      `gorm:"type:uuid;primary_key" json:"id"`
    SKU         string         `gorm:"uniqueIndex;not null" json:"sku"`
    Name        string         `gorm:"not null" json:"name"`
    Description string         `json:"description"`
    Price       float64        `gorm:"not null" json:"price"`
    Stock       int            `gorm:"not null" json:"stock"`
    Category    string         `gorm:"index" json:"category"`
    ImageURL    string         `json:"image_url"`
    Status      string         `gorm:"default:'active'" json:"status"` // active, inactive, deleted
    CreatedAt   time.Time      `json:"created_at"`
    UpdatedAt   time.Time      `json:"updated_at"`
    DeletedAt   gorm.DeletedAt `gorm:"index" json:"-"`
}

// BeforeCreate Hook
func (p *Product) BeforeCreate(tx *gorm.DB) error {
    if p.ID == uuid.Nil {
        p.ID = uuid.New()
    }
    return nil
}
```

### 4.2 å•†å“æœåŠ¡å®žçŽ°

```go
package product

import (
    "context"
    "encoding/json"
    "errors"
    "fmt"
    "time"
    
    "github.com/redis/go-redis/v9"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
    "gorm.io/gorm"
)

// Service å•†å“æœåŠ¡
type Service struct {
    db     *gorm.DB
    redis  *redis.Client
    tracer trace.Tracer
    meter  metric.Meter
    
    // Metrics
    queryCounter     metric.Int64Counter
    cacheHitCounter  metric.Int64Counter
    queryDuration    metric.Float64Histogram
}

// NewService åˆ›å»ºå•†å“æœåŠ¡
func NewService(db *gorm.DB, rdb *redis.Client) (*Service, error) {
    tracer := otel.Tracer("product-service")
    meter := otel.Meter("product-service")
    
    svc := &Service{
        db:     db,
        redis:  rdb,
        tracer: tracer,
        meter:  meter,
    }
    
    var err error
    
    // æŸ¥è¯¢è®¡æ•°å™¨
    svc.queryCounter, err = meter.Int64Counter(
        "product.query.count",
        metric.WithDescription("Product query count"),
    )
    if err != nil {
        return nil, err
    }
    
    // ç¼“å­˜å‘½ä¸­è®¡æ•°å™¨
    svc.cacheHitCounter, err = meter.Int64Counter(
        "product.cache.hit.count",
        metric.WithDescription("Product cache hit count"),
    )
    if err != nil {
        return nil, err
    }
    
    // æŸ¥è¯¢å»¶è¿Ÿ
    svc.queryDuration, err = meter.Float64Histogram(
        "product.query.duration",
        metric.WithDescription("Product query duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    return svc, nil
}

// GetByID æ ¹æ® ID èŽ·å–å•†å“ï¼ˆå¸¦ç¼“å­˜ï¼‰
func (s *Service) GetByID(ctx context.Context, productID string) (*Product, error) {
    ctx, span := s.tracer.Start(ctx, "product.get_by_id",
        trace.WithAttributes(
            attribute.String("product.id", productID),
        ),
    )
    defer span.End()
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        s.queryDuration.Record(ctx, float64(duration.Milliseconds()),
            metric.WithAttributes(attribute.String("operation", "get_by_id")),
        )
    }()
    
    // å°è¯•ä»Žç¼“å­˜èŽ·å–
    cacheKey := fmt.Sprintf("product:%s", productID)
    
    cachedData, err := s.redis.Get(ctx, cacheKey).Result()
    if err == nil {
        // ç¼“å­˜å‘½ä¸­
        var product Product
        if err := json.Unmarshal([]byte(cachedData), &product); err == nil {
            span.AddEvent("cache hit")
            span.SetAttributes(attribute.Bool("cache.hit", true))
            s.cacheHitCounter.Add(ctx, 1,
                metric.WithAttributes(attribute.Bool("hit", true)),
            )
            s.queryCounter.Add(ctx, 1,
                metric.WithAttributes(attribute.String("source", "cache")),
            )
            return &product, nil
        }
    }
    
    // ç¼“å­˜æœªå‘½ä¸­ï¼Œä»Žæ•°æ®åº“æŸ¥è¯¢
    span.AddEvent("cache miss")
    span.SetAttributes(attribute.Bool("cache.hit", false))
    s.cacheHitCounter.Add(ctx, 1,
        metric.WithAttributes(attribute.Bool("hit", false)),
    )
    
    var product Product
    if err := s.db.WithContext(ctx).
        Where("id = ? AND status = ?", productID, "active").
        First(&product).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            span.SetStatus(codes.Error, "product not found")
            return nil, errors.New("product not found")
        }
        span.RecordError(err)
        span.SetStatus(codes.Error, "database error")
        return nil, err
    }
    
    // å†™å…¥ç¼“å­˜
    productJSON, _ := json.Marshal(product)
    s.redis.Set(ctx, cacheKey, productJSON, 5*time.Minute)
    
    s.queryCounter.Add(ctx, 1,
        metric.WithAttributes(attribute.String("source", "database")),
    )
    
    span.SetStatus(codes.Ok, "")
    return &product, nil
}

// List åˆ—å‡ºå•†å“
func (s *Service) List(ctx context.Context, req *ListRequest) ([]*Product, int64, error) {
    ctx, span := s.tracer.Start(ctx, "product.list",
        trace.WithAttributes(
            attribute.Int("page", req.Page),
            attribute.Int("page_size", req.PageSize),
            attribute.String("category", req.Category),
        ),
    )
    defer span.End()
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        s.queryDuration.Record(ctx, float64(duration.Milliseconds()),
            metric.WithAttributes(attribute.String("operation", "list")),
        )
    }()
    
    query := s.db.WithContext(ctx).Where("status = ?", "active")
    
    if req.Category != "" {
        query = query.Where("category = ?", req.Category)
    }
    
    if req.MinPrice > 0 {
        query = query.Where("price >= ?", req.MinPrice)
    }
    
    if req.MaxPrice > 0 {
        query = query.Where("price <= ?", req.MaxPrice)
    }
    
    // èŽ·å–æ€»æ•°
    var total int64
    if err := query.Model(&Product{}).Count(&total).Error; err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "count error")
        return nil, 0, err
    }
    
    // åˆ†é¡µæŸ¥è¯¢
    var products []*Product
    offset := (req.Page - 1) * req.PageSize
    if err := query.Offset(offset).Limit(req.PageSize).Find(&products).Error; err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "query error")
        return nil, 0, err
    }
    
    span.SetAttributes(
        attribute.Int64("result.total", total),
        attribute.Int("result.count", len(products)),
    )
    span.SetStatus(codes.Ok, "")
    
    s.queryCounter.Add(ctx, 1,
        metric.WithAttributes(attribute.String("operation", "list")),
    )
    
    return products, total, nil
}

// UpdateStock æ›´æ–°åº“å­˜
func (s *Service) UpdateStock(ctx context.Context, productID string, delta int) error {
    ctx, span := s.tracer.Start(ctx, "product.update_stock",
        trace.WithAttributes(
            attribute.String("product.id", productID),
            attribute.Int("stock.delta", delta),
        ),
    )
    defer span.End()
    
    // ä½¿ç”¨äº‹åŠ¡
    err := s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        var product Product
        
        // é”å®šè¡Œ
        if err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).
            Where("id = ?", productID).
            First(&product).Error; err != nil {
            return err
        }
        
        // æ£€æŸ¥åº“å­˜
        newStock := product.Stock + delta
        if newStock < 0 {
            span.SetStatus(codes.Error, "insufficient stock")
            return errors.New("insufficient stock")
        }
        
        // æ›´æ–°åº“å­˜
        if err := tx.Model(&product).Update("stock", newStock).Error; err != nil {
            return err
        }
        
        span.SetAttributes(
            attribute.Int("stock.old", product.Stock),
            attribute.Int("stock.new", newStock),
        )
        
        // æ¸…é™¤ç¼“å­˜
        cacheKey := fmt.Sprintf("product:%s", productID)
        s.redis.Del(ctx, cacheKey)
        
        return nil
    })
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// ListRequest åˆ—è¡¨è¯·æ±‚
type ListRequest struct {
    Page     int     `form:"page" binding:"required,min=1"`
    PageSize int     `form:"page_size" binding:"required,min=1,max=100"`
    Category string  `form:"category"`
    MinPrice float64 `form:"min_price"`
    MaxPrice float64 `form:"max_price"`
}
```

---

## 5. è®¢å•æœåŠ¡å®žçŽ°

ç”±äºŽå†…å®¹è¾ƒé•¿ï¼Œæˆ‘å°†åœ¨ä¸‹ä¸€ä¸ªæ–‡ä»¶ä¸­ç»§ç»­å®žçŽ°è®¢å•æœåŠ¡ã€æ”¯ä»˜æœåŠ¡ç­‰å†…å®¹ã€‚

---

## æ€»ç»“

æœ¬æ–‡æ¡£å±•ç¤ºäº†ç”µå•†å¾®æœåŠ¡ç³»ç»Ÿçš„åŸºç¡€æž¶æž„å’Œæ ¸å¿ƒæœåŠ¡å®žçŽ°ï¼ŒåŒ…æ‹¬ï¼š

- **ç”¨æˆ·æœåŠ¡**ï¼šæ³¨å†Œã€ç™»å½•ã€JWT è®¤è¯
- **å•†å“æœåŠ¡**ï¼šå•†å“æŸ¥è¯¢ã€ç¼“å­˜ç­–ç•¥ã€åº“å­˜ç®¡ç†

æ¯ä¸ªæœåŠ¡éƒ½å®Œæ•´é›†æˆäº† OpenTelemetry OTLPï¼ŒåŒ…æ‹¬ï¼š

- âœ… Trace è¿½è¸ªï¼ˆSpan åˆ›å»ºã€Context ä¼ æ’­ï¼‰
- âœ… Metrics æŒ‡æ ‡ï¼ˆè®¡æ•°å™¨ã€ç›´æ–¹å›¾ï¼‰
- âœ… æ•°æ®åº“æ’æ¡©ï¼ˆgorm with contextï¼‰
- âœ… ç¼“å­˜è¿½è¸ªï¼ˆRedis æ“ä½œï¼‰

### ç›¸å…³æ–‡æ¡£

- [31_Goé«˜çº§å¹¶å‘æ¨¡å¼ä¸ŽOTLPå®Œæ•´é›†æˆ](./31_Goé«˜çº§å¹¶å‘æ¨¡å¼ä¸ŽOTLPå®Œæ•´é›†æˆ.md)
- [36_Goå¾®æœåŠ¡é—´é€šä¿¡ä¸Žåˆ†å¸ƒå¼è¿½è¸ª](./36_Goå¾®æœåŠ¡é—´é€šä¿¡ä¸Žåˆ†å¸ƒå¼è¿½è¸ª.md)
- [37_Goæ•°æ®åº“ä¸Žç¼“å­˜é›†æˆè¿½è¸ª](./37_Goæ•°æ®åº“ä¸Žç¼“å­˜é›†æˆè¿½è¸ª.md)
- [35_Goç”Ÿäº§çº§éƒ¨ç½²æ¨¡å¼ä¸Žåæ¨¡å¼](./35_Goç”Ÿäº§çº§éƒ¨ç½²æ¨¡å¼ä¸Žåæ¨¡å¼.md)
