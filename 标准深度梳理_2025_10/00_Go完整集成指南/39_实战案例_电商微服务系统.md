# 39. 实战案例：电商微服务系统完整 OTLP 集成

## 📚 目录

- [39. 实战案例：电商微服务系统完整 OTLP 集成](#39-实战案例电商微服务系统完整-otlp-集成)
  - [📚 目录](#-目录)
  - [1. 系统架构](#1-系统架构)
    - [1.1 架构图](#11-架构图)
    - [1.2 技术栈](#12-技术栈)
  - [2. 服务拆分](#2-服务拆分)
    - [2.1 服务清单](#21-服务清单)
    - [2.2 依赖关系](#22-依赖关系)
  - [3. 用户服务实现](#3-用户服务实现)
    - [3.1 数据模型](#31-数据模型)
    - [3.2 用户服务实现](#32-用户服务实现)
  - [4. 商品服务实现](#4-商品服务实现)
    - [4.1 数据模型](#41-数据模型)
    - [4.2 商品服务实现](#42-商品服务实现)
  - [5. 订单服务实现](#5-订单服务实现)
  - [总结](#总结)
    - [相关文档](#相关文档)

---

## 1. 系统架构

### 1.1 架构图

```text
                                    ┌─────────────┐
                                    │   Client    │
                                    └──────┬──────┘
                                           │
                                           ▼
                                    ┌─────────────┐
                                    │ API Gateway │
                                    └──────┬──────┘
                                           │
                ┌──────────────────────────┼──────────────────────────┐
                │                          │                          │
                ▼                          ▼                          ▼
         ┌─────────────┐          ┌─────────────┐          ┌─────────────┐
         │    User     │          │   Product   │          │    Order    │
         │   Service   │          │   Service   │          │   Service   │
         └──────┬──────┘          └──────┬──────┘          └──────┬──────┘
                │                        │                         │
                │                        │                 ┌───────┴───────┐
                │                        │                 │               │
                ▼                        ▼                 ▼               ▼
         ┌─────────────┐          ┌─────────────┐  ┌─────────────┐ ┌─────────────┐
         │  User DB    │          │ Product DB  │  │  Payment    │ │  Inventory  │
         │ (PostgreSQL)│          │ (PostgreSQL)│  │  Service    │ │  Service    │
         └─────────────┘          └─────────────┘  └──────┬──────┘ └──────┬──────┘
                                                           │               │
                                                           ▼               ▼
                                                    ┌─────────────┐ ┌─────────────┐
                                                    │ Payment DB  │ │Inventory DB │
                                                    │ (PostgreSQL)│ │ (PostgreSQL)│
                                                    └─────────────┘ └─────────────┘
                                                    
                                    ┌─────────────────────────────┐
                                    │     Redis (Cache/Queue)     │
                                    └─────────────────────────────┘
                                    
                                    ┌─────────────────────────────┐
                                    │   OTLP Collector/Backend    │
                                    │  (Jaeger/Tempo/Prometheus)  │
                                    └─────────────────────────────┘
```

### 1.2 技术栈

- **语言**: Go 1.25.1
- **框架**: Gin (API Gateway), gRPC (服务间通信)
- **数据库**: PostgreSQL, Redis
- **消息队列**: NATS
- **追踪**: OpenTelemetry + Jaeger/Tempo
- **指标**: Prometheus + Grafana
- **容器**: Docker, Kubernetes

---

## 2. 服务拆分

### 2.1 服务清单

| 服务名称 | 职责 | 端口 | 通信方式 |
|---------|------|------|----------|
| API Gateway | 统一入口、路由、认证 | 8080 | HTTP |
| User Service | 用户管理、认证授权 | 9001 | gRPC |
| Product Service | 商品管理、查询 | 9002 | gRPC |
| Order Service | 订单管理、流程编排 | 9003 | gRPC |
| Payment Service | 支付处理 | 9004 | gRPC |
| Inventory Service | 库存管理 | 9005 | gRPC |

### 2.2 依赖关系

```go
// go.mod
module ecommerce

go 1.25.1

require (
    // OpenTelemetry 核心
    go.opentelemetry.io/otel v1.32.0
    go.opentelemetry.io/otel/sdk v1.32.0
    go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.32.0
    go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc v1.32.0
    
    // OpenTelemetry 库插桩
    go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.57.0
    go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin v0.57.0
    go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.57.0
    go.opentelemetry.io/contrib/instrumentation/database/sql/otelsql v0.57.0
    
    // Web 框架
    github.com/gin-gonic/gin v1.10.0
    google.golang.org/grpc v1.69.2
    google.golang.org/protobuf v1.36.0
    
    // 数据库
    gorm.io/gorm v1.25.12
    gorm.io/driver/postgres v1.5.11
    github.com/redis/go-redis/v9 v9.7.0
    
    // 消息队列
    github.com/nats-io/nats.go v1.38.0
    
    // 工具库
    github.com/google/uuid v1.6.0
    github.com/golang-jwt/jwt/v5 v5.2.1
    golang.org/x/sync v0.10.0
)
```

---

## 3. 用户服务实现

### 3.1 数据模型

```go
package user

import (
    "time"
    
    "github.com/google/uuid"
    "gorm.io/gorm"
)

// User 用户模型
type User struct {
    ID           uuid.UUID      `gorm:"type:uuid;primary_key" json:"id"`
    Email        string         `gorm:"uniqueIndex;not null" json:"email"`
    Username     string         `gorm:"uniqueIndex;not null" json:"username"`
    PasswordHash string         `gorm:"not null" json:"-"`
    FullName     string         `json:"full_name"`
    Phone        string         `json:"phone"`
    Status       string         `gorm:"default:'active'" json:"status"` // active, suspended, deleted
    CreatedAt    time.Time      `json:"created_at"`
    UpdatedAt    time.Time      `json:"updated_at"`
    DeletedAt    gorm.DeletedAt `gorm:"index" json:"-"`
}

// BeforeCreate Hook
func (u *User) BeforeCreate(tx *gorm.DB) error {
    if u.ID == uuid.Nil {
        u.ID = uuid.New()
    }
    return nil
}
```

### 3.2 用户服务实现

```go
package user

import (
    "context"
    "errors"
    "time"
    
    "github.com/golang-jwt/jwt/v5"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
    "golang.org/x/crypto/bcrypt"
    "gorm.io/gorm"
)

// Service 用户服务
type Service struct {
    db     *gorm.DB
    tracer trace.Tracer
    meter  metric.Meter
    
    // Metrics
    registerCounter  metric.Int64Counter
    loginCounter     metric.Int64Counter
    queryDuration    metric.Float64Histogram
}

// NewService 创建用户服务
func NewService(db *gorm.DB) (*Service, error) {
    tracer := otel.Tracer("user-service")
    meter := otel.Meter("user-service")
    
    svc := &Service{
        db:     db,
        tracer: tracer,
        meter:  meter,
    }
    
    var err error
    
    // 注册计数器
    svc.registerCounter, err = meter.Int64Counter(
        "user.register.count",
        metric.WithDescription("User registration count"),
    )
    if err != nil {
        return nil, err
    }
    
    // 登录计数器
    svc.loginCounter, err = meter.Int64Counter(
        "user.login.count",
        metric.WithDescription("User login count"),
    )
    if err != nil {
        return nil, err
    }
    
    // 查询延迟
    svc.queryDuration, err = meter.Float64Histogram(
        "user.query.duration",
        metric.WithDescription("User query duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    return svc, nil
}

// Register 用户注册
func (s *Service) Register(ctx context.Context, req *RegisterRequest) (*User, error) {
    ctx, span := s.tracer.Start(ctx, "user.register",
        trace.WithAttributes(
            attribute.String("user.email", req.Email),
            attribute.String("user.username", req.Username),
        ),
    )
    defer span.End()
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        s.queryDuration.Record(ctx, float64(duration.Milliseconds()),
            metric.WithAttributes(attribute.String("operation", "register")),
        )
    }()
    
    // 检查用户是否已存在
    var existingUser User
    if err := s.db.WithContext(ctx).
        Where("email = ? OR username = ?", req.Email, req.Username).
        First(&existingUser).Error; err == nil {
        span.SetStatus(codes.Error, "user already exists")
        s.registerCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("status", "failed"),
                attribute.String("reason", "user_exists"),
            ),
        )
        return nil, errors.New("user already exists")
    }
    
    // 密码哈希
    passwordHash, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "password hashing failed")
        return nil, err
    }
    
    // 创建用户
    user := &User{
        Email:        req.Email,
        Username:     req.Username,
        PasswordHash: string(passwordHash),
        FullName:     req.FullName,
        Phone:        req.Phone,
        Status:       "active",
    }
    
    if err := s.db.WithContext(ctx).Create(user).Error; err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "database error")
        s.registerCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("status", "failed"),
                attribute.String("reason", "database_error"),
            ),
        )
        return nil, err
    }
    
    span.SetAttributes(attribute.String("user.id", user.ID.String()))
    span.SetStatus(codes.Ok, "")
    
    s.registerCounter.Add(ctx, 1,
        metric.WithAttributes(attribute.String("status", "success")),
    )
    
    return user, nil
}

// Login 用户登录
func (s *Service) Login(ctx context.Context, req *LoginRequest) (*LoginResponse, error) {
    ctx, span := s.tracer.Start(ctx, "user.login",
        trace.WithAttributes(
            attribute.String("user.email", req.Email),
        ),
    )
    defer span.End()
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        s.queryDuration.Record(ctx, float64(duration.Milliseconds()),
            metric.WithAttributes(attribute.String("operation", "login")),
        )
    }()
    
    // 查找用户
    var user User
    if err := s.db.WithContext(ctx).
        Where("email = ? AND status = ?", req.Email, "active").
        First(&user).Error; err != nil {
        span.SetStatus(codes.Error, "user not found")
        s.loginCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("status", "failed"),
                attribute.String("reason", "user_not_found"),
            ),
        )
        return nil, errors.New("invalid credentials")
    }
    
    span.SetAttributes(attribute.String("user.id", user.ID.String()))
    
    // 验证密码
    if err := bcrypt.CompareHashAndPassword(
        []byte(user.PasswordHash),
        []byte(req.Password),
    ); err != nil {
        span.SetStatus(codes.Error, "invalid password")
        s.loginCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("status", "failed"),
                attribute.String("reason", "invalid_password"),
            ),
        )
        return nil, errors.New("invalid credentials")
    }
    
    // 生成 JWT Token
    token, err := s.generateToken(user.ID)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "token generation failed")
        return nil, err
    }
    
    span.SetStatus(codes.Ok, "")
    s.loginCounter.Add(ctx, 1,
        metric.WithAttributes(attribute.String("status", "success")),
    )
    
    return &LoginResponse{
        Token: token,
        User:  &user,
    }, nil
}

// GetByID 根据 ID 获取用户
func (s *Service) GetByID(ctx context.Context, userID string) (*User, error) {
    ctx, span := s.tracer.Start(ctx, "user.get_by_id",
        trace.WithAttributes(
            attribute.String("user.id", userID),
        ),
    )
    defer span.End()
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        s.queryDuration.Record(ctx, float64(duration.Milliseconds()),
            metric.WithAttributes(attribute.String("operation", "get_by_id")),
        )
    }()
    
    var user User
    if err := s.db.WithContext(ctx).
        Where("id = ? AND status = ?", userID, "active").
        First(&user).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            span.SetStatus(codes.Error, "user not found")
            return nil, errors.New("user not found")
        }
        span.RecordError(err)
        span.SetStatus(codes.Error, "database error")
        return nil, err
    }
    
    span.SetStatus(codes.Ok, "")
    return &user, nil
}

// generateToken 生成 JWT Token
func (s *Service) generateToken(userID uuid.UUID) (string, error) {
    claims := jwt.MapClaims{
        "user_id": userID.String(),
        "exp":     time.Now().Add(24 * time.Hour).Unix(),
        "iat":     time.Now().Unix(),
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte("your-secret-key")) // 应从环境变量读取
}

// RegisterRequest 注册请求
type RegisterRequest struct {
    Email    string `json:"email" binding:"required,email"`
    Username string `json:"username" binding:"required,min=3,max=50"`
    Password string `json:"password" binding:"required,min=8"`
    FullName string `json:"full_name" binding:"required"`
    Phone    string `json:"phone"`
}

// LoginRequest 登录请求
type LoginRequest struct {
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required"`
}

// LoginResponse 登录响应
type LoginResponse struct {
    Token string `json:"token"`
    User  *User  `json:"user"`
}
```

---

## 4. 商品服务实现

### 4.1 数据模型

```go
package product

import (
    "time"
    
    "github.com/google/uuid"
    "gorm.io/gorm"
)

// Product 商品模型
type Product struct {
    ID          uuid.UUID      `gorm:"type:uuid;primary_key" json:"id"`
    SKU         string         `gorm:"uniqueIndex;not null" json:"sku"`
    Name        string         `gorm:"not null" json:"name"`
    Description string         `json:"description"`
    Price       float64        `gorm:"not null" json:"price"`
    Stock       int            `gorm:"not null" json:"stock"`
    Category    string         `gorm:"index" json:"category"`
    ImageURL    string         `json:"image_url"`
    Status      string         `gorm:"default:'active'" json:"status"` // active, inactive, deleted
    CreatedAt   time.Time      `json:"created_at"`
    UpdatedAt   time.Time      `json:"updated_at"`
    DeletedAt   gorm.DeletedAt `gorm:"index" json:"-"`
}

// BeforeCreate Hook
func (p *Product) BeforeCreate(tx *gorm.DB) error {
    if p.ID == uuid.Nil {
        p.ID = uuid.New()
    }
    return nil
}
```

### 4.2 商品服务实现

```go
package product

import (
    "context"
    "encoding/json"
    "errors"
    "fmt"
    "time"
    
    "github.com/redis/go-redis/v9"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
    "gorm.io/gorm"
)

// Service 商品服务
type Service struct {
    db     *gorm.DB
    redis  *redis.Client
    tracer trace.Tracer
    meter  metric.Meter
    
    // Metrics
    queryCounter     metric.Int64Counter
    cacheHitCounter  metric.Int64Counter
    queryDuration    metric.Float64Histogram
}

// NewService 创建商品服务
func NewService(db *gorm.DB, rdb *redis.Client) (*Service, error) {
    tracer := otel.Tracer("product-service")
    meter := otel.Meter("product-service")
    
    svc := &Service{
        db:     db,
        redis:  rdb,
        tracer: tracer,
        meter:  meter,
    }
    
    var err error
    
    // 查询计数器
    svc.queryCounter, err = meter.Int64Counter(
        "product.query.count",
        metric.WithDescription("Product query count"),
    )
    if err != nil {
        return nil, err
    }
    
    // 缓存命中计数器
    svc.cacheHitCounter, err = meter.Int64Counter(
        "product.cache.hit.count",
        metric.WithDescription("Product cache hit count"),
    )
    if err != nil {
        return nil, err
    }
    
    // 查询延迟
    svc.queryDuration, err = meter.Float64Histogram(
        "product.query.duration",
        metric.WithDescription("Product query duration"),
        metric.WithUnit("ms"),
    )
    if err != nil {
        return nil, err
    }
    
    return svc, nil
}

// GetByID 根据 ID 获取商品（带缓存）
func (s *Service) GetByID(ctx context.Context, productID string) (*Product, error) {
    ctx, span := s.tracer.Start(ctx, "product.get_by_id",
        trace.WithAttributes(
            attribute.String("product.id", productID),
        ),
    )
    defer span.End()
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        s.queryDuration.Record(ctx, float64(duration.Milliseconds()),
            metric.WithAttributes(attribute.String("operation", "get_by_id")),
        )
    }()
    
    // 尝试从缓存获取
    cacheKey := fmt.Sprintf("product:%s", productID)
    
    cachedData, err := s.redis.Get(ctx, cacheKey).Result()
    if err == nil {
        // 缓存命中
        var product Product
        if err := json.Unmarshal([]byte(cachedData), &product); err == nil {
            span.AddEvent("cache hit")
            span.SetAttributes(attribute.Bool("cache.hit", true))
            s.cacheHitCounter.Add(ctx, 1,
                metric.WithAttributes(attribute.Bool("hit", true)),
            )
            s.queryCounter.Add(ctx, 1,
                metric.WithAttributes(attribute.String("source", "cache")),
            )
            return &product, nil
        }
    }
    
    // 缓存未命中，从数据库查询
    span.AddEvent("cache miss")
    span.SetAttributes(attribute.Bool("cache.hit", false))
    s.cacheHitCounter.Add(ctx, 1,
        metric.WithAttributes(attribute.Bool("hit", false)),
    )
    
    var product Product
    if err := s.db.WithContext(ctx).
        Where("id = ? AND status = ?", productID, "active").
        First(&product).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            span.SetStatus(codes.Error, "product not found")
            return nil, errors.New("product not found")
        }
        span.RecordError(err)
        span.SetStatus(codes.Error, "database error")
        return nil, err
    }
    
    // 写入缓存
    productJSON, _ := json.Marshal(product)
    s.redis.Set(ctx, cacheKey, productJSON, 5*time.Minute)
    
    s.queryCounter.Add(ctx, 1,
        metric.WithAttributes(attribute.String("source", "database")),
    )
    
    span.SetStatus(codes.Ok, "")
    return &product, nil
}

// List 列出商品
func (s *Service) List(ctx context.Context, req *ListRequest) ([]*Product, int64, error) {
    ctx, span := s.tracer.Start(ctx, "product.list",
        trace.WithAttributes(
            attribute.Int("page", req.Page),
            attribute.Int("page_size", req.PageSize),
            attribute.String("category", req.Category),
        ),
    )
    defer span.End()
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        s.queryDuration.Record(ctx, float64(duration.Milliseconds()),
            metric.WithAttributes(attribute.String("operation", "list")),
        )
    }()
    
    query := s.db.WithContext(ctx).Where("status = ?", "active")
    
    if req.Category != "" {
        query = query.Where("category = ?", req.Category)
    }
    
    if req.MinPrice > 0 {
        query = query.Where("price >= ?", req.MinPrice)
    }
    
    if req.MaxPrice > 0 {
        query = query.Where("price <= ?", req.MaxPrice)
    }
    
    // 获取总数
    var total int64
    if err := query.Model(&Product{}).Count(&total).Error; err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "count error")
        return nil, 0, err
    }
    
    // 分页查询
    var products []*Product
    offset := (req.Page - 1) * req.PageSize
    if err := query.Offset(offset).Limit(req.PageSize).Find(&products).Error; err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "query error")
        return nil, 0, err
    }
    
    span.SetAttributes(
        attribute.Int64("result.total", total),
        attribute.Int("result.count", len(products)),
    )
    span.SetStatus(codes.Ok, "")
    
    s.queryCounter.Add(ctx, 1,
        metric.WithAttributes(attribute.String("operation", "list")),
    )
    
    return products, total, nil
}

// UpdateStock 更新库存
func (s *Service) UpdateStock(ctx context.Context, productID string, delta int) error {
    ctx, span := s.tracer.Start(ctx, "product.update_stock",
        trace.WithAttributes(
            attribute.String("product.id", productID),
            attribute.Int("stock.delta", delta),
        ),
    )
    defer span.End()
    
    // 使用事务
    err := s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        var product Product
        
        // 锁定行
        if err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).
            Where("id = ?", productID).
            First(&product).Error; err != nil {
            return err
        }
        
        // 检查库存
        newStock := product.Stock + delta
        if newStock < 0 {
            span.SetStatus(codes.Error, "insufficient stock")
            return errors.New("insufficient stock")
        }
        
        // 更新库存
        if err := tx.Model(&product).Update("stock", newStock).Error; err != nil {
            return err
        }
        
        span.SetAttributes(
            attribute.Int("stock.old", product.Stock),
            attribute.Int("stock.new", newStock),
        )
        
        // 清除缓存
        cacheKey := fmt.Sprintf("product:%s", productID)
        s.redis.Del(ctx, cacheKey)
        
        return nil
    })
    
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }
    
    span.SetStatus(codes.Ok, "")
    return nil
}

// ListRequest 列表请求
type ListRequest struct {
    Page     int     `form:"page" binding:"required,min=1"`
    PageSize int     `form:"page_size" binding:"required,min=1,max=100"`
    Category string  `form:"category"`
    MinPrice float64 `form:"min_price"`
    MaxPrice float64 `form:"max_price"`
}
```

---

## 5. 订单服务实现

由于内容较长，我将在下一个文件中继续实现订单服务、支付服务等内容。

---

## 总结

本文档展示了电商微服务系统的基础架构和核心服务实现，包括：

- **用户服务**：注册、登录、JWT 认证
- **商品服务**：商品查询、缓存策略、库存管理

每个服务都完整集成了 OpenTelemetry OTLP，包括：

- ✅ Trace 追踪（Span 创建、Context 传播）
- ✅ Metrics 指标（计数器、直方图）
- ✅ 数据库插桩（gorm with context）
- ✅ 缓存追踪（Redis 操作）

### 相关文档

- [31_Go高级并发模式与OTLP完整集成](./31_Go高级并发模式与OTLP完整集成.md)
- [36_Go微服务间通信与分布式追踪](./36_Go微服务间通信与分布式追踪.md)
- [37_Go数据库与缓存集成追踪](./37_Go数据库与缓存集成追踪.md)
- [35_Go生产级部署模式与反模式](./35_Go生产级部署模式与反模式.md)
