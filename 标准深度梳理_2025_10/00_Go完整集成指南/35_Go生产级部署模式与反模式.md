# Go ç”Ÿäº§çº§éƒ¨ç½²æ¨¡å¼ä¸åæ¨¡å¼

> **Go ç‰ˆæœ¬**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ10æ—¥

---

## ğŸ“‹ ç›®å½•

- [Go ç”Ÿäº§çº§éƒ¨ç½²æ¨¡å¼ä¸åæ¨¡å¼](#go-ç”Ÿäº§çº§éƒ¨ç½²æ¨¡å¼ä¸åæ¨¡å¼)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
  - [ç”Ÿäº§çº§åˆå§‹åŒ–](#ç”Ÿäº§çº§åˆå§‹åŒ–)
    - [å®Œæ•´çš„åº”ç”¨åˆå§‹åŒ–](#å®Œæ•´çš„åº”ç”¨åˆå§‹åŒ–)
  - [ä¼˜é›…å…³é—­æ¨¡å¼](#ä¼˜é›…å…³é—­æ¨¡å¼)
    - [å®Œæ•´çš„ä¼˜é›…å…³é—­å®ç°](#å®Œæ•´çš„ä¼˜é›…å…³é—­å®ç°)
  - [å¥åº·æ£€æŸ¥](#å¥åº·æ£€æŸ¥)
    - [å®Œæ•´çš„å¥åº·æ£€æŸ¥å®ç°](#å®Œæ•´çš„å¥åº·æ£€æŸ¥å®ç°)
  - [å¸¸è§åæ¨¡å¼](#å¸¸è§åæ¨¡å¼)
    - [âŒ åæ¨¡å¼ 1: ä¸å¤„ç†å…³é—­](#-åæ¨¡å¼-1-ä¸å¤„ç†å…³é—­)
    - [âŒ åæ¨¡å¼ 2: é˜»å¡å¯¼å‡º](#-åæ¨¡å¼-2-é˜»å¡å¯¼å‡º)
    - [âŒ åæ¨¡å¼ 3: è¿‡åº¦é‡‡æ ·](#-åæ¨¡å¼-3-è¿‡åº¦é‡‡æ ·)
    - [âŒ åæ¨¡å¼ 4: å¿½ç•¥ Context](#-åæ¨¡å¼-4-å¿½ç•¥-context)
    - [âŒ åæ¨¡å¼ 5: å†…å­˜æ³„æ¼](#-åæ¨¡å¼-5-å†…å­˜æ³„æ¼)
  - [éƒ¨ç½²æœ€ä½³å®è·µ](#éƒ¨ç½²æœ€ä½³å®è·µ)
    - [1. ç¯å¢ƒå˜é‡é…ç½®](#1-ç¯å¢ƒå˜é‡é…ç½®)
    - [2. Docker éƒ¨ç½²](#2-docker-éƒ¨ç½²)
    - [3. Kubernetes éƒ¨ç½²](#3-kubernetes-éƒ¨ç½²)
  - [æ€»ç»“](#æ€»ç»“)

---

## æ¦‚è¿°

æœ¬æ–‡æ¡£æ€»ç»“äº† Go åº”ç”¨ä¸ OpenTelemetry é›†æˆçš„ç”Ÿäº§çº§éƒ¨ç½²æ¨¡å¼å’Œåº”è¯¥é¿å…çš„åæ¨¡å¼ã€‚

**æ ¸å¿ƒåŸåˆ™**:

```text
âœ… ä¼˜é›…å¯åŠ¨å’Œå…³é—­
âœ… å®Œæ•´çš„å¥åº·æ£€æŸ¥
âœ… ç»“æ„åŒ–æ—¥å¿—
âœ… åˆ†å¸ƒå¼è¿½è¸ª
âœ… è‡ªåŠ¨åŒ–ç›‘æ§
âœ… é…ç½®çƒ­æ›´æ–°
âœ… é”™è¯¯æ¢å¤
```

---

## ç”Ÿäº§çº§åˆå§‹åŒ–

### å®Œæ•´çš„åº”ç”¨åˆå§‹åŒ–

```go
package main

import (
    "context"
    "fmt"
    "log"
    "os"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/sdk/metric"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.27.0"
)

// Application åº”ç”¨ç¨‹åºç»“æ„
type Application struct {
    config         *Config
    tracerProvider *sdktrace.TracerProvider
    meterProvider  *metric.MeterProvider
    logger         *Logger
    shutdown       []func(context.Context) error
}

// NewApplication åˆ›å»ºåº”ç”¨ç¨‹åº
func NewApplication(ctx context.Context, cfg *Config) (*Application, error) {
    app := &Application{
        config:   cfg,
        shutdown: make([]func(context.Context) error, 0),
    }
    
    // 1. åˆå§‹åŒ–æ—¥å¿—
    if err := app.initLogger(); err != nil {
        return nil, fmt.Errorf("failed to init logger: %w", err)
    }
    
    // 2. åˆå§‹åŒ–è¿½è¸ª
    if err := app.initTracing(ctx); err != nil {
        return nil, fmt.Errorf("failed to init tracing: %w", err)
    }
    
    // 3. åˆå§‹åŒ–æŒ‡æ ‡
    if err := app.initMetrics(ctx); err != nil {
        return nil, fmt.Errorf("failed to init metrics: %w", err)
    }
    
    // 4. è®¾ç½®ä¼ æ’­å™¨
    app.initPropagators()
    
    app.logger.Info("application initialized successfully",
        "service", cfg.ServiceName,
        "version", cfg.ServiceVersion,
        "environment", cfg.Environment,
    )
    
    return app, nil
}

// initTracing åˆå§‹åŒ–è¿½è¸ª
func (app *Application) initTracing(ctx context.Context) error {
    // åˆ›å»º OTLP å¯¼å‡ºå™¨
    exporter, err := otlptracegrpc.New(ctx,
        otlptracegrpc.WithEndpoint(app.config.OTLPEndpoint),
        otlptracegrpc.WithInsecure(), // ç”Ÿäº§ç¯å¢ƒåº”ä½¿ç”¨ TLS
        otlptracegrpc.WithTimeout(10*time.Second),
        otlptracegrpc.WithRetry(otlptracegrpc.RetryConfig{
            Enabled:         true,
            InitialInterval: 1 * time.Second,
            MaxInterval:     30 * time.Second,
            MaxElapsedTime:  5 * time.Minute,
        }),
    )
    if err != nil {
        return err
    }
    
    // åˆ›å»ºèµ„æº
    res, err := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName(app.config.ServiceName),
            semconv.ServiceVersion(app.config.ServiceVersion),
            semconv.DeploymentEnvironment(app.config.Environment),
        ),
        resource.WithFromEnv(),
        resource.WithProcess(),
        resource.WithOS(),
        resource.WithContainer(),
        resource.WithHost(),
    )
    if err != nil {
        return err
    }
    
    // åˆ›å»ºé‡‡æ ·å™¨
    sampler := sdktrace.ParentBased(
        sdktrace.TraceIDRatioBased(app.config.TraceSampleRate),
    )
    
    // åˆ›å»º TracerProvider
    app.tracerProvider = sdktrace.NewTracerProvider(
        sdktrace.WithBatcher(exporter,
            sdktrace.WithBatchTimeout(5*time.Second),
            sdktrace.WithMaxExportBatchSize(512),
            sdktrace.WithMaxQueueSize(2048),
        ),
        sdktrace.WithResource(res),
        sdktrace.WithSampler(sampler),
    )
    
    // è®¾ç½®å…¨å±€ TracerProvider
    otel.SetTracerProvider(app.tracerProvider)
    
    // æ³¨å†Œå…³é—­å‡½æ•°
    app.shutdown = append(app.shutdown, app.tracerProvider.Shutdown)
    
    return nil
}

// initMetrics åˆå§‹åŒ–æŒ‡æ ‡
func (app *Application) initMetrics(ctx context.Context) error {
    // åˆ›å»º OTLP å¯¼å‡ºå™¨
    exporter, err := otlpmetricgrpc.New(ctx,
        otlpmetricgrpc.WithEndpoint(app.config.OTLPEndpoint),
        otlpmetricgrpc.WithInsecure(),
        otlpmetricgrpc.WithTimeout(10*time.Second),
    )
    if err != nil {
        return err
    }
    
    // åˆ›å»ºèµ„æº
    res, err := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceName(app.config.ServiceName),
            semconv.ServiceVersion(app.config.ServiceVersion),
            semconv.DeploymentEnvironment(app.config.Environment),
        ),
    )
    if err != nil {
        return err
    }
    
    // åˆ›å»º Reader
    reader := metric.NewPeriodicReader(exporter,
        metric.WithInterval(30*time.Second),
    )
    
    // åˆ›å»º MeterProvider
    app.meterProvider = metric.NewMeterProvider(
        metric.WithResource(res),
        metric.WithReader(reader),
    )
    
    // è®¾ç½®å…¨å±€ MeterProvider
    otel.SetMeterProvider(app.meterProvider)
    
    // æ³¨å†Œå…³é—­å‡½æ•°
    app.shutdown = append(app.shutdown, app.meterProvider.Shutdown)
    
    return nil
}

// initPropagators åˆå§‹åŒ–ä¼ æ’­å™¨
func (app *Application) initPropagators() {
    otel.SetTextMapPropagator(
        propagation.NewCompositeTextMapPropagator(
            propagation.TraceContext{},
            propagation.Baggage{},
        ),
    )
}

// initLogger åˆå§‹åŒ–æ—¥å¿—
func (app *Application) initLogger() error {
    logger, err := NewLogger(app.config.LogLevel)
    if err != nil {
        return err
    }
    
    app.logger = logger
    return nil
}

// Shutdown ä¼˜é›…å…³é—­
func (app *Application) Shutdown(ctx context.Context) error {
    app.logger.Info("shutting down application")
    
    var errs []error
    
    for i := len(app.shutdown) - 1; i >= 0; i-- {
        if err := app.shutdown[i](ctx); err != nil {
            errs = append(errs, err)
        }
    }
    
    if len(errs) > 0 {
        return errors.Join(errs...)
    }
    
    app.logger.Info("application shutdown complete")
    return nil
}

// Config é…ç½®
type Config struct {
    ServiceName      string
    ServiceVersion   string
    Environment      string
    OTLPEndpoint     string
    TraceSampleRate  float64
    LogLevel         string
}

// LoadConfig åŠ è½½é…ç½®
func LoadConfig() (*Config, error) {
    return &Config{
        ServiceName:     getEnv("SERVICE_NAME", "my-service"),
        ServiceVersion:  getEnv("SERVICE_VERSION", "1.0.0"),
        Environment:     getEnv("ENVIRONMENT", "production"),
        OTLPEndpoint:    getEnv("OTLP_ENDPOINT", "localhost:4317"),
        TraceSampleRate: getEnvFloat("TRACE_SAMPLE_RATE", 0.1),
        LogLevel:        getEnv("LOG_LEVEL", "info"),
    }, nil
}

func getEnv(key, fallback string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return fallback
}

func getEnvFloat(key string, fallback float64) float64 {
    if value := os.Getenv(key); value != "" {
        if f, err := strconv.ParseFloat(value, 64); err == nil {
            return f
        }
    }
    return fallback
}
```

---

## ä¼˜é›…å…³é—­æ¨¡å¼

### å®Œæ•´çš„ä¼˜é›…å…³é—­å®ç°

```go
package shutdown

import (
    "context"
    "os"
    "os/signal"
    "sync"
    "syscall"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// GracefulShutdown ä¼˜é›…å…³é—­ç®¡ç†å™¨
type GracefulShutdown struct {
    timeout  time.Duration
    handlers []ShutdownHandler
    tracer   trace.Tracer
    mu       sync.Mutex
}

// ShutdownHandler å…³é—­å¤„ç†å™¨
type ShutdownHandler struct {
    Name    string
    Handler func(context.Context) error
    Order   int // æ‰§è¡Œé¡ºåºï¼Œæ•°å­—è¶Šå°è¶Šå…ˆæ‰§è¡Œ
}

// NewGracefulShutdown åˆ›å»ºä¼˜é›…å…³é—­ç®¡ç†å™¨
func NewGracefulShutdown(timeout time.Duration) *GracefulShutdown {
    return &GracefulShutdown{
        timeout:  timeout,
        handlers: make([]ShutdownHandler, 0),
        tracer:   otel.Tracer("graceful-shutdown"),
    }
}

// Register æ³¨å†Œå…³é—­å¤„ç†å™¨
func (gs *GracefulShutdown) Register(handler ShutdownHandler) {
    gs.mu.Lock()
    defer gs.mu.Unlock()
    
    gs.handlers = append(gs.handlers, handler)
}

// WaitForShutdown ç­‰å¾…å…³é—­ä¿¡å·
func (gs *GracefulShutdown) WaitForShutdown(ctx context.Context) error {
    ctx, span := gs.tracer.Start(ctx, "graceful-shutdown")
    defer span.End()
    
    // ç›‘å¬ä¿¡å·
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM, syscall.SIGINT)
    
    // ç­‰å¾…ä¿¡å·
    sig := <-sigChan
    span.AddEvent("received shutdown signal", trace.WithAttributes(
        attribute.String("signal", sig.String()),
    ))
    
    // åˆ›å»ºå…³é—­ context
    shutdownCtx, cancel := context.WithTimeout(context.Background(), gs.timeout)
    defer cancel()
    
    // æŒ‰é¡ºåºæ‰§è¡Œå…³é—­å¤„ç†å™¨
    return gs.executeShutdown(shutdownCtx, span)
}

// executeShutdown æ‰§è¡Œå…³é—­æµç¨‹
func (gs *GracefulShutdown) executeShutdown(ctx context.Context, span trace.Span) error {
    gs.mu.Lock()
    handlers := make([]ShutdownHandler, len(gs.handlers))
    copy(handlers, gs.handlers)
    gs.mu.Unlock()
    
    // æŒ‰ Order æ’åº
    sort.Slice(handlers, func(i, j int) bool {
        return handlers[i].Order < handlers[j].Order
    })
    
    var errs []error
    
    for _, handler := range handlers {
        span.AddEvent("executing shutdown handler", trace.WithAttributes(
            attribute.String("handler", handler.Name),
            attribute.Int("order", handler.Order),
        ))
        
        if err := handler.Handler(ctx); err != nil {
            span.RecordError(err)
            errs = append(errs, fmt.Errorf("%s: %w", handler.Name, err))
        } else {
            span.AddEvent("shutdown handler completed", trace.WithAttributes(
                attribute.String("handler", handler.Name),
            ))
        }
    }
    
    if len(errs) > 0 {
        return errors.Join(errs...)
    }
    
    return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    ctx := context.Background()
    
    // åŠ è½½é…ç½®
    cfg, err := LoadConfig()
    if err != nil {
        log.Fatal(err)
    }
    
    // åˆå§‹åŒ–åº”ç”¨
    app, err := NewApplication(ctx, cfg)
    if err != nil {
        log.Fatal(err)
    }
    
    // åˆ›å»ºä¼˜é›…å…³é—­ç®¡ç†å™¨
    gs := NewGracefulShutdown(30 * time.Second)
    
    // æ³¨å†Œå…³é—­å¤„ç†å™¨ï¼ˆæŒ‰é¡ºåºï¼‰
    gs.Register(ShutdownHandler{
        Name:  "stop-accepting-requests",
        Order: 1,
        Handler: func(ctx context.Context) error {
            // åœæ­¢æ¥å—æ–°è¯·æ±‚
            return httpServer.Shutdown(ctx)
        },
    })
    
    gs.Register(ShutdownHandler{
        Name:  "drain-active-connections",
        Order: 2,
        Handler: func(ctx context.Context) error {
            // ç­‰å¾…æ´»è·ƒè¿æ¥å®Œæˆ
            time.Sleep(5 * time.Second)
            return nil
        },
    })
    
    gs.Register(ShutdownHandler{
        Name:  "shutdown-otlp",
        Order: 3,
        Handler: func(ctx context.Context) error {
            // å…³é—­ OTLP
            return app.Shutdown(ctx)
        },
    })
    
    gs.Register(ShutdownHandler{
        Name:  "close-database",
        Order: 4,
        Handler: func(ctx context.Context) error {
            // å…³é—­æ•°æ®åº“
            return db.Close()
        },
    })
    
    // å¯åŠ¨æœåŠ¡
    go func() {
        if err := httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatal(err)
        }
    }()
    
    // ç­‰å¾…å…³é—­ä¿¡å·
    if err := gs.WaitForShutdown(ctx); err != nil {
        log.Printf("Shutdown error: %v", err)
        os.Exit(1)
    }
    
    log.Println("Shutdown complete")
}
```

---

## å¥åº·æ£€æŸ¥

### å®Œæ•´çš„å¥åº·æ£€æŸ¥å®ç°

```go
package health

import (
    "context"
    "encoding/json"
    "net/http"
    "sync"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// HealthChecker å¥åº·æ£€æŸ¥å™¨
type HealthChecker struct {
    checks  map[string]HealthCheck
    tracer  trace.Tracer
    mu      sync.RWMutex
}

// HealthCheck å¥åº·æ£€æŸ¥æ¥å£
type HealthCheck interface {
    Name() string
    Check(context.Context) error
}

// HealthStatus å¥åº·çŠ¶æ€
type HealthStatus string

const (
    StatusHealthy   HealthStatus = "healthy"
    StatusDegraded  HealthStatus = "degraded"
    StatusUnhealthy HealthStatus = "unhealthy"
)

// HealthResponse å¥åº·æ£€æŸ¥å“åº”
type HealthResponse struct {
    Status    HealthStatus           `json:"status"`
    Timestamp time.Time              `json:"timestamp"`
    Checks    map[string]CheckResult `json:"checks"`
}

// CheckResult æ£€æŸ¥ç»“æœ
type CheckResult struct {
    Status  HealthStatus `json:"status"`
    Message string       `json:"message,omitempty"`
    Latency string       `json:"latency"`
}

// NewHealthChecker åˆ›å»ºå¥åº·æ£€æŸ¥å™¨
func NewHealthChecker() *HealthChecker {
    return &HealthChecker{
        checks: make(map[string]HealthCheck),
        tracer: otel.Tracer("health-checker"),
    }
}

// Register æ³¨å†Œå¥åº·æ£€æŸ¥
func (hc *HealthChecker) Register(check HealthCheck) {
    hc.mu.Lock()
    defer hc.mu.Unlock()
    
    hc.checks[check.Name()] = check
}

// CheckHealth æ‰§è¡Œå¥åº·æ£€æŸ¥
func (hc *HealthChecker) CheckHealth(ctx context.Context) HealthResponse {
    ctx, span := hc.tracer.Start(ctx, "health.check")
    defer span.End()
    
    hc.mu.RLock()
    checks := make(map[string]HealthCheck, len(hc.checks))
    for name, check := range hc.checks {
        checks[name] = check
    }
    hc.mu.RUnlock()
    
    results := make(map[string]CheckResult)
    overallStatus := StatusHealthy
    
    for name, check := range checks {
        start := time.Now()
        
        err := check.Check(ctx)
        latency := time.Since(start)
        
        var result CheckResult
        if err != nil {
            result = CheckResult{
                Status:  StatusUnhealthy,
                Message: err.Error(),
                Latency: latency.String(),
            }
            overallStatus = StatusUnhealthy
            
            span.RecordError(err)
        } else {
            result = CheckResult{
                Status:  StatusHealthy,
                Latency: latency.String(),
            }
        }
        
        results[name] = result
        
        span.AddEvent("health check completed", trace.WithAttributes(
            attribute.String("check", name),
            attribute.String("status", string(result.Status)),
            attribute.Float64("latency_ms", float64(latency.Milliseconds())),
        ))
    }
    
    response := HealthResponse{
        Status:    overallStatus,
        Timestamp: time.Now(),
        Checks:    results,
    }
    
    span.SetAttributes(
        attribute.String("overall_status", string(overallStatus)),
        attribute.Int("checks_count", len(results)),
    )
    
    return response
}

// Handler HTTP å¥åº·æ£€æŸ¥å¤„ç†å™¨
func (hc *HealthChecker) Handler() http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        ctx := r.Context()
        
        response := hc.CheckHealth(ctx)
        
        w.Header().Set("Content-Type", "application/json")
        
        // æ ¹æ®çŠ¶æ€è®¾ç½® HTTP çŠ¶æ€ç 
        switch response.Status {
        case StatusHealthy:
            w.WriteHeader(http.StatusOK)
        case StatusDegraded:
            w.WriteHeader(http.StatusOK) // é™çº§ä½†ä»å¯ç”¨
        case StatusUnhealthy:
            w.WriteHeader(http.StatusServiceUnavailable)
        }
        
        json.NewEncoder(w).Encode(response)
    }
}

// å…·ä½“å¥åº·æ£€æŸ¥å®ç°

// DatabaseHealthCheck æ•°æ®åº“å¥åº·æ£€æŸ¥
type DatabaseHealthCheck struct {
    db *sql.DB
}

func (dhc *DatabaseHealthCheck) Name() string {
    return "database"
}

func (dhc *DatabaseHealthCheck) Check(ctx context.Context) error {
    ctx, cancel := context.WithTimeout(ctx, 2*time.Second)
    defer cancel()
    
    return dhc.db.PingContext(ctx)
}

// OTLPHealthCheck OTLP å¥åº·æ£€æŸ¥
type OTLPHealthCheck struct {
    endpoint string
}

func (ohc *OTLPHealthCheck) Name() string {
    return "otlp"
}

func (ohc *OTLPHealthCheck) Check(ctx context.Context) error {
    // æ£€æŸ¥æ˜¯å¦èƒ½è¿æ¥åˆ° OTLP Collector
    conn, err := grpc.DialContext(ctx, ohc.endpoint,
        grpc.WithInsecure(),
        grpc.WithTimeout(2*time.Second),
    )
    if err != nil {
        return err
    }
    defer conn.Close()
    
    return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func SetupHealthChecks(db *sql.DB, otlpEndpoint string) *HealthChecker {
    hc := NewHealthChecker()
    
    // æ³¨å†Œæ•°æ®åº“å¥åº·æ£€æŸ¥
    hc.Register(&DatabaseHealthCheck{db: db})
    
    // æ³¨å†Œ OTLP å¥åº·æ£€æŸ¥
    hc.Register(&OTLPHealthCheck{endpoint: otlpEndpoint})
    
    return hc
}
```

---

## å¸¸è§åæ¨¡å¼

### âŒ åæ¨¡å¼ 1: ä¸å¤„ç†å…³é—­

```go
// âŒ é”™è¯¯: ä¸ä¼˜é›…å…³é—­
func main() {
    tp, _ := initTracer()
    // ç¼ºå°‘: defer tp.Shutdown(ctx)
    
    http.ListenAndServe(":8080", nil)
    // ç¨‹åºé€€å‡ºæ—¶æ•°æ®å¯èƒ½ä¸¢å¤±
}

// âœ… æ­£ç¡®: ä¼˜é›…å…³é—­
func main() {
    ctx := context.Background()
    tp, _ := initTracer()
    defer func() {
        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()
        tp.Shutdown(ctx)
    }()
    
    // ...
}
```

### âŒ åæ¨¡å¼ 2: é˜»å¡å¯¼å‡º

```go
// âŒ é”™è¯¯: åŒæ­¥å¯¼å‡ºé˜»å¡ä¸»é€»è¾‘
tp := sdktrace.NewTracerProvider(
    sdktrace.WithSyncer(exporter), // åŒæ­¥å¯¼å‡º
)

// âœ… æ­£ç¡®: æ‰¹é‡å¼‚æ­¥å¯¼å‡º
tp := sdktrace.NewTracerProvider(
    sdktrace.WithBatcher(exporter,
        sdktrace.WithBatchTimeout(5*time.Second),
    ),
)
```

### âŒ åæ¨¡å¼ 3: è¿‡åº¦é‡‡æ ·

```go
// âŒ é”™è¯¯: 100% é‡‡æ ·å¯¼è‡´æ€§èƒ½é—®é¢˜
sampler := sdktrace.AlwaysSample()

// âœ… æ­£ç¡®: åˆç†çš„é‡‡æ ·ç‡
sampler := sdktrace.ParentBased(
    sdktrace.TraceIDRatioBased(0.1), // 10%
)
```

### âŒ åæ¨¡å¼ 4: å¿½ç•¥ Context

```go
// âŒ é”™è¯¯: ä¸ä¼ é€’ Context
func ProcessRequest() {
    ctx := context.Background() // ä¸¢å¤±è¿½è¸ªä¿¡æ¯
    // ...
}

// âœ… æ­£ç¡®: ä¼ é€’ Context
func ProcessRequest(ctx context.Context) {
    // Context åŒ…å«è¿½è¸ªä¿¡æ¯
    // ...
}
```

### âŒ åæ¨¡å¼ 5: å†…å­˜æ³„æ¼

```go
// âŒ é”™è¯¯: goroutine æ³„æ¼
func startWorker(ctx context.Context) {
    for {
        doWork()
        // ç¼ºå°‘é€€å‡ºæ¡ä»¶
    }
}

// âœ… æ­£ç¡®: ç›‘å¬å–æ¶ˆä¿¡å·
func startWorker(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            return // ä¼˜é›…é€€å‡º
        default:
            doWork()
        }
    }
}
```

---

## éƒ¨ç½²æœ€ä½³å®è·µ

### 1. ç¯å¢ƒå˜é‡é…ç½®

```bash
# æœåŠ¡ä¿¡æ¯
SERVICE_NAME=my-service
SERVICE_VERSION=1.0.0
ENVIRONMENT=production

# OTLP é…ç½®
OTLP_ENDPOINT=collector:4317
OTEL_EXPORTER_OTLP_PROTOCOL=grpc
OTEL_EXPORTER_OTLP_INSECURE=false

# é‡‡æ ·é…ç½®
TRACE_SAMPLE_RATE=0.1
METRIC_INTERVAL=30s

# èµ„æºé…ç½®
GOMAXPROCS=4
GOMEMLIMIT=2GiB
```

### 2. Docker éƒ¨ç½²

```dockerfile
FROM golang:1.25.1-alpine AS builder

WORKDIR /app
COPY go.* ./
RUN go mod download

COPY . ./
RUN CGO_ENABLED=0 go build -o /app/server .

FROM alpine:latest
RUN apk --no-cache add ca-certificates

COPY --from=builder /app/server /server

EXPOSE 8080
ENTRYPOINT ["/server"]
```

### 3. Kubernetes éƒ¨ç½²

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-service
  template:
    metadata:
      labels:
        app: my-service
    spec:
      containers:
      - name: my-service
        image: my-service:1.0.0
        ports:
        - containerPort: 8080
        env:
        - name: SERVICE_NAME
          value: "my-service"
        - name: OTLP_ENDPOINT
          value: "otel-collector:4317"
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /healthz
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /readyz
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
```

---

## æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†å®Œæ•´çš„ç”Ÿäº§çº§éƒ¨ç½²æŒ‡å—:

**âœ… åšä»€ä¹ˆ**:

- ä¼˜é›…å¯åŠ¨å’Œå…³é—­
- å®Œæ•´çš„å¥åº·æ£€æŸ¥
- ç»“æ„åŒ–æ—¥å¿—å’Œè¿½è¸ª
- åˆç†çš„é‡‡æ ·ç‡
- æ‰¹é‡å¼‚æ­¥å¯¼å‡º
- Context æ­£ç¡®ä¼ æ’­
- èµ„æºé™åˆ¶å’Œç›‘æ§

**âŒ ä¸è¦ä»€ä¹ˆ**:

- å¿˜è®°ä¼˜é›…å…³é—­
- åŒæ­¥é˜»å¡å¯¼å‡º
- 100% é‡‡æ ·
- å¿½ç•¥ Context
- goroutine æ³„æ¼
- ç¡¬ç¼–ç é…ç½®
- ç¼ºå°‘å¥åº·æ£€æŸ¥

**ç›¸å…³æ–‡æ¡£**:

- [Goç”Ÿäº§çº§éƒ¨ç½²ä¸è¿ç»´æœ€ä½³å®è·µ](./07_Goç”Ÿäº§çº§éƒ¨ç½²ä¸è¿ç»´æœ€ä½³å®è·µ.md)
- [Goå®¹å™¨åŒ–ä¸Kubernetesæ·±åº¦é›†æˆ](./08_Goå®¹å™¨åŒ–ä¸Kubernetesæ·±åº¦é›†æˆ.md)
- [Goå¾®æœåŠ¡æ¶æ„ä¸OTLPå®Œæ•´é›†æˆ](./10_Goå¾®æœåŠ¡æ¶æ„ä¸OTLPå®Œæ•´é›†æˆ.md)

---

**æœ€åæ›´æ–°**: 2025å¹´10æœˆ10æ—¥  
**ç»´æŠ¤è€…**: OTLP Go é›†æˆé¡¹ç›®ç»„
