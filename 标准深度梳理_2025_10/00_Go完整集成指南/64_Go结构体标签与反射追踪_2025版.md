# Go ç»“æ„ä½“æ ‡ç­¾ä¸åå°„è¿½è¸ªï¼ˆ2025ç‰ˆï¼‰

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
> **Go ç‰ˆæœ¬**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0  
> **æœ€åæ›´æ–°**: 2025-10-11  
> **ä½œè€…**: OTLP Go Integration Team

---

## ğŸ“‹ ç›®å½•

- [Go ç»“æ„ä½“æ ‡ç­¾ä¸åå°„è¿½è¸ªï¼ˆ2025ç‰ˆï¼‰](#go-ç»“æ„ä½“æ ‡ç­¾ä¸åå°„è¿½è¸ª2025ç‰ˆ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“– ç®€ä»‹](#-ç®€ä»‹)
    - [ä»€ä¹ˆæ˜¯ç»“æ„ä½“æ ‡ç­¾ï¼Ÿ](#ä»€ä¹ˆæ˜¯ç»“æ„ä½“æ ‡ç­¾)
    - [ä¸ºä»€ä¹ˆéœ€è¦ç»“æ„ä½“æ ‡ç­¾ï¼Ÿ](#ä¸ºä»€ä¹ˆéœ€è¦ç»“æ„ä½“æ ‡ç­¾)
  - [ğŸ¯ ç»“æ„ä½“æ ‡ç­¾åŸºç¡€](#-ç»“æ„ä½“æ ‡ç­¾åŸºç¡€)
    - [æ ‡ç­¾è¯­æ³•](#æ ‡ç­¾è¯­æ³•)
    - [æ ‡ç­¾çº¦å®š](#æ ‡ç­¾çº¦å®š)
  - [ğŸ” åå°„æœºåˆ¶](#-åå°„æœºåˆ¶)
    - [reflect åŒ…åŸºç¡€](#reflect-åŒ…åŸºç¡€)
    - [åå°„æ€§èƒ½è€ƒè™‘](#åå°„æ€§èƒ½è€ƒè™‘)
  - [ğŸ·ï¸ æ ‡ç­¾è§£æä¸åº”ç”¨](#ï¸-æ ‡ç­¾è§£æä¸åº”ç”¨)
    - [è‡ªå®šä¹‰æ ‡ç­¾è§£æå™¨](#è‡ªå®šä¹‰æ ‡ç­¾è§£æå™¨)
    - [éªŒè¯å™¨å®ç°](#éªŒè¯å™¨å®ç°)
  - [ğŸ”Œ OTLP é›†æˆæ¨¡å¼](#-otlp-é›†æˆæ¨¡å¼)
    - [è‡ªåŠ¨è¿½è¸ªå±æ€§ç”Ÿæˆ](#è‡ªåŠ¨è¿½è¸ªå±æ€§ç”Ÿæˆ)
    - [è‡ªåŠ¨æŒ‡æ ‡æ”¶é›†](#è‡ªåŠ¨æŒ‡æ ‡æ”¶é›†)
  - [ğŸš€ é«˜çº§åº”ç”¨](#-é«˜çº§åº”ç”¨)
    - [åºåˆ—åŒ–/ååºåˆ—åŒ–è‡ªåŠ¨åŒ–](#åºåˆ—åŒ–ååºåˆ—åŒ–è‡ªåŠ¨åŒ–)
    - [æ·±åº¦å¤åˆ¶ï¼ˆDeep Copyï¼‰](#æ·±åº¦å¤åˆ¶deep-copy)
  - [âš¡ æ€§èƒ½ä¼˜åŒ–](#-æ€§èƒ½ä¼˜åŒ–)
    - [åå°„ç»“æœç¼“å­˜](#åå°„ç»“æœç¼“å­˜)
  - [âœ… æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [1. ä½¿ç”¨ç±»å‹ç¼“å­˜](#1-ä½¿ç”¨ç±»å‹ç¼“å­˜)
    - [2. é¿å…ä¸å¿…è¦çš„åå°„](#2-é¿å…ä¸å¿…è¦çš„åå°„)
    - [3. ä½¿ç”¨æ ‡ç­¾çº¦å®š](#3-ä½¿ç”¨æ ‡ç­¾çº¦å®š)
    - [4. å¤„ç†æŒ‡é’ˆå’Œé›¶å€¼](#4-å¤„ç†æŒ‡é’ˆå’Œé›¶å€¼)
  - [ğŸ¯ å®æˆ˜æ¡ˆä¾‹](#-å®æˆ˜æ¡ˆä¾‹)
    - [æ¡ˆä¾‹ 1: è‡ªåŠ¨åŒ–æ•°æ®åº“æ˜ å°„](#æ¡ˆä¾‹-1-è‡ªåŠ¨åŒ–æ•°æ®åº“æ˜ å°„)
    - [æ¡ˆä¾‹ 2: é…ç½®æ–‡ä»¶ç»‘å®š](#æ¡ˆä¾‹-2-é…ç½®æ–‡ä»¶ç»‘å®š)
  - [ğŸ“ æ€»ç»“](#-æ€»ç»“)

---

## ğŸ“– ç®€ä»‹

Go çš„ç»“æ„ä½“æ ‡ç­¾ï¼ˆStruct Tagsï¼‰å’Œåå°„ï¼ˆReflectionï¼‰æœºåˆ¶æä¾›äº†å¼ºå¤§çš„å…ƒç¼–ç¨‹èƒ½åŠ›ã€‚
æœ¬æ–‡æ¡£æ·±å…¥æ¢è®¨å¦‚ä½•ä½¿ç”¨è¿™äº›ç‰¹æ€§å®ç°è‡ªåŠ¨åŒ–è¿½è¸ªã€åºåˆ—åŒ–ã€éªŒè¯ç­‰åŠŸèƒ½ã€‚

### ä»€ä¹ˆæ˜¯ç»“æ„ä½“æ ‡ç­¾ï¼Ÿ

```go
type User struct {
    ID        string `json:"id" db:"user_id" validate:"required,uuid" trace:"user.id"`
    Name      string `json:"name" db:"user_name" validate:"required,min=2,max=50" trace:"user.name"`
    Email     string `json:"email" db:"email" validate:"required,email" trace:"user.email"`
    CreatedAt time.Time `json:"created_at" db:"created_at" trace:"user.created_at"`
}
```

### ä¸ºä»€ä¹ˆéœ€è¦ç»“æ„ä½“æ ‡ç­¾ï¼Ÿ

âœ… **è‡ªåŠ¨åŒ–** - å‡å°‘é‡å¤ä»£ç   
âœ… **å£°æ˜å¼é…ç½®** - æ¸…æ™°çš„å…ƒæ•°æ®å®šä¹‰  
âœ… **çµæ´»æ€§** - æ”¯æŒå¤šç§åºåˆ—åŒ–æ ¼å¼  
âœ… **å¯è¿½è¸ªæ€§** - è‡ªåŠ¨ç”Ÿæˆè¿½è¸ªå±æ€§  
âœ… **éªŒè¯** - æ•°æ®éªŒè¯è§„åˆ™

---

## ğŸ¯ ç»“æ„ä½“æ ‡ç­¾åŸºç¡€

### æ ‡ç­¾è¯­æ³•

```go
package main

import "fmt"

// åŸºæœ¬æ ‡ç­¾è¯­æ³•
type Example struct {
    // å•ä¸ªæ ‡ç­¾
    Field1 string `json:"field1"`
    
    // å¤šä¸ªæ ‡ç­¾ï¼ˆç”¨ç©ºæ ¼åˆ†éš”ï¼‰
    Field2 string `json:"field2" xml:"field2" db:"field_2"`
    
    // æ ‡ç­¾é€‰é¡¹ï¼ˆç”¨é€—å·åˆ†éš”ï¼‰
    Field3 string `json:"field3,omitempty" validate:"required,min=3"`
    
    // å¿½ç•¥å­—æ®µ
    Field4 string `json:"-"`
    
    // å†…è”ç»“æ„ä½“
    Address `json:",inline"`
}

type Address struct {
    City    string `json:"city"`
    Country string `json:"country"`
}

// æ ‡å‡†åº“å¸¸ç”¨æ ‡ç­¾
type StandardTags struct {
    // JSON æ ‡ç­¾
    JSONField string `json:"json_field,omitempty"`
    
    // XML æ ‡ç­¾
    XMLField string `xml:"xml_field,attr"`
    
    // YAML æ ‡ç­¾ï¼ˆç¬¬ä¸‰æ–¹åº“ï¼‰
    YAMLField string `yaml:"yaml_field"`
    
    // TOML æ ‡ç­¾ï¼ˆç¬¬ä¸‰æ–¹åº“ï¼‰
    TOMLField string `toml:"toml_field"`
    
    // Database æ ‡ç­¾
    DBField string `db:"db_field"`
    
    // Validation æ ‡ç­¾
    ValidField string `validate:"required,min=3,max=50"`
    
    // Form æ ‡ç­¾
    FormField string `form:"form_field"`
    
    // è‡ªå®šä¹‰æ ‡ç­¾
    TraceField string `trace:"custom.field"`
}
```

### æ ‡ç­¾çº¦å®š

```go
// å¸¸è§æ ‡ç­¾çº¦å®š

// 1. JSON æ ‡ç­¾
type JSONExample struct {
    Field1 string `json:"field1"`                // åŸºæœ¬æ˜ å°„
    Field2 string `json:"field2,omitempty"`      // ç©ºå€¼çœç•¥
    Field3 string `json:"-"`                     // å¿½ç•¥å­—æ®µ
    Field4 string `json:"field4,string"`         // è½¬ä¸ºå­—ç¬¦ä¸²
    Field5 int    `json:",string"`                // ä¿æŒå­—æ®µåï¼Œè½¬ä¸ºå­—ç¬¦ä¸²
}

// 2. Database æ ‡ç­¾
type DBExample struct {
    ID        int64  `db:"id,primarykey,autoincrement"`
    Name      string `db:"name,size:100,notnull"`
    Email     string `db:"email,unique,index"`
    CreatedAt time.Time `db:"created_at,default:now()"`
    UpdatedAt time.Time `db:"updated_at,default:now(),onupdate:now()"`
}

// 3. Validation æ ‡ç­¾
type ValidExample struct {
    Username string `validate:"required,alphanum,min=3,max=20"`
    Email    string `validate:"required,email"`
    Age      int    `validate:"required,gte=0,lte=130"`
    Gender   string `validate:"required,oneof=male female other"`
    Website  string `validate:"omitempty,url"`
}

// 4. è‡ªå®šä¹‰ OTLP æ ‡ç­¾
type OTLPExample struct {
    UserID    string    `trace:"user.id" metric:"user_operations"`
    Action    string    `trace:"action.type" metric:"action_count"`
    Duration  int64     `trace:"duration.ms" metric:"duration_histogram"`
    Timestamp time.Time `trace:"timestamp" metric:"timestamp_gauge"`
}
```

---

## ğŸ” åå°„æœºåˆ¶

### reflect åŒ…åŸºç¡€

```go
package main

import (
    "fmt"
    "reflect"
)

// åå°„åŸºç¡€æ“ä½œ
func ReflectionBasics() {
    user := User{
        ID:   "user-123",
        Name: "John Doe",
    }
    
    // 1. è·å–ç±»å‹ä¿¡æ¯
    t := reflect.TypeOf(user)
    fmt.Printf("Type: %v\n", t)           // Type: main.User
    fmt.Printf("Kind: %v\n", t.Kind())    // Kind: struct
    fmt.Printf("Name: %v\n", t.Name())    // Name: User
    
    // 2. è·å–å€¼ä¿¡æ¯
    v := reflect.ValueOf(user)
    fmt.Printf("Value: %v\n", v)          // Value: {user-123 John Doe}
    fmt.Printf("Kind: %v\n", v.Kind())    // Kind: struct
    
    // 3. éå†ç»“æ„ä½“å­—æ®µ
    for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        value := v.Field(i)
        
        fmt.Printf("Field %d: Name=%s, Type=%v, Value=%v, Tag=%v\n",
            i, field.Name, field.Type, value.Interface(), field.Tag)
    }
}

// è¯»å–ç»“æ„ä½“æ ‡ç­¾
func ReadStructTags() {
    user := User{}
    t := reflect.TypeOf(user)
    
    for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        
        // è·å–æ•´ä¸ªæ ‡ç­¾å­—ç¬¦ä¸²
        fullTag := field.Tag
        fmt.Printf("Full Tag: %v\n", fullTag)
        
        // è·å–ç‰¹å®šé”®çš„æ ‡ç­¾å€¼
        jsonTag := field.Tag.Get("json")
        dbTag := field.Tag.Get("db")
        validateTag := field.Tag.Get("validate")
        traceTag := field.Tag.Get("trace")
        
        fmt.Printf("Field: %s, json=%s, db=%s, validate=%s, trace=%s\n",
            field.Name, jsonTag, dbTag, validateTag, traceTag)
    }
}

// ä¿®æ”¹ç»“æ„ä½“å€¼ï¼ˆéœ€è¦æŒ‡é’ˆï¼‰
func ModifyStructValues() {
    user := &User{
        ID:   "user-123",
        Name: "John Doe",
    }
    
    v := reflect.ValueOf(user).Elem() // Elem() è·å–æŒ‡é’ˆæŒ‡å‘çš„å€¼
    
    if v.Kind() == reflect.Struct {
        // é€šè¿‡å­—æ®µåä¿®æ”¹å€¼
        nameField := v.FieldByName("Name")
        if nameField.IsValid() && nameField.CanSet() {
            nameField.SetString("Jane Doe")
        }
        
        // é€šè¿‡ç´¢å¼•ä¿®æ”¹å€¼
        idField := v.Field(0)
        if idField.IsValid() && idField.CanSet() {
            idField.SetString("user-456")
        }
    }
    
    fmt.Printf("Modified User: %+v\n", user)
}
```

### åå°„æ€§èƒ½è€ƒè™‘

```go
package main

import (
    "reflect"
    "testing"
)

// ç›´æ¥è®¿é—® vs åå°„è®¿é—®
func BenchmarkDirectAccess(b *testing.B) {
    user := User{ID: "user-123", Name: "John Doe"}
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = user.ID
        _ = user.Name
    }
}

func BenchmarkReflectionAccess(b *testing.B) {
    user := User{ID: "user-123", Name: "John Doe"}
    v := reflect.ValueOf(user)
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = v.Field(0).String()
        _ = v.Field(1).String()
    }
}

// æ€§èƒ½æç¤ºï¼šåå°„æ¯”ç›´æ¥è®¿é—®æ…¢çº¦ 10-50 å€
```

---

## ğŸ·ï¸ æ ‡ç­¾è§£æä¸åº”ç”¨

### è‡ªå®šä¹‰æ ‡ç­¾è§£æå™¨

```go
package main

import (
    "errors"
    "reflect"
    "strings"
)

// TagParser æ ‡ç­¾è§£æå™¨
type TagParser struct {
    tagName string
}

// NewTagParser åˆ›å»ºæ ‡ç­¾è§£æå™¨
func NewTagParser(tagName string) *TagParser {
    return &TagParser{tagName: tagName}
}

// ParseStruct è§£æç»“æ„ä½“æ ‡ç­¾
func (tp *TagParser) ParseStruct(v interface{}) (map[string]string, error) {
    result := make(map[string]string)
    
    val := reflect.ValueOf(v)
    if val.Kind() == reflect.Ptr {
        val = val.Elem()
    }
    
    if val.Kind() != reflect.Struct {
        return nil, errors.New("expected struct or pointer to struct")
    }
    
    typ := val.Type()
    for i := 0; i < typ.NumField(); i++ {
        field := typ.Field(i)
        tag := field.Tag.Get(tp.tagName)
        
        if tag != "" && tag != "-" {
            fieldValue := val.Field(i)
            if fieldValue.IsValid() && fieldValue.CanInterface() {
                result[tag] = tp.formatValue(fieldValue.Interface())
            }
        }
    }
    
    return result, nil
}

func (tp *TagParser) formatValue(v interface{}) string {
    return fmt.Sprintf("%v", v)
}

// è§£ææ ‡ç­¾é€‰é¡¹
type TagOptions struct {
    Name      string
    Options   []string
    OmitEmpty bool
    Required  bool
}

func ParseTagOptions(tag string) TagOptions {
    parts := strings.Split(tag, ",")
    opts := TagOptions{
        Name:    parts[0],
        Options: make([]string, 0),
    }
    
    if len(parts) > 1 {
        for _, opt := range parts[1:] {
            switch opt {
            case "omitempty":
                opts.OmitEmpty = true
            case "required":
                opts.Required = true
            default:
                opts.Options = append(opts.Options, opt)
            }
        }
    }
    
    return opts
}

// Example: ä½¿ç”¨æ ‡ç­¾è§£æå™¨
func ExampleTagParser() {
    user := User{
        ID:   "user-123",
        Name: "John Doe",
        Email: "john@example.com",
    }
    
    parser := NewTagParser("trace")
    attrs, _ := parser.ParseStruct(&user)
    
    for key, value := range attrs {
        fmt.Printf("%s = %s\n", key, value)
    }
    // Output:
    // user.id = user-123
    // user.name = John Doe
    // user.email = john@example.com
}
```

### éªŒè¯å™¨å®ç°

```go
package main

import (
    "errors"
    "fmt"
    "reflect"
    "strconv"
    "strings"
)

// Validator éªŒè¯å™¨
type Validator struct{}

// Validate éªŒè¯ç»“æ„ä½“
func (v *Validator) Validate(s interface{}) error {
    val := reflect.ValueOf(s)
    if val.Kind() == reflect.Ptr {
        val = val.Elem()
    }
    
    if val.Kind() != reflect.Struct {
        return errors.New("expected struct")
    }
    
    typ := val.Type()
    for i := 0; i < typ.NumField(); i++ {
        field := typ.Field(i)
        fieldValue := val.Field(i)
        
        // è·å– validate æ ‡ç­¾
        validateTag := field.Tag.Get("validate")
        if validateTag == "" {
            continue
        }
        
        // è§£æéªŒè¯è§„åˆ™
        rules := strings.Split(validateTag, ",")
        for _, rule := range rules {
            if err := v.validateField(field.Name, fieldValue, rule); err != nil {
                return err
            }
        }
    }
    
    return nil
}

func (v *Validator) validateField(fieldName string, value reflect.Value, rule string) error {
    switch {
    case rule == "required":
        if v.isEmpty(value) {
            return fmt.Errorf("field %s is required", fieldName)
        }
        
    case strings.HasPrefix(rule, "min="):
        minStr := strings.TrimPrefix(rule, "min=")
        min, _ := strconv.Atoi(minStr)
        if err := v.validateMin(fieldName, value, min); err != nil {
            return err
        }
        
    case strings.HasPrefix(rule, "max="):
        maxStr := strings.TrimPrefix(rule, "max=")
        max, _ := strconv.Atoi(maxStr)
        if err := v.validateMax(fieldName, value, max); err != nil {
            return err
        }
        
    case rule == "email":
        if value.Kind() == reflect.String {
            email := value.String()
            if !strings.Contains(email, "@") {
                return fmt.Errorf("field %s must be a valid email", fieldName)
            }
        }
    }
    
    return nil
}

func (v *Validator) isEmpty(value reflect.Value) bool {
    switch value.Kind() {
    case reflect.String:
        return value.String() == ""
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        return value.Int() == 0
    case reflect.Ptr, reflect.Interface:
        return value.IsNil()
    default:
        return false
    }
}

func (v *Validator) validateMin(fieldName string, value reflect.Value, min int) error {
    switch value.Kind() {
    case reflect.String:
        if len(value.String()) < min {
            return fmt.Errorf("field %s must be at least %d characters", fieldName, min)
        }
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        if int(value.Int()) < min {
            return fmt.Errorf("field %s must be at least %d", fieldName, min)
        }
    }
    return nil
}

func (v *Validator) validateMax(fieldName string, value reflect.Value, max int) error {
    switch value.Kind() {
    case reflect.String:
        if len(value.String()) > max {
            return fmt.Errorf("field %s must be at most %d characters", fieldName, max)
        }
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        if int(value.Int()) > max {
            return fmt.Errorf("field %s must be at most %d", fieldName, max)
        }
    }
    return nil
}

// Example: ä½¿ç”¨éªŒè¯å™¨
func ExampleValidator() {
    validator := &Validator{}
    
    user := User{
        ID:   "",  // è¿å required è§„åˆ™
        Name: "Jo", // è¿å min=3 è§„åˆ™
        Email: "invalid-email", // è¿å email è§„åˆ™
    }
    
    if err := validator.Validate(&user); err != nil {
        fmt.Printf("Validation error: %v\n", err)
    }
}
```

---

## ğŸ”Œ OTLP é›†æˆæ¨¡å¼

### è‡ªåŠ¨è¿½è¸ªå±æ€§ç”Ÿæˆ

```go
package otlp

import (
    "context"
    "reflect"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/trace"
)

// TracedStruct å¯è¿½è¸ªçš„ç»“æ„ä½“æ¥å£
type TracedStruct interface {
    ToTraceAttributes() []attribute.KeyValue
}

// AutoTracer è‡ªåŠ¨è¿½è¸ªå™¨
type AutoTracer struct {
    tracer trace.Tracer
}

// NewAutoTracer åˆ›å»ºè‡ªåŠ¨è¿½è¸ªå™¨
func NewAutoTracer(serviceName string) *AutoTracer {
    return &AutoTracer{
        tracer: otel.Tracer(serviceName),
    }
}

// TraceStruct è‡ªåŠ¨ä¸ºç»“æ„ä½“åˆ›å»ºè¿½è¸ª
func (at *AutoTracer) TraceStruct(ctx context.Context, operationName string, s interface{}) (context.Context, trace.Span) {
    ctx, span := at.tracer.Start(ctx, operationName)
    
    // è‡ªåŠ¨æå–è¿½è¸ªå±æ€§
    attrs := at.extractTraceAttributes(s)
    if len(attrs) > 0 {
        span.SetAttributes(attrs...)
    }
    
    return ctx, span
}

// extractTraceAttributes ä»ç»“æ„ä½“æå–è¿½è¸ªå±æ€§
func (at *AutoTracer) extractTraceAttributes(s interface{}) []attribute.KeyValue {
    attrs := make([]attribute.KeyValue, 0)
    
    val := reflect.ValueOf(s)
    if val.Kind() == reflect.Ptr {
        val = val.Elem()
    }
    
    if val.Kind() != reflect.Struct {
        return attrs
    }
    
    typ := val.Type()
    for i := 0; i < typ.NumField(); i++ {
        field := typ.Field(i)
        fieldValue := val.Field(i)
        
        // è·å– trace æ ‡ç­¾
        traceTag := field.Tag.Get("trace")
        if traceTag == "" || traceTag == "-" {
            continue
        }
        
        // è½¬æ¢ä¸ºå±æ€§
        if attr := at.valueToAttribute(traceTag, fieldValue); attr.Valid() {
            attrs = append(attrs, attr)
        }
    }
    
    return attrs
}

func (at *AutoTracer) valueToAttribute(key string, value reflect.Value) attribute.KeyValue {
    if !value.IsValid() || !value.CanInterface() {
        return attribute.KeyValue{}
    }
    
    switch value.Kind() {
    case reflect.String:
        return attribute.String(key, value.String())
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        return attribute.Int64(key, value.Int())
    case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
        return attribute.Int64(key, int64(value.Uint()))
    case reflect.Float32, reflect.Float64:
        return attribute.Float64(key, value.Float())
    case reflect.Bool:
        return attribute.Bool(key, value.Bool())
    default:
        return attribute.String(key, fmt.Sprintf("%v", value.Interface()))
    }
}

// Example: ä½¿ç”¨è‡ªåŠ¨è¿½è¸ªå™¨
func ExampleAutoTracer() {
    ctx := context.Background()
    
    user := User{
        ID:   "user-123",
        Name: "John Doe",
        Email: "john@example.com",
    }
    
    tracer := NewAutoTracer("user-service")
    ctx, span := tracer.TraceStruct(ctx, "GetUser", &user)
    defer span.End()
    
    // Span è‡ªåŠ¨åŒ…å«ä»ç»“æ„ä½“æå–çš„å±æ€§:
    // user.id = user-123
    // user.name = John Doe
    // user.email = john@example.com
    
    // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
    processUser(ctx, user)
}
```

### è‡ªåŠ¨æŒ‡æ ‡æ”¶é›†

```go
package otlp

import (
    "context"
    "reflect"
    "strings"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

// MetricCollector æŒ‡æ ‡æ”¶é›†å™¨
type MetricCollector struct {
    meter    metric.Meter
    counters map[string]metric.Int64Counter
    histos   map[string]metric.Float64Histogram
}

// NewMetricCollector åˆ›å»ºæŒ‡æ ‡æ”¶é›†å™¨
func NewMetricCollector(serviceName string) (*MetricCollector, error) {
    meter := otel.Meter(serviceName)
    
    return &MetricCollector{
        meter:    meter,
        counters: make(map[string]metric.Int64Counter),
        histos:   make(map[string]metric.Float64Histogram),
    }, nil
}

// CollectMetrics ä»ç»“æ„ä½“æ”¶é›†æŒ‡æ ‡
func (mc *MetricCollector) CollectMetrics(ctx context.Context, s interface{}) error {
    val := reflect.ValueOf(s)
    if val.Kind() == reflect.Ptr {
        val = val.Elem()
    }
    
    if val.Kind() != reflect.Struct {
        return errors.New("expected struct")
    }
    
    typ := val.Type()
    for i := 0; i < typ.NumField(); i++ {
        field := typ.Field(i)
        fieldValue := val.Field(i)
        
        // è·å– metric æ ‡ç­¾
        metricTag := field.Tag.Get("metric")
        if metricTag == "" || metricTag == "-" {
            continue
        }
        
        // è§£ææ ‡ç­¾é€‰é¡¹
        parts := strings.Split(metricTag, ",")
        metricName := parts[0]
        metricType := "counter" // é»˜è®¤ç±»å‹
        
        if len(parts) > 1 {
            metricType = parts[1]
        }
        
        // è®°å½•æŒ‡æ ‡
        if err := mc.recordMetric(ctx, metricName, metricType, fieldValue); err != nil {
            return err
        }
    }
    
    return nil
}

func (mc *MetricCollector) recordMetric(ctx context.Context, name, metricType string, value reflect.Value) error {
    switch metricType {
    case "counter":
        return mc.recordCounter(ctx, name, value)
    case "histogram":
        return mc.recordHistogram(ctx, name, value)
    default:
        return fmt.Errorf("unsupported metric type: %s", metricType)
    }
}

func (mc *MetricCollector) recordCounter(ctx context.Context, name string, value reflect.Value) error {
    counter, exists := mc.counters[name]
    if !exists {
        var err error
        counter, err = mc.meter.Int64Counter(name)
        if err != nil {
            return err
        }
        mc.counters[name] = counter
    }
    
    var count int64
    switch value.Kind() {
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        count = value.Int()
    case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
        count = int64(value.Uint())
    default:
        count = 1
    }
    
    counter.Add(ctx, count)
    return nil
}

func (mc *MetricCollector) recordHistogram(ctx context.Context, name string, value reflect.Value) error {
    histo, exists := mc.histos[name]
    if !exists {
        var err error
        histo, err = mc.meter.Float64Histogram(name)
        if err != nil {
            return err
        }
        mc.histos[name] = histo
    }
    
    var val float64
    switch value.Kind() {
    case reflect.Float32, reflect.Float64:
        val = value.Float()
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        val = float64(value.Int())
    default:
        return fmt.Errorf("unsupported value type for histogram: %v", value.Kind())
    }
    
    histo.Record(ctx, val)
    return nil
}

// Example: ä½¿ç”¨æŒ‡æ ‡æ”¶é›†å™¨
type RequestMetrics struct {
    RequestCount int64   `metric:"http_requests_total,counter"`
    Duration     float64 `metric:"http_request_duration_ms,histogram"`
    ErrorCount   int64   `metric:"http_errors_total,counter"`
}

func ExampleMetricCollector() {
    ctx := context.Background()
    
    collector, _ := NewMetricCollector("http-server")
    
    metrics := RequestMetrics{
        RequestCount: 1,
        Duration:     123.45,
        ErrorCount:   0,
    }
    
    // è‡ªåŠ¨æ”¶é›†æŒ‡æ ‡
    collector.CollectMetrics(ctx, &metrics)
}
```

---

## ğŸš€ é«˜çº§åº”ç”¨

### åºåˆ—åŒ–/ååºåˆ—åŒ–è‡ªåŠ¨åŒ–

```go
package main

import (
    "encoding/json"
    "reflect"
    "strings"
)

// StructMapper ç»“æ„ä½“æ˜ å°„å™¨
type StructMapper struct {
    tagName string
}

// NewStructMapper åˆ›å»ºç»“æ„ä½“æ˜ å°„å™¨
func NewStructMapper(tagName string) *StructMapper {
    return &StructMapper{tagName: tagName}
}

// ToMap å°†ç»“æ„ä½“è½¬ä¸º map
func (sm *StructMapper) ToMap(s interface{}) (map[string]interface{}, error) {
    result := make(map[string]interface{})
    
    val := reflect.ValueOf(s)
    if val.Kind() == reflect.Ptr {
        val = val.Elem()
    }
    
    if val.Kind() != reflect.Struct {
        return nil, errors.New("expected struct")
    }
    
    typ := val.Type()
    for i := 0; i < typ.NumField(); i++ {
        field := typ.Field(i)
        fieldValue := val.Field(i)
        
        // è·å–æ ‡ç­¾
        tag := field.Tag.Get(sm.tagName)
        if tag == "" {
            tag = field.Name
        }
        if tag == "-" {
            continue
        }
        
        // è§£æé€‰é¡¹
        parts := strings.Split(tag, ",")
        key := parts[0]
        omitEmpty := false
        
        for _, opt := range parts[1:] {
            if opt == "omitempty" {
                omitEmpty = true
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦çœç•¥ç©ºå€¼
        if omitEmpty && sm.isEmpty(fieldValue) {
            continue
        }
        
        result[key] = fieldValue.Interface()
    }
    
    return result, nil
}

// FromMap ä» map å¡«å……ç»“æ„ä½“
func (sm *StructMapper) FromMap(m map[string]interface{}, s interface{}) error {
    val := reflect.ValueOf(s)
    if val.Kind() != reflect.Ptr {
        return errors.New("expected pointer to struct")
    }
    
    val = val.Elem()
    if val.Kind() != reflect.Struct {
        return errors.New("expected struct")
    }
    
    typ := val.Type()
    for i := 0; i < typ.NumField(); i++ {
        field := typ.Field(i)
        fieldValue := val.Field(i)
        
        if !fieldValue.CanSet() {
            continue
        }
        
        // è·å–æ ‡ç­¾
        tag := field.Tag.Get(sm.tagName)
        if tag == "" {
            tag = field.Name
        }
        if tag == "-" {
            continue
        }
        
        parts := strings.Split(tag, ",")
        key := parts[0]
        
        // ä» map è·å–å€¼
        if mapValue, exists := m[key]; exists {
            if err := sm.setValue(fieldValue, mapValue); err != nil {
                return err
            }
        }
    }
    
    return nil
}

func (sm *StructMapper) setValue(field reflect.Value, value interface{}) error {
    val := reflect.ValueOf(value)
    
    if field.Type() == val.Type() {
        field.Set(val)
        return nil
    }
    
    // ç±»å‹è½¬æ¢
    if val.Type().ConvertibleTo(field.Type()) {
        field.Set(val.Convert(field.Type()))
        return nil
    }
    
    return fmt.Errorf("cannot convert %v to %v", val.Type(), field.Type())
}

func (sm *StructMapper) isEmpty(value reflect.Value) bool {
    switch value.Kind() {
    case reflect.String:
        return value.String() == ""
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        return value.Int() == 0
    case reflect.Ptr, reflect.Interface:
        return value.IsNil()
    default:
        return false
    }
}

// Example: ç»“æ„ä½“æ˜ å°„
func ExampleStructMapper() {
    mapper := NewStructMapper("json")
    
    user := User{
        ID:   "user-123",
        Name: "John Doe",
        Email: "john@example.com",
    }
    
    // è½¬ä¸º map
    m, _ := mapper.ToMap(&user)
    fmt.Printf("Map: %+v\n", m)
    
    // ä» map å¡«å……
    var newUser User
    mapper.FromMap(m, &newUser)
    fmt.Printf("User: %+v\n", newUser)
}
```

### æ·±åº¦å¤åˆ¶ï¼ˆDeep Copyï¼‰

```go
package main

import "reflect"

// DeepCopy æ·±åº¦å¤åˆ¶ç»“æ„ä½“
func DeepCopy(src interface{}) (interface{}, error) {
    srcVal := reflect.ValueOf(src)
    if srcVal.Kind() == reflect.Ptr {
        srcVal = srcVal.Elem()
    }
    
    // åˆ›å»ºæ–°çš„å®ä¾‹
    dstVal := reflect.New(srcVal.Type())
    
    // é€’å½’å¤åˆ¶
    if err := deepCopyValue(srcVal, dstVal.Elem()); err != nil {
        return nil, err
    }
    
    return dstVal.Interface(), nil
}

func deepCopyValue(src, dst reflect.Value) error {
    switch src.Kind() {
    case reflect.Struct:
        for i := 0; i < src.NumField(); i++ {
            srcField := src.Field(i)
            dstField := dst.Field(i)
            
            if dstField.CanSet() {
                if err := deepCopyValue(srcField, dstField); err != nil {
                    return err
                }
            }
        }
        
    case reflect.Slice:
        if src.IsNil() {
            return nil
        }
        
        slice := reflect.MakeSlice(src.Type(), src.Len(), src.Cap())
        for i := 0; i < src.Len(); i++ {
            if err := deepCopyValue(src.Index(i), slice.Index(i)); err != nil {
                return err
            }
        }
        dst.Set(slice)
        
    case reflect.Map:
        if src.IsNil() {
            return nil
        }
        
        m := reflect.MakeMap(src.Type())
        for _, key := range src.MapKeys() {
            srcValue := src.MapIndex(key)
            dstValue := reflect.New(srcValue.Type()).Elem()
            if err := deepCopyValue(srcValue, dstValue); err != nil {
                return err
            }
            m.SetMapIndex(key, dstValue)
        }
        dst.Set(m)
        
    case reflect.Ptr:
        if src.IsNil() {
            return nil
        }
        
        ptr := reflect.New(src.Elem().Type())
        if err := deepCopyValue(src.Elem(), ptr.Elem()); err != nil {
            return err
        }
        dst.Set(ptr)
        
    default:
        if dst.CanSet() {
            dst.Set(src)
        }
    }
    
    return nil
}

// Example: æ·±åº¦å¤åˆ¶
func ExampleDeepCopy() {
    original := &User{
        ID:   "user-123",
        Name: "John Doe",
        Address: &Address{
            City:    "New York",
            Country: "USA",
        },
    }
    
    copied, _ := DeepCopy(original)
    copyUser := copied.(*User)
    
    // ä¿®æ”¹å¤åˆ¶åçš„å¯¹è±¡ä¸ä¼šå½±å“åŸå¯¹è±¡
    copyUser.Name = "Jane Doe"
    copyUser.Address.City = "Los Angeles"
    
    fmt.Printf("Original: %+v\n", original)
    fmt.Printf("Copied: %+v\n", copyUser)
}
```

---

## âš¡ æ€§èƒ½ä¼˜åŒ–

### åå°„ç»“æœç¼“å­˜

```go
package main

import (
    "reflect"
    "sync"
)

// TypeCache ç±»å‹ç¼“å­˜
type TypeCache struct {
    mu    sync.RWMutex
    cache map[reflect.Type]*TypeInfo
}

// TypeInfo ç±»å‹ä¿¡æ¯
type TypeInfo struct {
    Type   reflect.Type
    Fields []FieldInfo
}

// FieldInfo å­—æ®µä¿¡æ¯
type FieldInfo struct {
    Name      string
    Index     int
    Type      reflect.Type
    Tag       reflect.StructTag
    TraceTag  string
    MetricTag string
    JSONTag   string
}

// NewTypeCache åˆ›å»ºç±»å‹ç¼“å­˜
func NewTypeCache() *TypeCache {
    return &TypeCache{
        cache: make(map[reflect.Type]*TypeInfo),
    }
}

// GetTypeInfo è·å–ç±»å‹ä¿¡æ¯ï¼ˆå¸¦ç¼“å­˜ï¼‰
func (tc *TypeCache) GetTypeInfo(t reflect.Type) *TypeInfo {
    // å…ˆå°è¯•ä»ç¼“å­˜è¯»å–
    tc.mu.RLock()
    if info, exists := tc.cache[t]; exists {
        tc.mu.RUnlock()
        return info
    }
    tc.mu.RUnlock()
    
    // ç¼“å­˜æœªå‘½ä¸­ï¼Œè§£æç±»å‹
    tc.mu.Lock()
    defer tc.mu.Unlock()
    
    // åŒé‡æ£€æŸ¥
    if info, exists := tc.cache[t]; exists {
        return info
    }
    
    // è§£æç±»å‹
    info := &TypeInfo{
        Type:   t,
        Fields: make([]FieldInfo, 0, t.NumField()),
    }
    
    for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        fieldInfo := FieldInfo{
            Name:      field.Name,
            Index:     i,
            Type:      field.Type,
            Tag:       field.Tag,
            TraceTag:  field.Tag.Get("trace"),
            MetricTag: field.Tag.Get("metric"),
            JSONTag:   field.Tag.Get("json"),
        }
        info.Fields = append(info.Fields, fieldInfo)
    }
    
    tc.cache[t] = info
    return info
}

// å…¨å±€ç±»å‹ç¼“å­˜
var globalTypeCache = NewTypeCache()

// GetCachedTypeInfo è·å–ç¼“å­˜çš„ç±»å‹ä¿¡æ¯
func GetCachedTypeInfo(v interface{}) *TypeInfo {
    t := reflect.TypeOf(v)
    if t.Kind() == reflect.Ptr {
        t = t.Elem()
    }
    return globalTypeCache.GetTypeInfo(t)
}

// Benchmark: ç¼“å­˜ vs éç¼“å­˜
func BenchmarkWithCache(b *testing.B) {
    user := User{}
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = GetCachedTypeInfo(&user)
    }
}

func BenchmarkWithoutCache(b *testing.B) {
    user := User{}
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        t := reflect.TypeOf(&user).Elem()
        for j := 0; j < t.NumField(); j++ {
            _ = t.Field(j)
        }
    }
}
```

---

## âœ… æœ€ä½³å®è·µ

### 1. ä½¿ç”¨ç±»å‹ç¼“å­˜

```go
// âœ… ç¼“å­˜ç±»å‹ä¿¡æ¯
var typeCache = NewTypeCache()

func ProcessMany(users []*User) {
    typeInfo := GetCachedTypeInfo(&User{}) // åªè§£æä¸€æ¬¡
    
    for _, user := range users {
        processWithTypeInfo(user, typeInfo)
    }
}
```

### 2. é¿å…ä¸å¿…è¦çš„åå°„

```go
// âŒ åœ¨å¾ªç¯ä¸­ä½¿ç”¨åå°„
for _, user := range users {
    v := reflect.ValueOf(user)
    // å¤„ç†...
}

// âœ… ç›´æ¥è®¿é—®å­—æ®µ
for _, user := range users {
    _ = user.ID
    _ = user.Name
}
```

### 3. ä½¿ç”¨æ ‡ç­¾çº¦å®š

```go
// âœ… éµå¾ªæ ‡ç­¾çº¦å®š
type User struct {
    ID    string `json:"id" db:"user_id" trace:"user.id" validate:"required,uuid"`
    Name  string `json:"name" db:"user_name" trace:"user.name" validate:"required"`
}
```

### 4. å¤„ç†æŒ‡é’ˆå’Œé›¶å€¼

```go
func SafeGetField(v reflect.Value, index int) interface{} {
    if v.Kind() == reflect.Ptr {
        v = v.Elem()
    }
    
    if !v.IsValid() {
        return nil
    }
    
    field := v.Field(index)
    if !field.IsValid() || !field.CanInterface() {
        return nil
    }
    
    return field.Interface()
}
```

---

## ğŸ¯ å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹ 1: è‡ªåŠ¨åŒ–æ•°æ®åº“æ˜ å°„

```go
package main

// ä½¿ç”¨ç»“æ„ä½“æ ‡ç­¾è‡ªåŠ¨ç”Ÿæˆ SQL
type DBMapper struct {
    cache *TypeCache
}

func (dm *DBMapper) GenerateInsertSQL(tableName string, s interface{}) (string, []interface{}, error) {
    typeInfo := dm.cache.GetTypeInfo(reflect.TypeOf(s).Elem())
    
    var columns []string
    var placeholders []string
    var values []interface{}
    
    val := reflect.ValueOf(s).Elem()
    
    for _, fieldInfo := range typeInfo.Fields {
        dbTag := fieldInfo.Tag.Get("db")
        if dbTag == "" || dbTag == "-" {
            continue
        }
        
        columns = append(columns, dbTag)
        placeholders = append(placeholders, "?")
        values = append(values, val.Field(fieldInfo.Index).Interface())
    }
    
    sql := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s)",
        tableName,
        strings.Join(columns, ", "),
        strings.Join(placeholders, ", "))
    
    return sql, values, nil
}
```

### æ¡ˆä¾‹ 2: é…ç½®æ–‡ä»¶ç»‘å®š

```go
package main

// è‡ªåŠ¨ç»‘å®šç¯å¢ƒå˜é‡åˆ°ç»“æ„ä½“
type Config struct {
    ServerPort int    `env:"SERVER_PORT" default:"8080"`
    DBHost     string `env:"DB_HOST" default:"localhost"`
    DBPort     int    `env:"DB_PORT" default:"5432"`
}

func BindEnv(cfg interface{}) error {
    val := reflect.ValueOf(cfg).Elem()
    typ := val.Type()
    
    for i := 0; i < typ.NumField(); i++ {
        field := typ.Field(i)
        fieldValue := val.Field(i)
        
        envTag := field.Tag.Get("env")
        defaultTag := field.Tag.Get("default")
        
        if envTag == "" {
            continue
        }
        
        // ä»ç¯å¢ƒå˜é‡è¯»å–
        envValue := os.Getenv(envTag)
        if envValue == "" {
            envValue = defaultTag
        }
        
        // è®¾ç½®å€¼
        if err := setFieldValue(fieldValue, envValue); err != nil {
            return err
        }
    }
    
    return nil
}
```

---

## ğŸ“ æ€»ç»“

æœ¬æ–‡æ¡£å…¨é¢ä»‹ç»äº† Go ç»“æ„ä½“æ ‡ç­¾ä¸åå°„è¿½è¸ªï¼š

âœ… **ç»“æ„ä½“æ ‡ç­¾** - å£°æ˜å¼å…ƒæ•°æ®å®šä¹‰  
âœ… **åå°„æœºåˆ¶** - è¿è¡Œæ—¶ç±»å‹æ£€æŸ¥å’Œæ“ä½œ  
âœ… **OTLP é›†æˆ** - è‡ªåŠ¨è¿½è¸ªå’ŒæŒ‡æ ‡æ”¶é›†  
âœ… **æ€§èƒ½ä¼˜åŒ–** - ç±»å‹ç¼“å­˜ã€é¿å…è¿‡åº¦åå°„  
âœ… **å®æˆ˜æ¡ˆä¾‹** - æ•°æ®åº“æ˜ å°„ã€é…ç½®ç»‘å®š

**ä¸‹ä¸€æ­¥**:

- è®¾è®¡è‡ªå®šä¹‰æ ‡ç­¾
- å®ç°æ ‡ç­¾è§£æå™¨
- é›†æˆ OTLP è‡ªåŠ¨è¿½è¸ª
- ä¼˜åŒ–åå°„æ€§èƒ½

---

**ç‰ˆæœ¬**: v1.0.0  
**æœ€åæ›´æ–°**: 2025-10-11  
**ç»´æŠ¤è€…**: OTLP Go Integration Team
