# Go æ€§èƒ½ä¼˜åŒ–ä¸ OTLP æœ€ä½³å®è·µ

> **Go ç‰ˆæœ¬**: 1.25.1  
> **OpenTelemetry SDK**: v1.32.0+  
> **æœ€åæ›´æ–°**: 2025å¹´10æœˆ8æ—¥

---

## ğŸ“‹ ç›®å½•

- [Go æ€§èƒ½ä¼˜åŒ–ä¸ OTLP æœ€ä½³å®è·µ](#go-æ€§èƒ½ä¼˜åŒ–ä¸-otlp-æœ€ä½³å®è·µ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [å†…å­˜ä¼˜åŒ–](#å†…å­˜ä¼˜åŒ–)
    - [å‡å°‘å†…å­˜åˆ†é…](#å‡å°‘å†…å­˜åˆ†é…)
    - [å¯¹è±¡æ± åŒ–](#å¯¹è±¡æ± åŒ–)
  - [GC ä¼˜åŒ–](#gc-ä¼˜åŒ–)
    - [GC è°ƒä¼˜](#gc-è°ƒä¼˜)
  - [é‡‡æ ·ç­–ç•¥](#é‡‡æ ·ç­–ç•¥)
    - [æ™ºèƒ½é‡‡æ ·](#æ™ºèƒ½é‡‡æ ·)
    - [é‡‡æ ·é…ç½®](#é‡‡æ ·é…ç½®)
  - [æ‰¹å¤„ç†ä¼˜åŒ–](#æ‰¹å¤„ç†ä¼˜åŒ–)

---

## å†…å­˜ä¼˜åŒ–

### å‡å°‘å†…å­˜åˆ†é…

```go
package memoryopt

import (
 "context"
 "sync"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/trace"
)

// MemoryOptimization å†…å­˜ä¼˜åŒ–ç¤ºä¾‹
type MemoryOptimization struct {
 tracer trace.Tracer
 
 // ä½¿ç”¨ sync.Pool å¤ç”¨å¯¹è±¡
 attributePool *sync.Pool
 spanPool      *sync.Pool
}

// NewMemoryOptimization åˆ›å»ºå†…å­˜ä¼˜åŒ–å®ä¾‹
func NewMemoryOptimization() *MemoryOptimization {
 return &MemoryOptimization{
  tracer: otel.Tracer("memory-opt"),
  
  // å±æ€§æ± 
  attributePool: &sync.Pool{
   New: func() interface{} {
    // é¢„åˆ†é…å¸¸ç”¨å±æ€§å®¹é‡
    return make([]attribute.KeyValue, 0, 10)
   },
  },
  
  // Span æ•°æ®æ± 
  spanPool: &sync.Pool{
   New: func() interface{} {
    return &SpanData{}
   },
  },
 }
}

// SpanData Span æ•°æ®ç»“æ„
type SpanData struct {
 Name       string
 Attributes []attribute.KeyValue
 Events     []trace.Event
}

// OptimizedTracing ä¼˜åŒ–çš„è¿½è¸ª
func (m *MemoryOptimization) OptimizedTracing(ctx context.Context) {
 // ä»æ± ä¸­è·å–å±æ€§åˆ‡ç‰‡
 attrs := m.attributePool.Get().([]attribute.KeyValue)
 defer func() {
  // æ¸…ç©ºå¹¶å½’è¿˜åˆ°æ± 
  attrs = attrs[:0]
  m.attributePool.Put(attrs)
 }()

 // å¤ç”¨å±æ€§åˆ‡ç‰‡
 attrs = append(attrs,
  attribute.String("service", "my-service"),
  attribute.Int("version", 1),
 )

 ctx, span := m.tracer.Start(ctx, "optimized-operation",
  trace.WithAttributes(attrs...),
 )
 defer span.End()

 // ä¸šåŠ¡é€»è¾‘
 doWork()
}

// BatchAttributeCreation æ‰¹é‡åˆ›å»ºå±æ€§ï¼ˆé¿å…å¤šæ¬¡åˆ†é…ï¼‰
func (m *MemoryOptimization) BatchAttributeCreation() []attribute.KeyValue {
 // âŒ ä½æ•ˆ: å¤šæ¬¡ append å¯¼è‡´å¤šæ¬¡å†…å­˜åˆ†é…
 // attrs := []attribute.KeyValue{}
 // attrs = append(attrs, attribute.String("a", "1"))
 // attrs = append(attrs, attribute.String("b", "2"))
 // ...

 // âœ… é«˜æ•ˆ: é¢„åˆ†é…å®¹é‡
 attrs := make([]attribute.KeyValue, 0, 10)
 attrs = append(attrs,
  attribute.String("service.name", "my-service"),
  attribute.String("service.version", "1.0.0"),
  attribute.String("deployment.environment", "production"),
  attribute.String("host.name", "server-01"),
  attribute.String("host.type", "ec2"),
 )

 return attrs
}

// PreallocateBuffers é¢„åˆ†é…ç¼“å†²åŒº
func (m *MemoryOptimization) PreallocateBuffers(ctx context.Context, itemCount int) {
 ctx, span := m.tracer.Start(ctx, "batch-process")
 defer span.End()

 // âœ… é¢„åˆ†é…åˆ‡ç‰‡å®¹é‡
 results := make([]Result, 0, itemCount)
 
 for i := 0; i < itemCount; i++ {
  result := processItem(i)
  results = append(results, result)
 }

 span.SetAttributes(
  attribute.Int("results.count", len(results)),
 )
}

// StringBuilderOptimization ä½¿ç”¨ strings.Builder ä¼˜åŒ–å­—ç¬¦ä¸²æ„å»º
func (m *MemoryOptimization) StringBuilderOptimization(ctx context.Context, parts []string) string {
 ctx, span := m.tracer.Start(ctx, "build-string")
 defer span.End()

 // âŒ ä½æ•ˆ: å­—ç¬¦ä¸²è¿æ¥äº§ç”Ÿå¤šæ¬¡åˆ†é…
 // result := ""
 // for _, part := range parts {
 //     result += part
 // }

 // âœ… é«˜æ•ˆ: ä½¿ç”¨ strings.Builder
 var builder strings.Builder
 builder.Grow(len(parts) * 10) // é¢„ä¼°å®¹é‡

 for _, part := range parts {
  builder.WriteString(part)
 }

 return builder.String()
}

type Result struct {
 ID   int
 Data string
}

func processItem(id int) Result {
 return Result{ID: id, Data: fmt.Sprintf("item-%d", id)}
}

func doWork() {
 // æ¨¡æ‹Ÿå·¥ä½œ
}
```

### å¯¹è±¡æ± åŒ–

```go
package memoryopt

import (
 "context"
 "sync"

 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/trace"
)

// SpanDataPool Span æ•°æ®æ± 
type SpanDataPool struct {
 pool *sync.Pool
}

// NewSpanDataPool åˆ›å»º Span æ•°æ®æ± 
func NewSpanDataPool() *SpanDataPool {
 return &SpanDataPool{
  pool: &sync.Pool{
   New: func() interface{} {
    return &PooledSpanData{
     Attributes: make([]attribute.KeyValue, 0, 20),
     Events:     make([]Event, 0, 5),
    }
   },
  },
 }
}

// PooledSpanData æ± åŒ–çš„ Span æ•°æ®
type PooledSpanData struct {
 Name       string
 Attributes []attribute.KeyValue
 Events     []Event
 StartTime  time.Time
 EndTime    time.Time
}

// Event äº‹ä»¶
type Event struct {
 Name       string
 Timestamp  time.Time
 Attributes []attribute.KeyValue
}

// Acquire è·å– Span æ•°æ®
func (p *SpanDataPool) Acquire() *PooledSpanData {
 return p.pool.Get().(*PooledSpanData)
}

// Release é‡Šæ”¾ Span æ•°æ®
func (p *SpanDataPool) Release(data *PooledSpanData) {
 // æ¸…ç©ºæ•°æ®
 data.Name = ""
 data.Attributes = data.Attributes[:0]
 data.Events = data.Events[:0]
 data.StartTime = time.Time{}
 data.EndTime = time.Time{}

 // å½’è¿˜åˆ°æ± 
 p.pool.Put(data)
}

// ä½¿ç”¨ç¤ºä¾‹
func ExampleSpanDataPool(ctx context.Context, pool *SpanDataPool) {
 // è·å–å¯¹è±¡
 spanData := pool.Acquire()
 defer pool.Release(spanData)

 // ä½¿ç”¨å¯¹è±¡
 spanData.Name = "operation"
 spanData.Attributes = append(spanData.Attributes,
  attribute.String("key", "value"),
 )
 spanData.StartTime = time.Now()

 // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
 doWork()

 spanData.EndTime = time.Now()
}
```

---

## GC ä¼˜åŒ–

### GC è°ƒä¼˜

```go
package gcopt

import (
 "context"
 "runtime"
 "runtime/debug"
 "time"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/attribute"
 "go.opentelemetry.io/otel/metric"
)

// GCOptimization GC ä¼˜åŒ–
type GCOptimization struct {
 meter metric.Meter
 
 // GC Metrics
 gcPauses        metric.Float64Histogram
 gcCount         metric.Int64Counter
 heapAlloc       metric.Int64ObservableGauge
 heapSys         metric.Int64ObservableGauge
 numGoroutines   metric.Int64ObservableGauge
}

// NewGCOptimization åˆ›å»º GC ä¼˜åŒ–å®ä¾‹
func NewGCOptimization() (*GCOptimization, error) {
 meter := otel.Meter("gc-optimization")
 
 g := &GCOptimization{
  meter: meter,
 }

 var err error

 // GC æš‚åœæ—¶é—´
 g.gcPauses, err = meter.Float64Histogram(
  "go.gc.pause_duration",
  metric.WithDescription("GC æš‚åœæ—¶é—´"),
  metric.WithUnit("ms"),
 )
 if err != nil {
  return nil, err
 }

 // GC æ¬¡æ•°
 g.gcCount, err = meter.Int64Counter(
  "go.gc.count",
  metric.WithDescription("GC æ¬¡æ•°"),
 )
 if err != nil {
  return nil, err
 }

 // å †å†…å­˜åˆ†é…
 g.heapAlloc, err = meter.Int64ObservableGauge(
  "go.memory.heap_alloc",
  metric.WithDescription("å †å†…å­˜åˆ†é…"),
  metric.WithUnit("bytes"),
  metric.WithInt64Callback(func(ctx context.Context, observer metric.Int64Observer) error {
   var m runtime.MemStats
   runtime.ReadMemStats(&m)
   observer.Observe(int64(m.HeapAlloc))
   return nil
  }),
 )
 if err != nil {
  return nil, err
 }

 // å †ç³»ç»Ÿå†…å­˜
 g.heapSys, err = meter.Int64ObservableGauge(
  "go.memory.heap_sys",
  metric.WithDescription("å †ç³»ç»Ÿå†…å­˜"),
  metric.WithUnit("bytes"),
  metric.WithInt64Callback(func(ctx context.Context, observer metric.Int64Observer) error {
   var m runtime.MemStats
   runtime.ReadMemStats(&m)
   observer.Observe(int64(m.HeapSys))
   return nil
  }),
 )
 if err != nil {
  return nil, err
 }

 // Goroutine æ•°é‡
 g.numGoroutines, err = meter.Int64ObservableGauge(
  "go.goroutines.count",
  metric.WithDescription("Goroutine æ•°é‡"),
  metric.WithInt64Callback(func(ctx context.Context, observer metric.Int64Observer) error {
   observer.Observe(int64(runtime.NumGoroutine()))
   return nil
  }),
 )
 if err != nil {
  return nil, err
 }

 // å¯åŠ¨ GC ç›‘æ§
 go g.monitorGC(context.Background())

 return g, nil
}

// monitorGC ç›‘æ§ GC
func (g *GCOptimization) monitorGC(ctx context.Context) {
 var lastNumGC uint32
 ticker := time.NewTicker(10 * time.Second)
 defer ticker.Stop()

 for {
  select {
  case <-ctx.Done():
   return
  case <-ticker.C:
   var m runtime.MemStats
   runtime.ReadMemStats(&m)

   // è®°å½• GC æ¬¡æ•°å˜åŒ–
   if m.NumGC > lastNumGC {
    gcDiff := m.NumGC - lastNumGC
    g.gcCount.Add(ctx, int64(gcDiff))

    // è®°å½•æœ€è¿‘çš„ GC æš‚åœæ—¶é—´
    for i := uint32(0); i < gcDiff && i < 256; i++ {
     idx := (m.NumGC - 1 - i) % 256
     pauseNs := m.PauseNs[idx]
     pauseMs := float64(pauseNs) / 1e6
     
     g.gcPauses.Record(ctx, pauseMs,
      metric.WithAttributes(
       attribute.String("gc.type", "pause"),
      ),
     )
    }

    lastNumGC = m.NumGC
   }
  }
 }
}

// ConfigureGC é…ç½® GC
func (g *GCOptimization) ConfigureGC() {
 // è®¾ç½® GC ç™¾åˆ†æ¯” (é»˜è®¤ 100)
 // æ•°å€¼è¶Šå°ï¼ŒGC è¶Šé¢‘ç¹ï¼Œå†…å­˜å ç”¨è¶Šä½
 // æ•°å€¼è¶Šå¤§ï¼ŒGC è¶Šå°‘ï¼Œä½†å†…å­˜å ç”¨è¶Šé«˜
 debug.SetGCPercent(100)

 // è®¾ç½®å†…å­˜é™åˆ¶ (Go 1.19+)
 // debug.SetMemoryLimit(1 * 1024 * 1024 * 1024) // 1GB

 // æ‰‹åŠ¨è§¦å‘ GC (ä»…åœ¨éœ€è¦æ—¶)
 // runtime.GC()
}

// ReduceGCPressure å‡å°‘ GC å‹åŠ›çš„ç¤ºä¾‹
func (g *GCOptimization) ReduceGCPressure(ctx context.Context) {
 // 1. å¤ç”¨å¯¹è±¡è€Œä¸æ˜¯åˆ›å»ºæ–°å¯¹è±¡
 var bufferPool = sync.Pool{
  New: func() interface{} {
   return make([]byte, 4096)
  },
 }

 buf := bufferPool.Get().([]byte)
 defer bufferPool.Put(buf)

 // 2. ä½¿ç”¨å€¼ç±»å‹è€Œä¸æ˜¯æŒ‡é’ˆç±»å‹ï¼ˆé€‚ç”¨äºå°å¯¹è±¡ï¼‰
 type SmallStruct struct {
  A int
  B int
 }
 
 // âœ… å€¼ç±»å‹ (ä¸å¢åŠ  GC å‹åŠ›)
 values := make([]SmallStruct, 1000)
 
 // âŒ æŒ‡é’ˆç±»å‹ (å¢åŠ  GC æ‰«æå¼€é”€)
 // pointers := make([]*SmallStruct, 1000)

 // 3. æ‰¹é‡åˆ†é…è€Œä¸æ˜¯å•ä¸ªåˆ†é…
 // âœ… æ‰¹é‡åˆ†é…
 _ = make([]int, 1000)
 
 // âŒ å•ä¸ªåˆ†é…
 // for i := 0; i < 1000; i++ {
 //     _ = new(int)
 // }

 _ = values // ä½¿ç”¨ values
}
```

---

## é‡‡æ ·ç­–ç•¥

### æ™ºèƒ½é‡‡æ ·

```go
package sampling

import (
 "context"
 "math/rand"
 "sync/atomic"
 "time"

 "go.opentelemetry.io/otel/sdk/trace"
 sdktrace "go.opentelemetry.io/otel/sdk/trace"
)

// AdaptiveSampler è‡ªé€‚åº”é‡‡æ ·å™¨
type AdaptiveSampler struct {
 // å½“å‰é‡‡æ ·ç‡ (0.0 - 1.0)
 currentRate atomic.Uint64 // ä½¿ç”¨ uint64 å­˜å‚¨ float64
 
 // ç›®æ ‡ QPS
 targetQPS int64
 
 // å½“å‰ QPS
 currentQPS atomic.Int64
 
 // æœ€åè°ƒæ•´æ—¶é—´
 lastAdjustTime atomic.Int64
}

// NewAdaptiveSampler åˆ›å»ºè‡ªé€‚åº”é‡‡æ ·å™¨
func NewAdaptiveSampler(initialRate float64, targetQPS int64) *AdaptiveSampler {
 s := &AdaptiveSampler{
  targetQPS: targetQPS,
 }
 s.SetRate(initialRate)
 s.lastAdjustTime.Store(time.Now().Unix())
 
 // å¯åŠ¨è°ƒæ•´ goroutine
 go s.adjustRate()
 
 return s
}

// SetRate è®¾ç½®é‡‡æ ·ç‡
func (s *AdaptiveSampler) SetRate(rate float64) {
 s.currentRate.Store(math.Float64bits(rate))
}

// GetRate è·å–é‡‡æ ·ç‡
func (s *AdaptiveSampler) GetRate() float64 {
 return math.Float64frombits(s.currentRate.Load())
}

// ShouldSample æ˜¯å¦åº”è¯¥é‡‡æ ·
func (s *AdaptiveSampler) ShouldSample(parameters sdktrace.SamplingParameters) sdktrace.SamplingResult {
 // å¢åŠ è¯·æ±‚è®¡æ•°
 s.currentQPS.Add(1)
 
 rate := s.GetRate()
 
 // åŸºäºé‡‡æ ·ç‡å†³å®š
 if rand.Float64() < rate {
  return sdktrace.SamplingResult{
   Decision: sdktrace.RecordAndSample,
  }
 }
 
 return sdktrace.SamplingResult{
  Decision: sdktrace.Drop,
 }
}

// Description é‡‡æ ·å™¨æè¿°
func (s *AdaptiveSampler) Description() string {
 return "AdaptiveSampler"
}

// adjustRate è°ƒæ•´é‡‡æ ·ç‡
func (s *AdaptiveSampler) adjustRate() {
 ticker := time.NewTicker(10 * time.Second)
 defer ticker.Stop()

 for range ticker.C {
  now := time.Now().Unix()
  lastAdjust := s.lastAdjustTime.Load()
  elapsed := now - lastAdjust

  if elapsed <= 0 {
   continue
  }

  // è®¡ç®—å®é™… QPS
  count := s.currentQPS.Swap(0)
  actualQPS := count / elapsed

  // æ ¹æ®å®é™… QPS è°ƒæ•´é‡‡æ ·ç‡
  currentRate := s.GetRate()
  var newRate float64

  if actualQPS > s.targetQPS {
   // é™ä½é‡‡æ ·ç‡
   newRate = currentRate * float64(s.targetQPS) / float64(actualQPS)
  } else if actualQPS < s.targetQPS*80/100 {
   // æé«˜é‡‡æ ·ç‡
   newRate = currentRate * 1.1
  } else {
   // ä¿æŒå½“å‰é‡‡æ ·ç‡
   newRate = currentRate
  }

  // é™åˆ¶é‡‡æ ·ç‡èŒƒå›´ [0.001, 1.0]
  if newRate < 0.001 {
   newRate = 0.001
  } else if newRate > 1.0 {
   newRate = 1.0
  }

  s.SetRate(newRate)
  s.lastAdjustTime.Store(now)
 }
}

// PrioritySampler ä¼˜å…ˆçº§é‡‡æ ·å™¨
type PrioritySampler struct {
 baseRate     float64
 errorRate    float64    // é”™è¯¯é‡‡æ ·ç‡
 slowRate     float64    // æ…¢è¯·æ±‚é‡‡æ ·ç‡
 slowThreshold time.Duration
}

// NewPrioritySampler åˆ›å»ºä¼˜å…ˆçº§é‡‡æ ·å™¨
func NewPrioritySampler(baseRate, errorRate, slowRate float64, slowThreshold time.Duration) *PrioritySampler {
 return &PrioritySampler{
  baseRate:      baseRate,
  errorRate:     errorRate,
  slowRate:      slowRate,
  slowThreshold: slowThreshold,
 }
}

// ShouldSample æ˜¯å¦åº”è¯¥é‡‡æ ·
func (s *PrioritySampler) ShouldSample(parameters sdktrace.SamplingParameters) sdktrace.SamplingResult {
 // æ£€æŸ¥æ˜¯å¦æ˜¯é”™è¯¯
 // (éœ€è¦ä» attributes ä¸­æ£€æŸ¥)
 
 // æ£€æŸ¥æ˜¯å¦æ˜¯æ…¢è¯·æ±‚
 // (éœ€è¦ä» attributes ä¸­æ£€æŸ¥æŒç»­æ—¶é—´)
 
 // é»˜è®¤ä½¿ç”¨åŸºç¡€é‡‡æ ·ç‡
 if rand.Float64() < s.baseRate {
  return sdktrace.SamplingResult{
   Decision: sdktrace.RecordAndSample,
  }
 }
 
 return sdktrace.SamplingResult{
  Decision: sdktrace.Drop,
 }
}

// Description é‡‡æ ·å™¨æè¿°
func (s *PrioritySampler) Description() string {
 return "PrioritySampler"
}
```

### é‡‡æ ·é…ç½®

```go
package sampling

import (
 "go.opentelemetry.io/otel/sdk/trace"
 sdktrace "go.opentelemetry.io/otel/sdk/trace"
)

// SamplingConfig é‡‡æ ·é…ç½®
type SamplingConfig struct {
 // åŸºç¡€é‡‡æ ·ç‡
 BaseRate float64
 
 // æ˜¯å¦å¯ç”¨è‡ªé€‚åº”é‡‡æ ·
 Adaptive bool
 
 // ç›®æ ‡ QPS (ä»…è‡ªé€‚åº”é‡‡æ ·)
 TargetQPS int64
 
 // æ˜¯å¦å¯ç”¨ä¼˜å…ˆçº§é‡‡æ ·
 Priority bool
 
 // é”™è¯¯é‡‡æ ·ç‡
 ErrorRate float64
 
 // æ…¢è¯·æ±‚é‡‡æ ·ç‡
 SlowRate float64
 
 // æ…¢è¯·æ±‚é˜ˆå€¼
 SlowThreshold time.Duration
}

// CreateSampler åˆ›å»ºé‡‡æ ·å™¨
func CreateSampler(config SamplingConfig) sdktrace.Sampler {
 if config.Adaptive {
  // è‡ªé€‚åº”é‡‡æ ·
  return NewAdaptiveSampler(config.BaseRate, config.TargetQPS)
 }
 
 if config.Priority {
  // ä¼˜å…ˆçº§é‡‡æ ·
  return NewPrioritySampler(
   config.BaseRate,
   config.ErrorRate,
   config.SlowRate,
   config.SlowThreshold,
  )
 }
 
 // é»˜è®¤: åŸºäº TraceID çš„é‡‡æ ·
 return sdktrace.ParentBased(
  sdktrace.TraceIDRatioBased(config.BaseRate),
 )
}

// é¢„å®šä¹‰é‡‡æ ·é…ç½®

// DevelopmentSampling å¼€å‘ç¯å¢ƒé‡‡æ · (100%)
func DevelopmentSampling() SamplingConfig {
 return SamplingConfig{
  BaseRate: 1.0,
 }
}

// ProductionSampling ç”Ÿäº§ç¯å¢ƒé‡‡æ · (10%)
func ProductionSampling() SamplingConfig {
 return SamplingConfig{
  BaseRate:  0.1,
  Adaptive:  true,
  TargetQPS: 1000,
 }
}

// HighTrafficSampling é«˜æµé‡é‡‡æ · (1%)
func HighTrafficSampling() SamplingConfig {
 return SamplingConfig{
  BaseRate:  0.01,
  Adaptive:  true,
  TargetQPS: 10000,
 }
}

// SmartSampling æ™ºèƒ½é‡‡æ ·
func SmartSampling() SamplingConfig {
 return SamplingConfig{
  BaseRate:      0.1,
  Priority:      true,
  ErrorRate:     1.0,   // 100% é‡‡æ ·é”™è¯¯
  SlowRate:      0.5,   // 50% é‡‡æ ·æ…¢è¯·æ±‚
  SlowThreshold: 1 * time.Second,
 }
}
```

---

## æ‰¹å¤„ç†ä¼˜åŒ–

```go
package batchopt

import (
 "context"
 "sync"
 "time"

 "go.opentelemetry.io/otel"
 "go.opentelemetry.io/otel/sdk/trace"
 sdktrace "go.opentelemetry.io/otel/sdk/trace"
)

// BatchProcessor æ‰¹å¤„ç†å™¨é…ç½®
type BatchProcessorConfig struct {
 // æœ€å¤§å¯¼å‡ºæ‰¹å¤§å°
 MaxExportBatchSize int
 
 // æ‰¹å¤„ç†è¶…æ—¶
 BatchTimeout time.Duration
 
 // æœ€å¤§é˜Ÿåˆ—å¤§å°
 MaxQueueSize int
 
 // å¯¼å‡ºè¶…æ—¶
 ExportTimeout time.Duration
}

// OptimalBatchConfig æœ€ä¼˜æ‰¹å¤„ç†é…ç½®
func OptimalBatchConfig() sdktrace.BatchSpanProcessorOption {
 return func(o *sdktrace.BatchSpanProcessorOptions) {
  // æ‰¹å¤§å°: 512 (é»˜è®¤)
  // - å¤ªå°: é¢‘ç¹å¯¼å‡ºï¼Œå¼€é”€å¤§
  // - å¤ªå¤§: å†…å­˜å ç”¨é«˜ï¼Œå»¶è¿Ÿé«˜
  o.MaxExportBatchSize = 512
  
  // æ‰¹è¶…æ—¶: 5ç§’ (é»˜è®¤)
  // - å¤ªçŸ­: æ‰¹æ¬¡ä¸æ»¡å°±å¯¼å‡º
  // - å¤ªé•¿: æ•°æ®å»¶è¿Ÿé«˜
  o.BatchTimeout = 5 * time.Second
  
  // é˜Ÿåˆ—å¤§å°: 2048 (é»˜è®¤)
  // - å¤ªå°: å®¹æ˜“ä¸¢å¤±æ•°æ®
  // - å¤ªå¤§: å†…å­˜å ç”¨é«˜
  o.MaxQueueSize = 2048
  
  // å¯¼å‡ºè¶…æ—¶: 30ç§’ (é»˜è®¤)
  o.ExportTimeout = 30 * time.Second
 }
}

// HighThroughputBatchConfig é«˜ååé‡é…ç½®
func HighThroughputBatchConfig() sdktrace.BatchSpanProcessorOption {
 return func(o *sdktrace.BatchSpanProcessorOptions) {
  o.MaxExportBatchSize = 2048  // æ›´å¤§çš„æ‰¹
  o.BatchTimeout = 10 * time.Second
  o.MaxQueueSize = 8192        // æ›´å¤§çš„é˜Ÿåˆ—
  o.ExportTimeout = 60 * time.Second
 }
}

// LowLatencyBatchConfig ä½å»¶è¿Ÿé…ç½®
func LowLatencyBatchConfig() sdktrace.BatchSpanProcessorOption {
 return func(o *sdktrace.BatchSpanProcessorOptions) {
  o.MaxExportBatchSize = 128   // æ›´å°çš„æ‰¹
  o.BatchTimeout = 1 * time.Second  // æ›´çŸ­çš„è¶…æ—¶
  o.MaxQueueSize = 512
  o.ExportTimeout = 10 * time.Second
 }
}

// CustomBatchProcessor è‡ªå®šä¹‰æ‰¹å¤„ç†å™¨
type CustomBatchProcessor struct {
 exporter sdktrace.SpanExporter
 
 // æ‰¹å¤„ç†ç¼“å†²åŒº
 buffer    []sdktrace.ReadOnlySpan
 bufferMu  sync.Mutex
 
 // é…ç½®
 config BatchProcessorConfig
 
 // å®šæ—¶å™¨
 timer *time.Timer
 
 // å…³é—­ä¿¡å·
 stopCh chan struct{}
 wg     sync.WaitGroup
}

// NewCustomBatchProcessor åˆ›å»ºè‡ªå®šä¹‰æ‰¹å¤„ç†å™¨
func NewCustomBatchProcessor(exporter sdktrace.SpanExporter, config BatchProcessorConfig) *CustomBatchProcessor {
 processor := &CustomBatchProcessor{
  exporter: exporter,
  buffer:   make([]sdktrace.ReadOnlySpan, 0, config.MaxExportBatchSize),
  config:   config,
  stopCh:   make(chan struct{}),
 }
 
 processor.wg.Add(1)
 go processor.processLoop()
 
 return processor
}

// OnStart å¤„ç† Span å¼€å§‹
func (p *CustomBatchProcessor) OnStart(parent context.Context, s sdktrace.ReadWriteSpan) {
 // ä¸éœ€è¦å¤„ç†
}

// OnEnd å¤„ç† Span ç»“æŸ
func (p *CustomBatchProcessor) OnEnd(s sdktrace.ReadOnlySpan) {
 if !s.SpanContext().IsSampled() {
  return
 }

 p.bufferMu.Lock()
 defer p.bufferMu.Unlock()

 p.buffer = append(p.buffer, s)

 // å¦‚æœç¼“å†²åŒºæ»¡äº†ï¼Œç«‹å³å¯¼å‡º
 if len(p.buffer) >= p.config.MaxExportBatchSize {
  p.export()
 }
}

// Shutdown å…³é—­å¤„ç†å™¨
func (p *CustomBatchProcessor) Shutdown(ctx context.Context) error {
 close(p.stopCh)
 p.wg.Wait()
 
 // å¯¼å‡ºå‰©ä½™çš„ spans
 p.bufferMu.Lock()
 defer p.bufferMu.Unlock()
 
 if len(p.buffer) > 0 {
  return p.exporter.ExportSpans(ctx, p.buffer)
 }
 
 return nil
}

// ForceFlush å¼ºåˆ¶åˆ·æ–°
func (p *CustomBatchProcessor) ForceFlush(ctx context.Context) error {
 p.bufferMu.Lock()
 defer p.bufferMu.Unlock()
 
 if len(p.buffer) > 0 {
  return p.exporter.ExportSpans(ctx, p.buffer)
 }
 
 return nil
}

// processLoop å¤„ç†å¾ªç¯
func (p *CustomBatchProcessor) processLoop() {
 defer p.wg.Done()
 
 ticker := time.NewTicker(p.config.BatchTimeout)
 defer ticker.Stop()

 for {
  select {
  case <-p.stopCh:
   return
  case <-ticker.C:
   p.bufferMu.Lock()
   p.export()
   p.bufferMu.Unlock()
  }
 }
}

// export å¯¼å‡ºï¼ˆéœ€è¦æŒæœ‰é”ï¼‰
func (p *CustomBatchProcessor) export() {
 if len(p.buffer) == 0 {
  return
 }

 ctx, cancel := context.WithTimeout(context.Background(), p.config.ExportTimeout)
 defer cancel()

 // å¯¼å‡º
 _ = p.exporter.ExportSpans(ctx, p.buffer)

 // æ¸…ç©ºç¼“å†²åŒº
 p.buffer = p.buffer[:0]
}
```

è¿™ä¸ªæ–‡æ¡£æä¾›äº†å…¨é¢çš„ Go æ€§èƒ½ä¼˜åŒ–æŒ‡å—ï¼ŒåŒ…æ‹¬ï¼š

1. **å†…å­˜ä¼˜åŒ–** - å¯¹è±¡æ± ã€é¢„åˆ†é…ã€å‡å°‘åˆ†é…
2. **GC ä¼˜åŒ–** - GC ç›‘æ§ã€è°ƒä¼˜ã€å‹åŠ›å‡å°‘
3. **é‡‡æ ·ç­–ç•¥** - è‡ªé€‚åº”é‡‡æ ·ã€ä¼˜å…ˆçº§é‡‡æ ·
4. **æ‰¹å¤„ç†ä¼˜åŒ–** - æ‰¹å¤§å°ã€è¶…æ—¶é…ç½®

è®©æˆ‘ç»§ç»­åˆ›å»ºæµ‹è¯•å’ŒåŸºå‡†æµ‹è¯•æ–‡æ¡£ï¼Œç„¶åæ›´æ–°ç°æœ‰æ–‡æ¡£ä»¥ç§»é™¤é Go å†…å®¹...
