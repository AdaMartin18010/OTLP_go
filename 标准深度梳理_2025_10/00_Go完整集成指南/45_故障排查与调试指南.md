# 45. 故障排查与调试指南

## 📚 目录

- [1. 常见问题排查](#1-常见问题排查)
- [2. Trace 问题诊断](#2-trace-问题诊断)
- [3. Metrics 问题诊断](#3-metrics-问题诊断)
- [4. 性能问题定位](#4-性能问题定位)
- [5. 数据库问题](#5-数据库问题)
- [6. 分布式事务问题](#6-分布式事务问题)
- [7. 调试工具](#7-调试工具)
- [8. 总结](#8-总结)

---

## 1. 常见问题排查

### 1.1 Trace 数据丢失

**症状**: Jaeger 中看不到某些服务的 Trace 数据

**可能原因**:
1. OTLP Collector 未正确配置
2. 采样率设置过低
3. 网络连接问题
4. 导出器配置错误

**排查步骤**:

```bash
# 1. 检查 OTLP Collector 状态
curl http://localhost:13133/

# 2. 检查应用日志
docker logs api-gateway | grep -i "otel\|trace"

# 3. 检查网络连接
telnet localhost 4317

# 4. 验证采样配置
```

**解决方案**:

```go
// 确保采样率配置正确
tp := sdktrace.NewTracerProvider(
    sdktrace.WithBatcher(exporter),
    sdktrace.WithSampler(sdktrace.AlwaysSample()), // 开发环境使用
    // sdktrace.WithSampler(sdktrace.TraceIDRatioBased(0.1)), // 生产环境
)
```

### 1.2 Context 未传播

**症状**: Span 之间没有父子关系

**原因**: Context 未正确传递

**错误示例**:

```go
// ❌ 错误：没有传递 Context
func processRequest(req Request) error {
    ctx := context.Background() // 创建新的 Context
    span := tracer.Start(ctx, "process") // 丢失了父 Span
    defer span.End()
    
    return doWork(ctx)
}
```

**正确示例**:

```go
// ✅ 正确：传递 Context
func processRequest(ctx context.Context, req Request) error {
    ctx, span := tracer.Start(ctx, "process") // 继承父 Span
    defer span.End()
    
    return doWork(ctx)
}
```

### 1.3 Goroutine 泄漏

**症状**: 内存持续增长，goroutine 数量不断上升

**排查工具**:

```go
package main

import (
    "net/http"
    _ "net/http/pprof"
    "runtime"
)

func monitorGoroutines() {
    go func() {
        ticker := time.NewTicker(10 * time.Second)
        for range ticker.C {
            count := runtime.NumGoroutine()
            log.Printf("Current goroutines: %d", count)
            
            if count > 10000 {
                log.Printf("WARNING: High goroutine count detected!")
            }
        }
    }()
    
    // 启动 pprof
    go http.ListenAndServe("localhost:6060", nil)
}
```

**排查命令**:

```bash
# 查看 goroutine 栈
curl http://localhost:6060/debug/pprof/goroutine?debug=2

# 生成 goroutine profile
go tool pprof http://localhost:6060/debug/pprof/goroutine

# 分析 goroutine
top 20
list <function_name>
```

**常见原因**:

```go
// ❌ 没有正确关闭 Channel
func leakyFunction() {
    ch := make(chan int)
    go func() {
        for v := range ch { // 如果 ch 永远不关闭，goroutine 会一直等待
            process(v)
        }
    }()
}

// ✅ 正确关闭 Channel
func correctFunction(ctx context.Context) {
    ch := make(chan int)
    go func() {
        defer close(ch)
        for {
            select {
            case <-ctx.Done():
                return
            case v := <-source:
                ch <- v
            }
        }
    }()
}
```

---

## 2. Trace 问题诊断

### 2.1 Span 属性缺失

**问题**: Span 中缺少关键属性

**检查清单**:

```go
// 确保设置关键属性
span.SetAttributes(
    attribute.String("service.name", "my-service"),
    attribute.String("service.version", "1.0.0"),
    attribute.String("deployment.environment", "production"),
    
    // 业务属性
    attribute.String("user.id", userID),
    attribute.String("order.id", orderID),
    attribute.Int64("order.amount", amount),
)
```

### 2.2 Trace 链路断裂

**症状**: 跨服务调用时 Trace 链路中断

**原因**: HTTP/gRPC 调用时未传播 Context

**HTTP Client 正确示例**:

```go
// ✅ 正确：使用 otelhttp.Transport
client := &http.Client{
    Transport: otelhttp.NewTransport(http.DefaultTransport),
}

req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
resp, err := client.Do(req)
```

**gRPC Client 正确示例**:

```go
// ✅ 正确：使用 otelgrpc
conn, err := grpc.Dial(target,
    grpc.WithStatsHandler(otelgrpc.NewClientHandler()),
)
```

### 2.3 Span 时间异常

**问题**: Span 持续时间异常长或异常短

**排查**:

```go
// 添加 Event 标记关键时间点
span.AddEvent("validation_start")
// ... validation logic
span.AddEvent("validation_end")

span.AddEvent("db_query_start")
// ... database query
span.AddEvent("db_query_end")

// 在 Jaeger UI 中查看 Events 时间线
```

---

## 3. Metrics 问题诊断

### 3.1 Metrics 未上报

**排查步骤**:

```bash
# 1. 检查 Prometheus targets
curl http://localhost:9090/api/v1/targets

# 2. 检查应用 metrics 端点
curl http://localhost:9090/metrics

# 3. 查询特定 metric
curl 'http://localhost:9090/api/v1/query?query=http_server_requests_total'
```

### 3.2 Metric 值异常

**问题**: Counter 减少或 Gauge 值不合理

**检查**:

```go
// ❌ 错误：Counter 使用了 Add(-1)
counter.Add(ctx, -1) // Counter 不应该减少

// ✅ 正确：使用两个 Counter
activeRequests.Add(ctx, 1)  // 请求开始
completedRequests.Add(ctx, 1) // 请求完成

// 或使用 UpDownCounter
activeConnections := meter.Int64UpDownCounter("active_connections")
activeConnections.Add(ctx, 1)  // 连接建立
activeConnections.Add(ctx, -1) // 连接关闭
```

### 3.3 Histogram 分布异常

**问题**: P95/P99 延迟异常高

**分析**:

```promql
# 查看延迟分布
histogram_quantile(0.50, rate(http_server_duration_bucket[5m]))
histogram_quantile(0.95, rate(http_server_duration_bucket[5m]))
histogram_quantile(0.99, rate(http_server_duration_bucket[5m]))

# 按端点分组
histogram_quantile(0.95, 
    sum(rate(http_server_duration_bucket[5m])) by (le, endpoint)
)
```

---

## 4. 性能问题定位

### 4.1 CPU 使用率高

**排查**:

```bash
# 1. 生成 CPU profile
curl http://localhost:6060/debug/pprof/profile?seconds=30 > cpu.prof

# 2. 分析 profile
go tool pprof cpu.prof
(pprof) top 20
(pprof) list <function_name>
(pprof) web  # 生成可视化图

# 3. 查看火焰图
go tool pprof -http=:8080 cpu.prof
```

**常见原因**:

```go
// ❌ 频繁的字符串拼接
func buildMessage(items []string) string {
    result := ""
    for _, item := range items {
        result += item + ", " // 每次创建新字符串
    }
    return result
}

// ✅ 使用 strings.Builder
func buildMessage(items []string) string {
    var builder strings.Builder
    builder.Grow(len(items) * 10) // 预分配
    for i, item := range items {
        if i > 0 {
            builder.WriteString(", ")
        }
        builder.WriteString(item)
    }
    return builder.String()
}
```

### 4.2 内存泄漏

**排查**:

```bash
# 1. 生成 heap profile
curl http://localhost:6060/debug/pprof/heap > heap.prof

# 2. 分析内存分配
go tool pprof -alloc_space heap.prof
(pprof) top 20
(pprof) list <function_name>

# 3. 查看内存使用
go tool pprof -inuse_space heap.prof
```

**常见原因**:

```go
// ❌ 未关闭资源
func processFile(filename string) error {
    file, _ := os.Open(filename)
    // 忘记 defer file.Close()
    
    data, _ := ioutil.ReadAll(file)
    process(data)
    return nil
}

// ✅ 正确关闭资源
func processFile(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer file.Close()
    
    data, err := ioutil.ReadAll(file)
    if err != nil {
        return err
    }
    
    return process(data)
}
```

### 4.3 GC 暂停时间长

**排查**:

```bash
# 开启 GC trace
GODEBUG=gctrace=1 ./your-app

# 输出示例：
# gc 1 @0.003s 0%: 0.018+1.2+0.003 ms clock, 0.037+0.27/1.1/2.3+0.006 ms cpu
```

**优化**:

```go
// 调整 GC 参数
import "runtime/debug"

// 降低 GC 频率（增加内存使用）
debug.SetGCPercent(200) // 默认 100

// 设置内存限制（Go 1.19+）
debug.SetMemoryLimit(8 * 1024 * 1024 * 1024) // 8GB
```

---

## 5. 数据库问题

### 5.1 慢查询

**排查**:

```go
// 添加慢查询日志
db.Logger = logger.New(
    log.New(os.Stdout, "\r\n", log.LstdFlags),
    logger.Config{
        SlowThreshold: 200 * time.Millisecond,
        LogLevel:      logger.Warn,
        Colorful:      true,
    },
)

// 使用 OTLP 追踪慢查询
func (s *Service) QueryWithTracing(ctx context.Context, query string) error {
    ctx, span := s.tracer.Start(ctx, "db.query",
        trace.WithAttributes(
            attribute.String("db.statement", query),
        ),
    )
    defer span.End()
    
    start := time.Now()
    err := s.db.WithContext(ctx).Raw(query).Error
    duration := time.Since(start)
    
    if duration > 200*time.Millisecond {
        span.SetAttributes(attribute.Bool("db.slow_query", true))
    }
    
    return err
}
```

### 5.2 连接池耗尽

**症状**: `Error: too many connections` 或连接超时

**排查**:

```go
// 监控连接池
stats := db.Stats()
log.Printf("OpenConnections: %d", stats.OpenConnections)
log.Printf("InUse: %d", stats.InUse)
log.Printf("Idle: %d", stats.Idle)
log.Printf("WaitCount: %d", stats.WaitCount)
log.Printf("WaitDuration: %v", stats.WaitDuration)

// 配置连接池
db.SetMaxOpenConns(25)
db.SetMaxIdleConns(5)
db.SetConnMaxLifetime(5 * time.Minute)
db.SetConnMaxIdleTime(1 * time.Minute)
```

### 5.3 死锁

**排查**:

```sql
-- PostgreSQL 查看锁等待
SELECT 
    blocked_locks.pid AS blocked_pid,
    blocked_activity.usename AS blocked_user,
    blocking_locks.pid AS blocking_pid,
    blocking_activity.usename AS blocking_user,
    blocked_activity.query AS blocked_statement,
    blocking_activity.query AS blocking_statement
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks 
    ON blocking_locks.locktype = blocked_locks.locktype
    AND blocking_locks.database IS NOT DISTINCT FROM blocked_locks.database
    AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
    AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
    AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
    AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
    AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
    AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
    AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
    AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
    AND blocking_locks.pid != blocked_locks.pid
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;
```

---

## 6. 分布式事务问题

### 6.1 Saga 回滚失败

**问题**: 补偿操作失败导致数据不一致

**排查**:

```go
// 添加详细的回滚日志
func (s *OrderSaga) rollback(ctx context.Context) {
    ctx, span := s.tracer.Start(ctx, "saga.rollback")
    defer span.End()
    
    span.AddEvent("starting rollback")
    
    var rollbackErrors []error
    
    // 记录每一步回滚
    if s.paymentProcessed {
        span.AddEvent("attempting payment refund")
        if err := s.refundPayment(ctx); err != nil {
            span.RecordError(err)
            rollbackErrors = append(rollbackErrors, fmt.Errorf("refund failed: %w", err))
            // 发送告警
            alerting.SendAlert("saga_rollback_failed", map[string]string{
                "order_id": s.orderID.String(),
                "step": "payment_refund",
                "error": err.Error(),
            })
        }
    }
    
    // ... 其他回滚步骤
    
    if len(rollbackErrors) > 0 {
        span.SetStatus(codes.Error, "rollback partially failed")
        // 记录到补偿队列，稍后重试
        s.enqueueCompensation(ctx, rollbackErrors)
    }
}
```

### 6.2 2PC 超时

**问题**: Prepare 阶段超时导致事务失败

**排查**:

```go
// 添加超时控制和监控
func (tpc *TwoPhaseCommit) prepare(ctx context.Context) error {
    // 设置 Prepare 超时
    ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
    defer cancel()
    
    ctx, span := tpc.tracer.Start(ctx, "twopc.prepare")
    defer span.End()
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        tpc.prepareDuration.Record(ctx, float64(duration.Milliseconds()))
        
        if duration > 5*time.Second {
            span.SetAttributes(attribute.Bool("slow_prepare", true))
            log.Printf("WARN: Slow prepare detected: %v", duration)
        }
    }()
    
    // ... prepare logic
}
```

---

## 7. 调试工具

### 7.1 Jaeger UI 使用技巧

```bash
# 1. 按服务查找
Service: api-gateway
Operation: POST /api/orders

# 2. 按 TraceID 查找
TraceID: 1234567890abcdef

# 3. 按标签过滤
Tags: error=true
Tags: http.status_code=500

# 4. 按持续时间过滤
Duration: > 1s
```

### 7.2 Prometheus 查询示例

```promql
# 错误率
rate(http_server_requests_total{status=~"5.."}[5m]) / 
rate(http_server_requests_total[5m])

# 延迟 P95
histogram_quantile(0.95, 
    rate(http_server_duration_bucket[5m])
)

# QPS
sum(rate(http_server_requests_total[1m])) by (service)

# 数据库连接数
sum(db_connections_active) by (service)
```

### 7.3 日志分析

```bash
# 查找错误日志
docker logs api-gateway 2>&1 | grep -i "error\|fatal"

# 按 TraceID 关联日志
docker logs api-gateway 2>&1 | grep "trace_id=1234567890abcdef"

# 统计错误类型
docker logs api-gateway 2>&1 | \
    grep -i "error" | \
    awk '{print $NF}' | \
    sort | uniq -c | sort -rn
```

---

## 8. 总结

### 排查流程

1. **确认问题**: 收集错误信息、日志、监控数据
2. **定位服务**: 通过 Trace 找到问题服务
3. **分析原因**: 查看 Span 属性、Events、日志
4. **验证修复**: 使用 Metrics 确认问题解决

### 最佳实践

✅ **预防性监控**
- 设置合理的告警阈值
- 定期审查慢查询和慢 API
- 监控资源使用趋势

✅ **可观测性**
- 完整的 Trace、Metric、Log
- 关键操作添加 Span Event
- 错误信息包含 TraceID

✅ **自动化**
- 自动化健康检查
- 自动化性能测试
- 自动化故障恢复

### 相关文档

- [35_Go生产级部署模式与反模式](./35_Go生产级部署模式与反模式.md)
- [34_Go内存管理与性能调优实战](./34_Go内存管理与性能调优实战.md)
- [41_实战案例_API Gateway与服务集成](./41_实战案例_API Gateway与服务集成.md)

